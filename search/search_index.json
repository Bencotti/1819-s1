{
    "docs": [
        {
            "location": "/index.html",
            "text": "CS1010\n\n\nPiazza Q&A\n \n\n\nPiazza is the Q&A site for students and instructors to ask questions and discuss among each other on all matters related to CS1010.\n\n\nNotes and Lectures \n\n\nLecture 1\n\n\nAfter some admin matters, we will introduce what is a program, what is meant by programming, and what is computational problem solving.\n\n\nWe will cover \nUnit 1: What is a Program?\n and \nUnit 2: Computational Problems and Algorithms\n in the first lecture.",
            "title": "Home"
        },
        {
            "location": "/index.html#cs1010",
            "text": "",
            "title": "CS1010"
        },
        {
            "location": "/index.html#piazza-qa",
            "text": "Piazza is the Q&A site for students and instructors to ask questions and discuss among each other on all matters related to CS1010.",
            "title": "Piazza Q&amp;A"
        },
        {
            "location": "/index.html#notes-and-lectures",
            "text": "",
            "title": "Notes and Lectures"
        },
        {
            "location": "/index.html#lecture-1",
            "text": "After some admin matters, we will introduce what is a program, what is meant by programming, and what is computational problem solving.  We will cover  Unit 1: What is a Program?  and  Unit 2: Computational Problems and Algorithms  in the first lecture.",
            "title": "Lecture 1"
        },
        {
            "location": "/about/index.html",
            "text": "About CS1010\n\n\nModule Description\n\n\nThis module introduces the fundamental concepts of problem solving by computing and programming using an imperative programming language. It is the first and foremost introductory course to computing. It is also the first part of a three-part series on introductory programming and problem solving by computing, which also includes CS2030 and CS2040. Topics covered include problem solving by computing, writing pseudo-codes, basic problem formulation and problem solving, program development, coding, testing and debugging, fundamental programming constructs (variables, types, expressions, assignments, functions, control structures, etc.), fundamental data structures: arrays, strings and structures, simple file processing, and basic recursion. This module is appropriate for SoC students.\n\n\nWho/Where/When\n\n\n\n\nInstructor\n: Ooi Wei Tsang\n\n\nLecture Venue\n: \nI^3\nI^3\n Auditorium\n\n\nLecture Time\n: Every Tuesday, 4pm - 6pm\n\n\n\n\nTeaching Assistants\n:\n\n\n\n\nWu Biao\n\n\nYu Xiaoliang\n\n\nDou Rengan\n\n\n\n\n\n\n\n\nUndergraduate Discussion Leaders\n:\n\n\n\n\nAu Liang Jun\n\n\nChai Jie Feng (Jack)\n\n\nChua Jun Hui\n\n\nD David Livingston\n\n\nEvan Tay\n\n\nGu Wangfan\n\n\nHo Boon Wee Addison\n\n\nJeffery Kwoh Ji Hui\n\n\nJiang Qinhua\n\n\nJoanne Ong Cui FanG\n\n\nKerryn Eer\n\n\nKyle Timothy Ng Chu\n\n\nLim Heng Guang\n\n\nLin Si Jie\n\n\nNguyen Trong Truong Thanh\n\n\nOng Shu Peng (Metta)\n\n\nOng You Sheng Aaron\n\n\nQuek Shui Herng\n\n\nZhang Tianyang\n\n\n\n\n\n\n\n\nImportant Dates\n\n\n\n\nMidterm Assessment\n: Tuesday, 2 October, 2018 (4pm - 6pm)\n\n\nFinal Assessment\n: Tuesday, 27 Nov, 2018 (9am - 11am)\n\n\nPractical Exam 1\n: Saturday, 6 October, 2018 (9am - 12noon)\n\n\nPractical Exam 2\n: Saturday, 10 November, 2018 (9am - 12noon)\n\n\n\n\nAssessment Weightage\n\n\n\n\nProgramming Assignments\n: 30%\n\n\nFinal Assessment\n: 30%\n\n\nMidterm Assessment\n: 15%\n\n\nPractical Exam 1\n: 10%\n\n\nPractical Exam 2\n: 15%",
            "title": "About CS1010"
        },
        {
            "location": "/about/index.html#about-cs1010",
            "text": "",
            "title": "About CS1010"
        },
        {
            "location": "/about/index.html#module-description",
            "text": "This module introduces the fundamental concepts of problem solving by computing and programming using an imperative programming language. It is the first and foremost introductory course to computing. It is also the first part of a three-part series on introductory programming and problem solving by computing, which also includes CS2030 and CS2040. Topics covered include problem solving by computing, writing pseudo-codes, basic problem formulation and problem solving, program development, coding, testing and debugging, fundamental programming constructs (variables, types, expressions, assignments, functions, control structures, etc.), fundamental data structures: arrays, strings and structures, simple file processing, and basic recursion. This module is appropriate for SoC students.",
            "title": "Module Description"
        },
        {
            "location": "/about/index.html#whowherewhen",
            "text": "Instructor : Ooi Wei Tsang  Lecture Venue :  I^3 I^3  Auditorium  Lecture Time : Every Tuesday, 4pm - 6pm   Teaching Assistants :   Wu Biao  Yu Xiaoliang  Dou Rengan     Undergraduate Discussion Leaders :   Au Liang Jun  Chai Jie Feng (Jack)  Chua Jun Hui  D David Livingston  Evan Tay  Gu Wangfan  Ho Boon Wee Addison  Jeffery Kwoh Ji Hui  Jiang Qinhua  Joanne Ong Cui FanG  Kerryn Eer  Kyle Timothy Ng Chu  Lim Heng Guang  Lin Si Jie  Nguyen Trong Truong Thanh  Ong Shu Peng (Metta)  Ong You Sheng Aaron  Quek Shui Herng  Zhang Tianyang",
            "title": "Who/Where/When"
        },
        {
            "location": "/about/index.html#important-dates",
            "text": "Midterm Assessment : Tuesday, 2 October, 2018 (4pm - 6pm)  Final Assessment : Tuesday, 27 Nov, 2018 (9am - 11am)  Practical Exam 1 : Saturday, 6 October, 2018 (9am - 12noon)  Practical Exam 2 : Saturday, 10 November, 2018 (9am - 12noon)",
            "title": "Important Dates"
        },
        {
            "location": "/about/index.html#assessment-weightage",
            "text": "Programming Assignments : 30%  Final Assessment : 30%  Midterm Assessment : 15%  Practical Exam 1 : 10%  Practical Exam 2 : 15%",
            "title": "Assessment Weightage"
        },
        {
            "location": "/outcomes/index.html",
            "text": "After taking CS1010, students should\n\n\n\n\nbe familiar with fundamental  programming concepts and methodology (variables, assignments, conditions, branches, loops, functions, recursions, structures);\n\n\nbe familiar with and appreciate good programming practice, and apply it to follow-up courses;\n\n\nbe able to apply problem-solving knowledge and skills to write small, well-documented, effective C programs;\n\n\nbe able to appreciate the use of simple data structure such as array, know their limitations to pave way for more complex data structures in the next course;\n\n\nknow the responsibilities of an ethical programmer;\n\n\nbe able to write simple programs in the corresponding programming language to solve a task, given the constraints on the inputs;\n\n\nbe able to manually trace through a program to identify logical errors;\n\n\nbe able to differentiate between logical errors, syntax errors, and run-time errors;\n\n\nbe exposed informally to the concept of code specification in the form of comments in the code, explaining what are the expected inputs and outputs and what are the assumptions;\n\n\nknow about what are some insecure functions to avoid;\n\n\nbe able to generate test cases on their own, with a focus on boundary/special cases;\n\n\nbe able to debug with printf or equivalent functions;\n\n\nbe aware of common strategies and good practices of debugging with printf or equivalent functions;\n\n\nbe able to identify opportunities to, and write, modularized code;\n\n\nbe exposed to a debugger;\n\n\nbe able to write code following good programming style (clear comments, naming convention, indentation, etc.);\n\n\nunderstand the different data types and that there exists a representation of each in the memory, as well as the limitation of the representations due to the limited number of bits;\n\n\ndevelop a simple mental model of how a program is executed (CPU runs the code on data that is stored in memory, function call leads to the creation of call frames, which can explain recursion and variable scoping, etc).  For interpreted language, understand the role of virtual machine/interpreter;\n\n\nbe able to understand at a high level the compilation process (from pre-processing to compiling to linking), where applicable;\n\n\nunderstand the concept of reusability and how a software application can be built on top of software libraries/packages (standard or third parties);\n\n\nbe able to implement bubble sort and insertion sort;\n\n\nbe able to implement linear search and binary search (both iterative and recursive versions);",
            "title": "Learning Outcomes"
        },
        {
            "location": "/schedule/index.html",
            "text": "Schedule\n\n\nThis is a tentative schedule for CS1010.\n\n\nLecture Schedule (Tentative)\n\n\n\n\n\n\n\n\nWeek\n\n\nDate\n\n\nTopics\n\n\nLabs\n\n\n\n\n\n\n\n\n\n\n1\n\n\n2018-08-13\n\n\nUnits 1-2: Computational Problem Solving\n\n\n\n\n\n\n\n\n2\n\n\n2018-08-20\n\n\nUnits 3-4: Functions & Types\n\n\n\n\n\n\n\n\n3\n\n\n2018-08-27\n\n\nUnits 5-7: Basic C programs\n\n\n\n\n\n\n\n\n4\n\n\n2018-09-03\n\n\nConditionals\n\n\nLab 1\n\n\n\n\n\n\n5\n\n\n2018-09-10\n\n\nArrays and Loops\n\n\nLab 2\n\n\n\n\n\n\n6\n\n\n2018-09-17\n\n\nPointers and Strings\n\n\nLab 3\n\n\n\n\n\n\n-\n\n\n2018-09-24\n\n\nBreak\n\n\n\n\n\n\n\n\n7\n\n\n2018-10-01\n\n\nMidterm\n\n\nPE 1\n\n\n\n\n\n\n8\n\n\n2018-10-08\n\n\nSorting\n\n\nLab 4\n\n\n\n\n\n\n9\n\n\n2018-10-15\n\n\nSearching\n\n\nLab 5\n\n\n\n\n\n\n10\n\n\n2018-10-22\n\n\nComposite Data Type\n\n\nLab 6\n\n\n\n\n\n\n11\n\n\n2018-10-29\n\n\nI/O\n\n\nLab 7\n\n\n\n\n\n\n12\n\n\n2018-11-05\n\n\nModular C programming\n\n\nPE 2\n\n\n\n\n\n\n13\n\n\n2018-11-12\n\n\nRecap\n\n\nLab 8\n\n\n\n\n\n\n\n\nTutorial Time / Venue\n\n\n\n\n\n\n\n\nDay\n\n\nTime\n\n\nCOM1-B108\n\n\nCOM1-B109\n\n\nCOM1-B111\n\n\nCOM1-B112\n\n\nCOM1-0120\n\n\ni3-0336\n\n\nI3-0338\n\n\n\n\n\n\n\n\n\n\nMon\n\n\n1000\n\n\nC10\n\n\n\n\n\n\n\n\nC09\n\n\n\n\n\n\n\n\n\n\nMon\n\n\n1400\n\n\nC1B\n\n\n\n\n\n\nC1A\n\n\n\n\n\n\n\n\n\n\n\n\nTue\n\n\n1200\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n03\n\n\n\n\n\n\nTue\n\n\n1400\n\n\n\n\n\n\n\n\n\n\n\n\nC03\n\n\nC02\n\n\n\n\n\n\nWed\n\n\n1000\n\n\n\n\nC07\n\n\n\n\nC08\n\n\n\n\n\n\nC06\n\n\n\n\n\n\nWed\n\n\n1200\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n07\n\n\n\n\n\n\nWed\n\n\n1400\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n08\n\n\n\n\n\n\nThu\n\n\n1000\n\n\n\n\n\n\n\n\n05\n\n\n\n\n01\n\n\n\n\n\n\n\n\nThu\n\n\n1200\n\n\n\n\n\n\nC11\n\n\nC04\n\n\nC05\n\n\n\n\n\n\n\n\n\n\nThu\n\n\n1400\n\n\n\n\n\n\n\n\n06\n\n\n\n\n\n\n\n\n\n\n\n\nFri\n\n\n1200\n\n\n\n\n\n\n\n\n02\n\n\n\n\n\n\n09\n\n\n\n\n\n\nFri\n\n\n1400\n\n\n\n\n\n\n\n\n04",
            "title": "Schedule"
        },
        {
            "location": "/schedule/index.html#schedule",
            "text": "This is a tentative schedule for CS1010.",
            "title": "Schedule"
        },
        {
            "location": "/schedule/index.html#lecture-schedule-tentative",
            "text": "Week  Date  Topics  Labs      1  2018-08-13  Units 1-2: Computational Problem Solving     2  2018-08-20  Units 3-4: Functions & Types     3  2018-08-27  Units 5-7: Basic C programs     4  2018-09-03  Conditionals  Lab 1    5  2018-09-10  Arrays and Loops  Lab 2    6  2018-09-17  Pointers and Strings  Lab 3    -  2018-09-24  Break     7  2018-10-01  Midterm  PE 1    8  2018-10-08  Sorting  Lab 4    9  2018-10-15  Searching  Lab 5    10  2018-10-22  Composite Data Type  Lab 6    11  2018-10-29  I/O  Lab 7    12  2018-11-05  Modular C programming  PE 2    13  2018-11-12  Recap  Lab 8",
            "title": "Lecture Schedule (Tentative)"
        },
        {
            "location": "/schedule/index.html#tutorial-time-venue",
            "text": "Day  Time  COM1-B108  COM1-B109  COM1-B111  COM1-B112  COM1-0120  i3-0336  I3-0338      Mon  1000  C10     C09      Mon  1400  C1B    C1A       Tue  1200        03    Tue  1400       C03  C02    Wed  1000   C07   C08    C06    Wed  1200        07    Wed  1400        08    Thu  1000     05   01     Thu  1200    C11  C04  C05      Thu  1400     06       Fri  1200     02    09    Fri  1400     04",
            "title": "Tutorial Time / Venue"
        },
        {
            "location": "/accounts/index.html",
            "text": "CS1010 Accounts\n\n\nWe will be using a variety of services for CS1010.  To take CS1010, please make sure you have the following accounts:\n\n\nSoC UNIX Account\n\n\nYou can get one here: \nhttps://mysoc.nus.edu.sg/~newacct/\n\n\nThis account allows you to access SoC UNIX resources, including the main computing host running Solaris, \nsunfire\n, and computer clusters running Ubuntu / CentOS.  We will be using the compute clusters for CS1010 (details coming soon).\n\n\nGitHub Account\n\n\nCS1010 uses GitHub Classroom for programming assignment submissions and grading.  You should \nregister for a GitHub account\n if you do not have one. \n\n\nPiazza Account\n\n\nCS1010 uses Piazza for Q&A and discussion.  You should receive an email to register for Piazza.",
            "title": "Accounts"
        },
        {
            "location": "/accounts/index.html#cs1010-accounts",
            "text": "We will be using a variety of services for CS1010.  To take CS1010, please make sure you have the following accounts:",
            "title": "CS1010 Accounts"
        },
        {
            "location": "/accounts/index.html#soc-unix-account",
            "text": "You can get one here:  https://mysoc.nus.edu.sg/~newacct/  This account allows you to access SoC UNIX resources, including the main computing host running Solaris,  sunfire , and computer clusters running Ubuntu / CentOS.  We will be using the compute clusters for CS1010 (details coming soon).",
            "title": "SoC UNIX Account"
        },
        {
            "location": "/accounts/index.html#github-account",
            "text": "CS1010 uses GitHub Classroom for programming assignment submissions and grading.  You should  register for a GitHub account  if you do not have one.",
            "title": "GitHub Account"
        },
        {
            "location": "/accounts/index.html#piazza-account",
            "text": "CS1010 uses Piazza for Q&A and discussion.  You should receive an email to register for Piazza.",
            "title": "Piazza Account"
        },
        {
            "location": "/policies/index.html",
            "text": "Policies\n\n\nEmail Communication\n\n\n\n\n\n\nPlease use only your official NUS email for communication with the teaching staffs -- either the one with \n@u.nus.edu\n or \n@comp.nus.edu.sg\n.  \n\n\n\n\n\n\nPlease use email only for private matters.  Prefix your email subject with \n[CS1010]\n.\n\n\n\n\n\n\nPlease use \nPiazza\n for other matters related to the module.  If you email us privately and we feel that your questions/answers are useful to the rest of the class, we will publish it on Piazza, with anonymization when appropriate.\n\n\n\n\n\n\nLab Sessions\n\n\n\n\n\n\nAttendance is not compulsory at NUS, but we do take attendance during the tutorial sessions. \n\n\n\n\n\n\nYou should stick to your allocated time slot for tutorials.  If there is a strong reason for your to attend another tutorial session, please inform your undergraduate discussion leaders (UDLs).\n\n\n\n\n\n\nLate Submissions\n\n\n\n\n\n\nAll programming assignments must be submitted on time.  If you need an extension, please ask for one and provide a justification for approval.  Only academic reasons and compasionate reasons can be considered (e.g., representing NUS for a sports event is OK; Attending a wedding is not)\n\n\n\n\n\n\nFor late submission, there is a 1% penalty (of the assessment grade) for every 5-minute after the deadline, capped at 80%.  For example, if a homework is deserved 40 marks, and it is submitted 100 minutes after the deadline, the student will get 32 marks instead (20% penalty).  If it is submitted 10 hours after the deadline, the student will get 8 marks (as it has hit the cap of 80% penalty).\n\n\n\n\n\n\nDiscussions and Plagiarism\n\n\n\n\n\n\nWe encourage discussions among students for programming assignments, but each student should be responsible for writing his/her own code and should give credits to others when appropriate.  \n\n\n\n\n\n\nNUS and School of Computing have a high standard on academic honesty and take any violation seriously.  In the context of computing modules, source code plagiarism -- copying code from another source and attributing it as one's own code -- is a series violation.   Please read the page \nPreventing Plagiarism\n from the school's website to familiarize yourself with the policy.\n\n\n\n\n\n\nI adopt a \"no mercy\" policy when it comes to disciplinary action on plagiarism.  Both parties, the student who copied, and the student who allowed others to copy, will be penalized equally.\n\n\n\n\n\n\nScreencast\n\n\n\n\n\n\nScreencast will be recorded and posted online 3-4 days after the lecture. \nThis will be done on a 'best effort' basis and screencast will not be guaranteed to be available on time or at all.  \n\n\n\n\n\n\nPosting of screencast is meant to help students who attended the lecture to recap the content, or to help those who are not able to attend the lecture due to unexpected circumstances.  It does not mean that you should skip lecture.  \nResearch\n has shown that the effect of over-reliance on screencast is negative.\n\n\n\n\n\n\nModel Solutions and Slides\n\n\n\n\n\n\nSlides will be posted \nafter\n the class.  Note that slides are used as a \nvisual aid\n to assist me during lecture.  It is not meant as summary of lectures nor a replacement of lecture notes.\n\n\n\n\n\n\nIn a module like CS1010, there is often not a single correct answer.  Hence, there is no model solution for this module.  Sample solutions may be posted (both good and bad ones) for discussion.  I strongly encourage students to discuss your solution with the teaching team, instead of just comparing your solution with the sample solution.\n\n\n\n\n\n\nGrading\n\n\n\n\nStudents will received the grades they deserved irrespective of how the other students in the class performed (i.e., no bell curve)\n\n\n\n\nOpen Book Assessment\n\n\n\n\n\n\nAll assessment, including practical exams, midterm test, and final assessment, are open book assessment -- you can bring in your notes or other \nanalog\n reference materials.\n\n\n\n\n\n\nThere is \nnothing to memorize\n for this class.",
            "title": "Policies"
        },
        {
            "location": "/policies/index.html#policies",
            "text": "",
            "title": "Policies"
        },
        {
            "location": "/policies/index.html#email-communication",
            "text": "Please use only your official NUS email for communication with the teaching staffs -- either the one with  @u.nus.edu  or  @comp.nus.edu.sg .      Please use email only for private matters.  Prefix your email subject with  [CS1010] .    Please use  Piazza  for other matters related to the module.  If you email us privately and we feel that your questions/answers are useful to the rest of the class, we will publish it on Piazza, with anonymization when appropriate.",
            "title": "Email Communication"
        },
        {
            "location": "/policies/index.html#lab-sessions",
            "text": "Attendance is not compulsory at NUS, but we do take attendance during the tutorial sessions.     You should stick to your allocated time slot for tutorials.  If there is a strong reason for your to attend another tutorial session, please inform your undergraduate discussion leaders (UDLs).",
            "title": "Lab Sessions"
        },
        {
            "location": "/policies/index.html#late-submissions",
            "text": "All programming assignments must be submitted on time.  If you need an extension, please ask for one and provide a justification for approval.  Only academic reasons and compasionate reasons can be considered (e.g., representing NUS for a sports event is OK; Attending a wedding is not)    For late submission, there is a 1% penalty (of the assessment grade) for every 5-minute after the deadline, capped at 80%.  For example, if a homework is deserved 40 marks, and it is submitted 100 minutes after the deadline, the student will get 32 marks instead (20% penalty).  If it is submitted 10 hours after the deadline, the student will get 8 marks (as it has hit the cap of 80% penalty).",
            "title": "Late Submissions"
        },
        {
            "location": "/policies/index.html#discussions-and-plagiarism",
            "text": "We encourage discussions among students for programming assignments, but each student should be responsible for writing his/her own code and should give credits to others when appropriate.      NUS and School of Computing have a high standard on academic honesty and take any violation seriously.  In the context of computing modules, source code plagiarism -- copying code from another source and attributing it as one's own code -- is a series violation.   Please read the page  Preventing Plagiarism  from the school's website to familiarize yourself with the policy.    I adopt a \"no mercy\" policy when it comes to disciplinary action on plagiarism.  Both parties, the student who copied, and the student who allowed others to copy, will be penalized equally.",
            "title": "Discussions and Plagiarism"
        },
        {
            "location": "/policies/index.html#screencast",
            "text": "Screencast will be recorded and posted online 3-4 days after the lecture. \nThis will be done on a 'best effort' basis and screencast will not be guaranteed to be available on time or at all.      Posting of screencast is meant to help students who attended the lecture to recap the content, or to help those who are not able to attend the lecture due to unexpected circumstances.  It does not mean that you should skip lecture.   Research  has shown that the effect of over-reliance on screencast is negative.",
            "title": "Screencast"
        },
        {
            "location": "/policies/index.html#model-solutions-and-slides",
            "text": "Slides will be posted  after  the class.  Note that slides are used as a  visual aid  to assist me during lecture.  It is not meant as summary of lectures nor a replacement of lecture notes.    In a module like CS1010, there is often not a single correct answer.  Hence, there is no model solution for this module.  Sample solutions may be posted (both good and bad ones) for discussion.  I strongly encourage students to discuss your solution with the teaching team, instead of just comparing your solution with the sample solution.",
            "title": "Model Solutions and Slides"
        },
        {
            "location": "/policies/index.html#grading",
            "text": "Students will received the grades they deserved irrespective of how the other students in the class performed (i.e., no bell curve)",
            "title": "Grading"
        },
        {
            "location": "/policies/index.html#open-book-assessment",
            "text": "All assessment, including practical exams, midterm test, and final assessment, are open book assessment -- you can bring in your notes or other  analog  reference materials.    There is  nothing to memorize  for this class.",
            "title": "Open Book Assessment"
        },
        {
            "location": "/01-program/index.html",
            "text": "Unit 1: What is a Program?\n\n\nLearning Outcomes\n\n\nAfter this unit, students should:\n\n\n\n\nhave an idea of what is a program and how a program is executed by a computer\n\n\nunderstand the basic terminologies: machine code, assembly language, and higher-level programming languages\n\n\n\n\nWhat is a (computer) program?\n\n\nDespite all the wonderful and amazing things that computers can do, computers are not very smart. In fact, they are pretty dumb. Computers can only follow the instructions given by a human. A computer program is a sequence of step-by-step instructions given to computers to manipulate data in order to perform a certain task.\n\n\nProgramming is the art and science of writing a computer program, and that is what you will learn to do in CS1010.\n\n\nHow computer executes a program\n\n\nIn order to learn how to write a program, it is important to have an overview of how a computer executes a program.  You will learn in details how this is done in CS2100/CS2106 or EE2024/CG2271, but for CS1010, we will take a very simplistic and high-level view of this process.\n\n\nThe two important components of a computer we will discuss for CS1010 is the CPU, or \ncentral processing unit\n and the memory, which is a generalized term for where we store the data to be processed or manipulated by the CPU, as well as the instructions to do so.  A memory location is addressable using a \nmemory address\n.  \n\n\nThe instructions to the CPU comes in the form of \nmachine code\n, a sequence of bits (1s and 0s) that is interpreted and then followed by the CPU to do certain things.  These machine code could instruct the CPU, for instance, to compare if a particular number at a certain memory location is more than 0, to add one number to another, or to execute another instruction at another memory location.  The data stored in the memory is also stored as a sequence of 1s and 0s.\n\n\nFrom Machine Code to High-level Programming Language\n\n\nWhile it is possible for us, human, to write machine code directly, few actually do since it is challenging to do so. Different CPUs understand different sets of machine code; it is tedious to figure out where each piece of data is located in the memory (this is actually determined by the operating system).  The resulting code, even when it is correct and easy to read and understand by the machine, are often hard to decipher for a human.\nSimple operations such as comparing which number is bigger might require several instructions to perform.\n\n\nTo get around the readability problem, programmers can code in \nassembly language\n -- a human-readable form of machine code, where each instruction, instead of represented by 0s and 1s, is represented by a mnemonic (such as \ndecr\n, \nincr\n, \nstore\n, \nadd\n, etc.)\n\n\nWriting assembly code does not address the issues of machine-dependent code and the tediousness of programming.  Early programmers (in the fifties) understood this and designed \nhigh-level programming languages\n, where programmers can describe the operations that they wish to do in a language closer to their intention that is machine independent.  A program written in one of these programming languages is then \ncompiled\n into machine code for a specific CPU for execution using a compiler.\n\n\n\n\nThe first commercially available language is FORTRAN from IBM in the 1950s.  Among many early programming languages, C (birth year 1972) is the only one that is still popular and widely used today,  \nFor many reasons\n, C is the language of choice for CS1010.  \n\n\nThe Goals of CS1010\n\n\nThis brings us to the goals of CS1010.  First, you will learn the most important syntax element of the C programming language.  Second, you will learn how a C program behaves, in relation to how a program is executed and how data are stored and manipulated in memory.  Third, you will learn the various tools and techniques that will help you produce good and correct C programs.\n\n\nThe last, and the most important and challenging goal of CS1010, however, is that you will learn how to write programs to solve computational problems.  Learning to write a program that does what you want it to do is actually not difficult.  \nKnowing what you want your program to do is the more challenging part!",
            "title": "1. What is a Program?"
        },
        {
            "location": "/01-program/index.html#unit-1-what-is-a-program",
            "text": "",
            "title": "Unit 1: What is a Program?"
        },
        {
            "location": "/01-program/index.html#learning-outcomes",
            "text": "After this unit, students should:   have an idea of what is a program and how a program is executed by a computer  understand the basic terminologies: machine code, assembly language, and higher-level programming languages",
            "title": "Learning Outcomes"
        },
        {
            "location": "/01-program/index.html#what-is-a-computer-program",
            "text": "Despite all the wonderful and amazing things that computers can do, computers are not very smart. In fact, they are pretty dumb. Computers can only follow the instructions given by a human. A computer program is a sequence of step-by-step instructions given to computers to manipulate data in order to perform a certain task.  Programming is the art and science of writing a computer program, and that is what you will learn to do in CS1010.",
            "title": "What is a (computer) program?"
        },
        {
            "location": "/01-program/index.html#how-computer-executes-a-program",
            "text": "In order to learn how to write a program, it is important to have an overview of how a computer executes a program.  You will learn in details how this is done in CS2100/CS2106 or EE2024/CG2271, but for CS1010, we will take a very simplistic and high-level view of this process.  The two important components of a computer we will discuss for CS1010 is the CPU, or  central processing unit  and the memory, which is a generalized term for where we store the data to be processed or manipulated by the CPU, as well as the instructions to do so.  A memory location is addressable using a  memory address .    The instructions to the CPU comes in the form of  machine code , a sequence of bits (1s and 0s) that is interpreted and then followed by the CPU to do certain things.  These machine code could instruct the CPU, for instance, to compare if a particular number at a certain memory location is more than 0, to add one number to another, or to execute another instruction at another memory location.  The data stored in the memory is also stored as a sequence of 1s and 0s.",
            "title": "How computer executes a program"
        },
        {
            "location": "/01-program/index.html#from-machine-code-to-high-level-programming-language",
            "text": "While it is possible for us, human, to write machine code directly, few actually do since it is challenging to do so. Different CPUs understand different sets of machine code; it is tedious to figure out where each piece of data is located in the memory (this is actually determined by the operating system).  The resulting code, even when it is correct and easy to read and understand by the machine, are often hard to decipher for a human.\nSimple operations such as comparing which number is bigger might require several instructions to perform.  To get around the readability problem, programmers can code in  assembly language  -- a human-readable form of machine code, where each instruction, instead of represented by 0s and 1s, is represented by a mnemonic (such as  decr ,  incr ,  store ,  add , etc.)  Writing assembly code does not address the issues of machine-dependent code and the tediousness of programming.  Early programmers (in the fifties) understood this and designed  high-level programming languages , where programmers can describe the operations that they wish to do in a language closer to their intention that is machine independent.  A program written in one of these programming languages is then  compiled  into machine code for a specific CPU for execution using a compiler.   The first commercially available language is FORTRAN from IBM in the 1950s.  Among many early programming languages, C (birth year 1972) is the only one that is still popular and widely used today,   For many reasons , C is the language of choice for CS1010.",
            "title": "From Machine Code to High-level Programming Language"
        },
        {
            "location": "/01-program/index.html#the-goals-of-cs1010",
            "text": "This brings us to the goals of CS1010.  First, you will learn the most important syntax element of the C programming language.  Second, you will learn how a C program behaves, in relation to how a program is executed and how data are stored and manipulated in memory.  Third, you will learn the various tools and techniques that will help you produce good and correct C programs.  The last, and the most important and challenging goal of CS1010, however, is that you will learn how to write programs to solve computational problems.  Learning to write a program that does what you want it to do is actually not difficult.   Knowing what you want your program to do is the more challenging part!",
            "title": "The Goals of CS1010"
        },
        {
            "location": "/02-algo/index.html",
            "text": "Unit 2: Computational Problems and Algorithms\n\n\nLearning Outcomes:\n\n\nAfter this unit, students should:\n\n\n\n\nunderstand the basic terminologies: computational problem solving, algorithm, flowchart, debugging, testing, variables, value, assignment\n\n\nbe familiar with the algorithm to find the maximum among a list of numbers\n\n\nbe able to trace through flowcharts and updates of variables, and argue if a given algorithm is correct or incorrect\n\n\n\n\nComputational Problems\n\n\nSo, what is computational problem solving?  Let's start with the question, what is a \ncomputational problem\n?  \n\n\nA computational problem is a problem that can be solved step-by-step with a computer.  These problems usually have a well-defined input, constraints, and conditions that the output must satisfied.  Here are some types of computational problems:\n\n\n\n\n\n\nA \ndecision problem\n is one where the answer is yes or no.  For instance, \"given a number \nn\n, is \nn\n even?\" is a decision problem.  Some decision problems take more steps to solve than others.  For instance, \"given a number \nn\n, is \nn\n prime?\" takes more steps than just checking the parity of a number.\n\n\n\n\n\n\nA \nsearch problem\n is one where the solution consists of one or more values that satisfies a given condition.  For instance, we may want to compute a path from one geographical location to another on a map.\n\n\n\n\n\n\nA \ncounting problem\n is one where the answer is the number of solutions to a search problem.\n\n\n\n\n\n\nAn \noptimization problem\n is one where the solution is the \"best\" possible solution, where the \"best\" can be defined in a different way.  For instance, we may want to compute the fastest route from one location to another.\n\n\n\n\n\n\nQuestions such as \"what is the meaning of life?\" \"do I look good in this outfit?\"\n1\n are not computational problems, because they do not have well-defined input, constraints, and conditions that the output must satisfy.\n\n\nIn CS1010 (followed by CS2040C and CS3230), you will learn how to solve computational problems \ncomputationally\n -- this means that you learn to come up with step-by-step instructions meant for computers that you can translate into computer programs, to solve a given problem. \n\n\nExample: Finding the maximum\n\n\nLet's start with a simple problem.  Given a finite list \nL\nL\n of \nk\nk\n integers (\nk\nk\n > 0), find the integer with the maximum value from the list.\n\n\nFirst, let's consider if this is a computational problem.  The input is very well defined.  We know what an integer is.  We are told we have at least one, and we have a finite number of them\n2\n.\n\n\nSecond, let's consider the output.  What conditions must the output satisfy?  First, it has to be equal or larger than every other integer on the list.  Second, it must be an integer \nin\n the list.  This is well defined by the problem statement, so we can say that it is a computational problem.\n\n\nHere is an example.  Suppose the input consists of:\n\n\n4 1 -4 0 9 9 3 5 8\n\n\nThe output should be \n9\n.\n\n\nNow, you should pause reading and think about how you would solve this step-by-step.  \n\n\nAlgorithm\n\n\nOne way to solve this problem is to check through the integers in the list, one-by-one, and keep track of the maximum value so far.  When you reach the end of the list, your \"maximum value so far\" will also be the maximum for the whole list.  \n\n\nLet's look at an example:\n\n\n\n\n\n\n\n\nIntegers Scanned\n\n\nMaximum So Far\n\n\n\n\n\n\n\n\n\n\n4\n\n\n4\n\n\n\n\n\n\n4 1\n\n\n4\n\n\n\n\n\n\n4 1 -4\n\n\n4\n\n\n\n\n\n\n4 1 -4 0\n\n\n4\n\n\n\n\n\n\n4 1 -4 0 9\n\n\n9\n\n\n\n\n\n\n4 1 -4 0 9 9\n\n\n9\n\n\n\n\n\n\n4 1 -4 0 9 9 3\n\n\n9\n\n\n\n\n\n\n4 1 -4 0 9 9 3 5\n\n\n9\n\n\n\n\n\n\n4 1 -4 0 9 9 3 5 8\n\n\n9\n\n\n\n\n\n\n\n\nThe English description above, however, is not detailed enough for computers to understand.  What is the meaning of \"check one-by-one\"? \"keep track of maximum so far\"?  how to tell if we have reached \"the end of the list\"?\n\n\nLet's work out all the details.\n\n\nFirst, we need a concise way of representing the integers in the list.  Borrowing from mathematical notation, let's say that the list \nL\nL\n contains the integers \n\nl_0, l_1, ..., l_{k-1}\nl_0, l_1, ..., l_{k-1}\n. To \"check one-by-one,\" we introduce another notation \nl_i\nl_i\n, which is the integer currently being \"checked\".  We begin with \ni = 0\ni = 0\n, then \ni = 1\ni = 1\n, then \ni = 2\ni = 2\n, etc, until \ni = k-1\ni = k-1\n.  At every step, we increase \ni\ni\n by 1.\n\n\nSecond, we need a concise way of keeping track of the maximum so far.  We introduce another notation, \nm\nm\n, to represent the maximum value so far.  When \ni = 0\ni = 0\n, \nm = l_0\nm = l_0\n.  Since we only scan a single integer, it has to be the maximum.  When we check another integer \nl_i (i > 0)\nl_i (i > 0)\n, only two things can happen:\n\n\n\n\nif this \nl_i\nl_i\n is larger than \nm\nm\n, then \nl_i\nl_i\n has to be the maximum so far, so we update \nm\nm\n to be \nl_i\nl_i\n.\n\n\nif \nl_i\nl_i\n is equal to or smaller than \nm\nm\n, then \nm\nm\n is still the maximum value so far.\n\n\n\n\nWe keep doing the above and increase \ni\ni\n, until we reach the end of the list when (after increasing \ni\ni\n) we find that \ni\ni\n is \nk\nk\n.\n\n\nNow, we have enough details to describe step-by-step, how to find the maximum value from a list of integers.  Such steps, which the computer can take to solve a problem, is called an \nalgorithm\n.  \n\n\nFlowchart\n\n\nThere are different ways one can describe an algorithm.  The easiest way I find is to use a diagram called a \nflowchart\n.  The flowchart for the algorithm above looks like this.  A diamond box represents a \"question\" that can be true or false (yes or no), and we trace through the \"flow\" step by step, following the corresponding path depending on the answer. \n\n\n\n\nPlease spend some time to trace through the walkthrough above.  The snapshot of the values of the \ni\ni\n, \nl_i\nl_i\n, \nk\nk\n, and \nm\nm\n, at the point after \"is \ni\ni\n equals \nk\nk\n\" is shown in the table below \n(except for the first row, which shows the value just before entering \"is \ni\ni\n equals \nk\nk\n\")\n.\n\n\n\n\n\n\n\n\nIntegers Scanned\n\n\ni\ni\n\n\nl_i\nl_i\n\n\nk\nk\n\n\nMaximum So Far (\nm\nm\n)\n\n\n\n\n\n\n\n\n\n\n4\n\n\n1\n\n\n4\n\n\n9\n\n\n4\n\n\n\n\n\n\n4 1\n\n\n1\n\n\n1\n\n\n9\n\n\n4\n\n\n\n\n\n\n4 1 -4\n\n\n2\n\n\n-4\n\n\n9\n\n\n4\n\n\n\n\n\n\n4 1 -4 0\n\n\n3\n\n\n0\n\n\n9\n\n\n4\n\n\n\n\n\n\n4 1 -4 0 9\n\n\n4\n\n\n9\n\n\n9\n\n\n4\n\n\n\n\n\n\n4 1 -4 0 9 9\n\n\n5\n\n\n9\n\n\n9\n\n\n9\n\n\n\n\n\n\n4 1 -4 0 9 9 3\n\n\n6\n\n\n3\n\n\n9\n\n\n9\n\n\n\n\n\n\n4 1 -4 0 9 9 3 5\n\n\n7\n\n\n5\n\n\n9\n\n\n9\n\n\n\n\n\n\n4 1 -4 0 9 9 3 5 8\n\n\n8\n\n\n8\n\n\n9\n\n\n9\n\n\n\n\n\n\n4 1 -4 0 9 9 3 5 8\n\n\n9\n\n\n``\n\n\n9\n\n\n9\n\n\n\n\n\n\n\n\nVariables\n\n\nThere are a few important things to take note here.  \nm\nm\n, \ni\ni\n, \nk\nk\n, and the list \nL\nL\n are what we called \nstates\n or \nvariables\n.  While in the above, we can think of them as mathematical variables which we can assign \nvalues\n to, in a computer program, a variable is a location in the memory which holds a value.  \n\n\nWe can perform two very basic operations on the variables: reading and writing.  In other words, we can set their values and we can retrieve their values. \n\n\nWe can \nassign\n the value of one variable to a constant (e.g., set \ni\ni\n to 1) or to the value of another variable (e.g., set \nm\nm\n to \nl_i\nl_i\n).  In the latter example, we first read the value of \nl_i\nl_i\n, from \nl_i\nl_i\n's memory location and then we write that value to the memory location of \nm\nm\n.  Once written, the value of \nm\nm\n will not change until the next time we update the value of \nm\nm\n.\n\n\nIt is important to note that, when \ni\ni\n changes, \nm\nm\n \ndoes not change automatically\n to the new \nl_i\nl_i\n  This behavior is different from that which you may be familiar with in spreadsheet software -- if you set the value of a cell, say \nA1\n to be \n=B1\n, when the value in cell \nB1\n changes, the value \nA1\n also changes automatically.\n\n\nWe can also compare the values of two variables.  We see two examples above: \"\ni\ni\n equals \nk\nk\n?\"  \"\nl_i > m\nl_i > m\n?\"  When we compare, we read the values of the variables from their memory location and checks their relations.\n\n\nWe can perform arithmetic operations on the variables: addition, subtraction, etc.  We see one example above: \"increment \ni\ni\n\".  This operation is actually an assignment operation in disguise.  We can write it as \"set \ni\ni\n to \ni\ni\n + 1\".  Here, you see that \ni\ni\n is referred to twice.  This operation reads the value from the memory location of \ni\ni\n, adds 1 to it, and then writes the resulting value back to the location of \ni\ni\n.\n\n\nBugs\n\n\nIf you follow the execution of the algorithm above, step-by-step, using the example input \n4 1 -4 0 9 9 3 5\n above, you will obtain the correct maximum value \nm\nm\n of \n9\n.  But does that mean that the algorithm is correct?  The answer is NO.  \n\n\nFor an algorithm to correctly solve the given problem, it has to produce the correct result for all valid inputs to the problem.  If we can find one counterexample, one input where the algorithm does not produce the correct output, then the algorithm is incorrect.  Note that I say \ndoes not produce the correct output\n, which means that either the algorithm  \nproduces the wrong output\n or \ndoes not produce any output at all\n.  \n\n\nIn this case, we say that the algorithm or the program has a \nbug\n.  A bug is a defect that causes the algorithm to behave incorrectly.  As a software developer, you will spend some time finding bugs in your code, a process known as \ndebugging\n.  A \ndebugger\n is a tool that helps programmers find bugs in their code.\n\n\nBefore we even start the process of debugging, we first have to know if our algorithm is correct.  Remember that an algorithm is correct only if it produces the correct output only all possible valid inputs.  So, one way to check if an algorithm is correct is to try it with all possible valid inputs.  For the problem we are solving above, however, even though the list is finite, there are infinitely many possible inputs, and so, it is impossible to try all possible valid inputs.  In practice, we \ncraft\n a smaller set of test inputs to check if the algorithm behaves correctly for these test inputs, and \nhope\n that it is correct for all possible inputs.  With experience, you will choose the right set of test inputs to maximize that chances that you will find a bug in your code.  There are also systematic ways of deriving test cases so that the test cases \ncover\n different paths of execution of the algorithm, but we won't be covering it in CS1010\n3\n.\n\n\nAnother way of checking if an algorithm is correct, is to reason about the behavior of the algorithm.  We will do this rather informally in CS1010, starting in 1-2 lectures from now.  You get to rigorously prove that an algorithm is correct in a higher level module (CS3230 Design and Analysis of Algorithms).\n\n\nFinally, even if an algorithm is correct, the corresponding program might not be.  Recall that an algorithm is a step-by-step process to solve a problem.  It is what you want your program to do.  You still have to write a program (in C, or other languages) to actually have the computer do what you want it to do (in other words, to \nimplement the algorithm\n). This process of translating the algorithm to a computer program, called \ncoding\n may introduce bugs as well.  But we will worry about this later when we learn to program.\n\n\nIn the problem set at the end of this lecture, you will see slight variations of the algorithm above.  You should check through them to see whether they are correct or not.\n\n\nProblem Set\n\n\nProblem 1.1\n\n\nThe following algorithms are slight variations of the one in the notes above.  The differences are highlighted in red.  Do they correctly find the maximum integer from a finite list of \nk\nk\n integers (\nk > 0\nk > 0\n)?  \n\n\nIf an algorithm is buggy, give a counter-example where the output is incorrect.  In addition, give an example input where the algorithm still produces the correct output, where possible.  \n\n\n(a). \n\n\n\n(b). \n\n\n\n\u00a9. \n\n\n\n(d). \n\n\n\n(e). \n\n\n\nProblem 1.2\n\n\nChange the algorithm above to find the minimum value instead of the maximum value from the given list \nL = \\{l_0, ..., l_{k-1}\\}\nL = \\{l_0, ..., l_{k-1}\\}\n.\n\n\nProblem 1.3\n\n\nDraw the flowchart for an algorithm, that takes in a list of integers \nL = \\{l_0, ..., l_{k-1}\\}, k \\ge 0\nL = \\{l_0, ..., l_{k-1}\\}, k \\ge 0\n, and compute the \nsum\n of all the integers.  Think about what variable(s) do you need.\n\n\n\n\n\n\n\n\n\n\nThe answer is, by the way, always \"Yes.\"\u00a0\n\u21a9\n\n\n\n\n\n\nThink about why it is important to have a finite number of integers in the input.\u00a0\n\u21a9\n\n\n\n\n\n\nSoftware testing is a body of knowledge worthy of an advanced module by itself -- we offer one in CS4218.\u00a0\n\u21a9",
            "title": "2. Computational Problem &amp; Algorithms"
        },
        {
            "location": "/02-algo/index.html#unit-2-computational-problems-and-algorithms",
            "text": "",
            "title": "Unit 2: Computational Problems and Algorithms"
        },
        {
            "location": "/02-algo/index.html#learning-outcomes",
            "text": "After this unit, students should:   understand the basic terminologies: computational problem solving, algorithm, flowchart, debugging, testing, variables, value, assignment  be familiar with the algorithm to find the maximum among a list of numbers  be able to trace through flowcharts and updates of variables, and argue if a given algorithm is correct or incorrect",
            "title": "Learning Outcomes:"
        },
        {
            "location": "/02-algo/index.html#computational-problems",
            "text": "So, what is computational problem solving?  Let's start with the question, what is a  computational problem ?    A computational problem is a problem that can be solved step-by-step with a computer.  These problems usually have a well-defined input, constraints, and conditions that the output must satisfied.  Here are some types of computational problems:    A  decision problem  is one where the answer is yes or no.  For instance, \"given a number  n , is  n  even?\" is a decision problem.  Some decision problems take more steps to solve than others.  For instance, \"given a number  n , is  n  prime?\" takes more steps than just checking the parity of a number.    A  search problem  is one where the solution consists of one or more values that satisfies a given condition.  For instance, we may want to compute a path from one geographical location to another on a map.    A  counting problem  is one where the answer is the number of solutions to a search problem.    An  optimization problem  is one where the solution is the \"best\" possible solution, where the \"best\" can be defined in a different way.  For instance, we may want to compute the fastest route from one location to another.    Questions such as \"what is the meaning of life?\" \"do I look good in this outfit?\" 1  are not computational problems, because they do not have well-defined input, constraints, and conditions that the output must satisfy.  In CS1010 (followed by CS2040C and CS3230), you will learn how to solve computational problems  computationally  -- this means that you learn to come up with step-by-step instructions meant for computers that you can translate into computer programs, to solve a given problem.",
            "title": "Computational Problems"
        },
        {
            "location": "/02-algo/index.html#example-finding-the-maximum",
            "text": "Let's start with a simple problem.  Given a finite list  L L  of  k k  integers ( k k  > 0), find the integer with the maximum value from the list.  First, let's consider if this is a computational problem.  The input is very well defined.  We know what an integer is.  We are told we have at least one, and we have a finite number of them 2 .  Second, let's consider the output.  What conditions must the output satisfy?  First, it has to be equal or larger than every other integer on the list.  Second, it must be an integer  in  the list.  This is well defined by the problem statement, so we can say that it is a computational problem.  Here is an example.  Suppose the input consists of:  4 1 -4 0 9 9 3 5 8  The output should be  9 .  Now, you should pause reading and think about how you would solve this step-by-step.",
            "title": "Example: Finding the maximum"
        },
        {
            "location": "/02-algo/index.html#algorithm",
            "text": "One way to solve this problem is to check through the integers in the list, one-by-one, and keep track of the maximum value so far.  When you reach the end of the list, your \"maximum value so far\" will also be the maximum for the whole list.    Let's look at an example:     Integers Scanned  Maximum So Far      4  4    4 1  4    4 1 -4  4    4 1 -4 0  4    4 1 -4 0 9  9    4 1 -4 0 9 9  9    4 1 -4 0 9 9 3  9    4 1 -4 0 9 9 3 5  9    4 1 -4 0 9 9 3 5 8  9     The English description above, however, is not detailed enough for computers to understand.  What is the meaning of \"check one-by-one\"? \"keep track of maximum so far\"?  how to tell if we have reached \"the end of the list\"?  Let's work out all the details.  First, we need a concise way of representing the integers in the list.  Borrowing from mathematical notation, let's say that the list  L L  contains the integers  l_0, l_1, ..., l_{k-1} l_0, l_1, ..., l_{k-1} . To \"check one-by-one,\" we introduce another notation  l_i l_i , which is the integer currently being \"checked\".  We begin with  i = 0 i = 0 , then  i = 1 i = 1 , then  i = 2 i = 2 , etc, until  i = k-1 i = k-1 .  At every step, we increase  i i  by 1.  Second, we need a concise way of keeping track of the maximum so far.  We introduce another notation,  m m , to represent the maximum value so far.  When  i = 0 i = 0 ,  m = l_0 m = l_0 .  Since we only scan a single integer, it has to be the maximum.  When we check another integer  l_i (i > 0) l_i (i > 0) , only two things can happen:   if this  l_i l_i  is larger than  m m , then  l_i l_i  has to be the maximum so far, so we update  m m  to be  l_i l_i .  if  l_i l_i  is equal to or smaller than  m m , then  m m  is still the maximum value so far.   We keep doing the above and increase  i i , until we reach the end of the list when (after increasing  i i ) we find that  i i  is  k k .  Now, we have enough details to describe step-by-step, how to find the maximum value from a list of integers.  Such steps, which the computer can take to solve a problem, is called an  algorithm .",
            "title": "Algorithm"
        },
        {
            "location": "/02-algo/index.html#flowchart",
            "text": "There are different ways one can describe an algorithm.  The easiest way I find is to use a diagram called a  flowchart .  The flowchart for the algorithm above looks like this.  A diamond box represents a \"question\" that can be true or false (yes or no), and we trace through the \"flow\" step by step, following the corresponding path depending on the answer.    Please spend some time to trace through the walkthrough above.  The snapshot of the values of the  i i ,  l_i l_i ,  k k , and  m m , at the point after \"is  i i  equals  k k \" is shown in the table below  (except for the first row, which shows the value just before entering \"is  i i  equals  k k \") .     Integers Scanned  i i  l_i l_i  k k  Maximum So Far ( m m )      4  1  4  9  4    4 1  1  1  9  4    4 1 -4  2  -4  9  4    4 1 -4 0  3  0  9  4    4 1 -4 0 9  4  9  9  4    4 1 -4 0 9 9  5  9  9  9    4 1 -4 0 9 9 3  6  3  9  9    4 1 -4 0 9 9 3 5  7  5  9  9    4 1 -4 0 9 9 3 5 8  8  8  9  9    4 1 -4 0 9 9 3 5 8  9  ``  9  9",
            "title": "Flowchart"
        },
        {
            "location": "/02-algo/index.html#variables",
            "text": "There are a few important things to take note here.   m m ,  i i ,  k k , and the list  L L  are what we called  states  or  variables .  While in the above, we can think of them as mathematical variables which we can assign  values  to, in a computer program, a variable is a location in the memory which holds a value.    We can perform two very basic operations on the variables: reading and writing.  In other words, we can set their values and we can retrieve their values.   We can  assign  the value of one variable to a constant (e.g., set  i i  to 1) or to the value of another variable (e.g., set  m m  to  l_i l_i ).  In the latter example, we first read the value of  l_i l_i , from  l_i l_i 's memory location and then we write that value to the memory location of  m m .  Once written, the value of  m m  will not change until the next time we update the value of  m m .  It is important to note that, when  i i  changes,  m m   does not change automatically  to the new  l_i l_i   This behavior is different from that which you may be familiar with in spreadsheet software -- if you set the value of a cell, say  A1  to be  =B1 , when the value in cell  B1  changes, the value  A1  also changes automatically.  We can also compare the values of two variables.  We see two examples above: \" i i  equals  k k ?\"  \" l_i > m l_i > m ?\"  When we compare, we read the values of the variables from their memory location and checks their relations.  We can perform arithmetic operations on the variables: addition, subtraction, etc.  We see one example above: \"increment  i i \".  This operation is actually an assignment operation in disguise.  We can write it as \"set  i i  to  i i  + 1\".  Here, you see that  i i  is referred to twice.  This operation reads the value from the memory location of  i i , adds 1 to it, and then writes the resulting value back to the location of  i i .",
            "title": "Variables"
        },
        {
            "location": "/02-algo/index.html#bugs",
            "text": "If you follow the execution of the algorithm above, step-by-step, using the example input  4 1 -4 0 9 9 3 5  above, you will obtain the correct maximum value  m m  of  9 .  But does that mean that the algorithm is correct?  The answer is NO.    For an algorithm to correctly solve the given problem, it has to produce the correct result for all valid inputs to the problem.  If we can find one counterexample, one input where the algorithm does not produce the correct output, then the algorithm is incorrect.  Note that I say  does not produce the correct output , which means that either the algorithm   produces the wrong output  or  does not produce any output at all .    In this case, we say that the algorithm or the program has a  bug .  A bug is a defect that causes the algorithm to behave incorrectly.  As a software developer, you will spend some time finding bugs in your code, a process known as  debugging .  A  debugger  is a tool that helps programmers find bugs in their code.  Before we even start the process of debugging, we first have to know if our algorithm is correct.  Remember that an algorithm is correct only if it produces the correct output only all possible valid inputs.  So, one way to check if an algorithm is correct is to try it with all possible valid inputs.  For the problem we are solving above, however, even though the list is finite, there are infinitely many possible inputs, and so, it is impossible to try all possible valid inputs.  In practice, we  craft  a smaller set of test inputs to check if the algorithm behaves correctly for these test inputs, and  hope  that it is correct for all possible inputs.  With experience, you will choose the right set of test inputs to maximize that chances that you will find a bug in your code.  There are also systematic ways of deriving test cases so that the test cases  cover  different paths of execution of the algorithm, but we won't be covering it in CS1010 3 .  Another way of checking if an algorithm is correct, is to reason about the behavior of the algorithm.  We will do this rather informally in CS1010, starting in 1-2 lectures from now.  You get to rigorously prove that an algorithm is correct in a higher level module (CS3230 Design and Analysis of Algorithms).  Finally, even if an algorithm is correct, the corresponding program might not be.  Recall that an algorithm is a step-by-step process to solve a problem.  It is what you want your program to do.  You still have to write a program (in C, or other languages) to actually have the computer do what you want it to do (in other words, to  implement the algorithm ). This process of translating the algorithm to a computer program, called  coding  may introduce bugs as well.  But we will worry about this later when we learn to program.  In the problem set at the end of this lecture, you will see slight variations of the algorithm above.  You should check through them to see whether they are correct or not.",
            "title": "Bugs"
        },
        {
            "location": "/02-algo/index.html#problem-set",
            "text": "",
            "title": "Problem Set"
        },
        {
            "location": "/02-algo/index.html#problem-11",
            "text": "The following algorithms are slight variations of the one in the notes above.  The differences are highlighted in red.  Do they correctly find the maximum integer from a finite list of  k k  integers ( k > 0 k > 0 )?    If an algorithm is buggy, give a counter-example where the output is incorrect.  In addition, give an example input where the algorithm still produces the correct output, where possible.    (a).   (b).   \u00a9.   (d).   (e).",
            "title": "Problem 1.1"
        },
        {
            "location": "/02-algo/index.html#problem-12",
            "text": "Change the algorithm above to find the minimum value instead of the maximum value from the given list  L = \\{l_0, ..., l_{k-1}\\} L = \\{l_0, ..., l_{k-1}\\} .",
            "title": "Problem 1.2"
        },
        {
            "location": "/02-algo/index.html#problem-13",
            "text": "Draw the flowchart for an algorithm, that takes in a list of integers  L = \\{l_0, ..., l_{k-1}\\}, k \\ge 0 L = \\{l_0, ..., l_{k-1}\\}, k \\ge 0 , and compute the  sum  of all the integers.  Think about what variable(s) do you need.      The answer is, by the way, always \"Yes.\"\u00a0 \u21a9    Think about why it is important to have a finite number of integers in the input.\u00a0 \u21a9    Software testing is a body of knowledge worthy of an advanced module by itself -- we offer one in CS4218.\u00a0 \u21a9",
            "title": "Problem 1.3"
        },
        {
            "location": "/readings/index.html",
            "text": "Readings\n\n\nWhy C?\n\n\n\n\nLearn C programming and the rest will come, by Marty Jacobs\n\n\nThe Resurgence of C Programming, by Mark Barlow\n\n\nYou Can't Dig Upwards, by Evan Miller",
            "title": "Readings"
        },
        {
            "location": "/readings/index.html#readings",
            "text": "",
            "title": "Readings"
        },
        {
            "location": "/readings/index.html#why-c",
            "text": "Learn C programming and the rest will come, by Marty Jacobs  The Resurgence of C Programming, by Mark Barlow  You Can't Dig Upwards, by Evan Miller",
            "title": "Why C?"
        },
        {
            "location": "/environments/index.html",
            "text": "The CS1010 Programming Environment\n\n\nC is a common programming language and you can find different implementations of C compiler on many platforms.  Wikipedia \nlists more than 40 different C compilers\n.  These different compilers support different processor architecture, operating system, may behave slightly differently, and may support different features of C standards.  It is therefore important for CS1010 to stick to a single platform and single compiler.\n\n\nOur platform of choice is \nUbuntu 16.04 (or later)\n using the \nclang\n compiler (\nversion 3.4.2 or later\n).\n\n\nThe school has provided a list of computing servers for you to use.  You can access them remotely via \nssh\n, or secure shell.  The hosts are named \npe111\n, \npe112\n, ..., \npe120\n.  (\npe\n stands for \"programming environment\").\n\n\nYou can choose which of the 10 hosts to use.  You share the same home directory across all 10 hosts (this home directory, however, is different from that of \nsunfire\n).\n\n\nFor simplicity, the following guide uses \npe111\n in all examples.  Do keep in mind that you can use other hosts for CS1010 to spread out the load.\n\n\nWhile it is possible for you to complete the programming assignments on your own computers, the practical exams are done in a controlled environment using the desktop PCs in the programming labs.  It is therefore advisable for you to familiarize with accessing remote computing servers via \nssh\n and edit your program with either \nvim\n or \nmacro\n.\n\n\nBasic Requirements\n\n\n\n\n\n\nYou need to have an SoC UNIX account.  If you do not have one, you can \napply for one online\n.\n\n\n\n\n\n\nOnce you have an account, you need to [activate your access to the PE hosts] (\nhttps://mysoc.nus.edu.sg/~myacct/services.cgi\n), which is part of the SoC computer clusters.\n\n\n\n\n\n\nYou need an \nssh\n client.  MacOS and Linux users should already have it installed by default.  Windows 10 users should install \nthe Windows Subsystem for Linux\n and use Linux.\n\n\n\n\n\n\nFor older versions of Windows, such as those used in the SoC's programming labs, you can check out \nXShell 6\n (free for home/school use), or \nPuTTY\n.  These are GUI-based programs so the command lines instructions below do not apply.\n\n\nThe Command to SSH\n\n\nRun:\n\n1\nssh <username>@pe111.comp.nus.edu.sg\n\n\n\n\n\nReplace \n<username>\n with your SoC UNIX username, for instance, I would do:\n\n1\nssh ooiwt@pe111.comp.nus.edu.sg\n\n\n\n\n\nAfter the command above, following the instructions on the screen.  The first time you ever connect to \npe111.comp.nus.edu.sg\n, you will be warned that you are connecting to a previously unknown host.  Say \nyes\n, and you will be prompted with your SoC UNIX password.\n\n\nAccessing The PE Hosts from Outside SoC\n\n\nThe PE hosts can only be accessed from within the School of Computing networks.  If you want to access it from outside, there are two ways.\n\n\nUsing SoC VPN\n\n\nOne way is to set up a Virtual Private Network (VPN) (See \ninstruction here\n.  The staff at \nhelpdesk@comp.nus.edu.sg\n or the IT helpdesk in COM1, Level 1, will be able to help with you setting up if needed.\n\n\nTunneling through Sunfire\n\n\nThe alternative is to use ssh tunnels.\n\n\nSoC's Sunfire (\nsunfire.comp.nus.edu.sg\n) is configured to allow your connection if it's originating from a local telco. (See \nmore details here\n.)  Since \nsunfire\n is situated within the School of Computing network, \nsunfire\n is able to access the VM.  This opens the possibility of connecting from your device (using an Internet connection from a local telco) to \nsunfire\n, and then from \nsunfire\n to the VM.\n\n\nThere are two ways to achieve this, and in both ways it appears to the PE hosts that Sunfire is the client.\n\n\nSSH Using Sunfire's Terminal\n\n\nConnect to Sunfire at \nsunfire.comp.nus.edu.sg\n via your favorite SSH client.  After logging in, run the command \nssh pe111\n to connect to the programming environment.  This effectively starts an SSH session to the programming environment from within your existing SSH session to Sunfire.  Refer to instructions below on how to connect via SSH.\n\n\nSSH Port Forwarding\n\n\nSSH has built-in support for local and remote port forwarding, and local port forwarding can be used to connect to the programming environments.  Local port forwarding means that a port of the SSH client (your machine) is forwarded to the SSH server (\nsunfire\n), which opens a connection to a preset destination server (e.g., \npe111\n).  This method causes the host to seem as if it is hosted on a local port, e.g. \nlocalhost\n:\n1010\n, allowing you to use your favorite SCP program (e.g. \nFileZilla\n) to access the PE host.\n\n\nTo use local port forwarding (from local port \n1010\n), connect to \nsunfire\n using\n\n1\nssh -L 1010:pe111.comp.nus.edu.sg:22 <username>@sunfire.comp.nus.edu.sg\n\n\n\n\nThis command opens an SSH tunnel from port \n1010\n of your machine to port \n22\n (the default SSH port) of \npe111.comp.nus.edu.sg\n via \nsunfire\n.  After successful login, open a separate SSH (or SCP) connection from your machine to \nlocalhost\n:\n1010\n to access the VM.\n\n\nPuTTY\n supports SSH port forwarding, so this setup can also be used on Windows.\n\n\nSetting up SSH Keys\n\n\nOnce you are comfortable with UNIX, you can set up a pair of public/private keys for authentication.  \n\n\nYou can use\n\n1\nssh-keygen -t rsa\n\n\n\n\n\nto generate a pair of keys on your local computer.  Keep the private key \nid_rsa\n on your local machine in the hidden \n~/.ssh\n directory, and copy the public key \nid_rsa.pub\n to your home directory on PE \npe111\n.  On \npe111\n, run\n\n1\ncat id_rsa.pub >> ~/.ssh/authorized_keys\n\n\n\n\n\nMake sure that the permission for \n.ssh\n both on local machine and on PE is set to \n700\n and the files \nid_rsa\n on local machine and \nauthorized_keys\n on remote machine is set to \n600\n.  Once setup, you need not enter your password every time you run \nssh\n or \nscp\n.",
            "title": "Programming Environments"
        },
        {
            "location": "/environments/index.html#the-cs1010-programming-environment",
            "text": "C is a common programming language and you can find different implementations of C compiler on many platforms.  Wikipedia  lists more than 40 different C compilers .  These different compilers support different processor architecture, operating system, may behave slightly differently, and may support different features of C standards.  It is therefore important for CS1010 to stick to a single platform and single compiler.  Our platform of choice is  Ubuntu 16.04 (or later)  using the  clang  compiler ( version 3.4.2 or later ).  The school has provided a list of computing servers for you to use.  You can access them remotely via  ssh , or secure shell.  The hosts are named  pe111 ,  pe112 , ...,  pe120 .  ( pe  stands for \"programming environment\").  You can choose which of the 10 hosts to use.  You share the same home directory across all 10 hosts (this home directory, however, is different from that of  sunfire ).  For simplicity, the following guide uses  pe111  in all examples.  Do keep in mind that you can use other hosts for CS1010 to spread out the load.  While it is possible for you to complete the programming assignments on your own computers, the practical exams are done in a controlled environment using the desktop PCs in the programming labs.  It is therefore advisable for you to familiarize with accessing remote computing servers via  ssh  and edit your program with either  vim  or  macro .",
            "title": "The CS1010 Programming Environment"
        },
        {
            "location": "/environments/index.html#basic-requirements",
            "text": "You need to have an SoC UNIX account.  If you do not have one, you can  apply for one online .    Once you have an account, you need to [activate your access to the PE hosts] ( https://mysoc.nus.edu.sg/~myacct/services.cgi ), which is part of the SoC computer clusters.    You need an  ssh  client.  MacOS and Linux users should already have it installed by default.  Windows 10 users should install  the Windows Subsystem for Linux  and use Linux.    For older versions of Windows, such as those used in the SoC's programming labs, you can check out  XShell 6  (free for home/school use), or  PuTTY .  These are GUI-based programs so the command lines instructions below do not apply.",
            "title": "Basic Requirements"
        },
        {
            "location": "/environments/index.html#the-command-to-ssh",
            "text": "Run: 1 ssh <username>@pe111.comp.nus.edu.sg   Replace  <username>  with your SoC UNIX username, for instance, I would do: 1 ssh ooiwt@pe111.comp.nus.edu.sg   After the command above, following the instructions on the screen.  The first time you ever connect to  pe111.comp.nus.edu.sg , you will be warned that you are connecting to a previously unknown host.  Say  yes , and you will be prompted with your SoC UNIX password.",
            "title": "The Command to SSH"
        },
        {
            "location": "/environments/index.html#accessing-the-pe-hosts-from-outside-soc",
            "text": "The PE hosts can only be accessed from within the School of Computing networks.  If you want to access it from outside, there are two ways.",
            "title": "Accessing The PE Hosts from Outside SoC"
        },
        {
            "location": "/environments/index.html#using-soc-vpn",
            "text": "One way is to set up a Virtual Private Network (VPN) (See  instruction here .  The staff at  helpdesk@comp.nus.edu.sg  or the IT helpdesk in COM1, Level 1, will be able to help with you setting up if needed.",
            "title": "Using SoC VPN"
        },
        {
            "location": "/environments/index.html#tunneling-through-sunfire",
            "text": "The alternative is to use ssh tunnels.  SoC's Sunfire ( sunfire.comp.nus.edu.sg ) is configured to allow your connection if it's originating from a local telco. (See  more details here .)  Since  sunfire  is situated within the School of Computing network,  sunfire  is able to access the VM.  This opens the possibility of connecting from your device (using an Internet connection from a local telco) to  sunfire , and then from  sunfire  to the VM.  There are two ways to achieve this, and in both ways it appears to the PE hosts that Sunfire is the client.",
            "title": "Tunneling through Sunfire"
        },
        {
            "location": "/environments/index.html#ssh-using-sunfires-terminal",
            "text": "Connect to Sunfire at  sunfire.comp.nus.edu.sg  via your favorite SSH client.  After logging in, run the command  ssh pe111  to connect to the programming environment.  This effectively starts an SSH session to the programming environment from within your existing SSH session to Sunfire.  Refer to instructions below on how to connect via SSH.",
            "title": "SSH Using Sunfire's Terminal"
        },
        {
            "location": "/environments/index.html#ssh-port-forwarding",
            "text": "SSH has built-in support for local and remote port forwarding, and local port forwarding can be used to connect to the programming environments.  Local port forwarding means that a port of the SSH client (your machine) is forwarded to the SSH server ( sunfire ), which opens a connection to a preset destination server (e.g.,  pe111 ).  This method causes the host to seem as if it is hosted on a local port, e.g.  localhost : 1010 , allowing you to use your favorite SCP program (e.g.  FileZilla ) to access the PE host.  To use local port forwarding (from local port  1010 ), connect to  sunfire  using 1 ssh -L 1010:pe111.comp.nus.edu.sg:22 <username>@sunfire.comp.nus.edu.sg  \nThis command opens an SSH tunnel from port  1010  of your machine to port  22  (the default SSH port) of  pe111.comp.nus.edu.sg  via  sunfire .  After successful login, open a separate SSH (or SCP) connection from your machine to  localhost : 1010  to access the VM.  PuTTY  supports SSH port forwarding, so this setup can also be used on Windows.",
            "title": "SSH Port Forwarding"
        },
        {
            "location": "/environments/index.html#setting-up-ssh-keys",
            "text": "Once you are comfortable with UNIX, you can set up a pair of public/private keys for authentication.    You can use 1 ssh-keygen -t rsa   to generate a pair of keys on your local computer.  Keep the private key  id_rsa  on your local machine in the hidden  ~/.ssh  directory, and copy the public key  id_rsa.pub  to your home directory on PE  pe111 .  On  pe111 , run 1 cat id_rsa.pub >> ~/.ssh/authorized_keys   Make sure that the permission for  .ssh  both on local machine and on PE is set to  700  and the files  id_rsa  on local machine and  authorized_keys  on remote machine is set to  600 .  Once setup, you need not enter your password every time you run  ssh  or  scp .",
            "title": "Setting up SSH Keys"
        },
        {
            "location": "/unix/index.html",
            "text": "Basic UNIX Commands\n\n\nUNIX-based operating systems provide a command line to interact with the system: to create directory, to manipulate files, to run certain applications.  While these tasks can be done through a GUI interface, a command line is still useful because (i) it provides a simple way to interacting with a remote system (only text are exchanged between the local and remote hosts instead of graphics); (ii) it is extremely flexible and provides many customization options; (iii) you can easily automate the sequence of commands to issue for repetitive tasks; and (iv) it is faster.  \n\n\nConnect to the Programming Environment (PE)\n\n\nIf you would like to follow the following examples, you should first \nssh\n into one of the PE hosts provided.  We will use \npe111\n in the following example.  But feel free to use \npe112\n up to \npe120\n for your practice.  You should read \nthis guide\n to see how to access and connect to the environment.\n\n\nOnce you are connected, you should see a prompt like this.\n\n\n1\nooiwt@pe111:~$\n\n\n\n\n\n\nThis interface is provided by a UNIX shell -- this shell sits in a loop and wait for users to enter a command, then it interprets and executes the command.  There are many versions of shells, the default shell for our PE is \nbash\n1\n.\n\n\nThe following is adapted for CS1010 from \nthe instructions created by Aaron Tan\n. Bugs are mine.\n  \n\n\nThe power of UNIX stems from the many commands it offers. The following are a few commonly used commands. This list is by no means exhaustive and you are urged to explore on your own. Note that UNIX commands are \ncase-sensitive\n.\n\n\nAll commands are to be entered after the UNIX prompt of the form\n\n\n1\nooiwt@pe111:~$\n\n\n\n\n\n\n~\n indicates that you are currently in your home directory.  The following examples assumes that user \nooiwt\n is logged into \npe111\n.\n\n\nIt might be good to understand the directory structure in UNIX, a multi-user system. The directory tree is shown below:\n\n\n\n\nEach user has his/her own home directory, which is where he/she will be automatically placed when he/she logs into the system. The above figure shows where the home directory of user \nooiwt\n resides in the directory tree. The user \nooiwt\n may create files or directories in his/her home directory, but not elsewhere unless permission is given.\n\n\npwd\n: Print Current Working directory\n\n\npwd\n shows you which directory you are currently in\n\n1\n2\nooiwt@pe111:~$ pwd\n/home/o/ooiwt\n\n\n\n\n\nUNIX uses forward slash \n/\n to deliminate different parts of the directory structure.  This is the same notation as URLs so you should already be familiar with it.\n\n\nls\n: LiSt files\n\n\nThe \nls\n list the files in the current working directory.\n\n\n1\n2\nooiwt@pe111:~$ ls\nooiwt@pe111:~$\n\n\n\n\n\n\nIf you do not have any regular files in your home directory, as you should when you first login, you should immediately return to the shell prompt.  \n\n\n\n\nRule of Silence\n\n\nUNIX follows the \nrule of silence\n: programs should not print unnecessary output, to allow other programs and users to easily parse the output from one program.  So, if \nls\n has nothing to list, it will list nothing (as oppose to, say, printing \"This is an empty directory.\")\n\n\n\n\nmkdir\n: MaKe a subDIRectory\n\n\nThe \nmkdir\n command creates a subdirectory with the given name in the current directory.\n\n\n1\n2\n3\n4\n5\nooiwt@pe111:~$ mkdir tut01\nooiwt@pe111:~$ ls\ntut01\nooiwt@pe111:~$ ls -F\ntut01/\n\n\n\n\n\n\nHere, you create a directory called \ntut01\n.  Now, when you \nls\n, you can see the directory listed.\n\n\nYou may also use \nls -F\n for more information (\n-F\n is one of the many \noptions\n/\nflags\n available for the \nls\n command. To see a complete list of the options, refer to the man pages, i.e., \nman ls\n.)\n\n\nThe slash \n/\n beside the filename tells you that the file is a directory (aka folder in Windows lingo). A normal file does not have a slash beside its name when \"ls -F\" is used.\n\n\nYou may also use the \nls -l\n command (hyphen el, not hyphen one) to display almost all the file information, include the size of the file and the date of modification.\n\n\n\n\nUse Up Arrow for Command History\n\n\nUNIX maintains a history of your previously executed UNIX commands, and you may use the up and down arrows to go through it. Press the up arrow until you find a previously executed UNIX command. You may then press Enter to execute it, or edit the command before executing it. This is handy when you need to repeatedly executed a long UNIX command.\n\n\n\n\ncd\n: Change Directory\n\n\nTo navigate in the directory tree, changing the current working directory from to another, we use the \ncd\n command.\n\n\n1\n2\nooiwt@pe111:~$ cd tut01\nooiwt@pe111:~/tut01$\n\n\n\n\nNote that the prompt changes to \n~/tut01\n to indicate that you are now in the \ntut01\n directory below your \nHOME\n directory.\n\n\nEntering \ncd\n alone brings you back to your \nHOME\n directory, i.e., the directory in which you started with when you first logged into the system.\n\n1\n2\nooiwt@pe111:~/tut01$ cd\nooiwt@pe111:~$\n\n\n\n\n\nTwo dots \n..\n refers to the parent directory.  So, alternatively, for the case above, since we are only one level down from the \nHOME\n, to return to home, we can alternatively use \ncd ..\n.\n\n\n1\n2\nooiwt@pe111:~/tut01$ cd ..\nooiwt@pe111:~$\n\n\n\n\n\n\nrmdir\n: ReMove a subDIRectory\n\n\nrmdir\n removes a subDIRectory in current directory -- note that a directory must be empty before it can be removed.\n\n\n1\n2\n3\n4\n5\nooiwt@pe111:~$ rmdir tut01\nooiwt@pe111:~$ ls -F\nooiwt@pe111:~$ mkdir tut01\nooiwt@pe111:~$ ls -F\ntut01/\n\n\n\n\n\n\ncp\n: CoPy files\n\n\n1\n2\n3\nooiwt@pe111:~/tut01$ cp ~cs1010/tut01/hello.c .\nooiwt@pe111:~/tut01$ ls\nhello.c\n\n\n\n\nThe command above copies the file \nhello.c\n from the HOME of user \ncs1010\n, under directory \ntut01\n, to the current directory.\n\n\nIf you want to copy the whole directory, use \n-r\n flag, where \nr\n stands for recursive copy.\n\n\n1\nooiwt@pe111:~/tut01$ cp -r ~cs1010/tut01 .\n\n\n\n\n\n\nIn the last command above, the single \n.\n refers to the current directory.  \n\n\nThe directory \ntut01\n and everything under it will be copied to the current directory.\n\n\nmv\n: MoVe or rename files\n\n\nmv\n can move files from one directory to another.\n\n\n1\n2\n3\n4\n5\n6\n7\nooiwt@pe111:~/tut01$ ls\nhello.c\nooiwt@pe111:~/tut01$ mv hello.c ..\nooiwt@pe111:~/tut01$ ls\nooiwt@pe111:~/tut01$ ls ..\nhello.java\nooiwt@pe111:~/tut01$ mv ../hello.c .\n\n\n\n\n\n\nHere, we tell \nmv\n to copy a file \nhello.c\n from the parent directory to the current directory.\n\n\nmv\n can also be used to rename files.\n\n\n1\n2\n3\nooiwt@pe111:~/tut01$ mv hello.c hello_world.java\nooiwt@pe111:~/tut01$ ls\nhello_world.java\n\n\n\n\n\n\n\n\nUse TAB for name Completion\n\n\nIf you have a very long file name, you may use UNIX's filename completion feature to reduce typing. For instance, you may type:\n\n1\nooiwt@pe111:~/tut01$ mv h\n\n\n\n\nand press the tab key, and UNIX will complete the filename for you if there is only one filename with the prefix \"h\". Otherwise, it will fill up the filename up to point where you need to type in more characters for disambiguation.\nThe tab key can also complete the name of command.\n\n\n\n\nrm\n: ReMove files\n\n\nBe careful with this command -- files deleted cannot be restored.  There is no trash or recycled bin like in Mac or Windows.\n\n\n1\n2\n3\nooiwt@pe111:~/tut01$ rm hello.c\nooiwt@pe111:~/tut01$ ls\nooiwt@pe111:~/tut01$\n\n\n\n\n\n\n\n\nrm -rf *\n\n\nWhile UNIX command line provides lots of flexibility and power, with great power comes great responsibility.  Some of the commands are extremely dangerous.  \nrm -rf *\n is the most famous one.  The notation \n*\n refers to all files, and the flag \n-f\n means forceful deletion (no question asked!) and \n-r\n means remove recursively everything under the current directory tree.  Accidentally running this command has ruined many files.  \nRead more here\n\n\n\n\nrm\n comes with a \n-i\n flag that interactively ask you if you are sure if you want to delete a file.  It is a good idea to always run \nrm -i\n.  In case you format, I suggest that you \nalias\n the command \nrm\n to \nrm -i\n by inserting this line into the file \n~/.bashrc\n.\n\n\n1\nalias\n \nrm\n=\n\"rm -i\"\n\n\n\n\n\n\n\ncat\n: CATenate file content to screen\n\n\n1\nooiwt@pe111:~/tut01$ cat hello.c\n\n\n\n\n\n\nless\n is variant of \ncat\n that includes features to read each page leisurely)\n\n1\nooiwt@pe111:~/tut01$ less hello.c\n\n\n\n\n\nIn \nless\n, use \n<space>\n to move down one page, \nb\n to move Back up one page, and \nq\n to Quit.\n\n\nman\n: Online MANual\n\n\nAn online help facility is available in UNIX via the \nman\n command (\nman\n stands for MANual). To look for more information about any UNIX command, for example, \nls\n, type \nman ls\n. Type \nman man\n and refer to Man Pages to find out more about the facility. To exit \nman\n, press \nq\n.\n\n\nNow that you are familiar with how the UNIX shell works, I won't show the command prompt any more in the rest of this article.\n\n\nchmod\n: Changing UNIX File Permission\n\n\nIt is important to guide our files properly on a multi-user system where users share the same file system.  UNIX has a simple mechanism to for ensuring that: every file and directory has nine bits of access permission, corresponds to three access operations, read (\nr\n), write (\nw\n), and execute (\nx\n), for four classes of users, the user who owns of the file (\nu\n), users in the same group as the owner (\ng\n), all other users (\no\n), and all users (\na\n) (union of all three classes before)\n\n\nWhen you run \nls -l\n, you will see the permission encoded as strings that look like \n-rw-------\n or \ndrwx--x--x\n besides other file information.   \n\n\n\n\nThe first character indicates if the file is a directory (\nd\n) or not (\n-\n).  \n\n\nThe next three characters are the permission for the owner.  \nrwx\n means that the owner can do all three: reading, writing, and executing, \nrw-\n means that the owner can read and write, but cannot execute.\n\n\nThe next three characters are the permission for the users in the same group.\n\n\nThe last three characters are the permission for the users in the other groups.\n\n\n\n\nTo change permission, we use the \nchmod\n command.  Let's say that we want to remove the read and write permission from all other users in the group.  You can run:\n\n\n1\nchmod g-rw <file>\n\n\n\n\n\n\nwhere \n<file>\n is the name of the file whose permission you want to change.  This would change the permission from \n-rw-rw-rw-\n to \n-rw----rw-\n, or from \n-rwxr--r--\n to \n-rwx---r--\n.\n\n\nTo add executable permission to everyone, you can run:\n\n\n1\nchmod a+x <file>\n\n\n\n\n\n\nThis would change the permission from \n-rw-rw-rw-\n to \n-rwx--xrwx\n, or from \n-rwxr--r--\n to \n-rwx--xr-x\n, and so on.  You get the idea.\n\n\nAnother way to change the permission is set the permission directly, instead of adding with \n+\n and removing with \n-\n.  To do this, one convenient way is to treat the permission for each class of user as a 3-bit binary number between 0 to 7.  So, \nrwx\n is 7, \nrw-\n is 6, \n-w-\n is 2, \n---\n is 0, etc.  \n\n\nTo set the permission of a file to \n-r--r--r--\n (readable by everyone), run:\n\n\n1\nchmod \n444\n <file>\n\n\n\n\n\n\nTo set the permission to \n-rw-------\n, run:\n\n\n1\nchmod \n600\n <file>\n\n\n\n\n\n\nand so on.\n\n\nIt is important to ensure that your code is not readable and writable by other students, especially for graded lab exercises.\n\n\nscp\n: Secure Copy\n\n\nSecure copy, or \nscp\n, is one way to transfer files from the programming environments to your local computer for archiving or storage.  Let's say you want to transfer a set of C files from the directory \na01\n to your local computer, then, on your local computer, run:\n\n\n1\nooiwt@macbook:~$ scp ooiwt@pe111:~/a01/*.c .\n\n\n\n\n\n\n\n\nWarning\n\n\nIf you have files with the same name in the remote directory, the files will be overwritten without warning.  I have lost my code a few times due to \nscp\n.  \n\n\n\n\nThe expression \n*.c\n is a \nregular expression\n that means all files with filename ending with \n.c\n.  You can copy specific files as well.  For instance,\n\n\n1\nooiwt@macbook:~$ scp ooiwt@pe111:~/a01/hello.c .\n\n\n\n\n\n\nscp\n supports \n-r\n (recursive copy) as well.\n\n\nSpecifying A Path in UNIX\n\n\nIn any command above, when we need to refer to a directory or a file, we need to specify an \nunambiguous location\n of the directory or the file.  The most precise way to specify the location is to use the full path, or the \nabsolute path\n.  For instance:\n\n\n1\ncp /home/o/ooiwt/tut01/hello.c /home/o/ooiwt/tut01/hello_world.c\n\n\n\n\n\n\nThat's a lot of characters to type.  We could shorten it in a few ways.  \n\n\n\n\nWe could specify the location with respect to the home directory using \n~\n.  \n~ooiwt\n refers to the home directory of user \nooiwt\n.  \n\n\n\n\n1\ncp ~ooiwt/tut01/hello.c ~ooiwt/tut01/hello_world.c\n\n\n\n\n\n\nIf you are \nooiwt\n, then you can omit \nooiwt\n, since \n~\n without any username refers to your home directory.\n\n\n1\ncp ~/tut01/hello.c ~/tut01/hello_world.c\n\n\n\n\n\n\n\n\nOr we could specify the location with respect to the current directory.  Suppose the current working directory is \n~/tut01\n (i.e., we have \ncd\n into \n~/tut01\n), then we could say this:\n\n\n\n\n1\ncp ./hello.c ./hello_world.c\n\n\n\n\n\n\nRecall that a single dot \n.\n refers to the current directory.\n\n\nThe \n./\n however is redundant unless you are executing a command.  Since, by specifying a file name or a directory without a path (i.e., not using any \n/\n), the shell looks for the file or directory in the current directory.  So, we could just do:\n\n\n1\ncp hello.c hello_world.c\n\n\n\n\n\n\nAnother important short form for relative location is \n..\n.  Recall that this refers to the parent directory.  Suppose that the current directory is in \n~/tut02\n.  Then, to copy the files in \n~/tut01\n, you can run:\n\n\n1\ncp ../tut01/hello.c ../tut01/hello_world.c\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nI run \nfish\n on my macOS, as you might have noticed during the in-class demos.  You can use any shell you like, if you know what you are doing.  Otherwise, \nbash\n is a popular one.\u00a0\n\u21a9",
            "title": "UNIX"
        },
        {
            "location": "/unix/index.html#basic-unix-commands",
            "text": "UNIX-based operating systems provide a command line to interact with the system: to create directory, to manipulate files, to run certain applications.  While these tasks can be done through a GUI interface, a command line is still useful because (i) it provides a simple way to interacting with a remote system (only text are exchanged between the local and remote hosts instead of graphics); (ii) it is extremely flexible and provides many customization options; (iii) you can easily automate the sequence of commands to issue for repetitive tasks; and (iv) it is faster.",
            "title": "Basic UNIX Commands"
        },
        {
            "location": "/unix/index.html#connect-to-the-programming-environment-pe",
            "text": "If you would like to follow the following examples, you should first  ssh  into one of the PE hosts provided.  We will use  pe111  in the following example.  But feel free to use  pe112  up to  pe120  for your practice.  You should read  this guide  to see how to access and connect to the environment.  Once you are connected, you should see a prompt like this.  1 ooiwt@pe111:~$   This interface is provided by a UNIX shell -- this shell sits in a loop and wait for users to enter a command, then it interprets and executes the command.  There are many versions of shells, the default shell for our PE is  bash 1 .  The following is adapted for CS1010 from  the instructions created by Aaron Tan . Bugs are mine.     The power of UNIX stems from the many commands it offers. The following are a few commonly used commands. This list is by no means exhaustive and you are urged to explore on your own. Note that UNIX commands are  case-sensitive .  All commands are to be entered after the UNIX prompt of the form  1 ooiwt@pe111:~$   ~  indicates that you are currently in your home directory.  The following examples assumes that user  ooiwt  is logged into  pe111 .  It might be good to understand the directory structure in UNIX, a multi-user system. The directory tree is shown below:   Each user has his/her own home directory, which is where he/she will be automatically placed when he/she logs into the system. The above figure shows where the home directory of user  ooiwt  resides in the directory tree. The user  ooiwt  may create files or directories in his/her home directory, but not elsewhere unless permission is given.",
            "title": "Connect to the Programming Environment (PE)"
        },
        {
            "location": "/unix/index.html#pwd-print-current-working-directory",
            "text": "pwd  shows you which directory you are currently in 1\n2 ooiwt@pe111:~$ pwd\n/home/o/ooiwt   UNIX uses forward slash  /  to deliminate different parts of the directory structure.  This is the same notation as URLs so you should already be familiar with it.",
            "title": "pwd: Print Current Working directory"
        },
        {
            "location": "/unix/index.html#ls-list-files",
            "text": "The  ls  list the files in the current working directory.  1\n2 ooiwt@pe111:~$ ls\nooiwt@pe111:~$   If you do not have any regular files in your home directory, as you should when you first login, you should immediately return to the shell prompt.     Rule of Silence  UNIX follows the  rule of silence : programs should not print unnecessary output, to allow other programs and users to easily parse the output from one program.  So, if  ls  has nothing to list, it will list nothing (as oppose to, say, printing \"This is an empty directory.\")",
            "title": "ls: LiSt files"
        },
        {
            "location": "/unix/index.html#mkdir-make-a-subdirectory",
            "text": "The  mkdir  command creates a subdirectory with the given name in the current directory.  1\n2\n3\n4\n5 ooiwt@pe111:~$ mkdir tut01\nooiwt@pe111:~$ ls\ntut01\nooiwt@pe111:~$ ls -F\ntut01/   Here, you create a directory called  tut01 .  Now, when you  ls , you can see the directory listed.  You may also use  ls -F  for more information ( -F  is one of the many  options / flags  available for the  ls  command. To see a complete list of the options, refer to the man pages, i.e.,  man ls .)  The slash  /  beside the filename tells you that the file is a directory (aka folder in Windows lingo). A normal file does not have a slash beside its name when \"ls -F\" is used.  You may also use the  ls -l  command (hyphen el, not hyphen one) to display almost all the file information, include the size of the file and the date of modification.   Use Up Arrow for Command History  UNIX maintains a history of your previously executed UNIX commands, and you may use the up and down arrows to go through it. Press the up arrow until you find a previously executed UNIX command. You may then press Enter to execute it, or edit the command before executing it. This is handy when you need to repeatedly executed a long UNIX command.",
            "title": "mkdir: MaKe a subDIRectory"
        },
        {
            "location": "/unix/index.html#cd-change-directory",
            "text": "To navigate in the directory tree, changing the current working directory from to another, we use the  cd  command.  1\n2 ooiwt@pe111:~$ cd tut01\nooiwt@pe111:~/tut01$  \nNote that the prompt changes to  ~/tut01  to indicate that you are now in the  tut01  directory below your  HOME  directory.  Entering  cd  alone brings you back to your  HOME  directory, i.e., the directory in which you started with when you first logged into the system. 1\n2 ooiwt@pe111:~/tut01$ cd\nooiwt@pe111:~$   Two dots  ..  refers to the parent directory.  So, alternatively, for the case above, since we are only one level down from the  HOME , to return to home, we can alternatively use  cd .. .  1\n2 ooiwt@pe111:~/tut01$ cd ..\nooiwt@pe111:~$",
            "title": "cd: Change Directory"
        },
        {
            "location": "/unix/index.html#rmdir-remove-a-subdirectory",
            "text": "rmdir  removes a subDIRectory in current directory -- note that a directory must be empty before it can be removed.  1\n2\n3\n4\n5 ooiwt@pe111:~$ rmdir tut01\nooiwt@pe111:~$ ls -F\nooiwt@pe111:~$ mkdir tut01\nooiwt@pe111:~$ ls -F\ntut01/",
            "title": "rmdir: ReMove a subDIRectory"
        },
        {
            "location": "/unix/index.html#cp-copy-files",
            "text": "1\n2\n3 ooiwt@pe111:~/tut01$ cp ~cs1010/tut01/hello.c .\nooiwt@pe111:~/tut01$ ls\nhello.c  \nThe command above copies the file  hello.c  from the HOME of user  cs1010 , under directory  tut01 , to the current directory.  If you want to copy the whole directory, use  -r  flag, where  r  stands for recursive copy.  1 ooiwt@pe111:~/tut01$ cp -r ~cs1010/tut01 .   In the last command above, the single  .  refers to the current directory.    The directory  tut01  and everything under it will be copied to the current directory.",
            "title": "cp: CoPy files"
        },
        {
            "location": "/unix/index.html#mv-move-or-rename-files",
            "text": "mv  can move files from one directory to another.  1\n2\n3\n4\n5\n6\n7 ooiwt@pe111:~/tut01$ ls\nhello.c\nooiwt@pe111:~/tut01$ mv hello.c ..\nooiwt@pe111:~/tut01$ ls\nooiwt@pe111:~/tut01$ ls ..\nhello.java\nooiwt@pe111:~/tut01$ mv ../hello.c .   Here, we tell  mv  to copy a file  hello.c  from the parent directory to the current directory.  mv  can also be used to rename files.  1\n2\n3 ooiwt@pe111:~/tut01$ mv hello.c hello_world.java\nooiwt@pe111:~/tut01$ ls\nhello_world.java    Use TAB for name Completion  If you have a very long file name, you may use UNIX's filename completion feature to reduce typing. For instance, you may type: 1 ooiwt@pe111:~/tut01$ mv h  \nand press the tab key, and UNIX will complete the filename for you if there is only one filename with the prefix \"h\". Otherwise, it will fill up the filename up to point where you need to type in more characters for disambiguation.\nThe tab key can also complete the name of command.",
            "title": "mv: MoVe or rename files"
        },
        {
            "location": "/unix/index.html#rm-remove-files",
            "text": "Be careful with this command -- files deleted cannot be restored.  There is no trash or recycled bin like in Mac or Windows.  1\n2\n3 ooiwt@pe111:~/tut01$ rm hello.c\nooiwt@pe111:~/tut01$ ls\nooiwt@pe111:~/tut01$    rm -rf *  While UNIX command line provides lots of flexibility and power, with great power comes great responsibility.  Some of the commands are extremely dangerous.   rm -rf *  is the most famous one.  The notation  *  refers to all files, and the flag  -f  means forceful deletion (no question asked!) and  -r  means remove recursively everything under the current directory tree.  Accidentally running this command has ruined many files.   Read more here   rm  comes with a  -i  flag that interactively ask you if you are sure if you want to delete a file.  It is a good idea to always run  rm -i .  In case you format, I suggest that you  alias  the command  rm  to  rm -i  by inserting this line into the file  ~/.bashrc .  1 alias   rm = \"rm -i\"",
            "title": "rm: ReMove files"
        },
        {
            "location": "/unix/index.html#cat-catenate-file-content-to-screen",
            "text": "1 ooiwt@pe111:~/tut01$ cat hello.c   less  is variant of  cat  that includes features to read each page leisurely) 1 ooiwt@pe111:~/tut01$ less hello.c   In  less , use  <space>  to move down one page,  b  to move Back up one page, and  q  to Quit.",
            "title": "cat: CATenate file content to screen"
        },
        {
            "location": "/unix/index.html#man-online-manual",
            "text": "An online help facility is available in UNIX via the  man  command ( man  stands for MANual). To look for more information about any UNIX command, for example,  ls , type  man ls . Type  man man  and refer to Man Pages to find out more about the facility. To exit  man , press  q .  Now that you are familiar with how the UNIX shell works, I won't show the command prompt any more in the rest of this article.",
            "title": "man: Online MANual"
        },
        {
            "location": "/unix/index.html#chmod-changing-unix-file-permission",
            "text": "It is important to guide our files properly on a multi-user system where users share the same file system.  UNIX has a simple mechanism to for ensuring that: every file and directory has nine bits of access permission, corresponds to three access operations, read ( r ), write ( w ), and execute ( x ), for four classes of users, the user who owns of the file ( u ), users in the same group as the owner ( g ), all other users ( o ), and all users ( a ) (union of all three classes before)  When you run  ls -l , you will see the permission encoded as strings that look like  -rw-------  or  drwx--x--x  besides other file information.      The first character indicates if the file is a directory ( d ) or not ( - ).    The next three characters are the permission for the owner.   rwx  means that the owner can do all three: reading, writing, and executing,  rw-  means that the owner can read and write, but cannot execute.  The next three characters are the permission for the users in the same group.  The last three characters are the permission for the users in the other groups.   To change permission, we use the  chmod  command.  Let's say that we want to remove the read and write permission from all other users in the group.  You can run:  1 chmod g-rw <file>   where  <file>  is the name of the file whose permission you want to change.  This would change the permission from  -rw-rw-rw-  to  -rw----rw- , or from  -rwxr--r--  to  -rwx---r-- .  To add executable permission to everyone, you can run:  1 chmod a+x <file>   This would change the permission from  -rw-rw-rw-  to  -rwx--xrwx , or from  -rwxr--r--  to  -rwx--xr-x , and so on.  You get the idea.  Another way to change the permission is set the permission directly, instead of adding with  +  and removing with  - .  To do this, one convenient way is to treat the permission for each class of user as a 3-bit binary number between 0 to 7.  So,  rwx  is 7,  rw-  is 6,  -w-  is 2,  ---  is 0, etc.    To set the permission of a file to  -r--r--r--  (readable by everyone), run:  1 chmod  444  <file>   To set the permission to  -rw------- , run:  1 chmod  600  <file>   and so on.  It is important to ensure that your code is not readable and writable by other students, especially for graded lab exercises.",
            "title": "chmod: Changing UNIX File Permission"
        },
        {
            "location": "/unix/index.html#scp-secure-copy",
            "text": "Secure copy, or  scp , is one way to transfer files from the programming environments to your local computer for archiving or storage.  Let's say you want to transfer a set of C files from the directory  a01  to your local computer, then, on your local computer, run:  1 ooiwt@macbook:~$ scp ooiwt@pe111:~/a01/*.c .    Warning  If you have files with the same name in the remote directory, the files will be overwritten without warning.  I have lost my code a few times due to  scp .     The expression  *.c  is a  regular expression  that means all files with filename ending with  .c .  You can copy specific files as well.  For instance,  1 ooiwt@macbook:~$ scp ooiwt@pe111:~/a01/hello.c .   scp  supports  -r  (recursive copy) as well.",
            "title": "scp: Secure Copy"
        },
        {
            "location": "/unix/index.html#specifying-a-path-in-unix",
            "text": "In any command above, when we need to refer to a directory or a file, we need to specify an  unambiguous location  of the directory or the file.  The most precise way to specify the location is to use the full path, or the  absolute path .  For instance:  1 cp /home/o/ooiwt/tut01/hello.c /home/o/ooiwt/tut01/hello_world.c   That's a lot of characters to type.  We could shorten it in a few ways.     We could specify the location with respect to the home directory using  ~ .   ~ooiwt  refers to the home directory of user  ooiwt .     1 cp ~ooiwt/tut01/hello.c ~ooiwt/tut01/hello_world.c   If you are  ooiwt , then you can omit  ooiwt , since  ~  without any username refers to your home directory.  1 cp ~/tut01/hello.c ~/tut01/hello_world.c    Or we could specify the location with respect to the current directory.  Suppose the current working directory is  ~/tut01  (i.e., we have  cd  into  ~/tut01 ), then we could say this:   1 cp ./hello.c ./hello_world.c   Recall that a single dot  .  refers to the current directory.  The  ./  however is redundant unless you are executing a command.  Since, by specifying a file name or a directory without a path (i.e., not using any  / ), the shell looks for the file or directory in the current directory.  So, we could just do:  1 cp hello.c hello_world.c   Another important short form for relative location is  .. .  Recall that this refers to the parent directory.  Suppose that the current directory is in  ~/tut02 .  Then, to copy the files in  ~/tut01 , you can run:  1 cp ../tut01/hello.c ../tut01/hello_world.c       I run  fish  on my macOS, as you might have noticed during the in-class demos.  You can use any shell you like, if you know what you are doing.  Otherwise,  bash  is a popular one.\u00a0 \u21a9",
            "title": "Specifying A Path in UNIX"
        },
        {
            "location": "/clang/index.html",
            "text": "CS1010 Compilation Guide\n\n\n1. Compile a standalone C program\n\n\nSuppose we have a standalone C program \nteh.c\n that does not use any external libraries.  We can compile the program using the command\n\n\n1\nhappytan@host:~[xxx]$ clang teh.c\n\n\n\n\n\n\nThis command should create an executable called \na.out\n in the current directory, which you can then run with:\n\n\n1\nhappytan@host:~[xxx]$ ./a.out\n\n\n\n\n\n\n2. Renaming executable file\n\n\nThe name \na.out\n is an abbreviation for \nassembler output\n, a name that many compilers kept as the default output name since the 60s.  We should, however, give our executable more descriptive name, by using the \n-o\n flag.  (\no\n is the mnemonic for output).\n\n\n1\nhappytan@host:~[xxx]$ clang teh.c -o teh\n\n\n\n\n\n\nor\n\n\n1\nhappytan@host:~[xxx]$ clang -o teh teh.c\n\n\n\n\n\n\nThe command above would create an executable called \nteh\n.\n\n\n\n\nBeware of the order\n\n\nIf you are not careful and run the following command instead:\n\n1\nhappytan@host:~[xxx]$ clang -o teh.c teh\n\n\n\n\n\nclang\n would overwrite your code \nteh.c\n -- all your hard work will be gone!!\n\n\n\n\n3. Warning for possible bugs.\n\n\nThe \nclang\n checks for syntax errors in your C files -- i.e., things that violate the C syntax rules.  The compiler, however, is smart enough to identify possible bugs -- errors that will cause your program to behave incorrectly, even if the syntax follows C's rules.  You can ask \nclang\n to warn you about this, using the \n-W\n flag (\nW\n is the mnemonic for warning -- note the capital W).  The manual for \nclang\n lists different types of warnings that \nclang\n can warn you about.  For simplicity, we will ask \nclang\n to warn us about everything, by enabling \nall\n warnings.  The command to do so is:\n\n\n1\nhappytan@host:~[xxx]$ clang -Wall teh.c -o teh\n\n\n\n\n\n\nFor beginners, it is \nhighly recommended\n that you \nalways\n compile with \n-Wall\n flag.\n\n\n4. Generating additional information for debugging.\n\n\nIn order to use the debugger \nlldb\n to trace through and debug your program, \nclang\n needs to generate additional information and store them in the executable file.  We can instruct \nclang\n to generate them with the flag \n-g\n (\ng\n for \ng**enerate or debu**g\n).  \n\n\n1\nhappytan@host:~[xxx]$ clang -Wall -g teh.c -o teh\n\n\n\n\n\n\nIt is recommended that you always compile with \n-g\n flags during development phase.  If you need to measure the performance (e.g., how fast it runs) of your program or when you are releasing the program to the public, you can remove the \n-g\n flag and compile with the optimization flags (e.g., \n-O\n) instead.  \n\n\n5. Linking with standard library.\n\n\nTo link with a standard library, we use the \n-l\n flag to specify the name of the library to link.  For instance, to link with the C standard math library (abbreviated \nm\n), you issue the command:\n\n\n1\nhappytan@host:~[xxx]$ clang -Wall -g teh.c -o teh -lm",
            "title": "CLang"
        },
        {
            "location": "/clang/index.html#cs1010-compilation-guide",
            "text": "",
            "title": "CS1010 Compilation Guide"
        },
        {
            "location": "/clang/index.html#1-compile-a-standalone-c-program",
            "text": "Suppose we have a standalone C program  teh.c  that does not use any external libraries.  We can compile the program using the command  1 happytan@host:~[xxx]$ clang teh.c   This command should create an executable called  a.out  in the current directory, which you can then run with:  1 happytan@host:~[xxx]$ ./a.out",
            "title": "1. Compile a standalone C program"
        },
        {
            "location": "/clang/index.html#2-renaming-executable-file",
            "text": "The name  a.out  is an abbreviation for  assembler output , a name that many compilers kept as the default output name since the 60s.  We should, however, give our executable more descriptive name, by using the  -o  flag.  ( o  is the mnemonic for output).  1 happytan@host:~[xxx]$ clang teh.c -o teh   or  1 happytan@host:~[xxx]$ clang -o teh teh.c   The command above would create an executable called  teh .   Beware of the order  If you are not careful and run the following command instead: 1 happytan@host:~[xxx]$ clang -o teh.c teh   clang  would overwrite your code  teh.c  -- all your hard work will be gone!!",
            "title": "2. Renaming executable file"
        },
        {
            "location": "/clang/index.html#3-warning-for-possible-bugs",
            "text": "The  clang  checks for syntax errors in your C files -- i.e., things that violate the C syntax rules.  The compiler, however, is smart enough to identify possible bugs -- errors that will cause your program to behave incorrectly, even if the syntax follows C's rules.  You can ask  clang  to warn you about this, using the  -W  flag ( W  is the mnemonic for warning -- note the capital W).  The manual for  clang  lists different types of warnings that  clang  can warn you about.  For simplicity, we will ask  clang  to warn us about everything, by enabling  all  warnings.  The command to do so is:  1 happytan@host:~[xxx]$ clang -Wall teh.c -o teh   For beginners, it is  highly recommended  that you  always  compile with  -Wall  flag.",
            "title": "3. Warning for possible bugs."
        },
        {
            "location": "/clang/index.html#4-generating-additional-information-for-debugging",
            "text": "In order to use the debugger  lldb  to trace through and debug your program,  clang  needs to generate additional information and store them in the executable file.  We can instruct  clang  to generate them with the flag  -g  ( g  for  g**enerate or debu**g ).    1 happytan@host:~[xxx]$ clang -Wall -g teh.c -o teh   It is recommended that you always compile with  -g  flags during development phase.  If you need to measure the performance (e.g., how fast it runs) of your program or when you are releasing the program to the public, you can remove the  -g  flag and compile with the optimization flags (e.g.,  -O ) instead.",
            "title": "4. Generating additional information for debugging."
        },
        {
            "location": "/clang/index.html#5-linking-with-standard-library",
            "text": "To link with a standard library, we use the  -l  flag to specify the name of the library to link.  For instance, to link with the C standard math library (abbreviated  m ), you issue the command:  1 happytan@host:~[xxx]$ clang -Wall -g teh.c -o teh -lm",
            "title": "5. Linking with standard library."
        },
        {
            "location": "/library/index.html",
            "text": "The CS1010 I/O Library\n\n\nTo help students get started with C programming without worrying too much about the details and pitfalls of using \nprintf\n and \nscanf\n, we provide a simple-to-use library to read and write integers, floating point numbers, and strings.  \n\n\nInstalling the Library\n\n\n\n\nTo get an updated copy of the library, clone it from its git repo on GitHub with the command:\n\n\n\n\n1\ngit clone https://github.com/nus-cs1010-1819-s1/libcs1010.git\n\n\n\n\n\n\nIt is recommended you do this in your home directory.\n\n\nYou should see an output similar to:\n\n1\n2\n3\n4\n5\nCloning into 'libcs1010'...\nremote: Counting objects: 6, done.\nremote: Compressing objects: 100% (3/3), done.\nremote: Total 6 (delta 0), reused 0 (delta 0), pack-reused 0\nUnpacking objects: 100% (6/6), done.\n\n\n\n\n\nAfter that, you should see a subdirectory \nlibcs1010\n created in your current directory.  Inside, there should be a file called \nMakefile\n, and two subdirectories called \ninclude\n and \nsrc\n.  \n\n\n\n\nTo compile the library, run\n\n\n\n\n1\nmake\n\n\n\n\n\n\nThis should compile the file \nsrc/cs1010.c\n and create a static C library named \nlibcs1010.a\n under the \nlib\n directory.\n\n\nUsing the Library\n\n\nHeader\n\n\nTo use the CS1010 I/O library, you should \n#include\n the file \ncs1010.h\n, like this:\n\n\n1\n#include\n \n\"cs1010.h\"\n\n\n\n\n\n\n\nat the top of your C program.\n\n\nLinking\n\n\nThe CS1010 I/O library is provided as the file \nlibcs1010.a\n.  To link to the library, you need to compile with \n-lcs1010\n.  Usually, you need to specify where you can find \ncs1010.h\n with the \n-I\n flag, and \nlibcs1010.a\n with the \n-L\n flag.  Assuming that you are compiling in another subdirectory under your home and \nlibcs1010\n are located under your home directory, the header file and the library file are in \n../libcs1010/include\n and \n../libcs1010/lib\n respectively.\n\n\nSo you compile using the command line:\n\n\n1\nclang -I../libcs1010/include -L../libcs1010/lib hello.c -lcs1010\n\n\n\n\n\n\nIt is a long string to type.  We suggest that you put this in a shell script so that you just need to run the shell script to compile the program.\n\n\nReading of a Single Value\n\n\nThe CS1010 library supports reading of \nlong\n value, \ndouble\n value, and strings (both space-separated words and newline-separated lines) from the standard input.  For \nlong\n and \ndouble\n. The relevant methods are:\n\n\n\n\n\n\nlong cs1010_read_long()\n\nReturns a \nlong\n value from the standard input.  An error message will be printed (to \nstderr\n) if the input sequence is not a valid \nlong\n value -- in which case the value \nLONG_MAX\n will be returned.\n\n\n\n\n\n\ndouble cs1010_read_double()\n\nReturns a \ndouble\n value from the standard input.  An error message will be printed (to \nstderr\n) if the input sequence is not a valid \ndouble\n value -- in which case the value \nDBL_MAX\n will be returned.\n\n\n\n\n\n\nchar* cs1010_read_word()\n\nReturns a \nchar *\n pointing to the next white-space-separated string from the standard input.  A white-space character is defined based on the standard C function \nisspace()\n and includes the space \n, tab \n\\t\n, and newline \n\\n\n character.  Returns NULL if there is an error.  If the returned value is non-NULL, the caller is responsible for freeing the memory allocated by calling \nfree\n.  \n\n\n\n\n\n\nchar* cs1010_read_line()\n\nReturns a \nchar *\n pointing to the next new-line-separated string from the standard input.   The string returns from \ncs1010_read_line()\n includes the newline character (if one is found).\nReturns NULL if there is an error.  If the returned value is non-NULL, the caller is responsible for freeing the memory allocated by calling \nfree\n.\n\n\n\n\n\n\nReading of Multiple Values\n\n\nThe CS1010 library also supports reading of multiple values.  \n\n\n\n\n\n\nlong* cs1010_read_long_array(int k)\n\nReturns \nk\n numbers of \nlong\n values read from the standard input stored in an array.  An error message will be printed (to \nstderr\n) for each input that is not a valid \nlong\n value -- in which case the value \nLONG_MAX\n will be populated in the corresponding array element.  Returns NULL if there is a memory allocation error.  If the returned value is non-NULL, the caller is responsible for freeing the memory allocated by calling \nfree\n.\n\n\n\n\n\n\ndouble* cs1010_read_double_array(int k)\n\nReturns \nk\n numbers of \ndouble\n values read from the standard input stored in an array.  An error message will be printed (to \nstderr\n) for each input that is not a valid \ndouble\n value -- in which case the value \nDBL_MAX\n will be populated in the corresponding array element.\n\nReturns NULL if there is a memory allocation error.  If the returned value is non-NULL, the caller is responsible for freeing the memory allocated by calling \nfree\n.\n\n\n\n\n\n\nchar** cs1010_read_word_array(int k)\n\nReturns \nk\n white-space-separated words read from the standard input stored in an array.  The notion of \"word\" is the same to \ncs1010_read_word()\n.\n\nReturns NULL if there is a memory allocation error.  If the returned value is non-NULL, the caller is responsible for freeing the memory allocated for each word and for the whole array by calling \nfree\n.\n\n\n\n\n\n\nchar** cs1010_read_line_array(int k)\n\nReturns \nk\n new-line-separated words read from the standard input stored in an array.  The notion of line is the same to \ncs1010_read_line()\n.\n\nReturns NULL if there is a memory allocation error.  If the returned value is non-NULL, the caller is responsible for freeing the memory allocated for each line and for the whole array by calling \nfree\n.\n\n\n\n\n\n\nPrinting of a Single Value\n\n\nThe CS1010 library provide a few convenince functions to format and print \nlong\n and \ndouble\n values to the standard output.\n\n\n\n\n\n\nvoid cs1010_print_long(long value)\n and \nvoid cs1010_println_long(long value)\n\nPrint \nvalue\n to the standard output (with printf format \n%ld\n).\n\nThe \ncs1010_println_long\n version prints a newline after the value.\n\n\n\n\n\n\nvoid cs1010_print_double(double value)\n and \nvoid cs1010_println_double(double value)\n\nPrint \nvalue\n to the standard output (with printf format \n%.4f\n).\nThe \ncs1010_println_double\n version prints a newline after the value.\n\n\n\n\n\n\nvoid cs1010_print_string(char *str)\n and \nvoid cs1010_println_string(char *str)\n\nPrint a given string \nstr\n to the standard output.  These functions are provided for completeness and is a simple wrapper around \nprintf(str)\n and \nprintf(\"%s\\n\", str)\n repsectively.",
            "title": "CS1010 I/O"
        },
        {
            "location": "/library/index.html#the-cs1010-io-library",
            "text": "To help students get started with C programming without worrying too much about the details and pitfalls of using  printf  and  scanf , we provide a simple-to-use library to read and write integers, floating point numbers, and strings.",
            "title": "The CS1010 I/O Library"
        },
        {
            "location": "/library/index.html#installing-the-library",
            "text": "To get an updated copy of the library, clone it from its git repo on GitHub with the command:   1 git clone https://github.com/nus-cs1010-1819-s1/libcs1010.git   It is recommended you do this in your home directory.  You should see an output similar to: 1\n2\n3\n4\n5 Cloning into 'libcs1010'...\nremote: Counting objects: 6, done.\nremote: Compressing objects: 100% (3/3), done.\nremote: Total 6 (delta 0), reused 0 (delta 0), pack-reused 0\nUnpacking objects: 100% (6/6), done.   After that, you should see a subdirectory  libcs1010  created in your current directory.  Inside, there should be a file called  Makefile , and two subdirectories called  include  and  src .     To compile the library, run   1 make   This should compile the file  src/cs1010.c  and create a static C library named  libcs1010.a  under the  lib  directory.",
            "title": "Installing the Library"
        },
        {
            "location": "/library/index.html#using-the-library",
            "text": "",
            "title": "Using the Library"
        },
        {
            "location": "/library/index.html#header",
            "text": "To use the CS1010 I/O library, you should  #include  the file  cs1010.h , like this:  1 #include   \"cs1010.h\"    at the top of your C program.",
            "title": "Header"
        },
        {
            "location": "/library/index.html#linking",
            "text": "The CS1010 I/O library is provided as the file  libcs1010.a .  To link to the library, you need to compile with  -lcs1010 .  Usually, you need to specify where you can find  cs1010.h  with the  -I  flag, and  libcs1010.a  with the  -L  flag.  Assuming that you are compiling in another subdirectory under your home and  libcs1010  are located under your home directory, the header file and the library file are in  ../libcs1010/include  and  ../libcs1010/lib  respectively.  So you compile using the command line:  1 clang -I../libcs1010/include -L../libcs1010/lib hello.c -lcs1010   It is a long string to type.  We suggest that you put this in a shell script so that you just need to run the shell script to compile the program.",
            "title": "Linking"
        },
        {
            "location": "/library/index.html#reading-of-a-single-value",
            "text": "The CS1010 library supports reading of  long  value,  double  value, and strings (both space-separated words and newline-separated lines) from the standard input.  For  long  and  double . The relevant methods are:    long cs1010_read_long() \nReturns a  long  value from the standard input.  An error message will be printed (to  stderr ) if the input sequence is not a valid  long  value -- in which case the value  LONG_MAX  will be returned.    double cs1010_read_double() \nReturns a  double  value from the standard input.  An error message will be printed (to  stderr ) if the input sequence is not a valid  double  value -- in which case the value  DBL_MAX  will be returned.    char* cs1010_read_word() \nReturns a  char *  pointing to the next white-space-separated string from the standard input.  A white-space character is defined based on the standard C function  isspace()  and includes the space  , tab  \\t , and newline  \\n  character.  Returns NULL if there is an error.  If the returned value is non-NULL, the caller is responsible for freeing the memory allocated by calling  free .      char* cs1010_read_line() \nReturns a  char *  pointing to the next new-line-separated string from the standard input.   The string returns from  cs1010_read_line()  includes the newline character (if one is found).\nReturns NULL if there is an error.  If the returned value is non-NULL, the caller is responsible for freeing the memory allocated by calling  free .",
            "title": "Reading of a Single Value"
        },
        {
            "location": "/library/index.html#reading-of-multiple-values",
            "text": "The CS1010 library also supports reading of multiple values.      long* cs1010_read_long_array(int k) \nReturns  k  numbers of  long  values read from the standard input stored in an array.  An error message will be printed (to  stderr ) for each input that is not a valid  long  value -- in which case the value  LONG_MAX  will be populated in the corresponding array element.  Returns NULL if there is a memory allocation error.  If the returned value is non-NULL, the caller is responsible for freeing the memory allocated by calling  free .    double* cs1010_read_double_array(int k) \nReturns  k  numbers of  double  values read from the standard input stored in an array.  An error message will be printed (to  stderr ) for each input that is not a valid  double  value -- in which case the value  DBL_MAX  will be populated in the corresponding array element. \nReturns NULL if there is a memory allocation error.  If the returned value is non-NULL, the caller is responsible for freeing the memory allocated by calling  free .    char** cs1010_read_word_array(int k) \nReturns  k  white-space-separated words read from the standard input stored in an array.  The notion of \"word\" is the same to  cs1010_read_word() . \nReturns NULL if there is a memory allocation error.  If the returned value is non-NULL, the caller is responsible for freeing the memory allocated for each word and for the whole array by calling  free .    char** cs1010_read_line_array(int k) \nReturns  k  new-line-separated words read from the standard input stored in an array.  The notion of line is the same to  cs1010_read_line() . \nReturns NULL if there is a memory allocation error.  If the returned value is non-NULL, the caller is responsible for freeing the memory allocated for each line and for the whole array by calling  free .",
            "title": "Reading of Multiple Values"
        },
        {
            "location": "/library/index.html#printing-of-a-single-value",
            "text": "The CS1010 library provide a few convenince functions to format and print  long  and  double  values to the standard output.    void cs1010_print_long(long value)  and  void cs1010_println_long(long value) \nPrint  value  to the standard output (with printf format  %ld ). \nThe  cs1010_println_long  version prints a newline after the value.    void cs1010_print_double(double value)  and  void cs1010_println_double(double value) \nPrint  value  to the standard output (with printf format  %.4f ).\nThe  cs1010_println_double  version prints a newline after the value.    void cs1010_print_string(char *str)  and  void cs1010_println_string(char *str) \nPrint a given string  str  to the standard output.  These functions are provided for completeness and is a simple wrapper around  printf(str)  and  printf(\"%s\\n\", str)  repsectively.",
            "title": "Printing of a Single Value"
        }
    ]
}