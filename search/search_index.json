{
    "docs": [
        {
            "location": "/index.html",
            "text": "CS1010\n\n\nPiazza Q&A\n \n\n\nPiazza is the Q&A site for students and instructors to ask questions and discuss among each other on all matters related to CS1010.",
            "title": "Home"
        },
        {
            "location": "/index.html#cs1010",
            "text": "",
            "title": "CS1010"
        },
        {
            "location": "/index.html#piazza-qa",
            "text": "Piazza is the Q&A site for students and instructors to ask questions and discuss among each other on all matters related to CS1010.",
            "title": "Piazza Q&amp;A"
        },
        {
            "location": "/about/index.html",
            "text": "About CS1010\n\n\nModule Description\n\n\nThis module introduces the fundamental concepts of problem solving by computing and programming using an imperative programming language. It is the first and foremost introductory course to computing. It is also the first part of a three-part series on introductory programming and problem solving by computing, which also includes CS2030 and CS2040. Topics covered include problem solving by computing, writing pseudo-codes, basic problem formulation and problem solving, program development, coding, testing and debugging, fundamental programming constructs (variables, types, expressions, assignments, functions, control structures, etc.), fundamental data structures: arrays, strings and structures, simple file processing, and basic recursion. This module is appropriate for SoC students.\n\n\nWho/Where/When\n\n\n\n\nInstructor\n: Ooi Wei Tsang\n\n\nLecture Venue\n: \nI^3\nI^3\n Auditorium\n\n\nLecture Time\n: Every Tuesday, 4pm - 6pm\n\n\n\n\nTeaching Assistants\n:\n\n\n\n\nWu Biao\n\n\nYu Xiaoliang\n\n\nDou Rengan\n\n\n\n\n\n\n\n\nUndergraduate Discussion Leaders\n:\n\n\n\n\nAu Liang Jun\n\n\nChai Jie Feng (Jack)\n\n\nChua Jun Hui\n\n\nD David Livingston\n\n\nEvan Tay\n\n\nGu Wangfan\n\n\nHo Boon Wee Addison\n\n\nJeffery Kwoh Ji Hui\n\n\nJiang Qinhua\n\n\nJoanne Ong Cui FanG\n\n\nKerryn Eer\n\n\nKyle Timothy Ng Chu\n\n\nLim Heng Guang\n\n\nLin Si Jie\n\n\nNguyen Trong Truong Thanh\n\n\nOng Shu Peng (Metta)\n\n\nOng You Sheng Aaron\n\n\nQuek Shui Herng\n\n\nZhang Tianyang\n\n\n\n\n\n\n\n\nImportant Dates\n\n\n\n\nMidterm Assessment\n: Tuesday, 2 October, 2018 (4pm - 6pm)\n\n\nFinal Assessment\n: Tuesday, 27 Nov, 2018 (9am - 11am)\n\n\nPractical Exam 1\n: Saturday, 6 October, 2018 (9am - 12noon)\n\n\nPractical Exam 2\n: Saturday, 10 November, 2018 (9am - 12noon)\n\n\n\n\nAssessment Weightage\n\n\n\n\nProgramming Assignments\n: 30%\n\n\nFinal Assessment\n: 30%\n\n\nMidterm Assessment\n: 15%\n\n\nPractical Exam 1\n: 10%\n\n\nPractical Exam 2\n: 15%",
            "title": "About CS1010"
        },
        {
            "location": "/about/index.html#about-cs1010",
            "text": "",
            "title": "About CS1010"
        },
        {
            "location": "/about/index.html#module-description",
            "text": "This module introduces the fundamental concepts of problem solving by computing and programming using an imperative programming language. It is the first and foremost introductory course to computing. It is also the first part of a three-part series on introductory programming and problem solving by computing, which also includes CS2030 and CS2040. Topics covered include problem solving by computing, writing pseudo-codes, basic problem formulation and problem solving, program development, coding, testing and debugging, fundamental programming constructs (variables, types, expressions, assignments, functions, control structures, etc.), fundamental data structures: arrays, strings and structures, simple file processing, and basic recursion. This module is appropriate for SoC students.",
            "title": "Module Description"
        },
        {
            "location": "/about/index.html#whowherewhen",
            "text": "Instructor : Ooi Wei Tsang  Lecture Venue :  I^3 I^3  Auditorium  Lecture Time : Every Tuesday, 4pm - 6pm   Teaching Assistants :   Wu Biao  Yu Xiaoliang  Dou Rengan     Undergraduate Discussion Leaders :   Au Liang Jun  Chai Jie Feng (Jack)  Chua Jun Hui  D David Livingston  Evan Tay  Gu Wangfan  Ho Boon Wee Addison  Jeffery Kwoh Ji Hui  Jiang Qinhua  Joanne Ong Cui FanG  Kerryn Eer  Kyle Timothy Ng Chu  Lim Heng Guang  Lin Si Jie  Nguyen Trong Truong Thanh  Ong Shu Peng (Metta)  Ong You Sheng Aaron  Quek Shui Herng  Zhang Tianyang",
            "title": "Who/Where/When"
        },
        {
            "location": "/about/index.html#important-dates",
            "text": "Midterm Assessment : Tuesday, 2 October, 2018 (4pm - 6pm)  Final Assessment : Tuesday, 27 Nov, 2018 (9am - 11am)  Practical Exam 1 : Saturday, 6 October, 2018 (9am - 12noon)  Practical Exam 2 : Saturday, 10 November, 2018 (9am - 12noon)",
            "title": "Important Dates"
        },
        {
            "location": "/about/index.html#assessment-weightage",
            "text": "Programming Assignments : 30%  Final Assessment : 30%  Midterm Assessment : 15%  Practical Exam 1 : 10%  Practical Exam 2 : 15%",
            "title": "Assessment Weightage"
        },
        {
            "location": "/outcomes/index.html",
            "text": "After taking CS1010, students should\n\n\n\n\nbe familiar with fundamental  programming concepts and methodology (variables, assignments, conditions, branches, loops, functions, recursions, structures);\n\n\nbe familiar with and appreciate good programming practice, and apply it to follow-up courses;\n\n\nbe able to apply problem-solving knowledge and skills to write small, well-documented, effective C programs;\n\n\nbe able to appreciate the use of simple data structure such as array, know their limitations to pave way for more complex data structures in the next course;\n\n\nknow the responsibilities of an ethical programmer;\n\n\nbe able to write simple programs in the corresponding programming language to solve a task, given the constraints on the inputs;\n\n\nbe able to manually trace through a program to identify logical errors;\n\n\nbe able to differentiate between logical errors, syntax errors, and run-time errors;\n\n\nbe exposed informally to the concept of code specification in the form of comments in the code, explaining what are the expected inputs and outputs and what are the assumptions;\n\n\nknow about what are some insecure functions to avoid;\n\n\nbe able to generate test cases on their own, with a focus on boundary/special cases;\n\n\nbe able to debug with printf or equivalent functions;\n\n\nbe aware of common strategies and good practices of debugging with printf or equivalent functions;\n\n\nbe able to identify opportunities to, and write, modularized code;\n\n\nbe exposed to a debugger;\n\n\nbe able to write code following good programming style (clear comments, naming convention, indentation, etc.);\n\n\nunderstand the different data types and that there exists a representation of each in the memory, as well as the limitation of the representations due to the limited number of bits;\n\n\ndevelop a simple mental model of how a program is executed (CPU runs the code on data that is stored in memory, function call leads to the creation of call frames, which can explain recursion and variable scoping, etc).  For interpreted language, understand the role of virtual machine/interpreter;\n\n\nbe able to understand at a high level the compilation process (from pre-processing to compiling to linking), where applicable;\n\n\nunderstand the concept of reusability and how a software application can be built on top of software libraries/packages (standard or third parties);\n\n\nbe able to implement bubble sort and insertion sort;\n\n\nbe able to implement linear search and binary search (both iterative and recursive versions);",
            "title": "Learning Outcomes"
        },
        {
            "location": "/schedule/index.html",
            "text": "Schedule\n\n\nThis is a tentative schedule for CS1010.\n\n\nLecture Schedule (Tentative)\n\n\n\n\n\n\n\n\nWeek\n\n\nDate\n\n\nTopics\n\n\nLabs\n\n\n\n\n\n\n\n\n\n\n1\n\n\n2018-08-13\n\n\n1. Introduction: What is a program?  What is computational problem solving?\n\n\n\n\n\n\n\n\n2\n\n\n2018-08-20\n\n\n2. Your first C program: From C to executable, types, arrays, and memory model\n\n\n\n\n\n\n\n\n3\n\n\n2018-08-27\n\n\n3. Mathematical expression, functional abstraction, and wishful thinking\n\n\nLab 0: Warm Up\n\n\n\n\n\n\n4\n\n\n2018-09-03\n\n\n4. Conditional and loops I, using libraries\n\n\nLab 1\n\n\n\n\n\n\n5\n\n\n2018-09-10\n\n\n5. Conditional and loops II\n\n\nLab 2\n\n\n\n\n\n\n6\n\n\n2018-09-17\n\n\n6. Pointers and strings\n\n\nLab 3\n\n\n\n\n\n\n2018-09-24\n\n\nBreak\n\n\n\n\n\n\n\n\n\n\n7\n\n\n2018-10-01\n\n\nMidterm\n\n\nPE 1\n\n\n\n\n\n\n8\n\n\n2018-10-08\n\n\n7. Nested loop, sorting\n\n\nLab 4\n\n\n\n\n\n\n9\n\n\n2018-10-15\n\n\n8. Recursion, searching\n\n\nLab 5\n\n\n\n\n\n\n10\n\n\n2018-10-22\n\n\n9. Composite data type\n\n\nLab 6\n\n\n\n\n\n\n11\n\n\n2018-10-29\n\n\n10. I/O\n\n\nLab 7\n\n\n\n\n\n\n12\n\n\n2018-11-05\n\n\n11. Modular C programming\n\n\nPE 2\n\n\n\n\n\n\n13\n\n\n2018-11-12\n\n\n12. Recap\n\n\nLab 8\n\n\n\n\n\n\n\n\nTutorial Time / Venue\n\n\n\n\n\n\n\n\nDay\n\n\nTime\n\n\nCOM1-B108\n\n\nCOM1-B109\n\n\nCOM1-B111\n\n\nCOM1-B112\n\n\nCOM1-0120\n\n\ni3-0336\n\n\nI3-0338\n\n\n\n\n\n\n\n\n\n\nMon\n\n\n1000\n\n\nC10\n\n\n\n\n\n\n\n\nC09\n\n\n\n\n\n\n\n\n\n\nMon\n\n\n1400\n\n\nC1B\n\n\n\n\n\n\nC1A\n\n\n\n\n\n\n\n\n\n\n\n\nTue\n\n\n1200\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n03\n\n\n\n\n\n\nTue\n\n\n1400\n\n\n\n\n\n\n\n\n\n\n\n\nC03\n\n\nC02\n\n\n\n\n\n\nWed\n\n\n1000\n\n\n\n\nC07\n\n\n\n\nC08\n\n\n\n\n\n\nC06\n\n\n\n\n\n\nWed\n\n\n1200\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n07\n\n\n\n\n\n\nWed\n\n\n1400\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n08\n\n\n\n\n\n\nThu\n\n\n1000\n\n\n\n\n\n\n\n\n05\n\n\n\n\n01\n\n\n\n\n\n\n\n\nThu\n\n\n1200\n\n\n\n\n\n\nC11\n\n\nC04\n\n\nC05\n\n\n\n\n\n\n\n\n\n\nThu\n\n\n1400\n\n\n\n\n\n\n\n\n06\n\n\n\n\n\n\n\n\n\n\n\n\nFri\n\n\n1200\n\n\n\n\n\n\n\n\n02\n\n\n\n\n\n\n09\n\n\n\n\n\n\nFri\n\n\n1400\n\n\n\n\n\n\n\n\n04",
            "title": "Schedule"
        },
        {
            "location": "/schedule/index.html#schedule",
            "text": "This is a tentative schedule for CS1010.",
            "title": "Schedule"
        },
        {
            "location": "/schedule/index.html#lecture-schedule-tentative",
            "text": "Week  Date  Topics  Labs      1  2018-08-13  1. Introduction: What is a program?  What is computational problem solving?     2  2018-08-20  2. Your first C program: From C to executable, types, arrays, and memory model     3  2018-08-27  3. Mathematical expression, functional abstraction, and wishful thinking  Lab 0: Warm Up    4  2018-09-03  4. Conditional and loops I, using libraries  Lab 1    5  2018-09-10  5. Conditional and loops II  Lab 2    6  2018-09-17  6. Pointers and strings  Lab 3    2018-09-24  Break      7  2018-10-01  Midterm  PE 1    8  2018-10-08  7. Nested loop, sorting  Lab 4    9  2018-10-15  8. Recursion, searching  Lab 5    10  2018-10-22  9. Composite data type  Lab 6    11  2018-10-29  10. I/O  Lab 7    12  2018-11-05  11. Modular C programming  PE 2    13  2018-11-12  12. Recap  Lab 8",
            "title": "Lecture Schedule (Tentative)"
        },
        {
            "location": "/schedule/index.html#tutorial-time-venue",
            "text": "Day  Time  COM1-B108  COM1-B109  COM1-B111  COM1-B112  COM1-0120  i3-0336  I3-0338      Mon  1000  C10     C09      Mon  1400  C1B    C1A       Tue  1200        03    Tue  1400       C03  C02    Wed  1000   C07   C08    C06    Wed  1200        07    Wed  1400        08    Thu  1000     05   01     Thu  1200    C11  C04  C05      Thu  1400     06       Fri  1200     02    09    Fri  1400     04",
            "title": "Tutorial Time / Venue"
        },
        {
            "location": "/accounts/index.html",
            "text": "CS1010 Accounts\n\n\nWe will be using a variety of services for CS1010.  To take CS1010, please make sure you have the following accounts:\n\n\nSoC UNIX Account\n\n\nYou can get one here: \nhttps://mysoc.nus.edu.sg/~newacct/\n\n\nThis account allows you to access SoC UNIX resources, including the main computing host running Solaris, \nsunfire\n, and computer clusters running Ubuntu / CentOS.  We will be using the compute clusters for CS1010 (details coming soon).\n\n\nGitHub Account\n\n\nCS1010 uses GitHub Classroom for programming assignment submissions and grading.  You should \nregister for a GitHub account\n if you do not have one. \n\n\nPiazza Account\n\n\nCS1010 uses Piazza for Q&A and discussion.  You should receive an email to register for Piazza.",
            "title": "Accounts"
        },
        {
            "location": "/accounts/index.html#cs1010-accounts",
            "text": "We will be using a variety of services for CS1010.  To take CS1010, please make sure you have the following accounts:",
            "title": "CS1010 Accounts"
        },
        {
            "location": "/accounts/index.html#soc-unix-account",
            "text": "You can get one here:  https://mysoc.nus.edu.sg/~newacct/  This account allows you to access SoC UNIX resources, including the main computing host running Solaris,  sunfire , and computer clusters running Ubuntu / CentOS.  We will be using the compute clusters for CS1010 (details coming soon).",
            "title": "SoC UNIX Account"
        },
        {
            "location": "/accounts/index.html#github-account",
            "text": "CS1010 uses GitHub Classroom for programming assignment submissions and grading.  You should  register for a GitHub account  if you do not have one.",
            "title": "GitHub Account"
        },
        {
            "location": "/accounts/index.html#piazza-account",
            "text": "CS1010 uses Piazza for Q&A and discussion.  You should receive an email to register for Piazza.",
            "title": "Piazza Account"
        },
        {
            "location": "/01-program/index.html",
            "text": "Unit 1: Introduction\n\n\nLearning Outcomes:\n\n\nAfter this lecture, students should:\n\n\n\n\nhave an idea of what is a program and how a program is executed by a computer\n\n\nunderstand the basic terminologies: machine code, assembly language, a (high-level) programming language, computational problem solving, algorithm, flowchart, debugging, testing, variables, value, assignment.\n\n\nbe familiar with the algorithm to find the maximum among a list of numbers\n\n\n\n\nWhat is a (computer) program?\n\n\nDespite all the wonderful and amazing things that computers can do, computers are not very smart. In fact, they are pretty dumb. Computers can only follow the instructions given by a human. A computer program is a sequence of step-by-step instructions given to computers to manipulate data in order to perform a certain task.\n\n\nProgramming is the art and science of writing a computer program, and that is what you will learn to do in CS1010.\n\n\nHow computer executes a program\n\n\nIn order to learn how to write a program, it is important to have an overview of how a computer executes a program.  You will learn in details how this is done in CS2100/CS2106 or EE2024/CG2271, but for CS1010, we will take a very simplistic and high-level view of this process.\n\n\nThe two important components of a computer we will discuss for CS1010 is the CPU, or \ncentral processing unit\n and the RAM, or \nrandom access memory\n.  The memory is where we store the data to be processed or manipulated by the CPU, as well as the instructions to do so.  A memory location is addressable using a \nmemory address\n.  \n\n\nThe instructions to the CPU comes in the form of \nmachine code\n, a sequence of bits (1s and 0s) that is interpreted and then followed by the CPU to do certain things.  These machine code could instruct the CPU, for instance, to compare if a particular number at a certain memory location is more than 0, to add one number to another, or to execute another instruction at another memory location.  The data stored in the memory is also stored as a sequence of 1s and 0s.\n\n\nFrom Machine Code to High-level Programming Language\n\n\nWhile it is possible for us, human, to write machine code directly, few actually do since it is challenging to do so. Different CPUs understand different sets of machine code; it is tedious to figure out where each piece of data is located in the memory (this is actually determined by the operating system).  The resulting code, even when it is correct and easy to read and understand by the machine, are often hard to decipher for a human.\nSimple operations such as comparing which number is bigger might require several instructions to perform.\n\n\nTo get around the readability problem, programmers can code in \nassembly language\n -- a human-readable form of machine code, where each instruction, instead of represented by 0s and 1s, is represented by a mnemonic (such as \ndecr\n, \nincr\n, \nstore\n, \nadd\n, etc.)\n\n\nWriting assembly code does not address the issues of machine-dependent code and the tediousness of programming.  Early programmers (in the fifties) understood this and designed \nhigh-level programming languages\n, where programmers can describe the operations that they wish to do in a language closer to their intention that is machine independent.  A program written in one of these programming languages is then \ncompiled\n into machine code for a specific CPU for execution using a compiler.\n\n\n\n\nThe first commercially available language is FORTRAN from IBM in the 1950s.  Among many early programming languages, C (birth year 1972) is the only one that is still popular and widely used today,  \nFor many reasons\n, C is the language of choice for CS1010.  \n\n\nThe Goals of CS1010\n\n\nThis brings us to the goals of CS1010.  First, you will learn the most important syntax element of the C programming language.  Second, you will learn how a C program behaves, in relation to how a program is executed and how data are stored and manipulated in memory.  Third, you will learn the various tools and techniques that will help you produce good and correct C programs.\n\n\nThe last, and the most important and challenging goal of CS1010, however, is that you will learn how to write programs to solve computational problems.  Learning to write a program that does what you want it to do is actually not difficult.  \nKnowing what you want your program to do is the more challenging part!",
            "title": "1. Programming"
        },
        {
            "location": "/01-program/index.html#unit-1-introduction",
            "text": "",
            "title": "Unit 1: Introduction"
        },
        {
            "location": "/01-program/index.html#learning-outcomes",
            "text": "After this lecture, students should:   have an idea of what is a program and how a program is executed by a computer  understand the basic terminologies: machine code, assembly language, a (high-level) programming language, computational problem solving, algorithm, flowchart, debugging, testing, variables, value, assignment.  be familiar with the algorithm to find the maximum among a list of numbers",
            "title": "Learning Outcomes:"
        },
        {
            "location": "/01-program/index.html#what-is-a-computer-program",
            "text": "Despite all the wonderful and amazing things that computers can do, computers are not very smart. In fact, they are pretty dumb. Computers can only follow the instructions given by a human. A computer program is a sequence of step-by-step instructions given to computers to manipulate data in order to perform a certain task.  Programming is the art and science of writing a computer program, and that is what you will learn to do in CS1010.",
            "title": "What is a (computer) program?"
        },
        {
            "location": "/01-program/index.html#how-computer-executes-a-program",
            "text": "In order to learn how to write a program, it is important to have an overview of how a computer executes a program.  You will learn in details how this is done in CS2100/CS2106 or EE2024/CG2271, but for CS1010, we will take a very simplistic and high-level view of this process.  The two important components of a computer we will discuss for CS1010 is the CPU, or  central processing unit  and the RAM, or  random access memory .  The memory is where we store the data to be processed or manipulated by the CPU, as well as the instructions to do so.  A memory location is addressable using a  memory address .    The instructions to the CPU comes in the form of  machine code , a sequence of bits (1s and 0s) that is interpreted and then followed by the CPU to do certain things.  These machine code could instruct the CPU, for instance, to compare if a particular number at a certain memory location is more than 0, to add one number to another, or to execute another instruction at another memory location.  The data stored in the memory is also stored as a sequence of 1s and 0s.",
            "title": "How computer executes a program"
        },
        {
            "location": "/01-program/index.html#from-machine-code-to-high-level-programming-language",
            "text": "While it is possible for us, human, to write machine code directly, few actually do since it is challenging to do so. Different CPUs understand different sets of machine code; it is tedious to figure out where each piece of data is located in the memory (this is actually determined by the operating system).  The resulting code, even when it is correct and easy to read and understand by the machine, are often hard to decipher for a human.\nSimple operations such as comparing which number is bigger might require several instructions to perform.  To get around the readability problem, programmers can code in  assembly language  -- a human-readable form of machine code, where each instruction, instead of represented by 0s and 1s, is represented by a mnemonic (such as  decr ,  incr ,  store ,  add , etc.)  Writing assembly code does not address the issues of machine-dependent code and the tediousness of programming.  Early programmers (in the fifties) understood this and designed  high-level programming languages , where programmers can describe the operations that they wish to do in a language closer to their intention that is machine independent.  A program written in one of these programming languages is then  compiled  into machine code for a specific CPU for execution using a compiler.   The first commercially available language is FORTRAN from IBM in the 1950s.  Among many early programming languages, C (birth year 1972) is the only one that is still popular and widely used today,   For many reasons , C is the language of choice for CS1010.",
            "title": "From Machine Code to High-level Programming Language"
        },
        {
            "location": "/01-program/index.html#the-goals-of-cs1010",
            "text": "This brings us to the goals of CS1010.  First, you will learn the most important syntax element of the C programming language.  Second, you will learn how a C program behaves, in relation to how a program is executed and how data are stored and manipulated in memory.  Third, you will learn the various tools and techniques that will help you produce good and correct C programs.  The last, and the most important and challenging goal of CS1010, however, is that you will learn how to write programs to solve computational problems.  Learning to write a program that does what you want it to do is actually not difficult.   Knowing what you want your program to do is the more challenging part!",
            "title": "The Goals of CS1010"
        },
        {
            "location": "/02-algo/index.html",
            "text": "Unit 2: Computational Problems and Algorithms\n\n\nComputational Problems\n\n\nSo, what is computational problem solving?  Let's start with the question, what is a \ncomputational problem\n?  \n\n\nA computational problem is a problem that can be solved step-by-step with a computer.  These problems usually have a well-defined input, constraints, and conditions that the output must satisfied.  Here are some types of computational problems:\n\n\n\n\n\n\nA \ndecision problem\n is one where the answer is yes or no.  For instance, \"given a number \nn\n, is \nn\n even?\" is a decision problem.  Some decision problems take more steps to solve than others.  For instance, \"given a number \nn\n, is \nn\n prime?\" takes more steps than just checking the parity of a number.\n\n\n\n\n\n\nA \nsearch problem\n is one where the solution is some values that satisfy a given condition.  For instance, we may want to compute a path from one geographical location to another on a map.\n\n\n\n\n\n\nA \ncounting problem\n is one where the answer is the number of solutions to a search problem.\n\n\n\n\n\n\nAn \noptimization problem\n is one where the solution is the \"best\" possible solution, where the \"best\" can be defined in a different way.  For instance, we may want to compute the fastest route from one location to another.\n\n\n\n\n\n\nQuestions such as \"what is the meaning of life?\" \"do I look good in this outfit?\"\n1\n are not computational problems, because they do not have well-defined input, constraints, and conditions that the output must satisfy.\n\n\nIn CS1010 (followed by CS2040C and CS3230), you will learn how to solve computational problems \ncomputationally\n -- this means that you learn to come up with step-by-step instructions meant for computers that you can translate into computer programs, to solve a given problem. \n\n\nExample: Finding the maximum\n\n\nLet's start with a simple problem.  Given a finite list \nL\nL\n of \nk\nk\n integers (\nk\nk\n > 0), find the integer with the maximum value from the list.\n\n\nFirst, let's consider if this is a computational problem.  The input is very well defined.  We know what an integer is.  We are told we have at least one, and we have a finite number of them\n2\n.\n\n\nSecond, let's consider the output.  What conditions must the output satisfy?  First, it has to be equal or larger than every other integer on the list.  Second, it must be an integer \nin\n the list.  This is well defined by the problem statement, so we can say that it is a computational problem.\n\n\nHere is an example.  Suppose the input consists of:\n\n\n4 1 -4 0 9 9 3 5 8\n\n\nThe output should be \n9\n.\n\n\nNow, you should pause reading and think about how you would solve this step-by-step.  \n\n\nAlgorithm\n\n\nOne way to solve this problem is to check through the integers in the list, one-by-one, and keep track of the maximum value so far.  When you reach the end of the list, your \"maximum value so far\" will also be the maximum for the whole list.  \n\n\nLet's look at an example:\n\n\n\n\n\n\n\n\nIntegers Scanned\n\n\nMaximum So Far\n\n\n\n\n\n\n\n\n\n\n4\n\n\n4\n\n\n\n\n\n\n4 1\n\n\n4\n\n\n\n\n\n\n4 1 -4\n\n\n4\n\n\n\n\n\n\n4 1 -4 0\n\n\n4\n\n\n\n\n\n\n4 1 -4 0 9\n\n\n9\n\n\n\n\n\n\n4 1 -4 0 9 9\n\n\n9\n\n\n\n\n\n\n4 1 -4 0 9 9 3\n\n\n9\n\n\n\n\n\n\n4 1 -4 0 9 9 3 5\n\n\n9\n\n\n\n\n\n\n4 1 -4 0 9 9 3 5 8\n\n\n9\n\n\n\n\n\n\n\n\nThe English description above, however, is not detailed enough for computers to understand.  What is the meaning of \"check one-by-one\"? \"keep track of maximum so far\"?  how to tell if we have reached \"the end of the list\"?\n\n\nLet's work out all the details.\n\n\nFirst, we need a concise way of representing the integers in the list.  Borrowing from mathematical notation, let's say that the list \nL\nL\n contains the integers \n\nl_0, l_1, ..., l_{k-1}\nl_0, l_1, ..., l_{k-1}\n. To \"check one-by-one,\" we introduce another notation \nl_i\nl_i\n, which is the integer currently being \"checked\".  We begin with \ni = 0\ni = 0\n, then \ni = 1\ni = 1\n, then \ni = 2\ni = 2\n, etc, until \ni = k-1\ni = k-1\n.  At every step, we increase \ni\ni\n by 1.\n\n\nSecond, we need a concise way of keeping track of the maximum so far.  We introduce another notation, \nm\nm\n, to represent the maximum value so far.  When \ni = 0\ni = 0\n, \nm = l_0\nm = l_0\n.  Since we only scan a single integer, it has to be the maximum.  When we check another integer \nl_i (i > 0)\nl_i (i > 0)\n, only two things can happen:\n\n\n\n\nif this \nl_i\nl_i\n is larger than \nm\nm\n, then \nl_i\nl_i\n has to be the maximum so far, so we update \nm\nm\n to be \nl_i\nl_i\n.\n\n\nif \nl_i\nl_i\n is equal to or smaller than \nm\nm\n, then \nm\nm\n is still the maximum value so far.\n\n\n\n\nWe keep doing the above and increase \ni\ni\n, until we reach the end of the list when (after increasing \ni\ni\n) we find that \ni\ni\n is \nk\nk\n.\n\n\nNow, we have enough details to describe step-by-step, how to find the maximum value from a list of integers.  Such steps, which the computer can take to solve a problem, is called an \nalgorithm\n.  \n\n\nFlowchart\n\n\nThere are different ways one can describe an algorithm.  The easiest way I find is to use a diagram called a \nflowchart\n.  The flowchart for the algorithm above looks like this.  A diamond box represents a \"question\" that can be true or false (yes or no), and we trace through the \"flow\" step by step, following the corresponding path depending on the answer. \n\n\n\n\nPlease spend some time to trace through the walkthrough above.  The snapshot of the values of the \ni\ni\n, \nl_i\nl_i\n, \nk\nk\n, and \nm\nm\n, at the point after \"is \ni\ni\n equals \nk\nk\n\" is shown in the table below.\n\n\n\n\n\n\n\n\nIntegers Scanned\n\n\ni\ni\n\n\nl_i\nl_i\n\n\nk\nk\n\n\nMaximum So Far (\nm\nm\n)\n\n\n\n\n\n\n\n\n\n\n4\n\n\n1\n\n\n4\n\n\n9\n\n\n4\n\n\n\n\n\n\n4 1\n\n\n1\n\n\n1\n\n\n9\n\n\n4\n\n\n\n\n\n\n4 1 -4\n\n\n2\n\n\n-4\n\n\n9\n\n\n4\n\n\n\n\n\n\n4 1 -4 0\n\n\n3\n\n\n0\n\n\n9\n\n\n4\n\n\n\n\n\n\n4 1 -4 0 9\n\n\n4\n\n\n9\n\n\n9\n\n\n4\n\n\n\n\n\n\n4 1 -4 0 9 9\n\n\n5\n\n\n9\n\n\n9\n\n\n9\n\n\n\n\n\n\n4 1 -4 0 9 9 3\n\n\n6\n\n\n3\n\n\n9\n\n\n9\n\n\n\n\n\n\n4 1 -4 0 9 9 3 5\n\n\n7\n\n\n5\n\n\n9\n\n\n9\n\n\n\n\n\n\n4 1 -4 0 9 9 3 5 8\n\n\n8\n\n\n8\n\n\n9\n\n\n9\n\n\n\n\n\n\n4 1 -4 0 9 9 3 5 8\n\n\n9\n\n\n``\n\n\n9\n\n\n9\n\n\n\n\n\n\n\n\nVariables\n\n\nThere are a few important things to take note here.  \nm\nm\n, \ni\ni\n, \nk\nk\n, and the list \nL\nL\n are what we called \nstates\n or \nvariables\n.  While in the above, we can think of them as mathematical variables which we can assign \nvalues\n to, in a computer program, a variable is a location in the memory which holds a value.  \n\n\nWe can perform two very basic operations on the variables: reading and writing.  In other words, we can set their values and we can retrieve their values. \n\n\nWe can \nassign\n the value of one variable to a constant (e.g., set \ni\ni\n to 1) or to the value of another variable (e.g., set \nm\nm\n to \nl_i\nl_i\n).  In the latter example, we first read the value of \nl_i\nl_i\n, from \nl_i\nl_i\n's memory location and then we write that value to the memory location of \nm\nm\n.  Once written, the value of \nm\nm\n will not change until the next time we update the value of \nm\nm\n.\n\n\nIt is important to note that, when \ni\ni\n changes, \nm\nm\n \ndoes not change automatically\n to the new \nl_i\nl_i\n  This behavior is different from that which you may be familiar with in spreadsheet software -- if you set the value of a cell, say \nA1\n to be \n=B1\n, when the value in cell \nB1\n changes, the value \nA1\n also changes automatically.\n\n\nWe can also compare the values of two variables.  We see two examples above: \"\ni\ni\n equals \nk\nk\n?\"  \"\nl_i > m\nl_i > m\n?\"  When we compare, we read the values of the variables from their memory location and checks their relations.\n\n\nWe can perform arithmetic operations on the variables: addition, subtraction, etc.  We see one example above: \"increment \ni\ni\n\".  This operation is actually an assignment operation in disguise.  We can write it as \"set \ni\ni\n to \ni\ni\n + 1\".  Here, you see that \ni\ni\n is referred to twice.  This operation reads the value from the memory location of \ni\ni\n, adds 1 to it, and then writes the resulting value back to the location of \ni\ni\n.\n\n\nBugs\n\n\nIf you follow the execution of the algorithm above, step-by-step, using the example input \n4 1 -4 0 9 9 3 5\n above, you will obtain the correct maximum value \nm\nm\n of \n9\n.  But does that mean that the algorithm is correct?  The answer is NO.  \n\n\nFor an algorithm to correctly solve the given problem, it has to produce the correct result for all valid inputs to the problem.  If we can find one counterexample, one input where the algorithm does not produce the correct output, then the algorithm is incorrect.  Note that I say \ndoes not produce the correct output\n, which means that either the algorithm  \nproduces the wrong output\n or \ndoes not produce any output at all\n.  \n\n\nIn this case, we say that the algorithm or the program has a \nbug\n.  A bug is a defect that causes the algorithm to behave incorrectly.  As a software developer, you will spend some time finding bugs in your code, a process known as \ndebugging\n.  A \ndebugger\n is a tool that helps programmers find bugs in their code.\n\n\nBefore we even start the process of debugging, we first have to know if our algorithm is correct.  Remember that an algorithm is correct only if it produces the correct output only all possible valid inputs.  So, one way to check if an algorithm is correct is to try it with all possible valid inputs.  For the problem we are solving above, however, even though the list is finite, there are infinitely many possible inputs, and so, it is impossible to try all possible valid inputs.  In practice, we \ncraft\n a smaller set of test inputs to check if the algorithm behaves correctly for these test inputs, and \nhope\n that it is correct for all possible inputs.  With experience, you will choose the right set of test inputs to maximize that chances that you will find a bug in your code.  There are also systematic ways of deriving test cases so that the test cases \ncover\n different paths of execution of the algorithm, but we won't be covering it in CS1010\n3\n.\n\n\nAnother way of checking if an algorithm is correct, is to reason about the behavior of the algorithm.  We will do this rather informally in CS1010, starting in 1-2 lectures from now.  You get to rigorously prove that an algorithm is correct in a higher level module (CS3230 Design and Analysis of Algorithms).\n\n\nFinally, even if an algorithm is correct, the corresponding program might not be.  Recall that an algorithm is a step-by-step process to solve a problem.  It is what you want your program to do.  You still have to write a program (in C, or other languages) to actually have the computer do what you want it to do (in other words, to \nimplement the algorithm\n). This process of translating the algorithm to a computer program, called \ncoding\n may introduce bugs as well.  But we will worry about this later when we learn to program.\n\n\nIn the problem set at the end of this lecture, you will see slight variations of the algorithm above.  You should check through them to see whether they are correct or not.\n\n\nProblem Set\n\n\nProblem 1.1\n\n\nThe following algorithms are slight variations of the one in the notes above.  The differences are highlighted in red.  Do they correctly find the maximum integer from a finite list of \nk\nk\n integers (\nk > 0\nk > 0\n)?  \n\n\nIf an algorithm is buggy, give a counter-example where the output is incorrect.  In addition, give an example input where the algorithm still produces the correct output, where possible.  \n\n\n(a). \n\n\n\n(b). \n\n\n\n\u00a9. \n\n\n\n(d). \n\n\n\n(e). \n\n\n\nProblem 1.2\n\n\nChange the algorithm above to find the minimum value instead of the maximum value from the given list \nL = \\{l_0, ..., l_{k-1}\\}\nL = \\{l_0, ..., l_{k-1}\\}\n.\n\n\nProblem 1.3\n\n\nDraw the flowchart for an algorithm, that takes in a list of integers \nL = \\{l_0, ..., l_{k-1}\\}, k \\ge 0\nL = \\{l_0, ..., l_{k-1}\\}, k \\ge 0\n, and compute the \nsum\n of all the integers.  Think about what variable(s) do you need.\n\n\n\n\n\n\n\n\n\n\nThe answer is, by the way, always \"Yes.\"\u00a0\n\u21a9\n\n\n\n\n\n\nThink about why it is important to have a finite number of integers in the input.\u00a0\n\u21a9\n\n\n\n\n\n\nSoftware testing is a body of knowledge worthy of an advanced module by itself -- we offer one in CS4218.\u00a0\n\u21a9",
            "title": "2. Algorithms"
        },
        {
            "location": "/02-algo/index.html#unit-2-computational-problems-and-algorithms",
            "text": "",
            "title": "Unit 2: Computational Problems and Algorithms"
        },
        {
            "location": "/02-algo/index.html#computational-problems",
            "text": "So, what is computational problem solving?  Let's start with the question, what is a  computational problem ?    A computational problem is a problem that can be solved step-by-step with a computer.  These problems usually have a well-defined input, constraints, and conditions that the output must satisfied.  Here are some types of computational problems:    A  decision problem  is one where the answer is yes or no.  For instance, \"given a number  n , is  n  even?\" is a decision problem.  Some decision problems take more steps to solve than others.  For instance, \"given a number  n , is  n  prime?\" takes more steps than just checking the parity of a number.    A  search problem  is one where the solution is some values that satisfy a given condition.  For instance, we may want to compute a path from one geographical location to another on a map.    A  counting problem  is one where the answer is the number of solutions to a search problem.    An  optimization problem  is one where the solution is the \"best\" possible solution, where the \"best\" can be defined in a different way.  For instance, we may want to compute the fastest route from one location to another.    Questions such as \"what is the meaning of life?\" \"do I look good in this outfit?\" 1  are not computational problems, because they do not have well-defined input, constraints, and conditions that the output must satisfy.  In CS1010 (followed by CS2040C and CS3230), you will learn how to solve computational problems  computationally  -- this means that you learn to come up with step-by-step instructions meant for computers that you can translate into computer programs, to solve a given problem.",
            "title": "Computational Problems"
        },
        {
            "location": "/02-algo/index.html#example-finding-the-maximum",
            "text": "Let's start with a simple problem.  Given a finite list  L L  of  k k  integers ( k k  > 0), find the integer with the maximum value from the list.  First, let's consider if this is a computational problem.  The input is very well defined.  We know what an integer is.  We are told we have at least one, and we have a finite number of them 2 .  Second, let's consider the output.  What conditions must the output satisfy?  First, it has to be equal or larger than every other integer on the list.  Second, it must be an integer  in  the list.  This is well defined by the problem statement, so we can say that it is a computational problem.  Here is an example.  Suppose the input consists of:  4 1 -4 0 9 9 3 5 8  The output should be  9 .  Now, you should pause reading and think about how you would solve this step-by-step.",
            "title": "Example: Finding the maximum"
        },
        {
            "location": "/02-algo/index.html#algorithm",
            "text": "One way to solve this problem is to check through the integers in the list, one-by-one, and keep track of the maximum value so far.  When you reach the end of the list, your \"maximum value so far\" will also be the maximum for the whole list.    Let's look at an example:     Integers Scanned  Maximum So Far      4  4    4 1  4    4 1 -4  4    4 1 -4 0  4    4 1 -4 0 9  9    4 1 -4 0 9 9  9    4 1 -4 0 9 9 3  9    4 1 -4 0 9 9 3 5  9    4 1 -4 0 9 9 3 5 8  9     The English description above, however, is not detailed enough for computers to understand.  What is the meaning of \"check one-by-one\"? \"keep track of maximum so far\"?  how to tell if we have reached \"the end of the list\"?  Let's work out all the details.  First, we need a concise way of representing the integers in the list.  Borrowing from mathematical notation, let's say that the list  L L  contains the integers  l_0, l_1, ..., l_{k-1} l_0, l_1, ..., l_{k-1} . To \"check one-by-one,\" we introduce another notation  l_i l_i , which is the integer currently being \"checked\".  We begin with  i = 0 i = 0 , then  i = 1 i = 1 , then  i = 2 i = 2 , etc, until  i = k-1 i = k-1 .  At every step, we increase  i i  by 1.  Second, we need a concise way of keeping track of the maximum so far.  We introduce another notation,  m m , to represent the maximum value so far.  When  i = 0 i = 0 ,  m = l_0 m = l_0 .  Since we only scan a single integer, it has to be the maximum.  When we check another integer  l_i (i > 0) l_i (i > 0) , only two things can happen:   if this  l_i l_i  is larger than  m m , then  l_i l_i  has to be the maximum so far, so we update  m m  to be  l_i l_i .  if  l_i l_i  is equal to or smaller than  m m , then  m m  is still the maximum value so far.   We keep doing the above and increase  i i , until we reach the end of the list when (after increasing  i i ) we find that  i i  is  k k .  Now, we have enough details to describe step-by-step, how to find the maximum value from a list of integers.  Such steps, which the computer can take to solve a problem, is called an  algorithm .",
            "title": "Algorithm"
        },
        {
            "location": "/02-algo/index.html#flowchart",
            "text": "There are different ways one can describe an algorithm.  The easiest way I find is to use a diagram called a  flowchart .  The flowchart for the algorithm above looks like this.  A diamond box represents a \"question\" that can be true or false (yes or no), and we trace through the \"flow\" step by step, following the corresponding path depending on the answer.    Please spend some time to trace through the walkthrough above.  The snapshot of the values of the  i i ,  l_i l_i ,  k k , and  m m , at the point after \"is  i i  equals  k k \" is shown in the table below.     Integers Scanned  i i  l_i l_i  k k  Maximum So Far ( m m )      4  1  4  9  4    4 1  1  1  9  4    4 1 -4  2  -4  9  4    4 1 -4 0  3  0  9  4    4 1 -4 0 9  4  9  9  4    4 1 -4 0 9 9  5  9  9  9    4 1 -4 0 9 9 3  6  3  9  9    4 1 -4 0 9 9 3 5  7  5  9  9    4 1 -4 0 9 9 3 5 8  8  8  9  9    4 1 -4 0 9 9 3 5 8  9  ``  9  9",
            "title": "Flowchart"
        },
        {
            "location": "/02-algo/index.html#variables",
            "text": "There are a few important things to take note here.   m m ,  i i ,  k k , and the list  L L  are what we called  states  or  variables .  While in the above, we can think of them as mathematical variables which we can assign  values  to, in a computer program, a variable is a location in the memory which holds a value.    We can perform two very basic operations on the variables: reading and writing.  In other words, we can set their values and we can retrieve their values.   We can  assign  the value of one variable to a constant (e.g., set  i i  to 1) or to the value of another variable (e.g., set  m m  to  l_i l_i ).  In the latter example, we first read the value of  l_i l_i , from  l_i l_i 's memory location and then we write that value to the memory location of  m m .  Once written, the value of  m m  will not change until the next time we update the value of  m m .  It is important to note that, when  i i  changes,  m m   does not change automatically  to the new  l_i l_i   This behavior is different from that which you may be familiar with in spreadsheet software -- if you set the value of a cell, say  A1  to be  =B1 , when the value in cell  B1  changes, the value  A1  also changes automatically.  We can also compare the values of two variables.  We see two examples above: \" i i  equals  k k ?\"  \" l_i > m l_i > m ?\"  When we compare, we read the values of the variables from their memory location and checks their relations.  We can perform arithmetic operations on the variables: addition, subtraction, etc.  We see one example above: \"increment  i i \".  This operation is actually an assignment operation in disguise.  We can write it as \"set  i i  to  i i  + 1\".  Here, you see that  i i  is referred to twice.  This operation reads the value from the memory location of  i i , adds 1 to it, and then writes the resulting value back to the location of  i i .",
            "title": "Variables"
        },
        {
            "location": "/02-algo/index.html#bugs",
            "text": "If you follow the execution of the algorithm above, step-by-step, using the example input  4 1 -4 0 9 9 3 5  above, you will obtain the correct maximum value  m m  of  9 .  But does that mean that the algorithm is correct?  The answer is NO.    For an algorithm to correctly solve the given problem, it has to produce the correct result for all valid inputs to the problem.  If we can find one counterexample, one input where the algorithm does not produce the correct output, then the algorithm is incorrect.  Note that I say  does not produce the correct output , which means that either the algorithm   produces the wrong output  or  does not produce any output at all .    In this case, we say that the algorithm or the program has a  bug .  A bug is a defect that causes the algorithm to behave incorrectly.  As a software developer, you will spend some time finding bugs in your code, a process known as  debugging .  A  debugger  is a tool that helps programmers find bugs in their code.  Before we even start the process of debugging, we first have to know if our algorithm is correct.  Remember that an algorithm is correct only if it produces the correct output only all possible valid inputs.  So, one way to check if an algorithm is correct is to try it with all possible valid inputs.  For the problem we are solving above, however, even though the list is finite, there are infinitely many possible inputs, and so, it is impossible to try all possible valid inputs.  In practice, we  craft  a smaller set of test inputs to check if the algorithm behaves correctly for these test inputs, and  hope  that it is correct for all possible inputs.  With experience, you will choose the right set of test inputs to maximize that chances that you will find a bug in your code.  There are also systematic ways of deriving test cases so that the test cases  cover  different paths of execution of the algorithm, but we won't be covering it in CS1010 3 .  Another way of checking if an algorithm is correct, is to reason about the behavior of the algorithm.  We will do this rather informally in CS1010, starting in 1-2 lectures from now.  You get to rigorously prove that an algorithm is correct in a higher level module (CS3230 Design and Analysis of Algorithms).  Finally, even if an algorithm is correct, the corresponding program might not be.  Recall that an algorithm is a step-by-step process to solve a problem.  It is what you want your program to do.  You still have to write a program (in C, or other languages) to actually have the computer do what you want it to do (in other words, to  implement the algorithm ). This process of translating the algorithm to a computer program, called  coding  may introduce bugs as well.  But we will worry about this later when we learn to program.  In the problem set at the end of this lecture, you will see slight variations of the algorithm above.  You should check through them to see whether they are correct or not.",
            "title": "Bugs"
        },
        {
            "location": "/02-algo/index.html#problem-set",
            "text": "",
            "title": "Problem Set"
        },
        {
            "location": "/02-algo/index.html#problem-11",
            "text": "The following algorithms are slight variations of the one in the notes above.  The differences are highlighted in red.  Do they correctly find the maximum integer from a finite list of  k k  integers ( k > 0 k > 0 )?    If an algorithm is buggy, give a counter-example where the output is incorrect.  In addition, give an example input where the algorithm still produces the correct output, where possible.    (a).   (b).   \u00a9.   (d).   (e).",
            "title": "Problem 1.1"
        },
        {
            "location": "/02-algo/index.html#problem-12",
            "text": "Change the algorithm above to find the minimum value instead of the maximum value from the given list  L = \\{l_0, ..., l_{k-1}\\} L = \\{l_0, ..., l_{k-1}\\} .",
            "title": "Problem 1.2"
        },
        {
            "location": "/02-algo/index.html#problem-13",
            "text": "Draw the flowchart for an algorithm, that takes in a list of integers  L = \\{l_0, ..., l_{k-1}\\}, k \\ge 0 L = \\{l_0, ..., l_{k-1}\\}, k \\ge 0 , and compute the  sum  of all the integers.  Think about what variable(s) do you need.      The answer is, by the way, always \"Yes.\"\u00a0 \u21a9    Think about why it is important to have a finite number of integers in the input.\u00a0 \u21a9    Software testing is a body of knowledge worthy of an advanced module by itself -- we offer one in CS4218.\u00a0 \u21a9",
            "title": "Problem 1.3"
        },
        {
            "location": "/03-func/index.html",
            "text": "Unit 3: Functions\n\n\nProblem: Finding the Range\n\n\nThe \nrange\n of a finite list of at least one integers \nL\nL\n is defined as the difference between the maximum and the minimum.  For example, the range for \n4 1 -4 0 9 9 3 5 8\n is \n13\n.  How do we find the range of a given list? \n\n\nTo find the range of a list, we can break the solution down into three subtasks: first find the maximum, then find the minimum, and finally, find the difference between the two.  \n\n\nFrom the previous lecture, you already know how to find the maximum and the minimum (from Problem 2)!  So, in expressing the algorithm to find the range, we can refer to a previous solution to a sub-problem, which we assume we already know how to solve.  \n\n\nLet's call our solution to find the maximum value from a given list \nL\nL\n as \nmax\nmax\n.  \nmax\nmax\n takes as input (i) a list \nL\nL\n and (ii) \nk\nk\n, the number of integers in \nL\nL\n.  It produces, or \nreturns\n, the maximum value among the integers in \nL\nL\n.  Borrowing from mathematical notation, we use the notation \nmax(L, k)\nmax(L, k)\n to represent the maximum value of \nL\nL\n.  \n\n\nSuppose that \nmin(L,k)\nmin(L,k)\n returns the minimum value among the integers in \nL\nL\n, then, the algorithm to find the range of \nL\nL\n can be written in a single line: \n\n\n\n\nmax(L, k) - min(L, k)\n\n\nmax(L, k) - min(L, k)\n\n\n\n\nFunctions\n\n\nmax\nmax\n and \nmin\nmin\n are examples of a powerful and important concept with many names: \nfunction\n, \nprocedure\n, \nsubroutine\n, \nmethod\n, \nsubprogram\n.  In the context of CS1010, we will use the term \nfunction\n.  Functions allow us to solve a problem by thinking about the solution at a higher level.  For instance, in the example above, we no longer have to think about checking through the items in the list one-by-one and maintaining the maximum so far, or the minimum so far.  We just have to think about how to compute the range, assuming that we already know how to compute the maximum and the minimum value.\n\n\nSuch an assumption, that we already know how to solve a subproblem, is known as \nwishful thinking\n.  Sometimes, it is useful to solve a problem assuming that you know how to solve the subproblem first, then worry about solving the subproblem later.  \n\n\nFor instance, consider the following problem: Given a finite list of \nk\nk\n integers ($k > 0), find the mean.  \n\n\nThe algorithm again, can be written in one line:\n\n\n\n\nsum(L, k) / k\n\n\nsum(L, k) / k\n\n\n\n\nif we assume that we have a function \nsum\nsum\n that can help us find the total of all \nk\nk\n integers.  It turns out, in this case, that you should also know how to solve the subproblem \nsum\nsum\n, since it is Problem 3 from last week.\n\n\nWe can then make this into a function itself (\nmean(L, k)\nmean(L, k)\n) which we can then use to solve other problems.\n\n\nThinking in terms of functions also have another advantage: given a function, we only need to worry about \nwhat\n it does, but not \nhow\n it is done.   We can treat a function as a black box -- given an input, it will produce an output satisfying certain conditions.  Many programming languages, including C which we will be using in CS1010, come with a rich set of predefined functions that we can use to help us solve computational problems.  In CS1010, we will also provide you with some functions to help you with your lab assignments.  You will also define your own functions when solving problems with C.  In fact, a C program is just a collection of functions calling each other.\n\n\nProblem: Finding Standard Deviation\n\n\nLet's look at another problem: Given \nL\nL\n, a finite list of at least one integers, find the standard deviation of the integers in \nL\nL\n.  \n\n\nFirst, recall that the (population) standard deviation is given by \n\n\n\n\n\\sqrt{\\frac{\\sum_{i=0}^{k-1} (l_i - \\mu)^2}{k}}\n\n\n\\sqrt{\\frac{\\sum_{i=0}^{k-1} (l_i - \\mu)^2}{k}}\n\n\n\n\nwhere \n\\mu\n\\mu\n is the mean of the integers in \nL\nL\n.\n\n\nTo compute the standard deviation, we first need to compute \n\\mu\n\\mu\n, the mean.   We already know how to do that: \nmean(L, k)\nmean(L, k)\n.  Then, we need to compute \n\\sum_{i=0}^{k-1} (l_i - \\mu)^2\n\\sum_{i=0}^{k-1} (l_i - \\mu)^2\n.  We can break it down into two subproblems:\n\n\n\n\nGiven a list \nL\nL\n and a constant value \nx\nx\n, subtract \nx\nx\n from every number in \nL\nL\n, giving us a new list.\n\n\nGiven a list, square every number in the list, giving us a new list.\n\n\n\n\nFor now, let's apply wishful thinking and assume that we know how to compute the above two steps with functions \nsubstract(L, k, x)\nsubstract(L, k, x)\n and \nsquare(L, k)\nsquare(L, k)\n, then, the formula \n\\sum_{i=0}^{k-1} (l_i - \\mu)^2\n\\sum_{i=0}^{k-1} (l_i - \\mu)^2\n can be computed by the following steps:\n\n\n\n\nset \n\\mu\n\\mu\n to \nmean(L, k)\nmean(L, k)\n\n\nset \nL'\nL'\n to \nsubstract(L, k, \\mu)\nsubstract(L, k, \\mu)\n\n\nset \nL''\nL''\n to \nsquare(L', k)\nsquare(L', k)\n\n\nset \nsum\nsum\n to \nsum(L'', k)\nsum(L'', k)\n.\n\n\n\n\nWe can also write it in one line:\n\n\n\n\nset \nsum\nsum\n to \nsum(square(substract(L, k, mean(L, k)), k), k)\nsum(square(substract(L, k, mean(L, k)), k), k)\n\n\n\n\nNow, to compute the standard deviation, we need to divide \nsum\nsum\n by \nk\nk\n and find the square root.  But, finding \nsum\nsum\n and divide by \nk\nk\n is just \nmean\nmean\n.  To compute square root, we again apply wishful thinking and assume that there is a function \nsqrt\nsqrt\n to do so.\n\n\nWe can now compute the standard deviation with one line: \n\n\n\n\nsqrt(mean(square(substract(L, k, mean(L, k)), k), k))\n\n\nsqrt(mean(square(substract(L, k, mean(L, k)), k), k))\n\n\n\n\nUsing functions, we can easily pass the output from one function as input to another, essentially chain the functions together, like Lego(R) blocks, to solve problems.  We also see an example of \nreuse\n here -- \nmean\nmean\n is used twice with different inputs.\n\n\n\n\nReturning a list\n\n\nWhile the above one-liner is an elegant solution, when we actually implement this in C later, it will not so simple and elegant.  Let's worry about that later.\n\n\n\n\nNow that we have seen how to compute standard deviation by breaking it down the four subproblems, \nsqrt\nsqrt\n, \nmean\nmean\n, \nsquare\nsquare\n, and \nsubstract\nsubstract\n, we have to make sure that things we wish can be done can actually be done.  The C library, and many programming languages, provide a pre-defined method to compute \nsqrt\nsqrt\n.  We already know how to compute \nmean\nmean\n.  Computing \nsquare\nsquare\n can be done as follows:\n\n\n\n\nThe implementation for \nsubstract\nsubstract\n is similar.\n\n\nAnother Solution for Finding Maximum\n\n\nIn the previous lecture, you have seen an algorithm to find the maximum value from a list of integers, which involves checking the elements one-by-one and keeping track of the maximum value so far.\n\n\nNow that we have seen what a function is, we can use the concept of wishful thinking to help us solve this problem in a different way and more elegant way.\n\n\nLet's suppose that we have a function \nmax'(L, i, j)\nmax'(L, i, j)\n, that finds the maximum integer among the elements \nl_i, l_{i+1}, ... l_j\nl_i, l_{i+1}, ... l_j\n.  The function \nmax(L, k)\nmax(L, k)\n, which finds the maximum among all elements of \nL\nL\n, is therefore the same as \nmax'(L, 0, k-1)\nmax'(L, 0, k-1)\n.\n\n\nDo we know how to solve \nmax'(L, i, j)\nmax'(L, i, j)\n without checking the integers in \nL\nL\n one-by-one?  Well, if \ni\ni\n equals to \nj\nj\n, i.e., there is only one element in the range of \nl_i, ..., l_j\nl_i, ..., l_j\n, then yes, the function should return the value of \nl_i\nl_i\n.  But, what if there are multiple elements in the range? (i.e., \ni < j\ni < j\n)?  By wishful thinking, we assume that we already know how to solve smaller (as in a shorter list) problem -- \nmax'(L, i+1, j)\nmax'(L, i+1, j)\n, so the maximum value for the range of \nl_i, ..., l_j\nl_i, ..., l_j\n is the larger of the two: either \nl_i\nl_i\n, or \nmax'(L, i+1, j)\nmax'(L, i+1, j)\n.  We can express this algorithm as follows:\n\n\n\n\nLet's trace through the algorithm above, using our previous example: \n4 1 -4 0 9 9 3 5 8\n.  Given this list, we compare the first element, \n4\n, with the maximum of the rest of the list \n1 -4 0 9 9 3 5 8\n.  Since with wishful thinking, we know how to solve this already, we get \n9\n as maximum value of \n1 -4 0 9 9 3 5 8\n.  Comparing \n4\n and \n9\n, \n9\n is larger. Thus, the maximum value for the whole list is \n9\n.\n\n\nExample: Finding a Factorial\n\n\nLet us look at another example of a function before we move on to another topic.  Suppose we want to write a function \nfactorial(n)\nfactorial(n)\n for an integer \nn\nn\n (\nn \\ge 0\nn \\ge 0\n) that computes \nn!\nn!\n. Recall that \nn! = n \\times n - 1 \\times n - 2 \\times ... 2 \\times 1 = n \\times (n-1)!\nn! = n \\times n - 1 \\times n - 2 \\times ... 2 \\times 1 = n \\times (n-1)!\n.  As a special case, \n0!\n0!\n is defined to be \n1\n1\n.\n\n\nThe algorithm to do this can be expressed by the following diagram:\n\n\n\n\nLet's look at an example.  Let's say we want to compute \nfactorial(4)\nfactorial(4)\n.  We assume we know how to solve this for a smaller problem --  \nfactorial(3)\nfactorial(3)\n, which is 6.  $factorial(4) is thus 4 \n\\times\n\\times\n 6, i.e., 24.\n\n\nRecursion: Function Calling Itself\n\n\nmax'\nmax'\n and \nfactorial\nfactorial\n are examples of functions which calls itself to solve a simpler version of the problem.  This is known as \nrecursion\n.  We will revisit this concept in much greater detail in the later part of CS1010.\n\n\nProblem Set\n\n\nProblem 3.1 : Getting MAD\n\n\nThe mean absolute deviation, or MAD, of a set of integers measures how spread out a set of data is.  The \nabsolute deviation\n is the absolute difference between an element in the list with the mean of values of the list.  The mean absolute deviation is the mean of all the absolute difference.  In other words, given \nL = \\{l_0, ... l_{k-1}\\}\nL = \\{l_0, ... l_{k-1}\\}\n, the MAD of \nL\nL\n is:\n\n\n\n\n\\frac{\\sum_{i=0}^{k-1} |l_i - \\mu|}{k}}\n\n\n\\frac{\\sum_{i=0}^{k-1} |l_i - \\mu|}{k}}\n\n\n\n\nHow do you find MAD by composing various functions we have seen?  Do you need a new function?\n\n\nProblem 3.2 : Ownself calls ownself\n\n\n(a) Give an algorithm for finding the sum of all the integers in the list \nL\nL\n with \nk\nk\n integers (\nk > 0\nk > 0\n) that is recursive.\n(b) The function \npow(i, j)\npow(i, j)\n computes \ni^j\ni^j\n.  Give an algorithm to compute \npow(i, j)\npow(i, j)\n recursively.",
            "title": "3. Functions"
        },
        {
            "location": "/03-func/index.html#unit-3-functions",
            "text": "",
            "title": "Unit 3: Functions"
        },
        {
            "location": "/03-func/index.html#problem-finding-the-range",
            "text": "The  range  of a finite list of at least one integers  L L  is defined as the difference between the maximum and the minimum.  For example, the range for  4 1 -4 0 9 9 3 5 8  is  13 .  How do we find the range of a given list?   To find the range of a list, we can break the solution down into three subtasks: first find the maximum, then find the minimum, and finally, find the difference between the two.    From the previous lecture, you already know how to find the maximum and the minimum (from Problem 2)!  So, in expressing the algorithm to find the range, we can refer to a previous solution to a sub-problem, which we assume we already know how to solve.    Let's call our solution to find the maximum value from a given list  L L  as  max max .   max max  takes as input (i) a list  L L  and (ii)  k k , the number of integers in  L L .  It produces, or  returns , the maximum value among the integers in  L L .  Borrowing from mathematical notation, we use the notation  max(L, k) max(L, k)  to represent the maximum value of  L L .    Suppose that  min(L,k) min(L,k)  returns the minimum value among the integers in  L L , then, the algorithm to find the range of  L L  can be written in a single line:    max(L, k) - min(L, k)  max(L, k) - min(L, k)",
            "title": "Problem: Finding the Range"
        },
        {
            "location": "/03-func/index.html#functions",
            "text": "max max  and  min min  are examples of a powerful and important concept with many names:  function ,  procedure ,  subroutine ,  method ,  subprogram .  In the context of CS1010, we will use the term  function .  Functions allow us to solve a problem by thinking about the solution at a higher level.  For instance, in the example above, we no longer have to think about checking through the items in the list one-by-one and maintaining the maximum so far, or the minimum so far.  We just have to think about how to compute the range, assuming that we already know how to compute the maximum and the minimum value.  Such an assumption, that we already know how to solve a subproblem, is known as  wishful thinking .  Sometimes, it is useful to solve a problem assuming that you know how to solve the subproblem first, then worry about solving the subproblem later.    For instance, consider the following problem: Given a finite list of  k k  integers ($k > 0), find the mean.    The algorithm again, can be written in one line:   sum(L, k) / k  sum(L, k) / k   if we assume that we have a function  sum sum  that can help us find the total of all  k k  integers.  It turns out, in this case, that you should also know how to solve the subproblem  sum sum , since it is Problem 3 from last week.  We can then make this into a function itself ( mean(L, k) mean(L, k) ) which we can then use to solve other problems.  Thinking in terms of functions also have another advantage: given a function, we only need to worry about  what  it does, but not  how  it is done.   We can treat a function as a black box -- given an input, it will produce an output satisfying certain conditions.  Many programming languages, including C which we will be using in CS1010, come with a rich set of predefined functions that we can use to help us solve computational problems.  In CS1010, we will also provide you with some functions to help you with your lab assignments.  You will also define your own functions when solving problems with C.  In fact, a C program is just a collection of functions calling each other.",
            "title": "Functions"
        },
        {
            "location": "/03-func/index.html#problem-finding-standard-deviation",
            "text": "Let's look at another problem: Given  L L , a finite list of at least one integers, find the standard deviation of the integers in  L L .    First, recall that the (population) standard deviation is given by    \\sqrt{\\frac{\\sum_{i=0}^{k-1} (l_i - \\mu)^2}{k}}  \\sqrt{\\frac{\\sum_{i=0}^{k-1} (l_i - \\mu)^2}{k}}   where  \\mu \\mu  is the mean of the integers in  L L .  To compute the standard deviation, we first need to compute  \\mu \\mu , the mean.   We already know how to do that:  mean(L, k) mean(L, k) .  Then, we need to compute  \\sum_{i=0}^{k-1} (l_i - \\mu)^2 \\sum_{i=0}^{k-1} (l_i - \\mu)^2 .  We can break it down into two subproblems:   Given a list  L L  and a constant value  x x , subtract  x x  from every number in  L L , giving us a new list.  Given a list, square every number in the list, giving us a new list.   For now, let's apply wishful thinking and assume that we know how to compute the above two steps with functions  substract(L, k, x) substract(L, k, x)  and  square(L, k) square(L, k) , then, the formula  \\sum_{i=0}^{k-1} (l_i - \\mu)^2 \\sum_{i=0}^{k-1} (l_i - \\mu)^2  can be computed by the following steps:   set  \\mu \\mu  to  mean(L, k) mean(L, k)  set  L' L'  to  substract(L, k, \\mu) substract(L, k, \\mu)  set  L'' L''  to  square(L', k) square(L', k)  set  sum sum  to  sum(L'', k) sum(L'', k) .   We can also write it in one line:   set  sum sum  to  sum(square(substract(L, k, mean(L, k)), k), k) sum(square(substract(L, k, mean(L, k)), k), k)   Now, to compute the standard deviation, we need to divide  sum sum  by  k k  and find the square root.  But, finding  sum sum  and divide by  k k  is just  mean mean .  To compute square root, we again apply wishful thinking and assume that there is a function  sqrt sqrt  to do so.  We can now compute the standard deviation with one line:    sqrt(mean(square(substract(L, k, mean(L, k)), k), k))  sqrt(mean(square(substract(L, k, mean(L, k)), k), k))   Using functions, we can easily pass the output from one function as input to another, essentially chain the functions together, like Lego(R) blocks, to solve problems.  We also see an example of  reuse  here --  mean mean  is used twice with different inputs.   Returning a list  While the above one-liner is an elegant solution, when we actually implement this in C later, it will not so simple and elegant.  Let's worry about that later.   Now that we have seen how to compute standard deviation by breaking it down the four subproblems,  sqrt sqrt ,  mean mean ,  square square , and  substract substract , we have to make sure that things we wish can be done can actually be done.  The C library, and many programming languages, provide a pre-defined method to compute  sqrt sqrt .  We already know how to compute  mean mean .  Computing  square square  can be done as follows:   The implementation for  substract substract  is similar.",
            "title": "Problem: Finding Standard Deviation"
        },
        {
            "location": "/03-func/index.html#another-solution-for-finding-maximum",
            "text": "In the previous lecture, you have seen an algorithm to find the maximum value from a list of integers, which involves checking the elements one-by-one and keeping track of the maximum value so far.  Now that we have seen what a function is, we can use the concept of wishful thinking to help us solve this problem in a different way and more elegant way.  Let's suppose that we have a function  max'(L, i, j) max'(L, i, j) , that finds the maximum integer among the elements  l_i, l_{i+1}, ... l_j l_i, l_{i+1}, ... l_j .  The function  max(L, k) max(L, k) , which finds the maximum among all elements of  L L , is therefore the same as  max'(L, 0, k-1) max'(L, 0, k-1) .  Do we know how to solve  max'(L, i, j) max'(L, i, j)  without checking the integers in  L L  one-by-one?  Well, if  i i  equals to  j j , i.e., there is only one element in the range of  l_i, ..., l_j l_i, ..., l_j , then yes, the function should return the value of  l_i l_i .  But, what if there are multiple elements in the range? (i.e.,  i < j i < j )?  By wishful thinking, we assume that we already know how to solve smaller (as in a shorter list) problem --  max'(L, i+1, j) max'(L, i+1, j) , so the maximum value for the range of  l_i, ..., l_j l_i, ..., l_j  is the larger of the two: either  l_i l_i , or  max'(L, i+1, j) max'(L, i+1, j) .  We can express this algorithm as follows:   Let's trace through the algorithm above, using our previous example:  4 1 -4 0 9 9 3 5 8 .  Given this list, we compare the first element,  4 , with the maximum of the rest of the list  1 -4 0 9 9 3 5 8 .  Since with wishful thinking, we know how to solve this already, we get  9  as maximum value of  1 -4 0 9 9 3 5 8 .  Comparing  4  and  9 ,  9  is larger. Thus, the maximum value for the whole list is  9 .",
            "title": "Another Solution for Finding Maximum"
        },
        {
            "location": "/03-func/index.html#example-finding-a-factorial",
            "text": "Let us look at another example of a function before we move on to another topic.  Suppose we want to write a function  factorial(n) factorial(n)  for an integer  n n  ( n \\ge 0 n \\ge 0 ) that computes  n! n! . Recall that  n! = n \\times n - 1 \\times n - 2 \\times ... 2 \\times 1 = n \\times (n-1)! n! = n \\times n - 1 \\times n - 2 \\times ... 2 \\times 1 = n \\times (n-1)! .  As a special case,  0! 0!  is defined to be  1 1 .  The algorithm to do this can be expressed by the following diagram:   Let's look at an example.  Let's say we want to compute  factorial(4) factorial(4) .  We assume we know how to solve this for a smaller problem --   factorial(3) factorial(3) , which is 6.  $factorial(4) is thus 4  \\times \\times  6, i.e., 24.",
            "title": "Example: Finding a Factorial"
        },
        {
            "location": "/03-func/index.html#recursion-function-calling-itself",
            "text": "max' max'  and  factorial factorial  are examples of functions which calls itself to solve a simpler version of the problem.  This is known as  recursion .  We will revisit this concept in much greater detail in the later part of CS1010.",
            "title": "Recursion: Function Calling Itself"
        },
        {
            "location": "/03-func/index.html#problem-set",
            "text": "",
            "title": "Problem Set"
        },
        {
            "location": "/03-func/index.html#problem-31-getting-mad",
            "text": "The mean absolute deviation, or MAD, of a set of integers measures how spread out a set of data is.  The  absolute deviation  is the absolute difference between an element in the list with the mean of values of the list.  The mean absolute deviation is the mean of all the absolute difference.  In other words, given  L = \\{l_0, ... l_{k-1}\\} L = \\{l_0, ... l_{k-1}\\} , the MAD of  L L  is:   \\frac{\\sum_{i=0}^{k-1} |l_i - \\mu|}{k}}  \\frac{\\sum_{i=0}^{k-1} |l_i - \\mu|}{k}}   How do you find MAD by composing various functions we have seen?  Do you need a new function?",
            "title": "Problem 3.1 : Getting MAD"
        },
        {
            "location": "/03-func/index.html#problem-32-ownself-calls-ownself",
            "text": "(a) Give an algorithm for finding the sum of all the integers in the list  L L  with  k k  integers ( k > 0 k > 0 ) that is recursive.\n(b) The function  pow(i, j) pow(i, j)  computes  i^j i^j .  Give an algorithm to compute  pow(i, j) pow(i, j)  recursively.",
            "title": "Problem 3.2 : Ownself calls ownself"
        },
        {
            "location": "/04-type/index.html",
            "text": "Unit 4: Types\n\n\nRecall from Unit 1 that machine code and data manipulated by machine code are all stored as a sequence of 1s and 0s in the memory.  Each unit of either 1 or 0 is known as a \nbit\n.  8 bits form a \nbyte\n.\n\n\nRemember from Unit 2 that a variable is a memory location that stores a value, as a sequence of bits.  The bits stored in the memory has no meaning by itself.  It has to be interpreted by the machine code.  Does a sequence of 1s and 0s represent an integer?  A pixel of an image?  A sound sample in an audio clip?  A month?   As a programmer, we have to tag the variable with its \ntype\n, so that the machine code knows how to interpret the sequence of bits.  In addition, the type also tells the machine code, how many bits \"belong\" to this variable.  The number of bits of a type is also known as the \nsize\n of a type.\n\n\nThe size of a type determines how many different values a variable of that type can hold.  For instance, a type of one bit can only hold two possible values (e.g., \n0\n or \n1\n, \ntrue\n or \nfalse\n, \nblack\n or \nwhite\n).  A type of two bits can hold four values, represented as \n00\n, \n01,\n10\n,\n11`.  In general, a type of \nk\nk\n bits can hold \n2^k\n2^k\n values.\n\n\nIntegers\n\n\nTo represent integers, a type of 8 bits can represent 256 different values.  If the type only represents non-negative integers (called \nunsigned\n), then it can hold any value between 0 to 255.  If it represents both positive and negative integers (called \nsigned\n), it can hold any value between -128 to 127.  Depending on the needs (how much memory we have, how big is the number we need to represent), programmers have to decide on the size of the type used for a variable in their programs.  With 64 bits, a signed integer can store any value between -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807.  This might look big enough for you -- but we can't even fit the results from \nfactorial(21)\nfactorial(21)\n here!\n\nWe have to go to 128 bits to represent larger integers.\n\n\nCharacters\n\n\nTo represent a character (i.e., a symbol representing a letter, number, punctuation, etc), we use either 8 bits of 16 bits.  For English, the ASCII standard maps 127 binary sequences to common characters you can type on your keyboard (including 0-9, A-Z, a-z, all sorts of punctuations: <>?:\"{}!@#$%^&*()_+-=[]\\';/., and special characters like return and escape).  The unicode standard uses up to 32 bits per character, allowing many non-English letter characters (e.g., \nEmoticons\n, \nBraille\n, \nMahjong Tiles\n) to be represented.\n\n\nReal Numbers\n\n\nFor real numbers, because we need to represent a huge number of possible values, we normally use 32 bits or 64 bits.  In CS1231, you will learn that there are uncountably many possible real numbers.  But, no matter how many bits we use, we can only represent a finite number of possible values for real numbers.  Here, we run into a limit of digitizing information into 0s and 1s -- we can never represent all possible real numbers in a computer!  Because of this, programs that manipulate real numbers leads to weird answers (such as 0.1 + 0.2 is not exactly the same as 0.3) and so, we have to take special care when dealing with real numbers when writing programs (not just in C, but in many other languages as well).  Hence, if we only expect a variable to hold an integer, we should not choose a type that represents real numbers.\n\n\nThe details of how a sequence of bits can represent integers and real numbers (both positive and negative numbers) are covered in CS2100. \n\n\nYou should have also noticed that in the discussion above, we talk about types that are 8, 16, 32, 64, 128 bits -- all power of twos.  We do not have a type of size, say, 41 bits.  The reason for this has to do with how memory location is addressed.  This will again be explained in CS2100.\n\n\nType Declaration\n\n\nIn C, which we will use in CS1010, we have to associate \nevery\n variable with a type, and once a variable is \ndeclared\n with a type, the type cannot be changed\n1\n.\n\n\nWhen we write a function, we have to declare the types of each of the parameters and the return value as well.  \n\n\nTake the function \nmean(L, k)\nmean(L, k)\n as an example.  We have said that \nL\nL\n is a list\n2\n of integers.  So each element in \nL\nL\n should have an integer type (how many bits to use will depend on the range of numbers we want the program to possibly handle and how frugal we are about memory usage).  What about \nk\nk\n?  \nk\nk\n refers to the number of elements in \nL\nL\n, so it has to be an integer.  As for the value returned by \nmean(L, k)\nmean(L, k)\n, even when the inputs are all integers (and thus, the sum is an integer), the mean value can be a real number.  So we should choose a type that represents a real number for the return value.  \n\n\n\n\nImportance of Type\n\n\nChoosing a wrong type to represent a variable can lead to buggy code.  Suppose we say that \nmean(L, k)\nmean(L, k)\n returns an integer, then when we call \nmean\nmean\n on the input \n1 2 3 4\n, we will get \n2\n as the answer, instead of \n2.5\n as it should.\n\n\n\n\n\n\n\n\n\n\n\n\nThis behavior is known as static typing.  Some programming languages, such as Javascript and Python, are dynamically typed.  The type of a variable may change depending on the value the variable is assigned to.\u00a0\n\u21a9\n\n\n\n\n\n\nWe have not talked about how to represent a list yet.  I will do that in a later unit.\u00a0\n\u21a9",
            "title": "4. Types"
        },
        {
            "location": "/04-type/index.html#unit-4-types",
            "text": "Recall from Unit 1 that machine code and data manipulated by machine code are all stored as a sequence of 1s and 0s in the memory.  Each unit of either 1 or 0 is known as a  bit .  8 bits form a  byte .  Remember from Unit 2 that a variable is a memory location that stores a value, as a sequence of bits.  The bits stored in the memory has no meaning by itself.  It has to be interpreted by the machine code.  Does a sequence of 1s and 0s represent an integer?  A pixel of an image?  A sound sample in an audio clip?  A month?   As a programmer, we have to tag the variable with its  type , so that the machine code knows how to interpret the sequence of bits.  In addition, the type also tells the machine code, how many bits \"belong\" to this variable.  The number of bits of a type is also known as the  size  of a type.  The size of a type determines how many different values a variable of that type can hold.  For instance, a type of one bit can only hold two possible values (e.g.,  0  or  1 ,  true  or  false ,  black  or  white ).  A type of two bits can hold four values, represented as  00 ,  01, 10 , 11`.  In general, a type of  k k  bits can hold  2^k 2^k  values.",
            "title": "Unit 4: Types"
        },
        {
            "location": "/04-type/index.html#integers",
            "text": "To represent integers, a type of 8 bits can represent 256 different values.  If the type only represents non-negative integers (called  unsigned ), then it can hold any value between 0 to 255.  If it represents both positive and negative integers (called  signed ), it can hold any value between -128 to 127.  Depending on the needs (how much memory we have, how big is the number we need to represent), programmers have to decide on the size of the type used for a variable in their programs.  With 64 bits, a signed integer can store any value between -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807.  This might look big enough for you -- but we can't even fit the results from  factorial(21) factorial(21)  here! \nWe have to go to 128 bits to represent larger integers.",
            "title": "Integers"
        },
        {
            "location": "/04-type/index.html#characters",
            "text": "To represent a character (i.e., a symbol representing a letter, number, punctuation, etc), we use either 8 bits of 16 bits.  For English, the ASCII standard maps 127 binary sequences to common characters you can type on your keyboard (including 0-9, A-Z, a-z, all sorts of punctuations: <>?:\"{}!@#$%^&*()_+-=[]\\';/., and special characters like return and escape).  The unicode standard uses up to 32 bits per character, allowing many non-English letter characters (e.g.,  Emoticons ,  Braille ,  Mahjong Tiles ) to be represented.",
            "title": "Characters"
        },
        {
            "location": "/04-type/index.html#real-numbers",
            "text": "For real numbers, because we need to represent a huge number of possible values, we normally use 32 bits or 64 bits.  In CS1231, you will learn that there are uncountably many possible real numbers.  But, no matter how many bits we use, we can only represent a finite number of possible values for real numbers.  Here, we run into a limit of digitizing information into 0s and 1s -- we can never represent all possible real numbers in a computer!  Because of this, programs that manipulate real numbers leads to weird answers (such as 0.1 + 0.2 is not exactly the same as 0.3) and so, we have to take special care when dealing with real numbers when writing programs (not just in C, but in many other languages as well).  Hence, if we only expect a variable to hold an integer, we should not choose a type that represents real numbers.  The details of how a sequence of bits can represent integers and real numbers (both positive and negative numbers) are covered in CS2100.   You should have also noticed that in the discussion above, we talk about types that are 8, 16, 32, 64, 128 bits -- all power of twos.  We do not have a type of size, say, 41 bits.  The reason for this has to do with how memory location is addressed.  This will again be explained in CS2100.",
            "title": "Real Numbers"
        },
        {
            "location": "/04-type/index.html#type-declaration",
            "text": "In C, which we will use in CS1010, we have to associate  every  variable with a type, and once a variable is  declared  with a type, the type cannot be changed 1 .  When we write a function, we have to declare the types of each of the parameters and the return value as well.    Take the function  mean(L, k) mean(L, k)  as an example.  We have said that  L L  is a list 2  of integers.  So each element in  L L  should have an integer type (how many bits to use will depend on the range of numbers we want the program to possibly handle and how frugal we are about memory usage).  What about  k k ?   k k  refers to the number of elements in  L L , so it has to be an integer.  As for the value returned by  mean(L, k) mean(L, k) , even when the inputs are all integers (and thus, the sum is an integer), the mean value can be a real number.  So we should choose a type that represents a real number for the return value.     Importance of Type  Choosing a wrong type to represent a variable can lead to buggy code.  Suppose we say that  mean(L, k) mean(L, k)  returns an integer, then when we call  mean mean  on the input  1 2 3 4 , we will get  2  as the answer, instead of  2.5  as it should.       This behavior is known as static typing.  Some programming languages, such as Javascript and Python, are dynamically typed.  The type of a variable may change depending on the value the variable is assigned to.\u00a0 \u21a9    We have not talked about how to represent a list yet.  I will do that in a later unit.\u00a0 \u21a9",
            "title": "Type Declaration"
        },
        {
            "location": "/05-first-c/index.html",
            "text": "Unit 5: First C Program\n\n\nIn this unit, we will write and compile your first C program.  You have already learned, conceptually, what is a variable, what is a type and what is a function.  Let's see how we apply these concepts to C.\n\n\nTo start, let's look at a simple snippet of C code:\n\n\n1\n2\n3\n4\nint\n \nsquare\n(\nint\n \nx\n)\n \n\n{\n\n  \nreturn\n \nx\n*\nx\n;\n\n\n}\n\n\n\n\n\n\n\nThe code above defines a function named \nsquare\n.  The word \nint\n appears \nbefore\n the name \nsquare\n.  \nint\n is used to signify an integer type.  Appearing before the name \nsquare\n tells the compiler that \nsquare\n is returning a value of type \nint\n.\n\n\nAfter the word \nsquare\n, we write the parameters to the function in parenthesis \n(\n and \n)\n.  In between \n(\n and \n)\n is \nint x\n: \nx\n is the name of the parameter, \nint\n is the type of that parameter.  \n\n\nTo summarize, in Line 1, \nint square(int x)\n defines a function named \nsquare\n that takes in an integer parameter \nx\n and is returning a value which is also an integer.\n\n\nThe next three lines are written in between curly brackets \n{\n and \n}\n.  You will see these used a lot in C and other programming languages with C-like syntaxes, such as Javascript, C++, and Java.  These curly brackets group a \nblock\n of \nstatements\n together.  In this example, this block defines how the function \nsquare\n computes the square of \nx\n, and what it returns.  This is sometimes called the \nbody of a function\n.\n\n\nIn this function body, there is only one statement \nreturn x*x;\n  within the block.  A \nstatement\n is a unit in a programming language that expresses either a command to be executed or declares a new variable or function.  The word \nreturn\n says that this function \nsquare\n should return the following value, computed as \nx*x\n (\nx\n multiply by \nx\n).  This statement is terminated by a semicolon \n;\n.\n\n\nThe words \nint\n and \nreturn\n that appears above are \nkeywords\n defined in the C programming language, and they are reserved for the special meaning that they represent (a type and a command to return a value from a function).  We cannot repurpose keywords in C.\n\n\nWe are now ready to write our first C program.  The first program computes the square of the hypotenuse of a right-angled triangle with a base of 4 and height of 3.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\nint\n \nsquare\n(\nint\n \nx\n)\n \n\n{\n\n  \nreturn\n \nx\n*\nx\n;\n\n\n}\n\n\n\nint\n \nmain\n()\n \n\n{\n\n  \nint\n \nhypotenuse_square\n;\n\n\n  \nhypotenuse_square\n \n=\n \nsquare\n(\n3\n)\n \n+\n \nsquare\n(\n4\n);\n\n  \nreturn\n \n0\n;\n\n\n}\n\n\n\n\n\n\n\nRemember that a C program consists of a bunch of functions, calling each other.  The most important function is called \nmain\n, and it is the \nentry point\n to the program.  It is where the operating system will begin to execute the program.  So every program must define exactly one function called \nmain\n.\n\n\n1\n2\n3\n4\nint\n \nmain\n()\n \n\n{\n\n  \n:\n\n\n}\n\n\n\n\n\n\n\nmain\n returns an integer to the operating system, to signal to the operating system whether the program exits successfully or not.  In this case, we always return \n0\n (success) assuming that nothing goes wrong for simplicity.  This is the second example where you see the keyword \nreturn\n in action.\n\n\nIn modern C, the main always return 0 when it exits.  So, we will skip this statement \nreturn 0;\n from now on.\n\n\nVariable Declaration\n\n\nIn the example above, you also see the lines\n\n\n1\nint\n \nhypotenuse_square\n;\n\n\n\n\n\n\n\nThis is declaration statement (terminated with a semicolon, again).  Each statement declares a variable with its corresponding type (\nint\n here).  We gave each variable a name, here we call the variable \nhypotenuse_square\n.\n\n\nRemember that \nall variables must be declared with its corresponding type before used in C\n.\n\n\nIn C, a function must be either defined or declared before used as well.  In the example above, we define \nsquare\n before \nmain\n.  If we switch the order of the two, the compiler will complain.  Unless we declare the function first.  Declaring a function means that we simply state the return type, the name, and the parameters, \nwithout\n the body.\n\n\nAssignment Statement\n\n\nThe next line of the code shows an example of an assignment statement.  \n\n\n1\n  \nhypotenuse_square\n \n=\n \nsquare\n(\n3\n)\n \n+\n \nsquare\n(\n4\n);\n\n\n\n\n\n\n\nAn assignment operator takes the form of:\n\n\n1\n  \nleft_hand_side\n \n=\n \nright_hand_side\n;\n\n\n\n\n\n\n\nThe \nleft_hand_side\n must be the name of a variable.  We first evaluate the \nright_hand_side\n of the assignment statement, find its value, then put the value into the variable named on the \nleft_hand_side\n.\n\n\nHere, on the right-hand side, we call the function \nsquare\n, which we defined earlier.  We call \nsquare\n with \narguments\n \n3\n and \n4\n respectively.   We use the operator \n+\n to add the two results together.  The right-hand side should give the value 25, which we then assign to the variable \nhypotenuse_square\n.\n\n\nNote that we use \n=\n equal sign for assignment, NOT for checking equality.  The C notation for checking for equality is \n==\n (we will come back to this later).\n\n\nRecap\n\n\nBefore we move on, let's recap some concepts:\n\n\n\n\nA C program consists of functions, invoking each other.\n\n\nEach function is defined by its returned type, followed by its name, its parameter(s) (within a pair of parenthesis) and its body (within a pair of curly brackets).  \n\n\nEach function must be defined or declared before it is used.  \n\n\nThe function body consists of one or more statements.  We have seen assignment statements (using the \n=\n operator) and return statements, using \nreturn\n as the keyword.\n\n\nEach variable must be declared before it is used.  A declaration starts with its type followed by its name.\n\n\n\n\nExample 2\n\n\nLet's change the program slightly, so that instead of computing the square of the hypotenuse, we compute the hypotenuse itself.  Recall that we said C provides a bunch of predefined functions, include \nsqrt\n, which computes the square root of a given number.  Since a square root of a number is not necessarily an integer, we need to use a variable with a type that can store a real number.  \n\n\nTo represent real numbers, we commonly use the type \nfloat\n (which is short for a floating point number -- named so due to how a real number is represented in bits).  A \nfloat\n type can store 32 bits.  To double the precision (64 bits), we can use the type \ndouble\n.  A \nlong double\n type can store either 80-bits or 128-bits, depending on implementation.\n\n\nBut which one does \nsqrt\n returns?  To find out the exact \nspecification\n of a pre-defined function, we can consult the manual (or \nman\n for short) pages for the function.  \n\n\nIf you type \nman sqrt\n on the command line (or place the cursor on \nsqrt\n in \nvim\n and type \nK\n in command mode), you will see that the \nsqrt\n method has the following specification:\n\n\n1\ndouble\n \nsqrt\n(\ndouble\n \nx\n);\n\n\n\n\n\n\n\nThe \nsqrt\n function returns a \ndouble\n precision real number.  We can now modify the program above to the following:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\ndouble\n \nsqrt\n(\ndouble\n \nx\n);\n \n// not recommended\n\n\n\nlong\n \nsquare\n(\nlong\n \nx\n)\n \n\n{\n\n  \nreturn\n \nx\n*\nx\n;\n\n\n}\n\n\n\ndouble\n \nhypotenuse_of\n(\nlong\n \nbase\n,\n \nlong\n \nheight\n)\n \n\n{\n\n  \nreturn\n \nsqrt\n(\nsquare\n(\nbase\n)\n \n+\n \nsquare\n(\nheight\n));\n\n\n}\n\n\n\nint\n \nmain\n()\n \n\n{\n\n  \nhypotenuse_of\n(\n3\n,\n \n4\n);\n\n\n}\n\n\n\n\n\n\n\nNote that the first line declares the function \nsqrt\n, because we need to declare a function before it is used.  Since \nsqrt\n is pre-defined elsewhere, we do not have to supply the function body here.  Such practice of declaring a predefined function ourselves, however, is not recommended.  Different platform, compilers, libraries, may provide a different specification for the same function.  As such, it is better to use the declaration from the library that provides the predefined function itself.  A library usually provides one or more \nheader files\n, a set of files that contain function declarations, type definitions, and constant definitions.  In the case of \nsqrt\n, its declaration is contained in a header file called \nmath.h\n.  To include this file, you add the line \n#include\n \n<math.h>\n at the top of the program.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n#include\n \n<math.h>\n\n\n\nlong\n \nsquare\n(\nlong\n \nx\n)\n \n\n{\n\n  \nreturn\n \nx\n*\nx\n;\n\n\n}\n\n\n\ndouble\n \nhypotenuse_of\n(\nlong\n \nbase\n,\n \nlong\n \nheight\n)\n \n\n{\n\n  \nreturn\n \nsqrt\n(\nsquare\n(\nbase\n)\n \n+\n \nsquare\n(\nheight\n));\n\n\n}\n\n\n\nint\n \nmain\n()\n \n\n{\n\n  \nhypotenuse_of\n(\n3\n,\n \n4\n);\n\n\n}\n\n\n\n\n\n\n\nYou might notice the same line appear in the man page for \nsqrt\n.  Thus, the man pages tell us which header file to include if you want to use a certain function.\n\n\n\n\nFile Extension\n\n\nThe convention for file extension for a C program is \n.c\n and for a C header file is \n.h\n.  Even though you are allowed to name the files with any extension you like, you should stick to the convention so that it is clear to other tools/programmers what is the purpose of each file.\n\n\n\n\nOther Types in C\n\n\nAn \nint\n variable is usually 32-bits long.  If we only need 16 bits, we use the type \nshort int\n, or just \nshort\n.  If we only need 8-bits, we use the type \nchar\n (short for character).\n\n\nNote that in the above, I said an \nint\n is \nusually\n 32 bits.  Remember (from \nUnit 1\n that a C program gets compiled into machine code for a specific CPU architecture.  The C standard only guarantees that an \nint\n is at least 16 bits.  Although most C compilers compile \nint\n to 32 bits, there is no guarantee!    \n\n\nIf we need something more than an \nint\n, we can use \nlong int\n, or just \nlong\n.  The C standard guarantees that a \nlong\n is at least 32 bits.  Depending on the implementation, it sometimes compiled to 32-bits, sometimes 64-bits.  To get even longer, we can use the type \nlong long int\n, or just \nlong long\n, which is guaranteed to be at least 64 bits\n1\n.\n\n\nSigned vs. Unsigned\n\n\nWe have seen earlier that the same sequence of bits, if interpreted as signed or unsigned, would result in a different value.  By default, all types in C refer to signed types.  If you want a variable that holds only non-negative integers, you can add the keyword \nunsigned\n to the front of the type.  Doing so would mean that the range of values you can store in the variable is doubled, without adding more bits (since the bit used to present the + or - sign is no longer needed).  \n\n\nFor instance, since we know that \nsquare\n can only return a non-zero integer, we can actually declare it as:\n\n\n1\n2\n3\n4\nunsigned\n \nlong\n \nsquare\n(\nlong\n \nx\n)\n \n\n{\n\n  \nreturn\n \nx\n*\nx\n;\n\n\n}\n\n\n\n\n\n\n\n\n\nUnsigned Real Numbers?\n\n\nThere are no \nunsigned\n versions of \nfloat\n and \ndouble\n.  To understand the reason, we have to go further into how floating points numbers are represented in bits.  That is a topic for another module.\n\n\n\n\nstdint.h\n\n\nSince the number of bits for \nint\n, \nlong\n, and \nlong long\n could defer, in order to write a C program that is portable (i.e., works on different platforms, architecture, operating systems), we have two options:\n\n\n\n\nDo not write a program that assumes a specific number of bits is used for a certain type, or\n\n\nUse the type defined in the header file \nstdint.h\n: \nint8_t\n, \nuint8_t\n, \nint16_t\n, \nuint16_t\n, \nint32_t\n, \nuint32_t\n, \nint64_t\n, \nuint64_t\n.  The suffix \n_t\n is a convention to indicate that this is a customized type (more on this in later units).  The prefix \nu\n indicates that the type is an unsigned type.  The numbers \n8\n, \n16\n, \n32\n, and \n64\n indicate the number of bits for each type.  Thus, \nuint32_t\n is guaranteed to be of size 32 bits, and can hold unsigned integer values from \n0\n0\n to \n2^32-1\n2^32-1\n.\n\n\n\n\nProblem Set 5\n\n\n5.1\n\n\nIn the example above, \nsqrt\n is declared to take in a parameter of type \ndouble\n .  But the argument that we pass in is the sum of two \nint\n, which is also an \nint\n.   Would this result in an error?  \n\n\n5.2\n\n\nIn the code above, you see the following line:\n\n\n1\n// not recommended\n\n\n\n\n\n\n\nFind out what \n//\n means and what it is used for.\n\n\n5.3\n\n\nConsider the following alternative definition of \nsquare\n\n\n1\n2\n3\n???\n \nsquare\n(\nuint16_t\n \nx\n)\n \n{\n\n    \nreturn\n \nx\n*\nx\n;\n\n\n}\n\n\n\n\n\n\n\nWhat should the return type of this \nsquare\n be, in order for the return type to be big enough to store all possible value for \nx*x\n?\n\n\n\n\n\n\n\n\n\n\nAdding more \nlong\n does not make the integer longer, i.e., there is no \nlong long long int\n.\u00a0\n\u21a9",
            "title": "5. 1st C Program"
        },
        {
            "location": "/05-first-c/index.html#unit-5-first-c-program",
            "text": "In this unit, we will write and compile your first C program.  You have already learned, conceptually, what is a variable, what is a type and what is a function.  Let's see how we apply these concepts to C.  To start, let's look at a simple snippet of C code:  1\n2\n3\n4 int   square ( int   x )   { \n   return   x * x ;  }    The code above defines a function named  square .  The word  int  appears  before  the name  square .   int  is used to signify an integer type.  Appearing before the name  square  tells the compiler that  square  is returning a value of type  int .  After the word  square , we write the parameters to the function in parenthesis  (  and  ) .  In between  (  and  )  is  int x :  x  is the name of the parameter,  int  is the type of that parameter.    To summarize, in Line 1,  int square(int x)  defines a function named  square  that takes in an integer parameter  x  and is returning a value which is also an integer.  The next three lines are written in between curly brackets  {  and  } .  You will see these used a lot in C and other programming languages with C-like syntaxes, such as Javascript, C++, and Java.  These curly brackets group a  block  of  statements  together.  In this example, this block defines how the function  square  computes the square of  x , and what it returns.  This is sometimes called the  body of a function .  In this function body, there is only one statement  return x*x;   within the block.  A  statement  is a unit in a programming language that expresses either a command to be executed or declares a new variable or function.  The word  return  says that this function  square  should return the following value, computed as  x*x  ( x  multiply by  x ).  This statement is terminated by a semicolon  ; .  The words  int  and  return  that appears above are  keywords  defined in the C programming language, and they are reserved for the special meaning that they represent (a type and a command to return a value from a function).  We cannot repurpose keywords in C.  We are now ready to write our first C program.  The first program computes the square of the hypotenuse of a right-angled triangle with a base of 4 and height of 3.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12 int   square ( int   x )   { \n   return   x * x ;  }  int   main ()   { \n   int   hypotenuse_square ; \n\n   hypotenuse_square   =   square ( 3 )   +   square ( 4 ); \n   return   0 ;  }    Remember that a C program consists of a bunch of functions, calling each other.  The most important function is called  main , and it is the  entry point  to the program.  It is where the operating system will begin to execute the program.  So every program must define exactly one function called  main .  1\n2\n3\n4 int   main ()   { \n   :  }    main  returns an integer to the operating system, to signal to the operating system whether the program exits successfully or not.  In this case, we always return  0  (success) assuming that nothing goes wrong for simplicity.  This is the second example where you see the keyword  return  in action.  In modern C, the main always return 0 when it exits.  So, we will skip this statement  return 0;  from now on.",
            "title": "Unit 5: First C Program"
        },
        {
            "location": "/05-first-c/index.html#variable-declaration",
            "text": "In the example above, you also see the lines  1 int   hypotenuse_square ;    This is declaration statement (terminated with a semicolon, again).  Each statement declares a variable with its corresponding type ( int  here).  We gave each variable a name, here we call the variable  hypotenuse_square .  Remember that  all variables must be declared with its corresponding type before used in C .  In C, a function must be either defined or declared before used as well.  In the example above, we define  square  before  main .  If we switch the order of the two, the compiler will complain.  Unless we declare the function first.  Declaring a function means that we simply state the return type, the name, and the parameters,  without  the body.",
            "title": "Variable Declaration"
        },
        {
            "location": "/05-first-c/index.html#assignment-statement",
            "text": "The next line of the code shows an example of an assignment statement.    1    hypotenuse_square   =   square ( 3 )   +   square ( 4 );    An assignment operator takes the form of:  1    left_hand_side   =   right_hand_side ;    The  left_hand_side  must be the name of a variable.  We first evaluate the  right_hand_side  of the assignment statement, find its value, then put the value into the variable named on the  left_hand_side .  Here, on the right-hand side, we call the function  square , which we defined earlier.  We call  square  with  arguments   3  and  4  respectively.   We use the operator  +  to add the two results together.  The right-hand side should give the value 25, which we then assign to the variable  hypotenuse_square .  Note that we use  =  equal sign for assignment, NOT for checking equality.  The C notation for checking for equality is  ==  (we will come back to this later).",
            "title": "Assignment Statement"
        },
        {
            "location": "/05-first-c/index.html#recap",
            "text": "Before we move on, let's recap some concepts:   A C program consists of functions, invoking each other.  Each function is defined by its returned type, followed by its name, its parameter(s) (within a pair of parenthesis) and its body (within a pair of curly brackets).    Each function must be defined or declared before it is used.    The function body consists of one or more statements.  We have seen assignment statements (using the  =  operator) and return statements, using  return  as the keyword.  Each variable must be declared before it is used.  A declaration starts with its type followed by its name.",
            "title": "Recap"
        },
        {
            "location": "/05-first-c/index.html#example-2",
            "text": "Let's change the program slightly, so that instead of computing the square of the hypotenuse, we compute the hypotenuse itself.  Recall that we said C provides a bunch of predefined functions, include  sqrt , which computes the square root of a given number.  Since a square root of a number is not necessarily an integer, we need to use a variable with a type that can store a real number.    To represent real numbers, we commonly use the type  float  (which is short for a floating point number -- named so due to how a real number is represented in bits).  A  float  type can store 32 bits.  To double the precision (64 bits), we can use the type  double .  A  long double  type can store either 80-bits or 128-bits, depending on implementation.  But which one does  sqrt  returns?  To find out the exact  specification  of a pre-defined function, we can consult the manual (or  man  for short) pages for the function.    If you type  man sqrt  on the command line (or place the cursor on  sqrt  in  vim  and type  K  in command mode), you will see that the  sqrt  method has the following specification:  1 double   sqrt ( double   x );    The  sqrt  function returns a  double  precision real number.  We can now modify the program above to the following:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16 double   sqrt ( double   x );   // not recommended  long   square ( long   x )   { \n   return   x * x ;  }  double   hypotenuse_of ( long   base ,   long   height )   { \n   return   sqrt ( square ( base )   +   square ( height ));  }  int   main ()   { \n   hypotenuse_of ( 3 ,   4 );  }    Note that the first line declares the function  sqrt , because we need to declare a function before it is used.  Since  sqrt  is pre-defined elsewhere, we do not have to supply the function body here.  Such practice of declaring a predefined function ourselves, however, is not recommended.  Different platform, compilers, libraries, may provide a different specification for the same function.  As such, it is better to use the declaration from the library that provides the predefined function itself.  A library usually provides one or more  header files , a set of files that contain function declarations, type definitions, and constant definitions.  In the case of  sqrt , its declaration is contained in a header file called  math.h .  To include this file, you add the line  #include   <math.h>  at the top of the program.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16 #include   <math.h>  long   square ( long   x )   { \n   return   x * x ;  }  double   hypotenuse_of ( long   base ,   long   height )   { \n   return   sqrt ( square ( base )   +   square ( height ));  }  int   main ()   { \n   hypotenuse_of ( 3 ,   4 );  }    You might notice the same line appear in the man page for  sqrt .  Thus, the man pages tell us which header file to include if you want to use a certain function.   File Extension  The convention for file extension for a C program is  .c  and for a C header file is  .h .  Even though you are allowed to name the files with any extension you like, you should stick to the convention so that it is clear to other tools/programmers what is the purpose of each file.",
            "title": "Example 2"
        },
        {
            "location": "/05-first-c/index.html#other-types-in-c",
            "text": "An  int  variable is usually 32-bits long.  If we only need 16 bits, we use the type  short int , or just  short .  If we only need 8-bits, we use the type  char  (short for character).  Note that in the above, I said an  int  is  usually  32 bits.  Remember (from  Unit 1  that a C program gets compiled into machine code for a specific CPU architecture.  The C standard only guarantees that an  int  is at least 16 bits.  Although most C compilers compile  int  to 32 bits, there is no guarantee!      If we need something more than an  int , we can use  long int , or just  long .  The C standard guarantees that a  long  is at least 32 bits.  Depending on the implementation, it sometimes compiled to 32-bits, sometimes 64-bits.  To get even longer, we can use the type  long long int , or just  long long , which is guaranteed to be at least 64 bits 1 .",
            "title": "Other Types in C"
        },
        {
            "location": "/05-first-c/index.html#signed-vs-unsigned",
            "text": "We have seen earlier that the same sequence of bits, if interpreted as signed or unsigned, would result in a different value.  By default, all types in C refer to signed types.  If you want a variable that holds only non-negative integers, you can add the keyword  unsigned  to the front of the type.  Doing so would mean that the range of values you can store in the variable is doubled, without adding more bits (since the bit used to present the + or - sign is no longer needed).    For instance, since we know that  square  can only return a non-zero integer, we can actually declare it as:  1\n2\n3\n4 unsigned   long   square ( long   x )   { \n   return   x * x ;  }     Unsigned Real Numbers?  There are no  unsigned  versions of  float  and  double .  To understand the reason, we have to go further into how floating points numbers are represented in bits.  That is a topic for another module.",
            "title": "Signed vs. Unsigned"
        },
        {
            "location": "/05-first-c/index.html#stdinth",
            "text": "Since the number of bits for  int ,  long , and  long long  could defer, in order to write a C program that is portable (i.e., works on different platforms, architecture, operating systems), we have two options:   Do not write a program that assumes a specific number of bits is used for a certain type, or  Use the type defined in the header file  stdint.h :  int8_t ,  uint8_t ,  int16_t ,  uint16_t ,  int32_t ,  uint32_t ,  int64_t ,  uint64_t .  The suffix  _t  is a convention to indicate that this is a customized type (more on this in later units).  The prefix  u  indicates that the type is an unsigned type.  The numbers  8 ,  16 ,  32 , and  64  indicate the number of bits for each type.  Thus,  uint32_t  is guaranteed to be of size 32 bits, and can hold unsigned integer values from  0 0  to  2^32-1 2^32-1 .",
            "title": "stdint.h"
        },
        {
            "location": "/05-first-c/index.html#problem-set-5",
            "text": "",
            "title": "Problem Set 5"
        },
        {
            "location": "/05-first-c/index.html#51",
            "text": "In the example above,  sqrt  is declared to take in a parameter of type  double  .  But the argument that we pass in is the sum of two  int , which is also an  int .   Would this result in an error?",
            "title": "5.1"
        },
        {
            "location": "/05-first-c/index.html#52",
            "text": "In the code above, you see the following line:  1 // not recommended    Find out what  //  means and what it is used for.",
            "title": "5.2"
        },
        {
            "location": "/05-first-c/index.html#53",
            "text": "Consider the following alternative definition of  square  1\n2\n3 ???   square ( uint16_t   x )   { \n     return   x * x ;  }    What should the return type of this  square  be, in order for the return type to be big enough to store all possible value for  x*x ?      Adding more  long  does not make the integer longer, i.e., there is no  long long long int .\u00a0 \u21a9",
            "title": "5.3"
        },
        {
            "location": "/06-cs1010-io/index.html",
            "text": "Unit 6: The CS1010 I/O Library\n\n\nOur first C program that computes the hypotenuse doesn't do much -- it simply computes \n\\sqrt(3^2 + 4^2)\n\\sqrt(3^2 + 4^2)\n.  The value to be computed is hard-coded, and the result computed is not displayed.\n\n\nTo make this program more general and useful, first, we need to compute the hypotenuse for any length of the base and the height of a right-angled triangle.  We cannot hard code the length in the program.   We should read these values from the users.  Second, we need to output the result of the computation to the users.  In other words, to make the program more general and useful, we need to add input and output, or I/O, functions.\n\n\nStandard Input and Standard Output\n\n\nBefore we talk about how to read input and display output, we have to first talk about where the input comes from and where the output goes to.\n\n\nIn UNIX-flavored operating systems, an input is read from an abstract channel called the \nstandard input\n, or \nstdin\n for short, and an output is sent to an abstract channel called the \nstandard output\n, or \nstdout\n for short.  \n\n\nThe fact that these channels are abstract is a powerful concept -- when we write our code, we do not have to worry about where the inputs come from and where the outputs go to.  It will depend on how the user runs our program.  Thus, it allows the users of our program the flexibility to control where the data comes from or goes to.\n\n\nFor instance, the standard input, by default, reads from the keyboard.  But the user can choose to read from a file, using the redirection \n<\n operator \nfrom the command line\n or from the output of another process, using the pipe \n|\n operator \nfrom the command line\n.  Similarly, the standard output, by default, writes to the terminal.  But the user can choose to write to a file using the redirection \n>\n operator \non the command line\n or to the input of another process, using the pipe \n|\n operator, again, on the command line when invoking the program.  You will see how cool these are later.  But for the purpose of C programming, it suffices to know for now that we only need to read from \nstdin\n and write to \nstdout\n in our code, and we let the users decide where they come from / go to.\n\n\nNo \nprintf\n and \nscanf\n (yet)\n\n\nIn almost all articles and textbooks on C that I have seen, the \nscanf\n and \nprintf\n functions are taught as the standard C library functions to perform the input and output respectively.  The function \nscanf\n, however, is tricky to use correctly and securely.  The function \nprintf\n comes with many nuances, such as remembering the different conversion specifiers and modifiers.  I would rather not teach you \nscanf\n and \nprintf\n at this stage.  As such, CS1010 is providing you a library to perform I/O -- the library provides a small set of essential functions to read and write \nlong\n values, \ndouble\n values, space-separated words, and lines of text. \n\n\nYou can find the documentation for the CS1010 I/O Library here.  We will see how to use the library to improve our hypotenuse computation program here.\n\n\nUsing the CS1010 I/O Library\n\n\nLet's modify our earlier program to now read the base and height from \nstdin\n, compute the hypotenuse, and print the results out to \nstdout\n.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n#include\n \n<math.h>\n\n\n#include\n \n\"cs1010.h\"\n\n\n\nlong\n \nsquare\n(\nlong\n \nx\n)\n \n\n{\n\n  \nreturn\n \nx\n*\nx\n;\n\n\n}\n\n\n\ndouble\n \nhypotenuse_of\n(\nlong\n \nbase\n,\n \nlong\n \nheight\n)\n \n\n{\n\n  \nreturn\n \nsqrt\n(\nsquare\n(\nbase\n)\n \n+\n \nsquare\n(\nheight\n));\n\n\n}\n\n\n\nint\n \nmain\n()\n \n\n{\n\n  \ndouble\n \nhypotenuse\n;\n\n  \nlong\n \nbase\n \n=\n \ncs1010_read_long\n();\n\n  \nlong\n \nheight\n \n=\n \ncs1010_read_long\n();\n\n  \nhypotenuse\n \n=\n \nhypotenuse_of\n(\nbase\n,\n \nheight\n);\n\n  \ncs1010_println_double\n(\nhypotenuse\n);\n\n\n}\n\n\n\n\n\n\n\nThe first change you see (on Line 2) is to include the file \ncs1010.h\n, which includes the declaration of functions provided by the library.  On Lines 17 and 18, we introduce two new \nlong\n variables named \nbase\n and \nheight\n, which we initialized with the returned value from \ncs1010_read_long()\n.  The function \ncs1010_read_long\n reads a \nlong\n value from \nstdin\n and returns the value.  For now, we assume that the inputs are correctly passed to the program.\n\n\nFinally, on Line 20, we print the resulting hypotenuse to \nstdout\n using the library function \ncs1010_println_double\n.  Note that there are two versions of functions to print a \ndouble\n value: \ncs1010_println_double\n and \ncs1010_print_double\n.  The one with \nprintln\n prints a new line character so that the text that got printed after appears in the next line.\n\n\nRefer to \nCS1010 Compilation Guide\n on how to compile a program that uses the CS1010 I/O library.\n\n\nNote that the \nmain\n function above can be written as a single statement without any state and assignment.  The resulting code, however, is not necessarily easier to understand.\n\n1\n2\n3\n4\nint\n \nmain\n()\n \n\n{\n\n  \ncs1010_println_double\n(\nhypotenuse_of\n(\ncs1010_read_long\n(),\n \ncs1010_read_long\n()));\n\n\n}",
            "title": "6. CS1010 I/O Lib"
        },
        {
            "location": "/06-cs1010-io/index.html#unit-6-the-cs1010-io-library",
            "text": "Our first C program that computes the hypotenuse doesn't do much -- it simply computes  \\sqrt(3^2 + 4^2) \\sqrt(3^2 + 4^2) .  The value to be computed is hard-coded, and the result computed is not displayed.  To make this program more general and useful, first, we need to compute the hypotenuse for any length of the base and the height of a right-angled triangle.  We cannot hard code the length in the program.   We should read these values from the users.  Second, we need to output the result of the computation to the users.  In other words, to make the program more general and useful, we need to add input and output, or I/O, functions.",
            "title": "Unit 6: The CS1010 I/O Library"
        },
        {
            "location": "/06-cs1010-io/index.html#standard-input-and-standard-output",
            "text": "Before we talk about how to read input and display output, we have to first talk about where the input comes from and where the output goes to.  In UNIX-flavored operating systems, an input is read from an abstract channel called the  standard input , or  stdin  for short, and an output is sent to an abstract channel called the  standard output , or  stdout  for short.    The fact that these channels are abstract is a powerful concept -- when we write our code, we do not have to worry about where the inputs come from and where the outputs go to.  It will depend on how the user runs our program.  Thus, it allows the users of our program the flexibility to control where the data comes from or goes to.  For instance, the standard input, by default, reads from the keyboard.  But the user can choose to read from a file, using the redirection  <  operator  from the command line  or from the output of another process, using the pipe  |  operator  from the command line .  Similarly, the standard output, by default, writes to the terminal.  But the user can choose to write to a file using the redirection  >  operator  on the command line  or to the input of another process, using the pipe  |  operator, again, on the command line when invoking the program.  You will see how cool these are later.  But for the purpose of C programming, it suffices to know for now that we only need to read from  stdin  and write to  stdout  in our code, and we let the users decide where they come from / go to.",
            "title": "Standard Input and Standard Output"
        },
        {
            "location": "/06-cs1010-io/index.html#no-printf-and-scanf-yet",
            "text": "In almost all articles and textbooks on C that I have seen, the  scanf  and  printf  functions are taught as the standard C library functions to perform the input and output respectively.  The function  scanf , however, is tricky to use correctly and securely.  The function  printf  comes with many nuances, such as remembering the different conversion specifiers and modifiers.  I would rather not teach you  scanf  and  printf  at this stage.  As such, CS1010 is providing you a library to perform I/O -- the library provides a small set of essential functions to read and write  long  values,  double  values, space-separated words, and lines of text.   You can find the documentation for the CS1010 I/O Library here.  We will see how to use the library to improve our hypotenuse computation program here.",
            "title": "No printf and scanf (yet)"
        },
        {
            "location": "/06-cs1010-io/index.html#using-the-cs1010-io-library",
            "text": "Let's modify our earlier program to now read the base and height from  stdin , compute the hypotenuse, and print the results out to  stdout .   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21 #include   <math.h>  #include   \"cs1010.h\"  long   square ( long   x )   { \n   return   x * x ;  }  double   hypotenuse_of ( long   base ,   long   height )   { \n   return   sqrt ( square ( base )   +   square ( height ));  }  int   main ()   { \n   double   hypotenuse ; \n   long   base   =   cs1010_read_long (); \n   long   height   =   cs1010_read_long (); \n   hypotenuse   =   hypotenuse_of ( base ,   height ); \n   cs1010_println_double ( hypotenuse );  }    The first change you see (on Line 2) is to include the file  cs1010.h , which includes the declaration of functions provided by the library.  On Lines 17 and 18, we introduce two new  long  variables named  base  and  height , which we initialized with the returned value from  cs1010_read_long() .  The function  cs1010_read_long  reads a  long  value from  stdin  and returns the value.  For now, we assume that the inputs are correctly passed to the program.  Finally, on Line 20, we print the resulting hypotenuse to  stdout  using the library function  cs1010_println_double .  Note that there are two versions of functions to print a  double  value:  cs1010_println_double  and  cs1010_print_double .  The one with  println  prints a new line character so that the text that got printed after appears in the next line.  Refer to  CS1010 Compilation Guide  on how to compile a program that uses the CS1010 I/O library.  Note that the  main  function above can be written as a single statement without any state and assignment.  The resulting code, however, is not necessarily easier to understand. 1\n2\n3\n4 int   main ()   { \n   cs1010_println_double ( hypotenuse_of ( cs1010_read_long (),   cs1010_read_long ()));  }",
            "title": "Using the CS1010 I/O Library"
        },
        {
            "location": "/07-arithmetic-ops/index.html",
            "text": "Unit 7: Arithmetic Operations\n\n\nYou have seen the \n+\n operator in the previous units.  You can use \n+\n to add two variables, a value and a variable, or two values:\n\n\n1\n2\n3\n4\n5\n6\nlong\n \na\n \n=\n \n1\n;\n\n\nlong\n \nb\n \n=\n \n2\n;\n\n\nlong\n \nc\n \n=\n \n3\n;\n\n\na\n \n=\n \nb\n \n+\n \nc\n;\n \n// add two variables\n\n\nb\n \n=\n \na\n \n+\n \n4\n;\n \n// add a variable to a value\n\n\nc\n \n=\n \n5\n \n+\n \n6\n;\n \n// add two values\n\n\n\n\n\n\n\nYou can also use \n+\n on values returned by functions:\n\n\n1\nhypotenuse\n \n=\n \nsqrt\n(\nsquare\n(\nbase\n)\n \n+\n \nsquare\n(\nheight\n));\n\n\n\n\n\n\n\nYou have also seen the multiplication operator \n*\n.  It can be used in the same way as the \n+\n operator.  Three other useful operators are:\n\n\n\n\n/\n - division (e.g., \ndouble half_x = x / 2;\n)\n\n\n-\n - subtraction (e.g., \nlong deducted = income - 100\n)\n\n\n%\n - modulo (e.g, \nlong last_digit = number % 10\n);\n\n\n\n\nThe \n+\n, \n-\n, \n*\n, and \n/\n operators work on both integer types (\nchar\n, \nshort\n, \nint\n, \nlong\n, \nlong long\n) and real numbers (\nfloat\n, \ndouble\n).  The module operator \n%\n works only on integer types.\n\n\nOperator Precedence\n\n\nWe can chain the operations together to form expressions such as:\n\n\n1\n2\n3\nlong\n \nb\n \n=\n \n10\n;\n\n\nlong\n \nc\n \n=\n \n2\n;\n\n\nlong\n \na\n \n=\n \nb\n \n+\n \n2\n \n*\n \nc\n \n/\n \n4\n;\n\n\n\n\n\n\n\nWhen we have multiple operations appearing, however, it becomes harder to trace the sequence of evaluation.  What is the value of \na\n after the three lines above are executed?\n\n\nC actually has well-defined rules to the order of evaluation for the operators: \n*\n, \n/\n, and \n%\n take precedence over \n+\n and \n-\n, and the operators are evaluated from left to right.  \n\n\nThus, in the example above, \na\n will be 11 instead of 6 after the execution.\n\n\nTo change the order of execution, we can add parenthesis to the expression.  For instance:\n\n\n1\n2\nlong\n \na\n \n=\n \n(\nb\n \n+\n \n2\n)\n \n*\n \nc\n \n/\n \n4\n;\n \n// 6\n\n\nlong\n \na\n \n=\n \nb\n \n+\n \n(\n2\n \n*\n \nc\n \n/\n \n4\n);\n \n// 11\n\n\n\n\n\n\n\nThe expression in the paranthesis will be evaluated first.  To make your code easier to understand, \nyou should add parenthesis even if the order of evaluation is from left to right\n to make the order of evaluation explicit.\n\n\nCompound Operators\n\n\nIt is common to modify the value of a variable and store new value back to the same variable.  For example,\n\n\n1\n2\nindex\n \n=\n \nindex\n \n+\n \n1\n;\n  \n// increment the variable index\n\n\nage\n \n=\n \nage\n \n*\n \n2\n;\n  \n// double the variable age\n\n\n\n\n\n\n\nC provides \ncompound operators\n that simplify the expressions above.  For example,\n\n\n1\n2\nindex\n \n+=\n \n1\n;\n\n\nage\n \n*=\n \n2\n;\n\n\n\n\n\n\n\nThe syntax for a compound operator is \nop=\n, where \nop\n can be \n+\n, \n-\n, \n*\n, \n/\n, \n%\n, or other binary operators.  The statement:\n\n\n1\na op= b;\n\n\n\n\n\n\nmodifies \na\n the same way as:\n\n\n1\na = a op b\n\n\n\n\n\n\nCommon Mistakes Using Arithmatic Operations\n\n\nIt is important to remember that, when arithmatic operations in C is performed on a sequence of bits, where the value that it can represent is limited and is determined by its type.  A common mistake for beginner programmers is to forget this fact and treat the arithmatic operations as the same as the ones seen in mathematics.  \n\n\nLet's look at two common gotchas.\n\n\nOverflow\n\n\nConsider the following code:\n\n\n1\n2\nuint8_t\n \nc\n \n=\n \n255\n;\n\n\nc\n \n+=\n \n1\n;\n\n\n\n\n\n\n\nWhat is the value of variable \nc\n after the operation above?\n\n\nHere, we are adding one to the value 255, so \nc\n must store the value 256, right?\n\n\nIt turns out that after the execution above, \nc\n contains the value 0.  The variable \nc\n is of the type \nuint8_t\n, which is the unsigned 8-bit integer.  Being 8-bit, the variable can store values from 0 to 255.  When we add 1 to 255, even though we get the result 256, mathematically, we cannot store 256 in \nc\n -- there is no enough bits!  In this case, the value stored is \"wrap around\", and we get the value 0 instead.\n\n\nInteger Division\n\n\nNow, let's consider the following code:\n\n\n1\ndouble\n \nhalf\n \n=\n \n3\n/\n2\n;\n\n\n\n\n\n\n\nWhat is the value of variable \nhalf\n after the operation above?\n\n\nIt got to be 1.5, right?  \n\n\nIt turns out that, after executing the code above, the value of \nhalf\n is 1.0.  \n\n\nTo understand this, first, let's see what happen when we assign a floating point number to an integer type:\n\n\n1\nint\n \nx\n \n=\n \n1.5\n;\n\n\n\n\n\n\n\nC truncates the floating number and only stores the integer part of the value, 1 in this case, in \nx\n.\n\n\nSecond, when we perform an arithmatic operation, the resulting value will be an integer if both values are integer types.  If one of the operands is a floating point number, the result will be a floating point number[^1].  \n\n\nSince 3 and 2 are both integers, the resulting value 1.5 are stored in an integer, which cause it to become 1.  We then store 1 into a \ndouble\n variable, causing the value of \nhalf\n to become \n1.0\n.\n\n\nBecause of this limitation, the operation \n/\n is sometimes also known as integer division when both operands are integers.  \n\n\nIn order to get the result 1.5 as expected, we can write either:\n\n1\ndouble\n \nhalf\n \n=\n \n3\n/\n2.0\n;\n\n\n\n\n\n\nor \n\n\n1\ndouble\n \nhalf\n \n=\n \n3\n/\n(\ndouble\n)\n2\n;\n\n\n\n\n\n\n\nThe second fix above explicitly convert the type, or \ncast\n the type of value 2 into a \ndouble\n.\n\n\n^1: The actual rules used by C, called \ninteger promotion\n and \nusual arithmatic conversion\n, are much more complex and are outside the scope of CS1010.  You should take a note of this, however, and in later part of your study or career, if you need to delve deep in writing or debugging C code, take a look at \nthis\n.",
            "title": "7. Arithmatic Ops"
        },
        {
            "location": "/07-arithmetic-ops/index.html#unit-7-arithmetic-operations",
            "text": "You have seen the  +  operator in the previous units.  You can use  +  to add two variables, a value and a variable, or two values:  1\n2\n3\n4\n5\n6 long   a   =   1 ;  long   b   =   2 ;  long   c   =   3 ;  a   =   b   +   c ;   // add two variables  b   =   a   +   4 ;   // add a variable to a value  c   =   5   +   6 ;   // add two values    You can also use  +  on values returned by functions:  1 hypotenuse   =   sqrt ( square ( base )   +   square ( height ));    You have also seen the multiplication operator  * .  It can be used in the same way as the  +  operator.  Three other useful operators are:   /  - division (e.g.,  double half_x = x / 2; )  -  - subtraction (e.g.,  long deducted = income - 100 )  %  - modulo (e.g,  long last_digit = number % 10 );   The  + ,  - ,  * , and  /  operators work on both integer types ( char ,  short ,  int ,  long ,  long long ) and real numbers ( float ,  double ).  The module operator  %  works only on integer types.",
            "title": "Unit 7: Arithmetic Operations"
        },
        {
            "location": "/07-arithmetic-ops/index.html#operator-precedence",
            "text": "We can chain the operations together to form expressions such as:  1\n2\n3 long   b   =   10 ;  long   c   =   2 ;  long   a   =   b   +   2   *   c   /   4 ;    When we have multiple operations appearing, however, it becomes harder to trace the sequence of evaluation.  What is the value of  a  after the three lines above are executed?  C actually has well-defined rules to the order of evaluation for the operators:  * ,  / , and  %  take precedence over  +  and  - , and the operators are evaluated from left to right.    Thus, in the example above,  a  will be 11 instead of 6 after the execution.  To change the order of execution, we can add parenthesis to the expression.  For instance:  1\n2 long   a   =   ( b   +   2 )   *   c   /   4 ;   // 6  long   a   =   b   +   ( 2   *   c   /   4 );   // 11    The expression in the paranthesis will be evaluated first.  To make your code easier to understand,  you should add parenthesis even if the order of evaluation is from left to right  to make the order of evaluation explicit.",
            "title": "Operator Precedence"
        },
        {
            "location": "/07-arithmetic-ops/index.html#compound-operators",
            "text": "It is common to modify the value of a variable and store new value back to the same variable.  For example,  1\n2 index   =   index   +   1 ;    // increment the variable index  age   =   age   *   2 ;    // double the variable age    C provides  compound operators  that simplify the expressions above.  For example,  1\n2 index   +=   1 ;  age   *=   2 ;    The syntax for a compound operator is  op= , where  op  can be  + ,  - ,  * ,  / ,  % , or other binary operators.  The statement:  1 a op= b;   modifies  a  the same way as:  1 a = a op b",
            "title": "Compound Operators"
        },
        {
            "location": "/07-arithmetic-ops/index.html#common-mistakes-using-arithmatic-operations",
            "text": "It is important to remember that, when arithmatic operations in C is performed on a sequence of bits, where the value that it can represent is limited and is determined by its type.  A common mistake for beginner programmers is to forget this fact and treat the arithmatic operations as the same as the ones seen in mathematics.    Let's look at two common gotchas.",
            "title": "Common Mistakes Using Arithmatic Operations"
        },
        {
            "location": "/07-arithmetic-ops/index.html#overflow",
            "text": "Consider the following code:  1\n2 uint8_t   c   =   255 ;  c   +=   1 ;    What is the value of variable  c  after the operation above?  Here, we are adding one to the value 255, so  c  must store the value 256, right?  It turns out that after the execution above,  c  contains the value 0.  The variable  c  is of the type  uint8_t , which is the unsigned 8-bit integer.  Being 8-bit, the variable can store values from 0 to 255.  When we add 1 to 255, even though we get the result 256, mathematically, we cannot store 256 in  c  -- there is no enough bits!  In this case, the value stored is \"wrap around\", and we get the value 0 instead.",
            "title": "Overflow"
        },
        {
            "location": "/07-arithmetic-ops/index.html#integer-division",
            "text": "Now, let's consider the following code:  1 double   half   =   3 / 2 ;    What is the value of variable  half  after the operation above?  It got to be 1.5, right?    It turns out that, after executing the code above, the value of  half  is 1.0.    To understand this, first, let's see what happen when we assign a floating point number to an integer type:  1 int   x   =   1.5 ;    C truncates the floating number and only stores the integer part of the value, 1 in this case, in  x .  Second, when we perform an arithmatic operation, the resulting value will be an integer if both values are integer types.  If one of the operands is a floating point number, the result will be a floating point number[^1].    Since 3 and 2 are both integers, the resulting value 1.5 are stored in an integer, which cause it to become 1.  We then store 1 into a  double  variable, causing the value of  half  to become  1.0 .  Because of this limitation, the operation  /  is sometimes also known as integer division when both operands are integers.    In order to get the result 1.5 as expected, we can write either: 1 double   half   =   3 / 2.0 ;    or   1 double   half   =   3 / ( double ) 2 ;    The second fix above explicitly convert the type, or  cast  the type of value 2 into a  double .  ^1: The actual rules used by C, called  integer promotion  and  usual arithmatic conversion , are much more complex and are outside the scope of CS1010.  You should take a note of this, however, and in later part of your study or career, if you need to delve deep in writing or debugging C code, take a look at  this .",
            "title": "Integer Division"
        },
        {
            "location": "/readings/index.html",
            "text": "Readings\n\n\nWhy C?\n\n\n\n\nLearn C programming and the rest will come, by Marty Jacobs\n\n\nThe Resurgence of C Programming, by Mark Barlow\n\n\nYou Can't Dig Upwards, by Evan Miller",
            "title": "Readings"
        },
        {
            "location": "/readings/index.html#readings",
            "text": "",
            "title": "Readings"
        },
        {
            "location": "/readings/index.html#why-c",
            "text": "Learn C programming and the rest will come, by Marty Jacobs  The Resurgence of C Programming, by Mark Barlow  You Can't Dig Upwards, by Evan Miller",
            "title": "Why C?"
        },
        {
            "location": "/style/index.html",
            "text": "",
            "title": "Coding Style"
        },
        {
            "location": "/unix/index.html",
            "text": "Accessing CS2030 Lab Programming Environment\n\n\nThe Environment\n\n\nThe school has created a VM (virtual machine) for CS2030, with hostname \ncs2030-i.comp.nus.edu.sg\n.  The VM is running CentOS, one of the Linux distributions.\nThis will be the official programming environment for CS2030 for all your lab assignments.\n\n\nI have created your accounts on the VM based on your SoC UNIX account.  You can login with your SoC UNIX username (not your NUSNET username, unless you intentionally set the two to be the same) and password.\n\n\nSSH\n\n\nFor UNIX-based OS\n\n\nIf you use either macOS, Windows 10 (requires \nLinux Subsystem on Windows\n), or Linux, you should have the command line \nssh\n installed.  \n\n\nRun:\n\n1\nssh <username>@cs2030-i.comp.nus.edu.sg\n\n\n\n\n\nReplace \n<username>\n with your SoC UNIX username, for instance, I would do:\n\n1\nssh ooiwt@cs2030-i.comp.nus.edu.sg\n\n\n\n\n\nAfter the command above, following the instructions on screen.  The first time you ever connect to \ncs2030-i.comp.nus.edu.sg\n, you will be warned that you are connecting to a previously unknown host.  Say \nyes\n, and you will be prompted with your SoC UNIX password.\n\n\nFor Windows 7 or 8 (or Windows 10 without Linux Subsystem)\n\n\nThe desktop computers in Programming Lab 6 (PL6) runs Windows 7.  If you are using these computers, or your own computers with older versions of Windows, you need to use programs like \nPuTTY\n to access the VM.\n\n\nAccessing \ncs2030-i\n from Outside SoC\n\n\nTHe VM can only be accessed from within the School of Computing networks.  If you want to access it from outside, there are two ways\n\n\nUsing SoC VPN\n\n\nOne way is to setup a Virtual Private Network (VPN) (See \ninstruction here\n).  The staff at \nhelpdesk@comp.nus.edu.sg\n or the IT helpdesk in COM1, Level 1, will be able to help with you setting up if needed.\n\n\nTunneling through Sunfire\n\n\nThe alternative is to use ssh tunnels.\n\n\nSoC's Sunfire (\nsunfire.comp.nus.edu.sg\n) is configured to allow your connection if it's originating from a local telco. (See \nmore details here\n.)  Since \nsunfire\n is situated within the School of Computing network, \nsunfire\n is able to access the VM.  This opens the possibility of connecting from your device (using an Internet connection from a local telco) to \nsunfire\n, and then from \nsunfire\n to the VM.\n\n\nThere are two ways to achieve this, and in both ways it appears to the CS2030 VM that Sunfire is the client.\n\n\nSSH Using Sunfire's Terminal\n\n\nConnect to Sunfire at \nsunfire.comp.nus.edu.sg\n via your favourite SSH client.  After logging in, run the command \nssh cs2030-i\n to connect to the CS2030 VM.  This effectively starts an SSH session to the VM from within your existing SSH session to Sunfire.  Refer to instructions below on how to connect via SSH.\n\n\nSSH Port Forwarding\n\n\nSSH has built-in support for local and remote port forwarding, and local port forwarding can be used to commect to the CS2030 VM.  Local port forwarding means that a port of the SSH client (your machine) is forwarded to the SSH server (\nsunfire\n), which opens a connection to a preset destination server (\ncs2030-i\n).  This method causes the CS2030 VM to seem as if it is hosted on a local port, e.g. \nlocalhost\n:\n2030\n, allowing you to use your favourite SCP program (e.g. \nFileZilla\n) to access the VM.\n\n\nTo use local port forwarding (from local port \n2030\n), connect to \nsunfire\n using \n\n1\nssh -L 2030:cs2030-i.comp.nus.edu.sg:22 <username>@sunfire.comp.nus.edu.sg\n\n\n\n\nThis command opens an SSH tunnel from port \n2030\n of your machine to port \n22\n (the default SSH port) of \ncs2030-i.comp.nus.edu.sg\n via \nsunfire\n.  After successful login, open a separate SSH (or SCP) connection from your machine to \nlocalhost\n:\n2030\n to access the VM.\n\n\nPuTTY\n supports SSH port forwarding, so this setup can also be used on Windows.\n\n\nBasic UNIX Commands\n\n\nOnce you logged into the VM, you will be prompted to enter a command with a prompt that looks like this:\n\n1\nhappytan@cs2030-i:~[xxx]$\n\n\n\n\nThis interface is provided by a UNIX shell -- not unlike \njshell\n, this shell sits in a loop and wait for users to enter a command, then it interprets and executes the command.  There are many versions of shells, the default shell for our VM is \nbash\n1\n.\n\n\nThe following is adapted for CS2030 from \nthe instructions created by Aaron Tan\n. Bugs are mine.\n  \n\n\nThe power of UNIX stems from the many commands it offers. The following are a few commonly used commands. This list is by no means exhaustive and you are urged to explore on your own. Note that UNIX commands are case-sensitive.\n\n\nIn the examples below, bold words are commands which you are expected to enter. All commands are to be entered after the UNIX (local or \nsunfire\n or \ncs2030-i\n) prompt of the form\n\n\n1\nhappytan@cs2030-i:~[xxx]$\n\n\n\n\n\n\n~\n indicates that you are currently in your home directory, \nxxx\n is a number indicating the number of commands that have been entered.  The following examples assumes that user \nhappytan\n is logged into cs2030-i; however you can do it on your local UNIX platform too.\n\n\nIt might be good to understand the directory structure in UNIX, a multi-user system. The directory tree is shown below:\n\n\n\n\nEach user has his/her own home directory, which is where he/she will be automatically placed when he/she logs into the system. The above figure shows where the home directory of user \nhappytan\n resides in the directory tree. The user \nhappytan\n may create files or directories in his/her home directory, but not elsewhere unless permission is given.\n\n\nDirectory commands\n\n\n\n\n\n\npwd\n: Print current Working Directory to show you which directory you are currently in\n\n1\n2\nhappytan@cs2030-i:~[xxx]$ pwd\n/home/h/happytan\n\n\n\n\n\n\n\n\n\nls\n: LiSt files in your current directory\n\n1\n2\nhappytan@cs2030-i:~[xxx]$ ls\nhappytan@cs2030-i:~[xxx]$\n\n\n\n\n   If you do not have any regular files in your home directory, as you should when you first login, you should immediately return to the shell prompt.  \n\n\n\n\n\n\n\n\nRule of Silence\nUNIX follows the \nrule of silence\n: programs should not print unnecessary output, to allow other programs and users to easily parse the output from one program.  So, if \nls\n has nothing to list, it will list nothing (as oppose to, say, printing \"This is an empty directory.\")\n\n\n\n\n\n\n\n\n\n\nmkdir\n: MaKe a subDIRectory in current directory\n\n1\n2\n3\n4\n5\nhappytan@cs2030-i:~[xxx]$ mkdir lab01\nhappytan@cs2030-i:~[xxx]$ ls\nlab01\nhappytan@cs2030-i:~[xxx]$ ls -F\nlab01/\n\n\n\n\nHere, you create a directory called \nlab01\n.  Now, when you \nls\n, you can see the directory listed.\nYou may also use \nls -F\n for more information (\n-F\n is one of the many \noptions\n/\nflags\n available for the \nls\n command. To see a complete list of the options, refer to the man pages, i.e., \nman ls\n.)\n\n\nThe slash \n/\n beside the filename tells you that the file is a directory (aka folder in Windows lingo). A normal file does not have a slash beside its name when \"ls -F\" is used.\n\n\nYou may also use the \nls -l\n command (hyphen el, not hyphen one) to display almost all the file information, include the size of the file and the date of modification.\n\n\n\n\n\n\n\n\nCommand history\n\n\nUNIX maintains a history of your previously executed UNIX commands, and you may use the up and down arrows to go through it. Press the up arrow until you find a previously executed UNIX command. You may then press Enter to execute it, or edit the command before executing it. This is handy when you need to repeatedly executed a long UNIX command.\n\n\n\n\n\n\n\n\ncd\n: Change Directory from current directory to another\n\n1\n2\nhappytan@cs2030-i:~[xxx]$ cd lab01\nhappytan@cs2030-i:~/lab01[xxx]$\n\n\n\n\nNote that the prompt changes to \n~/lab01\n to indicate that you are now in the \nlab01\n directory below your \nHOME\n directory.\n\n\nEntering \ncd\n alone brings you back to your \nHOME\n directory, i.e.,. the directory in which you started with when you first logged into the system.\n\n1\n2\nhappytan@cs2030-i:~/lab01[xxx]$ cd\nhappytan@cs2030-i:~[xxx]$\n\n\n\n\n\n\n\n\n\nrmdir\n:  to ReMove a subDIRectory in current directory -- note that a directory must be empty before it can be removed.\n\n1\n2\n3\n4\n5\nhappytan@cs2030-i:~[xxx]$ rmdir lab01\nhappytan@cs2030-i:~[xxx]$ ls -F\nhappytan@cs2030-i:~[xxx]$ mkdir lab01\nhappytan@cs2030-i:~[xxx]$ ls -F\nlab01/\n\n\n\n\n\n\n\n\n\nFile commands\n\n\n\n\ncp\n:  CoPy files\n\n1\n2\n3\nhappytan@cs2030-i:~/lab01[xxx]$ cp ~cs2030/lab01/Circle.java .\nhappytan@cs2030-i:~/lab01[xxx]$ ls\nCircle.java\n\n\n\n\nThe command above copy the files Circle.java from the HOME of user \ncs2030\n, under directory \nlab01\n, to the current directory.\n\n\n\n\nIf you want to copy the whole directory, use \n-r\n flag, where \nr\n stands for recursive copy.\n\n\n1\nhappytan@cs2030-i:~/lab01[xxx]$ cp -r ~cs2030/lab01 .\n\n\n\n\n\n\nThe directory \nlab01\n and everything under it will be copied.\n\n\n\n\nmv\n: MoVe files from one directory to another; can also be used to rename files.\n\n1\n2\n3\nhappytan@cs2030-i:~/lab01[xxx]$ mv Circle.java Test.java\nhappytan@cs2030-i:~/lab01[xxx]$ ls\nTest.java\n\n\n\n\n\n\n\n\n\nFilename completion\n\n\nIf you have a very long file name, you may use UNIX's filename completion feature to reduce typing. For instance, you may type:\n\n1\nhappytan@cs2030-i:~/lab01[xxx]$ mv C\n\n\n\n\nand press the tab key, and UNIX will complete the filename for you if there is only one filename with the prefix \"C\". Otherwise, it will fill up the filename up to point where you need to type in more characters for disambiguation.\n\n\n\n\n\n\nrm\n: ReMove files. Be careful with this command -- files deleted cannot be restored (unless they have been backed up during the normal backup cycle).\n\n1\n2\n3\n4\nhappytan@cs2030-i:~/lab01[xxx]$ rm Test.java\nrm: remove 'Test.java'? y\nhappytan@cs2030-i:~/lab01[xxx]$ ls\nhappytan@cs2030-i:~/lab01[xxx]$\n\n\n\n\n\n\n\nCommand to display text files\n\n\n\n\ncat\n: to string together or display (CATenate) the contents of files onto the screen\n\n1\nhappytan@cs2030-i:~/lab01[xxx]$ cat Circle.java\n\n\n\n\n\nless\n - variant of \ncat\n (includes features to read each page leisurely)\n\n1\nhappytan@cs2030-i:~/lab01[xxx]$ less Circle.java\n\n\n\n\nIn \nless\n, use \n<space>\n to move down one page, \nb\n to move Back up one page, and \nq\n to Quit from \"less\".\n\n\n\n\nAn online help facility is available in UNIX via the \nman\n command (\nman\n stands for MANual). To look for more information about any UNIX command, for example, \nls\n, type \nman ls\n. Type \nman man\n and refer to Man Pages to find out more about the facility. To exit \nman\n, press \nq\n.\n\n\nNow that you are familiar with how the UNIX shell works, I won't show the command prompt any more in the rest of this article.\n\n\nUNIX File Permission\n\n\nIt is important to guide our files properly on a multi-user system where users share the same file system.  UNIX has a simple mechanism to for ensuring that: every file and directory has nine bits of access permission, corresponds to three access operations, read (\nr\n), write (\nw\n), and execute (\nx\n), for four classes of users, the user who owns of the file (\nu\n), users in the same group as the owner (\ng\n), all other users (\no\n), and all users (\na\n) (union of all three classes before)\n\n\nWhen you run \nls -l\n, you will see the permission encoded as strings that look like \n-rw-------\n or \ndrwx--x--x\n besides other file information.   \n\n\n\n\nThe first character indicates if the file is a directory (\nd\n) or not (\n-\n).  \n\n\nThe next three characters are the permission for the owner.  \nrwx\n means that the owner can do all three: reading, writing, and executing, \nrw-\n means that the owner can read and write, but cannot execute.\n\n\nThe next three characters are the permission for the users in the same group.\n\n\nThe last three characters are the permission for the users in the other groups.\n\n\n\n\nTo change permission, we use the \nchmod\n command.  Let's say that we want to remove the read and write permission from all other users in the group.  You can run:\n\n1\nchmod g-rw <file>\n\n\n\n\n\nwhere \n<file>\n is the name of the file whose permission you want to change.  This would change the permission from \n-rw-rw-rw-\n to \n-rw----rw-\n, or from \n-rwxr--r--\n to \n-rwx---r--\n.\n\n\nTo add executable permission to everyone, you can run:\n\n1\nchmod a+x <file>\n\n\n\n\n\nThis would change the permission from \n-rw-rw-rw-\n to \n-rwx--xrwx\n, or from \n-rwxr--r--\n to \n-rwx--xr-x\n, and so on.  You get the idea.\n\n\nAnother way to change the permission is set the permission directly, instead of adding with \n+\n and removing with \n-\n.  To do this, one convenient way is to treat the permission for each class of user as a 3-bit binary number between 0 to 7.  So, \nrwx\n is 7, \nrw-\n is 6, \n-w-\n is 2, \n---\n is 0, etc.  \n\n\nTo set the permission of a file to \n-r--r--r--\n (readable by everyone), run:\n\n1\nchmod 444 <file>\n\n\n\n\n\nTo set the permission to \n-rw-------\n, run:\n\n1\nchmod 600 <file>\n\n\n\n\n\nand so on.\n\n\nIt is important to ensure that your code is not readable and writable by other students, especially for graded lab exercises.\n\n\nSecure Copy (\nscp\n)\n\n\nSecure copy, or \nscp\n, is one way to transfer files from your local computer to \ncs2030-i\n.  If you choose not to use \nemacs\n or \nvim\n2\n and write your code on \ncs2030-i\n, you can write your code on your local computer, and transfer them.  Let's say that you are in the directory with a bunch of java files you want to transfer, and you want them transferred into directory \ntest\n that you have created, do the following:\n\n\n1\nscp *.java happytan@cs2030-i:~/test\n\n\n\n\n\n\n\n\nWarning\n\n\nIf you have files with the same name in the remote directory, the files will be overwritten without warning.  I have lost my code a few times due to \nscp\n.  \n\n\n\n\nThe expression \n*.java\n is a regular expression that means all files with filename ending with \n.java\n.  You can copy specific files as well.  For instance,\n\n\n1\nscp Circle.java Point.java happytan@cs2030-i:~/test\n\n\n\n\n\n\nscp\n supports \n-r\n (recursive copy) as well.\n\n\nSetting up SSH Keys\n\n\nOnce you are comfortable with UNIX, you can set up a pair of public/private keys for authentication.  \n\n\nYou can use\n\n1\nssh-keygen -t rsa\n\n\n\n\n\nto generate a pair of keys on your local computer.  Keep the private key \nid_rsa\n on your local machine in the hidden \n~/.ssh\n directory, and copy the public key \nid_rsa.pub\n to your home directory on VM \ncs2030-i\n.  On \ncs2030-i\n, run\n\n1\ncat id_rsa.pub >> ~/.ssh/authorized_keys\n\n\n\n\n\nMake sure that the permission for \n.ssh\n both on local machine and on VM is set to \n700\n and the files \nid_rsa\n on local machine and \nauthorized_keys\n on remote machine is set to \n600\n.  Once setup, you need not enter your password every time you run \nssh\n or \nscp\n.  \n\n\n\n\n\n\n\n\n\n\nI run \nfish\n on my macOS, as you might have noticed during the in-class demos.  You can use any shell you like, if you know what you are doing.  Otherwise, \nbash\n is a popular one.\u00a0\n\u21a9\n\n\n\n\n\n\nMy personal opinion is that, you should really master one of these two time-tested source code editor if you want a career in software development.\u00a0\n\u21a9",
            "title": "UNIX"
        },
        {
            "location": "/unix/index.html#accessing-cs2030-lab-programming-environment",
            "text": "",
            "title": "Accessing CS2030 Lab Programming Environment"
        },
        {
            "location": "/unix/index.html#the-environment",
            "text": "The school has created a VM (virtual machine) for CS2030, with hostname  cs2030-i.comp.nus.edu.sg .  The VM is running CentOS, one of the Linux distributions.\nThis will be the official programming environment for CS2030 for all your lab assignments.  I have created your accounts on the VM based on your SoC UNIX account.  You can login with your SoC UNIX username (not your NUSNET username, unless you intentionally set the two to be the same) and password.",
            "title": "The Environment"
        },
        {
            "location": "/unix/index.html#ssh",
            "text": "",
            "title": "SSH"
        },
        {
            "location": "/unix/index.html#for-unix-based-os",
            "text": "If you use either macOS, Windows 10 (requires  Linux Subsystem on Windows ), or Linux, you should have the command line  ssh  installed.    Run: 1 ssh <username>@cs2030-i.comp.nus.edu.sg   Replace  <username>  with your SoC UNIX username, for instance, I would do: 1 ssh ooiwt@cs2030-i.comp.nus.edu.sg   After the command above, following the instructions on screen.  The first time you ever connect to  cs2030-i.comp.nus.edu.sg , you will be warned that you are connecting to a previously unknown host.  Say  yes , and you will be prompted with your SoC UNIX password.",
            "title": "For UNIX-based OS"
        },
        {
            "location": "/unix/index.html#for-windows-7-or-8-or-windows-10-without-linux-subsystem",
            "text": "The desktop computers in Programming Lab 6 (PL6) runs Windows 7.  If you are using these computers, or your own computers with older versions of Windows, you need to use programs like  PuTTY  to access the VM.",
            "title": "For Windows 7 or 8 (or Windows 10 without Linux Subsystem)"
        },
        {
            "location": "/unix/index.html#accessing-cs2030-i-from-outside-soc",
            "text": "THe VM can only be accessed from within the School of Computing networks.  If you want to access it from outside, there are two ways",
            "title": "Accessing cs2030-i from Outside SoC"
        },
        {
            "location": "/unix/index.html#using-soc-vpn",
            "text": "One way is to setup a Virtual Private Network (VPN) (See  instruction here ).  The staff at  helpdesk@comp.nus.edu.sg  or the IT helpdesk in COM1, Level 1, will be able to help with you setting up if needed.",
            "title": "Using SoC VPN"
        },
        {
            "location": "/unix/index.html#tunneling-through-sunfire",
            "text": "The alternative is to use ssh tunnels.  SoC's Sunfire ( sunfire.comp.nus.edu.sg ) is configured to allow your connection if it's originating from a local telco. (See  more details here .)  Since  sunfire  is situated within the School of Computing network,  sunfire  is able to access the VM.  This opens the possibility of connecting from your device (using an Internet connection from a local telco) to  sunfire , and then from  sunfire  to the VM.  There are two ways to achieve this, and in both ways it appears to the CS2030 VM that Sunfire is the client.",
            "title": "Tunneling through Sunfire"
        },
        {
            "location": "/unix/index.html#ssh-using-sunfires-terminal",
            "text": "Connect to Sunfire at  sunfire.comp.nus.edu.sg  via your favourite SSH client.  After logging in, run the command  ssh cs2030-i  to connect to the CS2030 VM.  This effectively starts an SSH session to the VM from within your existing SSH session to Sunfire.  Refer to instructions below on how to connect via SSH.",
            "title": "SSH Using Sunfire's Terminal"
        },
        {
            "location": "/unix/index.html#ssh-port-forwarding",
            "text": "SSH has built-in support for local and remote port forwarding, and local port forwarding can be used to commect to the CS2030 VM.  Local port forwarding means that a port of the SSH client (your machine) is forwarded to the SSH server ( sunfire ), which opens a connection to a preset destination server ( cs2030-i ).  This method causes the CS2030 VM to seem as if it is hosted on a local port, e.g.  localhost : 2030 , allowing you to use your favourite SCP program (e.g.  FileZilla ) to access the VM.  To use local port forwarding (from local port  2030 ), connect to  sunfire  using  1 ssh -L 2030:cs2030-i.comp.nus.edu.sg:22 <username>@sunfire.comp.nus.edu.sg  \nThis command opens an SSH tunnel from port  2030  of your machine to port  22  (the default SSH port) of  cs2030-i.comp.nus.edu.sg  via  sunfire .  After successful login, open a separate SSH (or SCP) connection from your machine to  localhost : 2030  to access the VM.  PuTTY  supports SSH port forwarding, so this setup can also be used on Windows.",
            "title": "SSH Port Forwarding"
        },
        {
            "location": "/unix/index.html#basic-unix-commands",
            "text": "Once you logged into the VM, you will be prompted to enter a command with a prompt that looks like this: 1 happytan@cs2030-i:~[xxx]$  \nThis interface is provided by a UNIX shell -- not unlike  jshell , this shell sits in a loop and wait for users to enter a command, then it interprets and executes the command.  There are many versions of shells, the default shell for our VM is  bash 1 .  The following is adapted for CS2030 from  the instructions created by Aaron Tan . Bugs are mine.     The power of UNIX stems from the many commands it offers. The following are a few commonly used commands. This list is by no means exhaustive and you are urged to explore on your own. Note that UNIX commands are case-sensitive.  In the examples below, bold words are commands which you are expected to enter. All commands are to be entered after the UNIX (local or  sunfire  or  cs2030-i ) prompt of the form  1 happytan@cs2030-i:~[xxx]$   ~  indicates that you are currently in your home directory,  xxx  is a number indicating the number of commands that have been entered.  The following examples assumes that user  happytan  is logged into cs2030-i; however you can do it on your local UNIX platform too.  It might be good to understand the directory structure in UNIX, a multi-user system. The directory tree is shown below:   Each user has his/her own home directory, which is where he/she will be automatically placed when he/she logs into the system. The above figure shows where the home directory of user  happytan  resides in the directory tree. The user  happytan  may create files or directories in his/her home directory, but not elsewhere unless permission is given.",
            "title": "Basic UNIX Commands"
        },
        {
            "location": "/unix/index.html#directory-commands",
            "text": "pwd : Print current Working Directory to show you which directory you are currently in 1\n2 happytan@cs2030-i:~[xxx]$ pwd\n/home/h/happytan     ls : LiSt files in your current directory 1\n2 happytan@cs2030-i:~[xxx]$ ls\nhappytan@cs2030-i:~[xxx]$  \n   If you do not have any regular files in your home directory, as you should when you first login, you should immediately return to the shell prompt.       Rule of Silence UNIX follows the  rule of silence : programs should not print unnecessary output, to allow other programs and users to easily parse the output from one program.  So, if  ls  has nothing to list, it will list nothing (as oppose to, say, printing \"This is an empty directory.\")      mkdir : MaKe a subDIRectory in current directory 1\n2\n3\n4\n5 happytan@cs2030-i:~[xxx]$ mkdir lab01\nhappytan@cs2030-i:~[xxx]$ ls\nlab01\nhappytan@cs2030-i:~[xxx]$ ls -F\nlab01/  \nHere, you create a directory called  lab01 .  Now, when you  ls , you can see the directory listed.\nYou may also use  ls -F  for more information ( -F  is one of the many  options / flags  available for the  ls  command. To see a complete list of the options, refer to the man pages, i.e.,  man ls .)  The slash  /  beside the filename tells you that the file is a directory (aka folder in Windows lingo). A normal file does not have a slash beside its name when \"ls -F\" is used.  You may also use the  ls -l  command (hyphen el, not hyphen one) to display almost all the file information, include the size of the file and the date of modification.     Command history  UNIX maintains a history of your previously executed UNIX commands, and you may use the up and down arrows to go through it. Press the up arrow until you find a previously executed UNIX command. You may then press Enter to execute it, or edit the command before executing it. This is handy when you need to repeatedly executed a long UNIX command.     cd : Change Directory from current directory to another 1\n2 happytan@cs2030-i:~[xxx]$ cd lab01\nhappytan@cs2030-i:~/lab01[xxx]$  \nNote that the prompt changes to  ~/lab01  to indicate that you are now in the  lab01  directory below your  HOME  directory.  Entering  cd  alone brings you back to your  HOME  directory, i.e.,. the directory in which you started with when you first logged into the system. 1\n2 happytan@cs2030-i:~/lab01[xxx]$ cd\nhappytan@cs2030-i:~[xxx]$     rmdir :  to ReMove a subDIRectory in current directory -- note that a directory must be empty before it can be removed. 1\n2\n3\n4\n5 happytan@cs2030-i:~[xxx]$ rmdir lab01\nhappytan@cs2030-i:~[xxx]$ ls -F\nhappytan@cs2030-i:~[xxx]$ mkdir lab01\nhappytan@cs2030-i:~[xxx]$ ls -F\nlab01/",
            "title": "Directory commands"
        },
        {
            "location": "/unix/index.html#file-commands",
            "text": "cp :  CoPy files 1\n2\n3 happytan@cs2030-i:~/lab01[xxx]$ cp ~cs2030/lab01/Circle.java .\nhappytan@cs2030-i:~/lab01[xxx]$ ls\nCircle.java  \nThe command above copy the files Circle.java from the HOME of user  cs2030 , under directory  lab01 , to the current directory.   If you want to copy the whole directory, use  -r  flag, where  r  stands for recursive copy.  1 happytan@cs2030-i:~/lab01[xxx]$ cp -r ~cs2030/lab01 .   The directory  lab01  and everything under it will be copied.   mv : MoVe files from one directory to another; can also be used to rename files. 1\n2\n3 happytan@cs2030-i:~/lab01[xxx]$ mv Circle.java Test.java\nhappytan@cs2030-i:~/lab01[xxx]$ ls\nTest.java     Filename completion  If you have a very long file name, you may use UNIX's filename completion feature to reduce typing. For instance, you may type: 1 happytan@cs2030-i:~/lab01[xxx]$ mv C  \nand press the tab key, and UNIX will complete the filename for you if there is only one filename with the prefix \"C\". Otherwise, it will fill up the filename up to point where you need to type in more characters for disambiguation.    rm : ReMove files. Be careful with this command -- files deleted cannot be restored (unless they have been backed up during the normal backup cycle). 1\n2\n3\n4 happytan@cs2030-i:~/lab01[xxx]$ rm Test.java\nrm: remove 'Test.java'? y\nhappytan@cs2030-i:~/lab01[xxx]$ ls\nhappytan@cs2030-i:~/lab01[xxx]$",
            "title": "File commands"
        },
        {
            "location": "/unix/index.html#command-to-display-text-files",
            "text": "cat : to string together or display (CATenate) the contents of files onto the screen 1 happytan@cs2030-i:~/lab01[xxx]$ cat Circle.java   less  - variant of  cat  (includes features to read each page leisurely) 1 happytan@cs2030-i:~/lab01[xxx]$ less Circle.java  \nIn  less , use  <space>  to move down one page,  b  to move Back up one page, and  q  to Quit from \"less\".   An online help facility is available in UNIX via the  man  command ( man  stands for MANual). To look for more information about any UNIX command, for example,  ls , type  man ls . Type  man man  and refer to Man Pages to find out more about the facility. To exit  man , press  q .  Now that you are familiar with how the UNIX shell works, I won't show the command prompt any more in the rest of this article.",
            "title": "Command to display text files"
        },
        {
            "location": "/unix/index.html#unix-file-permission",
            "text": "It is important to guide our files properly on a multi-user system where users share the same file system.  UNIX has a simple mechanism to for ensuring that: every file and directory has nine bits of access permission, corresponds to three access operations, read ( r ), write ( w ), and execute ( x ), for four classes of users, the user who owns of the file ( u ), users in the same group as the owner ( g ), all other users ( o ), and all users ( a ) (union of all three classes before)  When you run  ls -l , you will see the permission encoded as strings that look like  -rw-------  or  drwx--x--x  besides other file information.      The first character indicates if the file is a directory ( d ) or not ( - ).    The next three characters are the permission for the owner.   rwx  means that the owner can do all three: reading, writing, and executing,  rw-  means that the owner can read and write, but cannot execute.  The next three characters are the permission for the users in the same group.  The last three characters are the permission for the users in the other groups.   To change permission, we use the  chmod  command.  Let's say that we want to remove the read and write permission from all other users in the group.  You can run: 1 chmod g-rw <file>   where  <file>  is the name of the file whose permission you want to change.  This would change the permission from  -rw-rw-rw-  to  -rw----rw- , or from  -rwxr--r--  to  -rwx---r-- .  To add executable permission to everyone, you can run: 1 chmod a+x <file>   This would change the permission from  -rw-rw-rw-  to  -rwx--xrwx , or from  -rwxr--r--  to  -rwx--xr-x , and so on.  You get the idea.  Another way to change the permission is set the permission directly, instead of adding with  +  and removing with  - .  To do this, one convenient way is to treat the permission for each class of user as a 3-bit binary number between 0 to 7.  So,  rwx  is 7,  rw-  is 6,  -w-  is 2,  ---  is 0, etc.    To set the permission of a file to  -r--r--r--  (readable by everyone), run: 1 chmod 444 <file>   To set the permission to  -rw------- , run: 1 chmod 600 <file>   and so on.  It is important to ensure that your code is not readable and writable by other students, especially for graded lab exercises.",
            "title": "UNIX File Permission"
        },
        {
            "location": "/unix/index.html#secure-copy-scp",
            "text": "Secure copy, or  scp , is one way to transfer files from your local computer to  cs2030-i .  If you choose not to use  emacs  or  vim 2  and write your code on  cs2030-i , you can write your code on your local computer, and transfer them.  Let's say that you are in the directory with a bunch of java files you want to transfer, and you want them transferred into directory  test  that you have created, do the following:  1 scp *.java happytan@cs2030-i:~/test    Warning  If you have files with the same name in the remote directory, the files will be overwritten without warning.  I have lost my code a few times due to  scp .     The expression  *.java  is a regular expression that means all files with filename ending with  .java .  You can copy specific files as well.  For instance,  1 scp Circle.java Point.java happytan@cs2030-i:~/test   scp  supports  -r  (recursive copy) as well.",
            "title": "Secure Copy (scp)"
        },
        {
            "location": "/unix/index.html#setting-up-ssh-keys",
            "text": "Once you are comfortable with UNIX, you can set up a pair of public/private keys for authentication.    You can use 1 ssh-keygen -t rsa   to generate a pair of keys on your local computer.  Keep the private key  id_rsa  on your local machine in the hidden  ~/.ssh  directory, and copy the public key  id_rsa.pub  to your home directory on VM  cs2030-i .  On  cs2030-i , run 1 cat id_rsa.pub >> ~/.ssh/authorized_keys   Make sure that the permission for  .ssh  both on local machine and on VM is set to  700  and the files  id_rsa  on local machine and  authorized_keys  on remote machine is set to  600 .  Once setup, you need not enter your password every time you run  ssh  or  scp .        I run  fish  on my macOS, as you might have noticed during the in-class demos.  You can use any shell you like, if you know what you are doing.  Otherwise,  bash  is a popular one.\u00a0 \u21a9    My personal opinion is that, you should really master one of these two time-tested source code editor if you want a career in software development.\u00a0 \u21a9",
            "title": "Setting up SSH Keys"
        },
        {
            "location": "/vim/index.html",
            "text": "Vim Tips\n\n\nI collected below some tips on \nvim\n that I find helpful.\n\n\nConfiguration\n\n\nYou can configure your \nvim\n by putting your configuration options and scripts in the \n~/.vimrc\n file (a hidden file named \n.vimrc\n in your home directory).  This file will be loaded whenever you starts \nvim\n.\n\n\nHelp\n\n\nIn \nvim,\n the command \n:help <topic>\n shows help about a particular topic in \nvim\n.  Example, \n:help backup\n.\n\n\nBackup Files\n\n\nYou can ask \nvim\n to automatically backup files that you edit.  This has been a life saver for me in multiple  occasions.\n\n\nIn your \n~/.vimrc\n file, \n\n\n1\nset backup=on\n\n\n\n\n\n\nwill cause a copy of your file to be save with suffix \n~\n appended to its name everytime you save.\n\n\nI prefer not to clutter my working directory, so I set\n\n\n1\nset backupdir=~/.backup\n\n\n\n\n\n\nand create a directory named \n~/.backup\n to store my backup files.\n\n\nThe settings above are the default in your \ncs2030-i\n account.  So if you made changes to a file that you regreted on \ncs2030-i\n, or if accidentally deleted a file, you can check under \n~/.backup\n to see if the backup can save you.\n\n\nUndo\n\n\nSince we are on the topic of correcting mistakes, \nu\n in command mode undo your changes.  Prefix it with a number \nn\nn\n to undo \nn\nn\n times.  If you regreted your undo, \n<CTRL-R>\n will redo.\n\n\nSyntax Highlighting\n\n\nIf for some reasons, syntax highlighting is not on by default, add this to your \n~/.vimrc\n:\n\n\n1\nsyntax on\n\n\n\n\n\n\nRuler and Numbers\n\n\nIf you prefer to show the line number you are on and the column number you are on, adding the commands to \n~/.vimrc\n\n\n1\nset ruler\n\n\n\n\n\n\nwill display the line number and the column number on the lower right corner.  \n\n\nYou can also add\n\n1\nset number\n\n\n\n\n\nto label each line with a line number.\n\n\nJumping to a Line\n\n\nIf the compiler tells you there is an error on Line \nx\nx\n, you can issue \n:<x>\n to jump to Line \nx\nx\n.  For instance, \n:40\n will go to Line 40.\n\n\nNavigation\n\n\n\n\nw\n   jump to the beginning of the next word\n\n\nb\n   jump to the beginning of the previous word (reverse of \nw\n)\n\n\ne\n   jump to the end of the word (or next word when pressed again)\n\n\nf\n + char: search forward in the line and sit on the next matching char\n\n\nt\n + char:  search forward in the line and sit on one space before the matching char\n\n\n jump forward half page\n\n\n jump backward half page\n\n\n$\n jump to end of line\n\n\n0\n jump to the beginning of the line\n\n\n%\n jump between matching parentheses\n\n\n\n\nNavigation + Editing\n\n\nvim\n is powerful because you can combine \noperations\n with \nnavigation\n.  For instance \nc\n to change, \nd\n to delete, \ny\n to yank (copy).  Since \nw\n is the navigation command to move over the current word, combining them we get:\n\n\n\n\ncw\n change the current word (delete the current word and enter insert mode)\n\n\ndw\n delete the current word\n\n\nyw\n yank the current word (copy word into buffer)\n\n\n\n\nCan you guess what \ndf)\n, \ndt)\n, \nc$\n, \ny0\n do?\n\n\nIf you repeat the operation \nc\n, \nd\n, and \ny\n, it applies to the whole line, so:\n\n\n\n\ncc\n change the whole line\n\n\ndd\n delete the whole line\n\n\nyy\n yank the whole line\n\n\n\n\nYou can add a number before an operation to specify how many times you want to repeat an operation.  So \n5dd\n deletes 5 lines, \n5dw\n deletes 5 words, etc.\n\n\nSee the article \nOperator, the True Power of \nVim\n for more details.\n\n\nOther Editing Operations\n\n\n\n\nA\n jump to end of line and enter insert mode\n\n\no\n open next line and enter insert mode\n\n\nO\n open previous line and enter insert mode\n\n\n\n\nSearch and Replace in \nvim\n\n\n1\n:%s/oldWord/newWord/gc \n\n\n\n\n\n\n:\n enters the command mode.  \n%\n means apply to the whole document, \ns\n means substitute, \ng\n means global (otherwise, only the first occurance of each line is replaced). \nc\n is optional -- adding it cause \nvim\n to confirm with you before each replacement  \n\n\nCommenting blocks of code\n\n\nSometimes we need to comment out a whole block of code in Java for testing purposes. There are several ways to do it in \nvim\n:\n\n\n\n\nPlace the cursor on the first line of the block of code you want to comment.\n\n\n0\n to jump to the beginning of the line\n\n\nV\n enter visual mode\n\n\nUse arrow key to select the block of code you want to comment. \n\n\nI\n to insert at the beginning of the line (here, since we already selected the block, we will insert at the beginning of every selected)\n\n\n//\n to insert the Java comment character (you will see it inserted in the current line, but don't worry)\n\n\n to escape from the visual code.\n\n\n\n\nTo uncomment, \n\n\n\n\nPlace the cursor on the first line of the block of code you want to comment.\n\n\n0\n to jump to the beginning of the line\n\n\n<CTRL-v>\n enter block visual mode\n\n\nUse arrow key to select the columns of text containing \n//\n\n\nx\n to delete them\n\n\n\n\nShell Command\n\n\nIf you need to issue a shell command quickly, you don't have to exit \nvim\n, run the command, and launch \nvim\n again.  You can use \n!\n, \n\n\n1\n:!<command>\n\n\n\n\n\n\nwill issue the command to shell.  E.g.,\n\n\n1\n:!ls\n\n\n\n\n\n\nYou can use this to compile your current file, without exiting \nvim\n.\n\n\n1\n:!javac %\n\n\n\n\n\n\nAbbreviation\n\n\nYou can use the command \nab\n to abbreviate frequently typed commands.  E.g., in your \n~/.vimrc\n, \n\n\n1\nab Sop System.out.println(\"\n\n\n\n\n\n\nNow, when you type \nSop\n, it will be expanded into \nSystem.out.println(\"\n\n\nAuto-Completion\n\n\nYou can \n<CTRL-P>\n to auto-complete.  By default, the auto-complete dictionary is based on text in your current editing buffers.  This is a very useful keystroke saver for long function and variable names.\n\n\nAuto-Indent the Whole File\n\n\nYou can \ngg=G\n in command mode to auto-indent the whole file.  \ngg\n is the command to go to the beginning of the file.  \n=\n is the command to indent.  \nG\n is the command to go to the end of the file.\n\n\nSwapping Lines\n\n\nSometimes you want to swap the order of two lines of code, in command mode, \nddp\n will do the trick.  \ndd\n deletes the current line, \np\n paste it after the current line, in effect swapping the order of the two lines.\n\n\nGoto File\n\n\nPlace your cursor on the name of a class (e.g., \nEvent\n), then in command mode, issue the \ngf\n command (goto file).  \nvim\n will open \nEvent.java\n.  You can set the \npath\n to load files from directories other than the current directory.   \"Ctrl-^\" will get out and back to the previous file.\n\n\nSyntax and Style Checker\n\n\nI use \nsyntastic\n to check for style and syntax whenever I save a file.  \nsyntastic\n is a \nvim\n plugin. \n\n\nMy \n.vimrc\n configuration file contains the following:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n\"For syntastic\nset laststatus=2\nset statusline+=%#warningmsg#\nset statusline+=%{SyntasticStatuslineFlag()}\nset statusline+=%*\n\nlet g:syntastic_always_populate_loc_list = 1\nlet g:syntastic_auto_loc_list = 1\nlet g:syntastic_check_on_open = 1\nlet g:syntastic_check_on_wq = 0\nlet g:syntastic_java_checkers = [ \"checkstyle\", \"javac\" ]\nlet g:syntastic_java_checkstyle_classpath = \"~cs2030/bin/checkstyle-8.2-all.jar\"\nlet g:syntastic_java_checkstyle_conf_file = \"~cs2030/bin/cs2030_checks.xml\"\n\n\n\n\n\n\nThe last two lines refer to \ncheckstyle\n tool and its configuration file available from \n~cs2030/bin\n on the host \ncs2030-i.comp.nus.edu.sg\n.\n\n\nSplitting \nvim\n's Viewport\n\n\n\n\n:sp file.java\n splits the \nvim\n window horizontally\n\n\n:vsp file.java\n splits the \nvim\n window vertically\n\n\nCtrl-w Ctrl-w\n moves between the different \nvim\n viewports",
            "title": "Vim"
        },
        {
            "location": "/vim/index.html#vim-tips",
            "text": "I collected below some tips on  vim  that I find helpful.",
            "title": "Vim Tips"
        },
        {
            "location": "/vim/index.html#configuration",
            "text": "You can configure your  vim  by putting your configuration options and scripts in the  ~/.vimrc  file (a hidden file named  .vimrc  in your home directory).  This file will be loaded whenever you starts  vim .",
            "title": "Configuration"
        },
        {
            "location": "/vim/index.html#help",
            "text": "In  vim,  the command  :help <topic>  shows help about a particular topic in  vim .  Example,  :help backup .",
            "title": "Help"
        },
        {
            "location": "/vim/index.html#backup-files",
            "text": "You can ask  vim  to automatically backup files that you edit.  This has been a life saver for me in multiple  occasions.  In your  ~/.vimrc  file,   1 set backup=on   will cause a copy of your file to be save with suffix  ~  appended to its name everytime you save.  I prefer not to clutter my working directory, so I set  1 set backupdir=~/.backup   and create a directory named  ~/.backup  to store my backup files.  The settings above are the default in your  cs2030-i  account.  So if you made changes to a file that you regreted on  cs2030-i , or if accidentally deleted a file, you can check under  ~/.backup  to see if the backup can save you.",
            "title": "Backup Files"
        },
        {
            "location": "/vim/index.html#undo",
            "text": "Since we are on the topic of correcting mistakes,  u  in command mode undo your changes.  Prefix it with a number  n n  to undo  n n  times.  If you regreted your undo,  <CTRL-R>  will redo.",
            "title": "Undo"
        },
        {
            "location": "/vim/index.html#syntax-highlighting",
            "text": "If for some reasons, syntax highlighting is not on by default, add this to your  ~/.vimrc :  1 syntax on",
            "title": "Syntax Highlighting"
        },
        {
            "location": "/vim/index.html#ruler-and-numbers",
            "text": "If you prefer to show the line number you are on and the column number you are on, adding the commands to  ~/.vimrc  1 set ruler   will display the line number and the column number on the lower right corner.    You can also add 1 set number   to label each line with a line number.",
            "title": "Ruler and Numbers"
        },
        {
            "location": "/vim/index.html#jumping-to-a-line",
            "text": "If the compiler tells you there is an error on Line  x x , you can issue  :<x>  to jump to Line  x x .  For instance,  :40  will go to Line 40.",
            "title": "Jumping to a Line"
        },
        {
            "location": "/vim/index.html#navigation",
            "text": "w    jump to the beginning of the next word  b    jump to the beginning of the previous word (reverse of  w )  e    jump to the end of the word (or next word when pressed again)  f  + char: search forward in the line and sit on the next matching char  t  + char:  search forward in the line and sit on one space before the matching char   jump forward half page   jump backward half page  $  jump to end of line  0  jump to the beginning of the line  %  jump between matching parentheses",
            "title": "Navigation"
        },
        {
            "location": "/vim/index.html#navigation-editing",
            "text": "vim  is powerful because you can combine  operations  with  navigation .  For instance  c  to change,  d  to delete,  y  to yank (copy).  Since  w  is the navigation command to move over the current word, combining them we get:   cw  change the current word (delete the current word and enter insert mode)  dw  delete the current word  yw  yank the current word (copy word into buffer)   Can you guess what  df) ,  dt) ,  c$ ,  y0  do?  If you repeat the operation  c ,  d , and  y , it applies to the whole line, so:   cc  change the whole line  dd  delete the whole line  yy  yank the whole line   You can add a number before an operation to specify how many times you want to repeat an operation.  So  5dd  deletes 5 lines,  5dw  deletes 5 words, etc.  See the article  Operator, the True Power of  Vim  for more details.",
            "title": "Navigation + Editing"
        },
        {
            "location": "/vim/index.html#other-editing-operations",
            "text": "A  jump to end of line and enter insert mode  o  open next line and enter insert mode  O  open previous line and enter insert mode",
            "title": "Other Editing Operations"
        },
        {
            "location": "/vim/index.html#search-and-replace-in-vim",
            "text": "1 :%s/oldWord/newWord/gc    :  enters the command mode.   %  means apply to the whole document,  s  means substitute,  g  means global (otherwise, only the first occurance of each line is replaced).  c  is optional -- adding it cause  vim  to confirm with you before each replacement",
            "title": "Search and Replace in vim"
        },
        {
            "location": "/vim/index.html#commenting-blocks-of-code",
            "text": "Sometimes we need to comment out a whole block of code in Java for testing purposes. There are several ways to do it in  vim :   Place the cursor on the first line of the block of code you want to comment.  0  to jump to the beginning of the line  V  enter visual mode  Use arrow key to select the block of code you want to comment.   I  to insert at the beginning of the line (here, since we already selected the block, we will insert at the beginning of every selected)  //  to insert the Java comment character (you will see it inserted in the current line, but don't worry)   to escape from the visual code.   To uncomment,    Place the cursor on the first line of the block of code you want to comment.  0  to jump to the beginning of the line  <CTRL-v>  enter block visual mode  Use arrow key to select the columns of text containing  //  x  to delete them",
            "title": "Commenting blocks of code"
        },
        {
            "location": "/vim/index.html#shell-command",
            "text": "If you need to issue a shell command quickly, you don't have to exit  vim , run the command, and launch  vim  again.  You can use  ! ,   1 :!<command>   will issue the command to shell.  E.g.,  1 :!ls   You can use this to compile your current file, without exiting  vim .  1 :!javac %",
            "title": "Shell Command"
        },
        {
            "location": "/vim/index.html#abbreviation",
            "text": "You can use the command  ab  to abbreviate frequently typed commands.  E.g., in your  ~/.vimrc ,   1 ab Sop System.out.println(\"   Now, when you type  Sop , it will be expanded into  System.out.println(\"",
            "title": "Abbreviation"
        },
        {
            "location": "/vim/index.html#auto-completion",
            "text": "You can  <CTRL-P>  to auto-complete.  By default, the auto-complete dictionary is based on text in your current editing buffers.  This is a very useful keystroke saver for long function and variable names.",
            "title": "Auto-Completion"
        },
        {
            "location": "/vim/index.html#auto-indent-the-whole-file",
            "text": "You can  gg=G  in command mode to auto-indent the whole file.   gg  is the command to go to the beginning of the file.   =  is the command to indent.   G  is the command to go to the end of the file.",
            "title": "Auto-Indent the Whole File"
        },
        {
            "location": "/vim/index.html#swapping-lines",
            "text": "Sometimes you want to swap the order of two lines of code, in command mode,  ddp  will do the trick.   dd  deletes the current line,  p  paste it after the current line, in effect swapping the order of the two lines.",
            "title": "Swapping Lines"
        },
        {
            "location": "/vim/index.html#goto-file",
            "text": "Place your cursor on the name of a class (e.g.,  Event ), then in command mode, issue the  gf  command (goto file).   vim  will open  Event.java .  You can set the  path  to load files from directories other than the current directory.   \"Ctrl-^\" will get out and back to the previous file.",
            "title": "Goto File"
        },
        {
            "location": "/vim/index.html#syntax-and-style-checker",
            "text": "I use  syntastic  to check for style and syntax whenever I save a file.   syntastic  is a  vim  plugin.   My  .vimrc  configuration file contains the following:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13 \"For syntastic\nset laststatus=2\nset statusline+=%#warningmsg#\nset statusline+=%{SyntasticStatuslineFlag()}\nset statusline+=%*\n\nlet g:syntastic_always_populate_loc_list = 1\nlet g:syntastic_auto_loc_list = 1\nlet g:syntastic_check_on_open = 1\nlet g:syntastic_check_on_wq = 0\nlet g:syntastic_java_checkers = [ \"checkstyle\", \"javac\" ]\nlet g:syntastic_java_checkstyle_classpath = \"~cs2030/bin/checkstyle-8.2-all.jar\"\nlet g:syntastic_java_checkstyle_conf_file = \"~cs2030/bin/cs2030_checks.xml\"   The last two lines refer to  checkstyle  tool and its configuration file available from  ~cs2030/bin  on the host  cs2030-i.comp.nus.edu.sg .",
            "title": "Syntax and Style Checker"
        },
        {
            "location": "/vim/index.html#splitting-vims-viewport",
            "text": ":sp file.java  splits the  vim  window horizontally  :vsp file.java  splits the  vim  window vertically  Ctrl-w Ctrl-w  moves between the different  vim  viewports",
            "title": "Splitting vim's Viewport"
        },
        {
            "location": "/clang/index.html",
            "text": "CS1010 Compilation Guide\n\n\n1. Compile a standalone C program\n\n\nSuppose we have a standalone C program \nteh.c\n that does not use any external libraries.  We can compile the program using the command\n\n\n1\nhappytan@host:~[xxx]$ clang teh.c\n\n\n\n\n\n\nThis command should create an executable called \na.out\n in the current directory, which you can then run with:\n\n\n1\nhappytan@host:~[xxx]$ ./a.out\n\n\n\n\n\n\n2. Renaming executable file\n\n\nThe name \na.out\n is an abbreviation for \nassembler output\n, a name that many compilers kept as the default output name since the 60s.  We should, however, give our executable more descriptive name, by using the \n-o\n flag.  (\no\n is the mnemonic for output).\n\n\n1\nhappytan@host:~[xxx]$ clang teh.c -o teh\n\n\n\n\n\n\nor\n\n\n1\nhappytan@host:~[xxx]$ clang -o teh teh.c\n\n\n\n\n\n\nThe command above would create an executable called \nteh\n.\n\n\n\n\nBeware of the order\n\n\nIf you are not careful and run the following command instead:\n\n1\nhappytan@host:~[xxx]$ clang -o teh.c teh\n\n\n\n\n\nclang\n would overwrite your code \nteh.c\n -- all your hard work will be gone!!\n\n\n\n\n3. Warning for possible bugs.\n\n\nThe \nclang\n checks for syntax errors in your C files -- i.e., things that violate the C syntax rules.  The compiler, however, is smart enough to identify possible bugs -- errors that will cause your program to behave incorrectly, even if the syntax follows C's rules.  You can ask \nclang\n to warn you about this, using the \n-W\n flag (\nW\n is the mnemonic for warning -- note the capital W).  The manual for \nclang\n lists different types of warnings that \nclang\n can warn you about.  For simplicity, we will ask \nclang\n to warn us about everything, by enabling \nall\n warnings.  The command to do so is:\n\n\n1\nhappytan@host:~[xxx]$ clang -Wall teh.c -o teh\n\n\n\n\n\n\nFor beginners, it is \nhighly recommended\n that you \nalways\n compile with \n-Wall\n flag.\n\n\n4. Generating additional information for debugging.\n\n\nIn order to use the debugger \nlldb\n to trace through and debug your program, \nclang\n needs to generate additional information and store them in the executable file.  We can instruct \nclang\n to generate them with the flag \n-g\n (\ng\n for \ng**enerate or debu**g\n).  \n\n\n1\nhappytan@host:~[xxx]$ clang -Wall -g teh.c -o teh\n\n\n\n\n\n\nIt is recommended that you always compile with \n-g\n flags during development phase.  If you need to measure the performance (e.g., how fast it runs) of your program or when you are releasing the program to the public, you can remove the \n-g\n flag and compile with the optimization flags (e.g., \n-O\n) instead.  \n\n\n5. Linking with standard library.\n\n\nTo link with a standard library, we use the \n-l\n flag to specify the name of the library to link.  For instance, to link with the C standard math library (abbreviated \nm\n), you issue the command:\n\n\n1\nhappytan@host:~[xxx]$ clang -Wall -g teh.c -o teh -lm",
            "title": "CLang"
        },
        {
            "location": "/clang/index.html#cs1010-compilation-guide",
            "text": "",
            "title": "CS1010 Compilation Guide"
        },
        {
            "location": "/clang/index.html#1-compile-a-standalone-c-program",
            "text": "Suppose we have a standalone C program  teh.c  that does not use any external libraries.  We can compile the program using the command  1 happytan@host:~[xxx]$ clang teh.c   This command should create an executable called  a.out  in the current directory, which you can then run with:  1 happytan@host:~[xxx]$ ./a.out",
            "title": "1. Compile a standalone C program"
        },
        {
            "location": "/clang/index.html#2-renaming-executable-file",
            "text": "The name  a.out  is an abbreviation for  assembler output , a name that many compilers kept as the default output name since the 60s.  We should, however, give our executable more descriptive name, by using the  -o  flag.  ( o  is the mnemonic for output).  1 happytan@host:~[xxx]$ clang teh.c -o teh   or  1 happytan@host:~[xxx]$ clang -o teh teh.c   The command above would create an executable called  teh .   Beware of the order  If you are not careful and run the following command instead: 1 happytan@host:~[xxx]$ clang -o teh.c teh   clang  would overwrite your code  teh.c  -- all your hard work will be gone!!",
            "title": "2. Renaming executable file"
        },
        {
            "location": "/clang/index.html#3-warning-for-possible-bugs",
            "text": "The  clang  checks for syntax errors in your C files -- i.e., things that violate the C syntax rules.  The compiler, however, is smart enough to identify possible bugs -- errors that will cause your program to behave incorrectly, even if the syntax follows C's rules.  You can ask  clang  to warn you about this, using the  -W  flag ( W  is the mnemonic for warning -- note the capital W).  The manual for  clang  lists different types of warnings that  clang  can warn you about.  For simplicity, we will ask  clang  to warn us about everything, by enabling  all  warnings.  The command to do so is:  1 happytan@host:~[xxx]$ clang -Wall teh.c -o teh   For beginners, it is  highly recommended  that you  always  compile with  -Wall  flag.",
            "title": "3. Warning for possible bugs."
        },
        {
            "location": "/clang/index.html#4-generating-additional-information-for-debugging",
            "text": "In order to use the debugger  lldb  to trace through and debug your program,  clang  needs to generate additional information and store them in the executable file.  We can instruct  clang  to generate them with the flag  -g  ( g  for  g**enerate or debu**g ).    1 happytan@host:~[xxx]$ clang -Wall -g teh.c -o teh   It is recommended that you always compile with  -g  flags during development phase.  If you need to measure the performance (e.g., how fast it runs) of your program or when you are releasing the program to the public, you can remove the  -g  flag and compile with the optimization flags (e.g.,  -O ) instead.",
            "title": "4. Generating additional information for debugging."
        },
        {
            "location": "/clang/index.html#5-linking-with-standard-library",
            "text": "To link with a standard library, we use the  -l  flag to specify the name of the library to link.  For instance, to link with the C standard math library (abbreviated  m ), you issue the command:  1 happytan@host:~[xxx]$ clang -Wall -g teh.c -o teh -lm",
            "title": "5. Linking with standard library."
        }
    ]
}