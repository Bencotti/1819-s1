# Assignment 5: Gameoflife, Maze, MagicSquare

### Deadline

19 October, 2018 (Friday), 6:00pm.

### Prerequisite

- You are able to access the [CS1010 programming environment](environments.md).
- You are familiar with [basic UNIX CLI](unix.md) and using terminal-based editor [`vim`](vim.md).
- You have gone through Exercise 1 and have already set up your `.gitconfig`.
- You are familiar with the steps of accepting, downloading, and submitting your exercise and assignment.
- You are familiar with the directory structure and the common files included in your assignment skeleton.

### Learning Outcomes

- Be comfortable writing C programs that involve arithmetic operations, `long`, `double`, `bool`, and `char` types, conditional `if`/`else` statements, loops with `while`/`for`/`do-while` statements, arrays, and strings.
- Be comfortable breaking down a problem into smaller subproblems which can be resolved using functions, including reusing existing functions written for other programs (with a tweak), writing a function that calls itself, designing what should the inputs and return values/types of a function be.

### Setup

- [Click on this link](https://classroom.github.com/a/yYcYzYid) to accept the assignment.
- Login to one of the hosts of [CS1010 programming environment](environments.md)
- Run:

```
~cs1010/get-as05
```

- You should see the folder `as05-<github id>` in your home directory with the assignment skeleton inside.

### Solving The Assignments

- Edit the files `gameoflife.c,maze.c,magicsquare.c`, to solve the corresponding question as described below.
- You should break down the problem into smaller subproblems, and write one function for each of the subproblem to solve the problem.  
- To compile and run tests with the sample inputs and outputs:

```
make
```

- The test cases are given in the `inputs` and `outputs` subdirectory.  You can use `cat` or `less` to look at the content of these test cases.  You can add more test cases or edit the given ones if needed.

### Submission

When you are ready, run the following command to submit:

```
~cs1010/submit-as05
```

The files `gameoflife.c,maze.c,magicsquare.c`, will be uploaded to GitHub.  You can submit multiple times, but only the last submission will be graded.

!!! warn "Editing Your Files in Multiple Locations"
    You should edit your code only on the CS1010 PE hosts.  If you choose to edit your code in other places, such as directly on Github or in a second location (such as your own laptop), you need to be comfortable with various `git` command to synchronize your code across the different locations, possibly needing to resolve synchronization conflicts.  

Only the C files listed above will be submitted.  You can create additional C files for testing different solutions, but eventually, you must put your solution into the corresponding C file provided as the skeleton.

### Identifying Yourself

In every C file that you submit to CS1010, you need to identify yourself by writing your name and tutorial group. Marks will be deducted if you fail to do so. You need to edit the line:

```
@author XXXX (Group YYYY)
```

and change it to something like:

```
@author Jean Luc Picard (Group 9)
```

### Grading

This assignment contributes towards 3% of your final grade.  The total mark for this assignment is 40 marks.  There are three marking criteria: correctness, documentation, and style.  

- Documentation: For each question, two marks are allocated for documentation.  Please refer to the [documentation](documentation.md) and follow the recommended format.  You need to explain the purpose of every file, function, and parameter.  Logic in your code that is not obvious should be explained as well.
- Style: For each question, two marks are allocated for style.  Please refer to the [CS1010 C Style Guide](style.md) and follow the recommended guideline.  
- Correctness: The rest of the marks are allocated to correctness.  Note that passing the tests does not guarantee that your code is correct.  Correctness here is defined in the broad sense of using the various programming constructs in C (type, function, variable, loops, conditionals, arithmetic expressions, logical expressions) _properly_, not just producing the correct output and bug-free.  

We reserve the right to penalize students for using banned C syntax in the assignments.  In addition, each grader at his or her own discretion can penalize students for repeating mistakes / bad practices from the student's past assignments (even if it was just a warning with no marks deducted in the earlier assignments).

## Question 1: Game of Life (10 marks)

Game of life is a game played on an infinite, two-dimensional orthogonal grid of square cells, while each cell has only 2 possible states: alive or dead. The game is played in iterations. During each iteration, each cell will become alive or dead, depending on state of its 4 neighbour cells in previous iteration. Interesting patterns and moving behaviour can be created, sometimes infinitely, from an initial state. Refer to [wiki page](https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life) for more details if you are interested. 

In this problem, we are going to simulate game of life for certain number of iterations, given a starting state. Here is a complete description of the rules
1. The universe is a bounded plane, and can be simply referred as a two dimensional orthogonal grid of square cells with n rows and n columns. For conveniece, we let row indexes as 0 to n-1 from top to bottom, and column indexes as 0 to n-1 from left to right. So in total there're n*n cells.
2. Neighbour of a cell is defined as the 8 cells either horizontall, vertically or diagonally connected to the cell
3. An intial state is given, with some cells alive while the others dead.
4. In each iteration, all cells will remain or switch their status, according to below rules by referring to the universe of previous iteration:
    * Any live cell with fewer than two live neighbors becomes dead
    * Any live cell with two or three live neighbors remains alive.
    * Any live cell with more than three live neighbors becomes dead.
    * Any dead cell with exactly three live neighbors becomes alive
    * **border cells, i.e. cells with row number 0 or n-1, or column number 0 or n-1, are always dead. This is to simplify and bound the universe**

You may verify the rules by checking how the pattern during each iteration in below image. The pattern is called glider and it will move indefinitely in one direction. Here shows status of 5 iterations only. The number in each cell denotes how many of its neibouring cells are alive. After 4 iterations, the glider moves 1 cell to the right and to the bottom. Here black filled cells are alive and white filled cells are dead in current iteration. A cell going to change from dead to alive is colored blue, a cell going to change from alive to dead has the digits inside colored red, and a cell remains alive in current and next iteration has the digits colored green.
![glider](figures/glider.png)
<small>[source](http://www.paleotechnologist.net/?p=451)<small>

Write a program `gameoflife`. It reads from standard inputs 2 integers n and k (3<=n<=100, 0<=k<=10000) in first row where n denotes the universe is a n*n grid, and k is the number of iterations to simulate. It then reads from standard inputs n rows, with n characters in each row representing the inital state. Each character is either alive ("#") or dead ("."). 

The program then prints, to standard output, the status of universe after k iterations. The output should only contains n rows with n characters in each row. Similarly use "#" to represent a live cell, and "." to represents a dead cell.

### Sample Run
```
ooiwt@pe119:~/as05-skeleton$ ./gameoflife
4 0
....
.##.
..#.
....
-------------------(separator only, input above and corresponding output below)
....
.##.
..#.
....
ooiwt@pe119:~/as05-skeleton$ ./gameoflife
4 1
....
.##.
..#.
....
-------------------(separator only, input above and corresponding output below)
....
.##.
.##.
....
ooiwt@pe119:~/as05-skeleton$ ./gameoflife
7 4
.......
..#....
...#...
.###...
.......
.......
.......
-------------------(separator only, input above and corresponding output below)
.......
.......
...#...
....#..
..###..
.......
.......
```

## Question 2: Maze (10 marks)

Robot Ali is lost in a maze! Luckily you can still remotely control him to escape.

The maze is simplified as a m*n grid of cells, where each cell can be of the following:
1. a segment of wall, denoted by character "#"
2. empty space, denoted by character "."
3. a trap, denoted by character "*"

For conveniece, we let row indexes as 0 to m-1 from top to bottom, and column indexes as 0 to n-1 from left to right. 
You are giving the order to Ali as a series of instructions denoted by "U","D","L" or "R". "U" means go to the cell 1 row above. "D" means go to the cell 1 row below. "L" means go to the cell 1 column to the left. "R" means go to the cell 1 column to the right. Note Ali follows all the instructions in the order they are given, and he only moves 1 cell adjacent by following each order, with below exceptions:
1. if the instruction leads Ali to a wall, he will be angry and stay in position, and continue with next order if there is
2. if the instruction leads Ali to a trap, he is trapped there and unable to move anymore. OOPS POOR ALI
3. if the instruction leads Ali to anywhere outside the maze, Ali escaped happily and any order after that is ignored

Write a program `maze`, that reads from standard input two integer m and n (3<=m,n<=100). Then reads from standard input m rows with n characters in each row. This denotes the maze of size m*n. Each character will only be "#", ".", "*" or "A" where "A" denotes initial position of Ali and it is an empty space. It is guaranteed only 1 "A" exists in the input. Then read one row of string denoting the order you give to Ali, and each character is only "U","D","L" or "R". Print to standard output one of the following:
1. if Ali escaped from the maze after following some instructions, print "ESCAPED!"
2. if Ali is trapped due to unwise instruction, print "TRAPPED!"
3. if Ali is still stuck in the maze but not trapped after following all the instructions, print the position of Ali as "(x, y)" where x and y denotes the row and column Ali is finally.

### Sample Run
```
ooiwt@pe119:~/as05-skeleton$ ./maze
3 3
...
.A#
.*.
RLU
(0,0)
ooiwt@pe119:~/as05-skeleton$ ./maze
3 3
...
.A#
.*.
RLUU
ESCAPED!
ooiwt@pe119:~/as05-skeleton$ ./maze
3 3
...
.A#
.*.
LLURL
ESCAPED!
ooiwt@pe119:~/as05-skeleton$ ./maze
3 3
...
.A#
.*.
UDDLUL
TRAPPED!
```

## Question 3: Magicsquare (10 marks)

A magic square is a grid of n*n with each cell filled with distinct number from 1 to n*n, such that the sum of each row, column or diagonal are all the same. Refer to below as an example of magic square with size 7*7. 

![magic square of size 7*7](figures/magicsquare.png)

<small>[source](http://www.dr-mikes-math-games-for-kids.com/magic-square-recipe.html)<small>

Now we do something simpler: construct a magic square of odd size (n*n). You shall follow method described below only.
1. At first, put 1 at center column of top row
2. All the other numbers are placed 1 row up and 1 column to the right of the previous number. This may have some problems, and you shall follow below rules to resolve them.
    * If a number's position is already taken, put it 1 row below the position of the previous number
    * If a number's position is above the top row, stay in that column and put it in the bottom row
    * If a number's position is outside of rightmost column, stay in that row and put it in the leftmost column
    * If the number's position is outside both a row and a column, put it 1 row below the previous number

Refering back to the sample 7*7 magic sqaure, it is actually constructed using the above described rule. You may find special case a is employed when filling number 8 and 43. Similarly special case b for number 2 and 11, special case c for number 5 and 13, and special case d for number 29.

Write a program `magicsquare`, that reads from standard input an integer n (1<=n<=99, and n is guaranteed to be odd). Print to standard output n rows with n numbers in each row, denoting the constructed magic square using above described method.

### Sample Run
```
ooiwt@pe119:~/as05-skeleton$ ./magicsquare
3
8 1 6
3 5 7
4 9 2
ooiwt@pe119:~/as05-skeleton$ ./magicsquare
7
30 39 48 1 10 19 28
38 47 7 9 18 27 29
46 6 8 17 26 35 37
5 14 16 25 34 36 45
13 15 24 33 42 44 4
21 23 32 41 43 3 12
22 31 40 49 2 11 20
```
