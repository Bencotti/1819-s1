{
    "docs": [
        {
            "location": "/index.html",
            "text": "CS1010\n\n\nWhat's New\n\n\nLecture 12\n\n\nIn this lecture, we will review what we have covered in CS1010 as well as to peak ahead to give you a teaser of CS2040C.  There is no notes for this lecture.\n\n\nAssignment 9: Digits\n\n\nLecture 11\n\n\n\n\nScreencast: \nPart 1 on struct\n\n\n\n\nIn this lecture, we discussed a few C specific topics: \nstruct\n, \ntypedef\n, \nprintf\n, and \nscanf\n.  We covered \nUnit 28\n and \nUnit 29\n.\n\n\nAssignment 7: Comments and Answer Keys\n\n\nAssignment 6: Comments and Answer Keys\n\n\nInformation on PE 2\n\n\nPE 1: Comments and Answer Keys\n\n\nYou should receive an email containing URLs containing feedback on your code for Q1 - Q3.  Email me if you did not receive it.\n\n\nAssignment 5: Comments and Answer Keys\n\n\nAssignment 8: Maze, Fill\n\n\nReleased 2 November 2018, 23:59pm, Due 9 November 2018, 23:59pm\n\n\nExercise 5: Square, Escape, MagicSquare\n\n\nReleased 31 October 2018\n\n\nTools: \nLLDB\n\n\nA brief tutorial on how to use \nlldb\n to debug\n\n\nPractical Exam 1\n\n\n\n\nQuestion Paper and Skeleton Code Posted.\n\n\n\n\n\n\nPiazza Q&A\n \n\n\nPiazza is the Q&A site for students and instructors to ask questions and discuss among each other on all matters related to CS1010.\n\n\n\n\nNotes and Lectures \n\n\nLecture 10\n\n\n\n\nSlides\n | \nScreencast\n\n\n\n\nIn this lecture, we discussed three classic recursive algorithms: the Tower of Hanoi (\nUnit 25\n), generating permutations (\nUnit 26\n) and the \nn\nn\n-Queens Problem (\nUnit 27\n).\n\n\nLecture 9\n\n\n\n\nScreencast\n\n\n\n\nIn this lecture, we will discuss three classic algorithms: binary search (in \nUnit 23\n) bubble sort, and insertion sort (both in \nUnit 24: Sorting\n).  Note: There are no slides.\n\n\nLecture 8\n\n\n\n\nSlides\n | \nScreencast\n\n\n\n\nIn this lecture, we introduced C pre-processing, the \nassert\n macros, and the notion of efficiency in algorithms.\n\n\nUnits covered are Units 20 - 22: \nUnit 20: C Pre-processing\n, \nUnit 21: Assert\n, \nUnit 22: Efficiency\n.\n\n\nLecture 7\n\n\n\n\nSlides\n | \nScreencast\n\n\n\n\nIn this lecture, we discussed how call-by-reference works in C, talked about memory allocation on the heap, and moved on the multi-dimensional arrays.\n\n\nUnits covered are Units 17 - 19: \nUnit 17: Call by Reference\n, \nUnit 18: Heap\n, \nUnit 19: Multi-Dimensional Arrays\n.\n\n\nLecture 6\n\n\n\n\nSlides\n | \nScreencast\n\n\n\n\nIn this lecture, we discussed how call stack works, giving more insights about how a C program is executed, particularly when we call a function and when a function returns.  We then discussed about pointers and arrays, ending with a brief introduction to strings as an array of \nchar\n.\n\n\nUnits covered are Units 13 - 16: \nUnit 13: Call Stack\n, \nUnit 14: Pointers\n, \nUnit 15: Arrays\n and \nUnit 16: Strings\n.\n\n\nLecture 5\n\n\n\n\nSlides\n | \nScreencast\n\n\n\n\nIn this lecture, we talked about how to write loops, followed by using assertions to reason about the behavior and logic of our programs.\n\n\nUnits covered are Units \n10 Assertions\n, \n11 Loops\n, and \n12 Reasoning About Loops\n.\n\n\nLecture 4\n\n\n\n\nSlides\n | \nScreencast\n | \nKahoot Quiz\n\n\n\n\nIn this lecture, we learned how to write programs that involve branching execution paths, using \nif\n-\nelse\n statements and logical expressions.  \nUnit 8 If-Else\n, \nUnit 9 Logical Expression\n were covered.\n\n\nLecture 3\n\n\n\n\nSlides\n | \nScreencast\n\n\n\n\nWe covered \nUnit 5: First C Program\n, \nUnit 6: CS1010 I/O Library\n and \nUnit 7: Arithmetic Operations\n.\n\n\nIn this lecture, we got started with writing simple C programs that read inputs, perform some calculations, and display the result.\n\n\nLecture 2\n\n\n\n\nSlides\n | \nScreencast\n\n\n\n\nWe covered \nUnit 3: functions\n and \nUnit 4: types\n.\n\n\nIn this lecture, we learned the concepts of functions, with which we can build up a more complex algorithm from smaller building blocks, such as finding the maximum.  We also learned about the concept of types.\n\n\nLecture 1\n\n\n\n\nSlides\n | \nScreencast\n (password posted on Piazza)\n\n\n\n\nAfter some admin matters, we introduced what is a program, what is meant by programming, and what is computational problem solving.\n\n\nWe covered \nUnit 1: What is a Program?\n and \nUnit 2: Computational Problems and Algorithms\n in the first lecture.\n\n\n\n\nProgramming Exercises\n\n\nExercises are ungraded programming questions for practicing on your own.\n\n\nExercise 4: ID, Grade, Index, Max\n\n\nReleased 20 September 2018\n\n\nExercise 3: Binary, Rectangle, Fibonacci, Prime\n\n\nReleased 13 September 2018\n\n\nExercise 2: Leap, Suffix, Days\n\n\nReleased 6 September 2018\n\n\nExercise 1: Freezer\n\n\nReleased 3 September 2018\n\n\n\n\nProgramming Assignments\n\n\nAssignment 7: Peak, Scripts, Inversion\n\n\nReleased 26 October 2018, Due 2 November 2018, 23:59pm.\n\n\nAssignment 6: Permutation 1 2 3\n\n\nReleased 19 October 2018, Due 26 October 2018, 23:59pm.\n\n\nAssignment 5: Social, Life\n\n\nReleased 12 October 2018, Due 19 October 2018, 6pm.\n\n\nAssignment 4: SelectionSort, Add, Mastermind\n\n\nReleased 5 October 2018, Due 12 October 2018, 6pm.\n\n\nAssignment 3: Kendall, Histogram, CountingSort\n\n\nReleased 21 September 2018, Due 5 October 2018, 6pm.\n\n\nAssignment 2: Collatz, Weekday, Circle, Pattern\n\n\nReleased 14 September 2018, Due 21 September 2018, 6pm.\n\n\nAssignment 1: Invest, Box, Digits, and Taxi\n\n\nReleased 7 September 2018, Due 14 September 2018, 6pm.",
            "title": "Home"
        },
        {
            "location": "/index.html#cs1010",
            "text": "",
            "title": "CS1010"
        },
        {
            "location": "/index.html#whats-new",
            "text": "",
            "title": "What's New"
        },
        {
            "location": "/index.html#lecture-12",
            "text": "In this lecture, we will review what we have covered in CS1010 as well as to peak ahead to give you a teaser of CS2040C.  There is no notes for this lecture.",
            "title": "Lecture 12"
        },
        {
            "location": "/index.html#assignment-9-digits",
            "text": "",
            "title": "Assignment 9: Digits"
        },
        {
            "location": "/index.html#lecture-11",
            "text": "Screencast:  Part 1 on struct   In this lecture, we discussed a few C specific topics:  struct ,  typedef ,  printf , and  scanf .  We covered  Unit 28  and  Unit 29 .",
            "title": "Lecture 11"
        },
        {
            "location": "/index.html#assignment-7-comments-and-answer-keys",
            "text": "",
            "title": "Assignment 7: Comments and Answer Keys"
        },
        {
            "location": "/index.html#assignment-6-comments-and-answer-keys",
            "text": "",
            "title": "Assignment 6: Comments and Answer Keys"
        },
        {
            "location": "/index.html#information-on-pe-2",
            "text": "",
            "title": "Information on PE 2"
        },
        {
            "location": "/index.html#pe-1-comments-and-answer-keys",
            "text": "You should receive an email containing URLs containing feedback on your code for Q1 - Q3.  Email me if you did not receive it.",
            "title": "PE 1: Comments and Answer Keys"
        },
        {
            "location": "/index.html#assignment-5-comments-and-answer-keys",
            "text": "",
            "title": "Assignment 5: Comments and Answer Keys"
        },
        {
            "location": "/index.html#assignment-8-maze-fill",
            "text": "Released 2 November 2018, 23:59pm, Due 9 November 2018, 23:59pm",
            "title": "Assignment 8: Maze, Fill"
        },
        {
            "location": "/index.html#exercise-5-square-escape-magicsquare",
            "text": "Released 31 October 2018",
            "title": "Exercise 5: Square, Escape, MagicSquare"
        },
        {
            "location": "/index.html#tools-lldb",
            "text": "A brief tutorial on how to use  lldb  to debug",
            "title": "Tools: LLDB"
        },
        {
            "location": "/index.html#practical-exam-1",
            "text": "Question Paper and Skeleton Code Posted.",
            "title": "Practical Exam 1"
        },
        {
            "location": "/index.html#piazza-qa",
            "text": "Piazza is the Q&A site for students and instructors to ask questions and discuss among each other on all matters related to CS1010.",
            "title": "Piazza Q&amp;A"
        },
        {
            "location": "/index.html#notes-and-lectures",
            "text": "",
            "title": "Notes and Lectures"
        },
        {
            "location": "/index.html#lecture-10",
            "text": "Slides  |  Screencast   In this lecture, we discussed three classic recursive algorithms: the Tower of Hanoi ( Unit 25 ), generating permutations ( Unit 26 ) and the  n n -Queens Problem ( Unit 27 ).",
            "title": "Lecture 10"
        },
        {
            "location": "/index.html#lecture-9",
            "text": "Screencast   In this lecture, we will discuss three classic algorithms: binary search (in  Unit 23 ) bubble sort, and insertion sort (both in  Unit 24: Sorting ).  Note: There are no slides.",
            "title": "Lecture 9"
        },
        {
            "location": "/index.html#lecture-8",
            "text": "Slides  |  Screencast   In this lecture, we introduced C pre-processing, the  assert  macros, and the notion of efficiency in algorithms.  Units covered are Units 20 - 22:  Unit 20: C Pre-processing ,  Unit 21: Assert ,  Unit 22: Efficiency .",
            "title": "Lecture 8"
        },
        {
            "location": "/index.html#lecture-7",
            "text": "Slides  |  Screencast   In this lecture, we discussed how call-by-reference works in C, talked about memory allocation on the heap, and moved on the multi-dimensional arrays.  Units covered are Units 17 - 19:  Unit 17: Call by Reference ,  Unit 18: Heap ,  Unit 19: Multi-Dimensional Arrays .",
            "title": "Lecture 7"
        },
        {
            "location": "/index.html#lecture-6",
            "text": "Slides  |  Screencast   In this lecture, we discussed how call stack works, giving more insights about how a C program is executed, particularly when we call a function and when a function returns.  We then discussed about pointers and arrays, ending with a brief introduction to strings as an array of  char .  Units covered are Units 13 - 16:  Unit 13: Call Stack ,  Unit 14: Pointers ,  Unit 15: Arrays  and  Unit 16: Strings .",
            "title": "Lecture 6"
        },
        {
            "location": "/index.html#lecture-5",
            "text": "Slides  |  Screencast   In this lecture, we talked about how to write loops, followed by using assertions to reason about the behavior and logic of our programs.  Units covered are Units  10 Assertions ,  11 Loops , and  12 Reasoning About Loops .",
            "title": "Lecture 5"
        },
        {
            "location": "/index.html#lecture-4",
            "text": "Slides  |  Screencast  |  Kahoot Quiz   In this lecture, we learned how to write programs that involve branching execution paths, using  if - else  statements and logical expressions.   Unit 8 If-Else ,  Unit 9 Logical Expression  were covered.",
            "title": "Lecture 4"
        },
        {
            "location": "/index.html#lecture-3",
            "text": "Slides  |  Screencast   We covered  Unit 5: First C Program ,  Unit 6: CS1010 I/O Library  and  Unit 7: Arithmetic Operations .  In this lecture, we got started with writing simple C programs that read inputs, perform some calculations, and display the result.",
            "title": "Lecture 3"
        },
        {
            "location": "/index.html#lecture-2",
            "text": "Slides  |  Screencast   We covered  Unit 3: functions  and  Unit 4: types .  In this lecture, we learned the concepts of functions, with which we can build up a more complex algorithm from smaller building blocks, such as finding the maximum.  We also learned about the concept of types.",
            "title": "Lecture 2"
        },
        {
            "location": "/index.html#lecture-1",
            "text": "Slides  |  Screencast  (password posted on Piazza)   After some admin matters, we introduced what is a program, what is meant by programming, and what is computational problem solving.  We covered  Unit 1: What is a Program?  and  Unit 2: Computational Problems and Algorithms  in the first lecture.",
            "title": "Lecture 1"
        },
        {
            "location": "/index.html#programming-exercises",
            "text": "Exercises are ungraded programming questions for practicing on your own.",
            "title": "Programming Exercises"
        },
        {
            "location": "/index.html#exercise-4-id-grade-index-max",
            "text": "Released 20 September 2018",
            "title": "Exercise 4: ID, Grade, Index, Max"
        },
        {
            "location": "/index.html#exercise-3-binary-rectangle-fibonacci-prime",
            "text": "Released 13 September 2018",
            "title": "Exercise 3: Binary, Rectangle, Fibonacci, Prime"
        },
        {
            "location": "/index.html#exercise-2-leap-suffix-days",
            "text": "Released 6 September 2018",
            "title": "Exercise 2: Leap, Suffix, Days"
        },
        {
            "location": "/index.html#exercise-1-freezer",
            "text": "Released 3 September 2018",
            "title": "Exercise 1: Freezer"
        },
        {
            "location": "/index.html#programming-assignments",
            "text": "",
            "title": "Programming Assignments"
        },
        {
            "location": "/index.html#assignment-7-peak-scripts-inversion",
            "text": "Released 26 October 2018, Due 2 November 2018, 23:59pm.",
            "title": "Assignment 7: Peak, Scripts, Inversion"
        },
        {
            "location": "/index.html#assignment-6-permutation-1-2-3",
            "text": "Released 19 October 2018, Due 26 October 2018, 23:59pm.",
            "title": "Assignment 6: Permutation 1 2 3"
        },
        {
            "location": "/index.html#assignment-5-social-life",
            "text": "Released 12 October 2018, Due 19 October 2018, 6pm.",
            "title": "Assignment 5: Social, Life"
        },
        {
            "location": "/index.html#assignment-4-selectionsort-add-mastermind",
            "text": "Released 5 October 2018, Due 12 October 2018, 6pm.",
            "title": "Assignment 4: SelectionSort, Add, Mastermind"
        },
        {
            "location": "/index.html#assignment-3-kendall-histogram-countingsort",
            "text": "Released 21 September 2018, Due 5 October 2018, 6pm.",
            "title": "Assignment 3: Kendall, Histogram, CountingSort"
        },
        {
            "location": "/index.html#assignment-2-collatz-weekday-circle-pattern",
            "text": "Released 14 September 2018, Due 21 September 2018, 6pm.",
            "title": "Assignment 2: Collatz, Weekday, Circle, Pattern"
        },
        {
            "location": "/index.html#assignment-1-invest-box-digits-and-taxi",
            "text": "Released 7 September 2018, Due 14 September 2018, 6pm.",
            "title": "Assignment 1: Invest, Box, Digits, and Taxi"
        },
        {
            "location": "/midterm/index.html",
            "text": "Midterm\n\n\nQuestion, Solution, Marking Scheme\n\n\nImportant Information\n\n\n\n\nDate: 2 October, 2018 (Tuesday)\n\n\nTime: 4pm to 6pm\n\n\nVenue: MPSH 1 (Section B)\n\n\nScope: Units 1-12, Assignments 1-2, Tutorials 1-4\n\n\nMCQs and Short Structured Questions\n\n\nDuration: 90 minutes\n\n\nOpen Book (You can bring analog references)\n\n\nCalculator is allowed (although you do not need it)\n\n\n\n\nSeating Arrangement\n\n\n\n\n\n\n\n\nName\n\n\nSeat Number\n\n\n\n\n\n\n\n\n\n\nAARUSHI SINGH\n\n\n76\n\n\n\n\n\n\nAHMAD MUDAAFI' B ZAINUDDIN\n\n\n77\n\n\n\n\n\n\nAI ZHENGWEI\n\n\n78\n\n\n\n\n\n\nALEX TEO KANG JIE\n\n\n79\n\n\n\n\n\n\nAMIR AZHAR B AZIZAN\n\n\n80\n\n\n\n\n\n\nANDREW LAU JIA JUN\n\n\n81\n\n\n\n\n\n\nANG KENG SIANG\n\n\n82\n\n\n\n\n\n\nANG KIANG YANG\n\n\n83\n\n\n\n\n\n\nAW CHIAN HAO\n\n\n84\n\n\n\n\n\n\nBALAM SAI ROHIT REDDY\n\n\n85\n\n\n\n\n\n\nBEATRICE CHAN TONG\n\n\n86\n\n\n\n\n\n\nBENEDICT YU CHENG EN\n\n\n87\n\n\n\n\n\n\nBENJAMIN CHIA SHAN HONG\n\n\n88\n\n\n\n\n\n\nBRANSON LEE JUN XIAN\n\n\n89\n\n\n\n\n\n\nCAI RONG\n\n\n90\n\n\n\n\n\n\nCHAN EE ZHENG, BENJAMIN\n\n\n91\n\n\n\n\n\n\nCHAN HIN, SEAN\n\n\n92\n\n\n\n\n\n\nCHAN WEI FONG, MAX\n\n\n93\n\n\n\n\n\n\nCHAN YEE CHONG PHILIP\n\n\n94\n\n\n\n\n\n\nCHAN YEW CHUN DANIEL\n\n\n95\n\n\n\n\n\n\nCHAN ZHI ZHENG, AMOS\n\n\n96\n\n\n\n\n\n\nCHANG HUI ZHEN\n\n\n97\n\n\n\n\n\n\nCHANG ZHONG KAI\n\n\n98\n\n\n\n\n\n\nCHEN CHAO\n\n\n99\n\n\n\n\n\n\nCHEN TONG\n\n\n100\n\n\n\n\n\n\nCHENG LE DA, CLEMENT\n\n\n101\n\n\n\n\n\n\nCHENG WANYIN\n\n\n102\n\n\n\n\n\n\nCHENG WEIXUAN\n\n\n103\n\n\n\n\n\n\nCHERYL NG YUN LIN\n\n\n104\n\n\n\n\n\n\nCHEW JUN KONG\n\n\n105\n\n\n\n\n\n\nCHIA BIING HANN\n\n\n106\n\n\n\n\n\n\nCHNG XIAN YI\n\n\n107\n\n\n\n\n\n\nCHOI WONJAE\n\n\n108\n\n\n\n\n\n\nCHU JUI HUNG @JEFFERSON CHU\n\n\n109\n\n\n\n\n\n\nCHUA MAI FENG, CARL\n\n\n110\n\n\n\n\n\n\nCHUA WEN XUAN\n\n\n111\n\n\n\n\n\n\nCHUA ZONG WEI\n\n\n112\n\n\n\n\n\n\nCLAIRE CHAN YEN HWA\n\n\n113\n\n\n\n\n\n\nCYNTHIA LEE WENG YAN\n\n\n114\n\n\n\n\n\n\nDANIEL TAN WEE LIANG\n\n\n115\n\n\n\n\n\n\nDANISH B EDDIE\n\n\n116\n\n\n\n\n\n\nDARREN ONG\n\n\n117\n\n\n\n\n\n\nDEBBIE TAN JIA MIN\n\n\n118\n\n\n\n\n\n\nDING NING\n\n\n119\n\n\n\n\n\n\nDIVAKARAN HARITHA\n\n\n120\n\n\n\n\n\n\nEDMUND TEO WEI XIN\n\n\n121\n\n\n\n\n\n\nEU JING SEN\n\n\n122\n\n\n\n\n\n\nEVELYN YI-WEN CHEN\n\n\n123\n\n\n\n\n\n\nFATIN NABILAH BTE SUHAIMI\n\n\n124\n\n\n\n\n\n\nFOO CHI HEN\n\n\n125\n\n\n\n\n\n\nGINA QUAH JIE XI\n\n\n126\n\n\n\n\n\n\nGLEN WONG SHU ZE\n\n\n127\n\n\n\n\n\n\nGOH RUI PING SAMANTHA\n\n\n128\n\n\n\n\n\n\nGOH ZHEN HAO JOEY\n\n\n129\n\n\n\n\n\n\nGONDHALEKAR SUKRUT YOGESH\n\n\n130\n\n\n\n\n\n\nGREGORY TAN WEI YUAN\n\n\n131\n\n\n\n\n\n\nGUI XIXIAN\n\n\n132\n\n\n\n\n\n\nGUO HAOREN\n\n\n133\n\n\n\n\n\n\nHANS KURNIA WIDJAJA\n\n\n134\n\n\n\n\n\n\nHAO YUN\n\n\n135\n\n\n\n\n\n\nHASHIR ZAHIR\n\n\n136\n\n\n\n\n\n\nHENG HONG CHUAN\n\n\n137\n\n\n\n\n\n\nHO JING YANG DANIEL\n\n\n138\n\n\n\n\n\n\nHO SI SHI ANNETTE\n\n\n139\n\n\n\n\n\n\nHO WEI BIN, JERRY\n\n\n140\n\n\n\n\n\n\nHU XINYING\n\n\n141\n\n\n\n\n\n\nHUANG XUANKUN\n\n\n142\n\n\n\n\n\n\nIAN CHUA\n\n\n143\n\n\n\n\n\n\nISABELLA CHEONG XIAO XUAN\n\n\n144\n\n\n\n\n\n\nIVAN ANDIKA LIE\n\n\n145\n\n\n\n\n\n\nJANEL ANG YEE HUEY\n\n\n146\n\n\n\n\n\n\nJASON SATHYA CITRO\n\n\n147\n\n\n\n\n\n\nJASPER ONG SHAO YONG\n\n\n148\n\n\n\n\n\n\nJAZHTEN LOW YONGSHEN\n\n\n149\n\n\n\n\n\n\nJERRY ZHANG ZHUORAN\n\n\n150\n\n\n\n\n\n\nJESS TEO XI ZHI\n\n\n151\n\n\n\n\n\n\nJOEL CHANG ZHI KAI\n\n\n152\n\n\n\n\n\n\nJOHN CUTHBERT KHOO TENG FONG\n\n\n153\n\n\n\n\n\n\nJOSEPH WONG YEFENG\n\n\n154\n\n\n\n\n\n\nJUSTIN CHIA JIA JIN\n\n\n155\n\n\n\n\n\n\nK ALAGES\n\n\n156\n\n\n\n\n\n\nKARAN SARAT\n\n\n157\n\n\n\n\n\n\nKARNATI SAI ABHISHEK\n\n\n158\n\n\n\n\n\n\nKEE KAH LOK\n\n\n159\n\n\n\n\n\n\nKEITH CHAN JUN KAI\n\n\n160\n\n\n\n\n\n\nKELVIN HARRIS\n\n\n161\n\n\n\n\n\n\nKEVIN PUTERA\n\n\n162\n\n\n\n\n\n\nKEZIA KEW KAI YUN\n\n\n163\n\n\n\n\n\n\nKHAIRUL IMAN NASRI B AZHARIE\n\n\n164\n\n\n\n\n\n\nKHOO TZE YANG RAYSON\n\n\n165\n\n\n\n\n\n\nKISHORE R\n\n\n166\n\n\n\n\n\n\nKWOK KUIN EK JEREMY\n\n\n167\n\n\n\n\n\n\nKYAWT KYAWT SAN\n\n\n168\n\n\n\n\n\n\nLAI WEN XUAN JEREMY\n\n\n169\n\n\n\n\n\n\nLAM TIAN WEI JUSTIN\n\n\n170\n\n\n\n\n\n\nLE HONG LONG\n\n\n171\n\n\n\n\n\n\nLEE HONG CHIEN, KENNETH\n\n\n172\n\n\n\n\n\n\nLEE LI XIN\n\n\n173\n\n\n\n\n\n\nLEE RAIYAN BIN ZULKIFLI\n\n\n174\n\n\n\n\n\n\nLEE WEI HERN, JASON\n\n\n175\n\n\n\n\n\n\nLEE YUEYU\n\n\n176\n\n\n\n\n\n\nLEE ZHEN YU\n\n\n177\n\n\n\n\n\n\nLEOW YONG HENG\n\n\n178\n\n\n\n\n\n\nLEOW YONG KANG ANDREW\n\n\n179\n\n\n\n\n\n\nLI JIAYU\n\n\n180\n\n\n\n\n\n\nLI ZIHAN\n\n\n181\n\n\n\n\n\n\nLIAO LIXIN\n\n\n182\n\n\n\n\n\n\nLIAO TIANCHANG\n\n\n183\n\n\n\n\n\n\nLIM CHEE SENG BRIAN\n\n\n184\n\n\n\n\n\n\nLIM CHEK JUN\n\n\n185\n\n\n\n\n\n\nLIM CHENG YIN, RYAN\n\n\n186\n\n\n\n\n\n\nLIM HAO XIANG, SEAN\n\n\n187\n\n\n\n\n\n\nLIM JIA WEI\n\n\n188\n\n\n\n\n\n\nLIM JIAYI, TAMELLY\n\n\n189\n\n\n\n\n\n\nLIM JUN KUANG, LIONEL\n\n\n190\n\n\n\n\n\n\nLIM LI LINCOLN\n\n\n191\n\n\n\n\n\n\nLIM SI YING\n\n\n192\n\n\n\n\n\n\nLIM TING WEI\n\n\n193\n\n\n\n\n\n\nLIM WEN HAN, EUGENE\n\n\n194\n\n\n\n\n\n\nLIM YAN TING\n\n\n195\n\n\n\n\n\n\nLIN JIAYUE\n\n\n196\n\n\n\n\n\n\nLING WEN JIAN\n\n\n197\n\n\n\n\n\n\nLIU JINGXUAN\n\n\n198\n\n\n\n\n\n\nLIU PEIZE\n\n\n199\n\n\n\n\n\n\nLIU SHIRU\n\n\n200\n\n\n\n\n\n\nLIU SONGTAO\n\n\n201\n\n\n\n\n\n\nLIU WEI JIE NICHOLAS\n\n\n202\n\n\n\n\n\n\nLOH CHING WEI, JOSHUA\n\n\n203\n\n\n\n\n\n\nLOH YONG ZEE\n\n\n204\n\n\n\n\n\n\nLOW EE TER\n\n\n205\n\n\n\n\n\n\nLOW JIA YEE\n\n\n206\n\n\n\n\n\n\nLOW SIU YUAN, FRANCIS\n\n\n207\n\n\n\n\n\n\nLUCAS FOO SOO QUAN\n\n\n208\n\n\n\n\n\n\nLYE JUN WEI ANANDA\n\n\n209\n\n\n\n\n\n\nMARC PHUA HSIAO MENG\n\n\n210\n\n\n\n\n\n\nMATTHEW NATHANAEL SUGIRI\n\n\n211\n\n\n\n\n\n\nMERVIN WEE MINGWEN\n\n\n212\n\n\n\n\n\n\nMICHELLE TOH HUI PING\n\n\n213\n\n\n\n\n\n\nMODAK SHANTANU BHARAT\n\n\n214\n\n\n\n\n\n\nMOHAMED RIYAS\n\n\n215\n\n\n\n\n\n\nMOHAMMAD YOUSUF MINHAJ ZIA\n\n\n216\n\n\n\n\n\n\nMUHAMMAD FAIRUZ B AMIRHAMZAH\n\n\n217\n\n\n\n\n\n\nMUHAMMAD HOZEFA ZUMKHAWALA\n\n\n218\n\n\n\n\n\n\nMUHAMMAD SHOLIHIN BIN KAMARUDIN\n\n\n219\n\n\n\n\n\n\nMUHHAMMAD NUR HAFIDZ BIN HUSSAIN\n\n\n220\n\n\n\n\n\n\nName\n\n\n221\n\n\n\n\n\n\nNATHAN YEO KEE HERN\n\n\n222\n\n\n\n\n\n\nNEO WEN HUI\n\n\n223\n\n\n\n\n\n\nNG JIE WU\n\n\n224\n\n\n\n\n\n\nNG JING KANG\n\n\n225\n\n\n\n\n\n\nNG JING KIAT\n\n\n226\n\n\n\n\n\n\nNG SHI QI, CARRIE\n\n\n227\n\n\n\n\n\n\nNG SIU HIAN\n\n\n228\n\n\n\n\n\n\nNG WEE KIAT\n\n\n229\n\n\n\n\n\n\nNG WEI JIE, BRANDON\n\n\n230\n\n\n\n\n\n\nNG ZI HUI\n\n\n231\n\n\n\n\n\n\nNGAN JI CHENG\n\n\n232\n\n\n\n\n\n\nNGUYEN THANH DUC\n\n\n233\n\n\n\n\n\n\nNGUYEN TIEN DAT\n\n\n234\n\n\n\n\n\n\nNIGEL TAN\n\n\n235\n\n\n\n\n\n\nNIGELLE LEO YUWEN\n\n\n236\n\n\n\n\n\n\nNISHANTH ELANGO\n\n\n237\n\n\n\n\n\n\nNYAN WUN PAING\n\n\n238\n\n\n\n\n\n\nOEI CHIU YAN REBECCA\n\n\n239\n\n\n\n\n\n\nONG YU XUAN\n\n\n240\n\n\n\n\n\n\nOUNG YONG SHENG KENNEDY\n\n\n241\n\n\n\n\n\n\nOW ZHENG KUAN\n\n\n242\n\n\n\n\n\n\nP PRADEEP\n\n\n243\n\n\n\n\n\n\nPANG JIA JUN VERNON\n\n\n244\n\n\n\n\n\n\nPARK SO HYUN\n\n\n245\n\n\n\n\n\n\nPARMAR VARUN SAMIR\n\n\n246\n\n\n\n\n\n\nPARVATHI RANJITH MENON\n\n\n247\n\n\n\n\n\n\nPATWARI RISHAB\n\n\n248\n\n\n\n\n\n\nPEI YAN BO\n\n\n249\n\n\n\n\n\n\nPHOON JIA JUIN\n\n\n250\n\n\n\n\n\n\nPOH CHOO LEONG, LINSTON\n\n\n251\n\n\n\n\n\n\nPONG LOONG BOB\n\n\n252\n\n\n\n\n\n\nPOON KAH ONN, BENJAMIN\n\n\n253\n\n\n\n\n\n\nPOW JING YONG\n\n\n254\n\n\n\n\n\n\nQIAN JIE\n\n\n255\n\n\n\n\n\n\nQUAH YOU JING KANE\n\n\n256\n\n\n\n\n\n\nQUEK AIK PENG\n\n\n257\n\n\n\n\n\n\nRAGHAV BHARDWAJ\n\n\n258\n\n\n\n\n\n\nRAJAMOHAN B PRIYAN\n\n\n259\n\n\n\n\n\n\nRAVEENDRAN AJEY ASHOK\n\n\n260\n\n\n\n\n\n\nRISHI MAHADEVAN\n\n\n261\n\n\n\n\n\n\nRUSDI HAIZIM B RAHIM\n\n\n262\n\n\n\n\n\n\nRYAN TAN YU\n\n\n263\n\n\n\n\n\n\nSAI GANESH SURESH\n\n\n264\n\n\n\n\n\n\nSCOTT FLOYD ZHEN-YAN SMAHON\n\n\n265\n\n\n\n\n\n\nSEE SHENG CHAO\n\n\n266\n\n\n\n\n\n\nSENTHIL ARAAVIND\n\n\n267\n\n\n\n\n\n\nSHA LONG\n\n\n268\n\n\n\n\n\n\nSHANNON LEE\n\n\n269\n\n\n\n\n\n\nSHAWN WONG JUN KIT\n\n\n270\n\n\n\n\n\n\nSHRIYA SAXENA\n\n\n271\n\n\n\n\n\n\nSIM YU JIE\n\n\n272\n\n\n\n\n\n\nSITI NADIAH BINTE MOHAMED RAMLI\n\n\n273\n\n\n\n\n\n\nSUTHER DAVID SAMUEL\n\n\n274\n\n\n\n\n\n\nTALAGADADIVI DURGA RUKMINI MANASWINI\n\n\n275\n\n\n\n\n\n\nTAM WEI IAN JOSHUA\n\n\n276\n\n\n\n\n\n\nTAN GUAN YEW\n\n\n277\n\n\n\n\n\n\nTAN KAI LI CATHERINE\n\n\n278\n\n\n\n\n\n\nTAN KOK JOON\n\n\n279\n\n\n\n\n\n\nTAN LI ANN PETER\n\n\n280\n\n\n\n\n\n\nTAN YEH HAN, JOHN\n\n\n281\n\n\n\n\n\n\nTAN YI XIANG\n\n\n282\n\n\n\n\n\n\nTAN ZHENG FU JUSTIN\n\n\n283\n\n\n\n\n\n\nTAN ZHENG WEN\n\n\n284\n\n\n\n\n\n\nTAY JIN WEN\n\n\n285\n\n\n\n\n\n\nTAY JING XUAN\n\n\n286\n\n\n\n\n\n\nTAY TZE-WEI, CALEB\n\n\n287\n\n\n\n\n\n\nTAY YEE EN, RYAN\n\n\n288\n\n\n\n\n\n\nTEH ZI HUAI\n\n\n289\n\n\n\n\n\n\nTEO WEI JIE, SHAUN\n\n\n290\n\n\n\n\n\n\nTOH YING YING JANICE\n\n\n291\n\n\n\n\n\n\nTONG QI WEI\n\n\n292\n\n\n\n\n\n\nTRAN MINH DUONG\n\n\n293\n\n\n\n\n\n\nTRAN QUANG THANH\n\n\n294\n\n\n\n\n\n\nTSHIN QI REN\n\n\n295\n\n\n\n\n\n\nUMAR BIN MOIZ\n\n\n296\n\n\n\n\n\n\nVASAVADA TEJAS SUDHIR\n\n\n297\n\n\n\n\n\n\nVIDHYABHARATHI SOMASUNDARAM\n\n\n298\n\n\n\n\n\n\nVIVIAN LEE BOON GEOK\n\n\n299\n\n\n\n\n\n\nWANG ZICONG\n\n\n300\n\n\n\n\n\n\nWEI FENG\n\n\n301\n\n\n\n\n\n\nWENG KEXIN\n\n\n302\n\n\n\n\n\n\nWONG JIN EN, SHANNON\n\n\n303\n\n\n\n\n\n\nWONG REN-WEI, RYAN\n\n\n304\n\n\n\n\n\n\nXUE ZHENGQING\n\n\n305\n\n\n\n\n\n\nYANG AN QI\n\n\n306\n\n\n\n\n\n\nYANG CHENGLONG\n\n\n307\n\n\n\n\n\n\nYANG KAI ZE\n\n\n308\n\n\n\n\n\n\nYANG ZI YUN\n\n\n309\n\n\n\n\n\n\nYAP JIN FA\n\n\n310\n\n\n\n\n\n\nYAP KESIN\n\n\n311\n\n\n\n\n\n\nYE GUOQUAN\n\n\n312\n\n\n\n\n\n\nYE TONG\n\n\n313\n\n\n\n\n\n\nYEN PEI CHIH\n\n\n314\n\n\n\n\n\n\nYEW JING HUI\n\n\n315\n\n\n\n\n\n\nYU XIAOXUE\n\n\n316\n\n\n\n\n\n\nYUAN JIAYI\n\n\n317\n\n\n\n\n\n\nYUE JUN YI\n\n\n318\n\n\n\n\n\n\nZHANG SHIYU\n\n\n319\n\n\n\n\n\n\nZHANG YIHAN\n\n\n320\n\n\n\n\n\n\nZHANG YIPING\n\n\n321\n\n\n\n\n\n\nZHANG YUE HAN\n\n\n322\n\n\n\n\n\n\nZHAO PENGFEI\n\n\n323\n\n\n\n\n\n\nZHAO TIANQI\n\n\n324\n\n\n\n\n\n\nZHENG KAINING\n\n\n325\n\n\n\n\n\n\nZHU BO\n\n\n326\n\n\n\n\n\n\nZHU YIJIE\n\n\n327\n\n\n\n\n\n\nZOE WONG XIN LEI\n\n\n328",
            "title": "Midterm"
        },
        {
            "location": "/midterm/index.html#midterm",
            "text": "",
            "title": "Midterm"
        },
        {
            "location": "/midterm/index.html#question-solution-marking-scheme",
            "text": "",
            "title": "Question, Solution, Marking Scheme"
        },
        {
            "location": "/midterm/index.html#important-information",
            "text": "Date: 2 October, 2018 (Tuesday)  Time: 4pm to 6pm  Venue: MPSH 1 (Section B)  Scope: Units 1-12, Assignments 1-2, Tutorials 1-4  MCQs and Short Structured Questions  Duration: 90 minutes  Open Book (You can bring analog references)  Calculator is allowed (although you do not need it)",
            "title": "Important Information"
        },
        {
            "location": "/midterm/index.html#seating-arrangement",
            "text": "Name  Seat Number      AARUSHI SINGH  76    AHMAD MUDAAFI' B ZAINUDDIN  77    AI ZHENGWEI  78    ALEX TEO KANG JIE  79    AMIR AZHAR B AZIZAN  80    ANDREW LAU JIA JUN  81    ANG KENG SIANG  82    ANG KIANG YANG  83    AW CHIAN HAO  84    BALAM SAI ROHIT REDDY  85    BEATRICE CHAN TONG  86    BENEDICT YU CHENG EN  87    BENJAMIN CHIA SHAN HONG  88    BRANSON LEE JUN XIAN  89    CAI RONG  90    CHAN EE ZHENG, BENJAMIN  91    CHAN HIN, SEAN  92    CHAN WEI FONG, MAX  93    CHAN YEE CHONG PHILIP  94    CHAN YEW CHUN DANIEL  95    CHAN ZHI ZHENG, AMOS  96    CHANG HUI ZHEN  97    CHANG ZHONG KAI  98    CHEN CHAO  99    CHEN TONG  100    CHENG LE DA, CLEMENT  101    CHENG WANYIN  102    CHENG WEIXUAN  103    CHERYL NG YUN LIN  104    CHEW JUN KONG  105    CHIA BIING HANN  106    CHNG XIAN YI  107    CHOI WONJAE  108    CHU JUI HUNG @JEFFERSON CHU  109    CHUA MAI FENG, CARL  110    CHUA WEN XUAN  111    CHUA ZONG WEI  112    CLAIRE CHAN YEN HWA  113    CYNTHIA LEE WENG YAN  114    DANIEL TAN WEE LIANG  115    DANISH B EDDIE  116    DARREN ONG  117    DEBBIE TAN JIA MIN  118    DING NING  119    DIVAKARAN HARITHA  120    EDMUND TEO WEI XIN  121    EU JING SEN  122    EVELYN YI-WEN CHEN  123    FATIN NABILAH BTE SUHAIMI  124    FOO CHI HEN  125    GINA QUAH JIE XI  126    GLEN WONG SHU ZE  127    GOH RUI PING SAMANTHA  128    GOH ZHEN HAO JOEY  129    GONDHALEKAR SUKRUT YOGESH  130    GREGORY TAN WEI YUAN  131    GUI XIXIAN  132    GUO HAOREN  133    HANS KURNIA WIDJAJA  134    HAO YUN  135    HASHIR ZAHIR  136    HENG HONG CHUAN  137    HO JING YANG DANIEL  138    HO SI SHI ANNETTE  139    HO WEI BIN, JERRY  140    HU XINYING  141    HUANG XUANKUN  142    IAN CHUA  143    ISABELLA CHEONG XIAO XUAN  144    IVAN ANDIKA LIE  145    JANEL ANG YEE HUEY  146    JASON SATHYA CITRO  147    JASPER ONG SHAO YONG  148    JAZHTEN LOW YONGSHEN  149    JERRY ZHANG ZHUORAN  150    JESS TEO XI ZHI  151    JOEL CHANG ZHI KAI  152    JOHN CUTHBERT KHOO TENG FONG  153    JOSEPH WONG YEFENG  154    JUSTIN CHIA JIA JIN  155    K ALAGES  156    KARAN SARAT  157    KARNATI SAI ABHISHEK  158    KEE KAH LOK  159    KEITH CHAN JUN KAI  160    KELVIN HARRIS  161    KEVIN PUTERA  162    KEZIA KEW KAI YUN  163    KHAIRUL IMAN NASRI B AZHARIE  164    KHOO TZE YANG RAYSON  165    KISHORE R  166    KWOK KUIN EK JEREMY  167    KYAWT KYAWT SAN  168    LAI WEN XUAN JEREMY  169    LAM TIAN WEI JUSTIN  170    LE HONG LONG  171    LEE HONG CHIEN, KENNETH  172    LEE LI XIN  173    LEE RAIYAN BIN ZULKIFLI  174    LEE WEI HERN, JASON  175    LEE YUEYU  176    LEE ZHEN YU  177    LEOW YONG HENG  178    LEOW YONG KANG ANDREW  179    LI JIAYU  180    LI ZIHAN  181    LIAO LIXIN  182    LIAO TIANCHANG  183    LIM CHEE SENG BRIAN  184    LIM CHEK JUN  185    LIM CHENG YIN, RYAN  186    LIM HAO XIANG, SEAN  187    LIM JIA WEI  188    LIM JIAYI, TAMELLY  189    LIM JUN KUANG, LIONEL  190    LIM LI LINCOLN  191    LIM SI YING  192    LIM TING WEI  193    LIM WEN HAN, EUGENE  194    LIM YAN TING  195    LIN JIAYUE  196    LING WEN JIAN  197    LIU JINGXUAN  198    LIU PEIZE  199    LIU SHIRU  200    LIU SONGTAO  201    LIU WEI JIE NICHOLAS  202    LOH CHING WEI, JOSHUA  203    LOH YONG ZEE  204    LOW EE TER  205    LOW JIA YEE  206    LOW SIU YUAN, FRANCIS  207    LUCAS FOO SOO QUAN  208    LYE JUN WEI ANANDA  209    MARC PHUA HSIAO MENG  210    MATTHEW NATHANAEL SUGIRI  211    MERVIN WEE MINGWEN  212    MICHELLE TOH HUI PING  213    MODAK SHANTANU BHARAT  214    MOHAMED RIYAS  215    MOHAMMAD YOUSUF MINHAJ ZIA  216    MUHAMMAD FAIRUZ B AMIRHAMZAH  217    MUHAMMAD HOZEFA ZUMKHAWALA  218    MUHAMMAD SHOLIHIN BIN KAMARUDIN  219    MUHHAMMAD NUR HAFIDZ BIN HUSSAIN  220    Name  221    NATHAN YEO KEE HERN  222    NEO WEN HUI  223    NG JIE WU  224    NG JING KANG  225    NG JING KIAT  226    NG SHI QI, CARRIE  227    NG SIU HIAN  228    NG WEE KIAT  229    NG WEI JIE, BRANDON  230    NG ZI HUI  231    NGAN JI CHENG  232    NGUYEN THANH DUC  233    NGUYEN TIEN DAT  234    NIGEL TAN  235    NIGELLE LEO YUWEN  236    NISHANTH ELANGO  237    NYAN WUN PAING  238    OEI CHIU YAN REBECCA  239    ONG YU XUAN  240    OUNG YONG SHENG KENNEDY  241    OW ZHENG KUAN  242    P PRADEEP  243    PANG JIA JUN VERNON  244    PARK SO HYUN  245    PARMAR VARUN SAMIR  246    PARVATHI RANJITH MENON  247    PATWARI RISHAB  248    PEI YAN BO  249    PHOON JIA JUIN  250    POH CHOO LEONG, LINSTON  251    PONG LOONG BOB  252    POON KAH ONN, BENJAMIN  253    POW JING YONG  254    QIAN JIE  255    QUAH YOU JING KANE  256    QUEK AIK PENG  257    RAGHAV BHARDWAJ  258    RAJAMOHAN B PRIYAN  259    RAVEENDRAN AJEY ASHOK  260    RISHI MAHADEVAN  261    RUSDI HAIZIM B RAHIM  262    RYAN TAN YU  263    SAI GANESH SURESH  264    SCOTT FLOYD ZHEN-YAN SMAHON  265    SEE SHENG CHAO  266    SENTHIL ARAAVIND  267    SHA LONG  268    SHANNON LEE  269    SHAWN WONG JUN KIT  270    SHRIYA SAXENA  271    SIM YU JIE  272    SITI NADIAH BINTE MOHAMED RAMLI  273    SUTHER DAVID SAMUEL  274    TALAGADADIVI DURGA RUKMINI MANASWINI  275    TAM WEI IAN JOSHUA  276    TAN GUAN YEW  277    TAN KAI LI CATHERINE  278    TAN KOK JOON  279    TAN LI ANN PETER  280    TAN YEH HAN, JOHN  281    TAN YI XIANG  282    TAN ZHENG FU JUSTIN  283    TAN ZHENG WEN  284    TAY JIN WEN  285    TAY JING XUAN  286    TAY TZE-WEI, CALEB  287    TAY YEE EN, RYAN  288    TEH ZI HUAI  289    TEO WEI JIE, SHAUN  290    TOH YING YING JANICE  291    TONG QI WEI  292    TRAN MINH DUONG  293    TRAN QUANG THANH  294    TSHIN QI REN  295    UMAR BIN MOIZ  296    VASAVADA TEJAS SUDHIR  297    VIDHYABHARATHI SOMASUNDARAM  298    VIVIAN LEE BOON GEOK  299    WANG ZICONG  300    WEI FENG  301    WENG KEXIN  302    WONG JIN EN, SHANNON  303    WONG REN-WEI, RYAN  304    XUE ZHENGQING  305    YANG AN QI  306    YANG CHENGLONG  307    YANG KAI ZE  308    YANG ZI YUN  309    YAP JIN FA  310    YAP KESIN  311    YE GUOQUAN  312    YE TONG  313    YEN PEI CHIH  314    YEW JING HUI  315    YU XIAOXUE  316    YUAN JIAYI  317    YUE JUN YI  318    ZHANG SHIYU  319    ZHANG YIHAN  320    ZHANG YIPING  321    ZHANG YUE HAN  322    ZHAO PENGFEI  323    ZHAO TIANQI  324    ZHENG KAINING  325    ZHU BO  326    ZHU YIJIE  327    ZOE WONG XIN LEI  328",
            "title": "Seating Arrangement"
        },
        {
            "location": "/pe1/index.html",
            "text": "Practice Exam 1\n\n\nQuestions\n\n\n\n\nExam Paper\n\n\nClick on \nGitHub Link\n to accept, run \nget-pe01\n and \nsubmit-pe01\n to solve this like any other assignments.\n\n\n\n\nBasic Info\n\n\n\n\nDate: 6 October, 2018 (Saturday)\n\n\nTime: 9am to 12noon\n\n\nVenue: Various programming labs\n\n\nScope: Units 1-12, Assignments 1-2, Tutorials 1-4\n\n\n4 to\n 5 programming questions, very easy to hard\n\n\n Criteria: Correctness and Style. One mark is allocated for programming style for each question. \n\n\nDuration: 2 hours and 30 minutes\n\n\nOpen Book (You can bring analog references)\n\n\n\n\nLab Allocation\n\n\n\n\nEvery student is assigned to a programming lab.  \n\n\nPlease see the allocation below.\n\n\nYou should acclimatize yourself to the use of the PC desktops in the lab assigned to you.\n\n\nSpecial access has been given to students assigned to ES Lab 1 and 2 (Embedded System Teaching Lab 1 and 2)\n\n\nHere are the \nlocatons for the respective labs\n\n\n\n\nSpecial Restrictions\n\n\n\n\n\n\nYou will be issued a special account on the PE day to solve the exam questions.  \n\n\n\n\n\n\nThere will be no Internet access.\n\n\n\n\n\n\nVim Configuration\n\n\nYour default account will have the same \n.vimrc\n as \n~cs1010/.vimrc\n on the CS1010 PE hosts.  \n\n\nYou are free to edit this during the practical exams.  \n\n\nYou, however, will not be able to download nor install \nvim\n plugins.\n\n\nGeneral Advice\n\n\n\n\nSave your program regularly.  We will use setup every account with \n~/.vimrc\n copied from \n~cs1010/.vimrc\n.  Thus, you can find the last saved version of your files under \n~/.backup\n if you accidentally deleted your code.\n\n\nPlan your time properly.  Do not spend excessive time on any task.  Read through all questions and solved those that you are confident to solve first.\n\n\nThere are five questions, from very easy to very hard.  Solve as many as you can.  I expect most students will be able to solve 3 out of the 5 questions within the time limit.\n\n\nThere is one mark allocated to style for each question.  As long as you keep your code clean, neat, and readable, you will get this one mark, almost for free.  Review the CS1010 style guide so that you know what is expected in terms of coding style.\n\n\nDon't start typing your code right away.  Think about the solution first -- what variables are needed?  what is the control flow (using branches and loops)?  Draw out the flowchart if it helps.  \n\n\nBreak down the problem into smaller ones if the problem is too complex to solve.\n\n\nYou are not allowed to start typing on the computer for the first 10 minutes of the practical exam, or until the invigilator announced that you can do so.\n\n\nYou will be given a question form to ask questions to clarify doubts about the question paper.  But note that you can only ask a boolean question (YES/NO answer).\n\n\nJust like the assignments, you are not given all the test cases that we will be using during grading.  Please test your code against additional test cases, especially for boundary cases.\n\n\n\n\nLab and Seat Allocation\n\n\n\n\n\n\n\n\nNAME\n\n\nVenue\n\n\nSeat Number\n\n\n\n\n\n\n\n\n\n\nAARUSHI SINGH\n\n\nPL1\n\n\nsoctf-imac215-002\n\n\n\n\n\n\nADELYN KOH JING YING\n\n\nPL1\n\n\nsoctf-imac215-003\n\n\n\n\n\n\nAHMAD MUDAAFI' B ZAINUDDIN\n\n\nPL1\n\n\nsoctf-imac215-004\n\n\n\n\n\n\nAI ZHENGWEI\n\n\nPL1\n\n\nsoctf-imac215-005\n\n\n\n\n\n\nALEX TEO KANG JIE\n\n\nPL1\n\n\nsoctf-imac215-008\n\n\n\n\n\n\nAMIR AZHAR B AZIZAN\n\n\nPL1\n\n\nsoctf-imac215-009\n\n\n\n\n\n\nANDREW LAU JIA JUN\n\n\nPL1\n\n\nsoctf-imac215-010\n\n\n\n\n\n\nANG KENG SIANG\n\n\nPL1\n\n\nsoctf-imac215-011\n\n\n\n\n\n\nANG KIANG YANG\n\n\nPL1\n\n\nsoctf-imac215-012\n\n\n\n\n\n\nAW CHIAN HAO\n\n\nPL1\n\n\nsoctf-imac215-013\n\n\n\n\n\n\nBALAM SAI ROHIT REDDY\n\n\nPL1\n\n\nsoctf-imac215-014\n\n\n\n\n\n\nBEATRICE CHAN TONG\n\n\nPL1\n\n\nsoctf-imac215-015\n\n\n\n\n\n\nBENEDICT YU CHENG EN\n\n\nPL1\n\n\nsoctf-imac215-016\n\n\n\n\n\n\nBENJAMIN CHIA SHAN HONG\n\n\nPL1\n\n\nsoctf-imac215-017\n\n\n\n\n\n\nCAI RONG\n\n\nPL1\n\n\nsoctf-imac215-019\n\n\n\n\n\n\nCHAN EE ZHENG, BENJAMIN\n\n\nPL1\n\n\nsoctf-imac215-020\n\n\n\n\n\n\nCHAN HIN, SEAN\n\n\nPL1\n\n\nsoctf-imac215-021\n\n\n\n\n\n\nCHAN WEI FONG, MAX\n\n\nPL1\n\n\nsoctf-imac215-022\n\n\n\n\n\n\nCHAN YEE CHONG PHILIP\n\n\nPL1\n\n\nsoctf-imac215-023\n\n\n\n\n\n\nCHAN YEW CHUN DANIEL\n\n\nPL1\n\n\nsoctf-imac215-024\n\n\n\n\n\n\nCHAN ZHI ZHENG, AMOS\n\n\nPL1\n\n\nsoctf-imac215-025\n\n\n\n\n\n\nCHANG HUI ZHEN\n\n\nPL1\n\n\nsoctf-imac215-026\n\n\n\n\n\n\nCHANG ZHONG KAI\n\n\nPL1\n\n\nsoctf-imac215-027\n\n\n\n\n\n\nCHEN CHAO\n\n\nPL1\n\n\nsoctf-imac215-028\n\n\n\n\n\n\nCHEN TONG\n\n\nPL1\n\n\nsoctf-imac215-029\n\n\n\n\n\n\nCHENG LE DA, CLEMENT\n\n\nPL1\n\n\nsoctf-imac215-030\n\n\n\n\n\n\nCHENG WANYIN\n\n\nPL1\n\n\nsoctf-imac215-031\n\n\n\n\n\n\nCHENG WEIXUAN\n\n\nPL1\n\n\nsoctf-imac215-032\n\n\n\n\n\n\nCHERYL NG YUN LIN\n\n\nPL1\n\n\nsoctf-imac215-033\n\n\n\n\n\n\nCHEW JUN KONG\n\n\nPL1\n\n\nsoctf-imac215-034\n\n\n\n\n\n\nCHIA BIING HANN\n\n\nPL1\n\n\nsoctf-imac215-035\n\n\n\n\n\n\nCHNG XIAN YI\n\n\nWSLab 3\n\n\nws3-002\n\n\n\n\n\n\nCHOI WONJAE\n\n\nPL1\n\n\nsoctf-imac215-037\n\n\n\n\n\n\nCHU JUI HUNG @JEFFERSON CHU\n\n\nPL1\n\n\nsoctf-imac215-038\n\n\n\n\n\n\nCHUA MAI FENG, CARL\n\n\nPL1\n\n\nsoctf-imac215-039\n\n\n\n\n\n\nCHUA WEN XUAN\n\n\nPL1\n\n\nsoctf-imac215-040\n\n\n\n\n\n\nCHUA ZONG WEI\n\n\nPL1\n\n\nsoctf-imac215-043\n\n\n\n\n\n\nCLAIRE CHAN YEN HWA\n\n\nPL1\n\n\nsoctf-imac215-044\n\n\n\n\n\n\nCYNTHIA LEE WENG YAN\n\n\nPL1\n\n\nsoctf-imac215-045\n\n\n\n\n\n\nDANIEL TAN WEE LIANG\n\n\nPL2\n\n\nsoctf-pl2-002\n\n\n\n\n\n\nDANISH B EDDIE\n\n\nPL2\n\n\nsoctf-pl2-003\n\n\n\n\n\n\nDARREN ONG\n\n\nPL2\n\n\nsoctf-pl2-004\n\n\n\n\n\n\nDEBBIE TAN JIA MIN\n\n\nPL2\n\n\nsoctf-pl2-005\n\n\n\n\n\n\nDING NING\n\n\nPL2\n\n\nsoctf-pl2-006\n\n\n\n\n\n\nDIVAKARAN HARITHA\n\n\nPL2\n\n\nsoctf-pl2-007\n\n\n\n\n\n\nEDMUND TEO WEI XIN\n\n\nPL2\n\n\nsoctf-pl2-009\n\n\n\n\n\n\nEU JING SEN\n\n\nPL2\n\n\nsoctf-pl2-010\n\n\n\n\n\n\nEVELYN YI-WEN CHEN\n\n\nPL2\n\n\nsoctf-pl2-011\n\n\n\n\n\n\nFATIN NABILAH BTE SUHAIMI\n\n\nPL2\n\n\nsoctf-pl2-012\n\n\n\n\n\n\nFOO CHI HEN\n\n\nPL2\n\n\nsoctf-pl2-013\n\n\n\n\n\n\nGINA QUAH JIE XI\n\n\nPL2\n\n\nsoctf-pl2-014\n\n\n\n\n\n\nGLEN WONG SHU ZE\n\n\nPL2\n\n\nsoctf-pl2-016\n\n\n\n\n\n\nGOH RUI PING SAMANTHA\n\n\nPL2\n\n\nsoctf-pl2-017\n\n\n\n\n\n\nGOH ZHEN HAO JOEY\n\n\nPL2\n\n\nsoctf-pl2-018\n\n\n\n\n\n\nGONDHALEKAR SUKRUT YOGESH\n\n\nPL2\n\n\nsoctf-pl2-019\n\n\n\n\n\n\nGREGORY TAN WEI YUAN\n\n\nPL2\n\n\nsoctf-pl2-020\n\n\n\n\n\n\nGUI XIXIAN\n\n\nPL2\n\n\nsoctf-pl2-021\n\n\n\n\n\n\nGUO HAOREN\n\n\nPL2\n\n\nsoctf-pl2-022\n\n\n\n\n\n\nHANS KURNIA WIDJAJA\n\n\nPL2\n\n\nsoctf-pl2-023\n\n\n\n\n\n\nHAO YUN\n\n\nPL2\n\n\nsoctf-pl2-024\n\n\n\n\n\n\nHASHIR ZAHIR\n\n\nPL2\n\n\nsoctf-pl2-025\n\n\n\n\n\n\nHENG HONG CHUAN\n\n\nPL2\n\n\nsoctf-pl2-026\n\n\n\n\n\n\nHO JING YANG DANIEL\n\n\nPL2\n\n\nsoctf-pl2-028\n\n\n\n\n\n\nHO SI SHI ANNETTE\n\n\nPL2\n\n\nsoctf-pl2-029\n\n\n\n\n\n\nHO WEI BIN, JERRY\n\n\nPL2\n\n\nsoctf-pl2-030\n\n\n\n\n\n\nHU XINYING\n\n\nPL2\n\n\nsoctf-pl2-031\n\n\n\n\n\n\nHUANG XUANKUN\n\n\nPL2\n\n\nsoctf-pl2-032\n\n\n\n\n\n\nIAN CHUA\n\n\nPL2\n\n\nsoctf-pl2-033\n\n\n\n\n\n\nISABELLA CHEONG XIAO XUAN\n\n\nPL2\n\n\nsoctf-pl2-035\n\n\n\n\n\n\nIVAN ANDIKA LIE\n\n\nPL2\n\n\nsoctf-pl2-036\n\n\n\n\n\n\nJANEL ANG YEE HUEY\n\n\nPL2\n\n\nsoctf-pl2-037\n\n\n\n\n\n\nJASON SATHYA CITRO\n\n\nPL2\n\n\nsoctf-pl2-038\n\n\n\n\n\n\nJASPER ONG SHAO YONG\n\n\nPL2\n\n\nsoctf-pl2-039\n\n\n\n\n\n\nJAZHTEN LOW YONGSHEN\n\n\nPL2\n\n\nsoctf-pl2-040\n\n\n\n\n\n\nJERRY ZHANG ZHUORAN\n\n\nPL2\n\n\nsoctf-pl2-042\n\n\n\n\n\n\nJESS TEO XI ZHI\n\n\nPL2\n\n\nsoctf-pl2-043\n\n\n\n\n\n\nJOEL CHANG ZHI KAI\n\n\nPL2\n\n\nsoctf-pl2-044\n\n\n\n\n\n\nJOHN CUTHBERT KHOO TENG FONG\n\n\nPL2\n\n\nsoctf-pl2-045\n\n\n\n\n\n\nJOSEPH WONG YEFENG\n\n\nPL2\n\n\nsoctf-pl2-046\n\n\n\n\n\n\nJUSTIN CHIA JIA JIN\n\n\nPL3\n\n\nsoctf-pl3-001\n\n\n\n\n\n\nK ALAGES\n\n\nPL3\n\n\nsoctf-pl3-002\n\n\n\n\n\n\nKARAN SARAT\n\n\nPL3\n\n\nsoctf-pl3-003\n\n\n\n\n\n\nKARNATI SAI ABHISHEK\n\n\nPL3\n\n\nsoctf-pl3-005\n\n\n\n\n\n\nKEE KAH LOK\n\n\nPL3\n\n\nsoctf-pl3-006\n\n\n\n\n\n\nKEITH CHAN JUN KAI\n\n\nPL3\n\n\nsoctf-pl3-007\n\n\n\n\n\n\nKELVIN HARRIS\n\n\nPL3\n\n\nsoctf-pl3-009\n\n\n\n\n\n\nKEVIN PUTERA\n\n\nPL3\n\n\nsoctf-pl3-010\n\n\n\n\n\n\nKEZIA KEW KAI YUN\n\n\nPL3\n\n\nsoctf-pl3-011\n\n\n\n\n\n\nKHAIRUL IMAN NASRI B AZHARIE\n\n\nPL3\n\n\nsoctf-pl3-013\n\n\n\n\n\n\nKHOO TZE YANG RAYSON\n\n\nPL3\n\n\nsoctf-pl3-014\n\n\n\n\n\n\nKISHORE R\n\n\nPL3\n\n\nsoctf-pl3-015\n\n\n\n\n\n\nKWOK KUIN EK JEREMY\n\n\nPL3\n\n\nsoctf-pl3-016\n\n\n\n\n\n\nKYAWT KYAWT SAN\n\n\nPL3\n\n\nsoctf-pl3-017\n\n\n\n\n\n\nLAI WEN XUAN JEREMY\n\n\nPL3\n\n\nsoctf-pl3-018\n\n\n\n\n\n\nLAM TIAN WEI JUSTIN\n\n\nPL3\n\n\nsoctf-pl3-019\n\n\n\n\n\n\nLE HONG LONG\n\n\nPL3\n\n\nsoctf-pl3-020\n\n\n\n\n\n\nLEE HONG CHIEN, KENNETH\n\n\nPL3\n\n\nsoctf-pl3-021\n\n\n\n\n\n\nLEE LI XIN\n\n\nWSLab 3\n\n\nws3-003\n\n\n\n\n\n\nLEE RAIYAN BIN ZULKIFLI\n\n\nPL3\n\n\nsoctf-pl3-023\n\n\n\n\n\n\nLEE WEI HERN, JASON\n\n\nPL3\n\n\nsoctf-pl3-025\n\n\n\n\n\n\nLEE YUEYU\n\n\nPL3\n\n\nsoctf-pl3-026\n\n\n\n\n\n\nLEE ZHEN YU\n\n\nPL4\n\n\nsoctf-pl4-002\n\n\n\n\n\n\nLEOW YONG HENG\n\n\nPL4\n\n\nsoctf-pl4-003\n\n\n\n\n\n\nLEOW YONG KANG ANDREW\n\n\nPL4\n\n\nsoctf-pl4-004\n\n\n\n\n\n\nLI JIAYU\n\n\nPL4\n\n\nsoctf-pl4-005\n\n\n\n\n\n\nLI ZIHAN\n\n\nPL4\n\n\nsoctf-pl4-006\n\n\n\n\n\n\nLIAO LIXIN\n\n\nPL4\n\n\nsoctf-pl4-007\n\n\n\n\n\n\nLIAO TIANCHANG\n\n\nPL4\n\n\nsoctf-pl4-008\n\n\n\n\n\n\nLIM CHEE SENG BRIAN\n\n\nPL4\n\n\nsoctf-pl4-009\n\n\n\n\n\n\nLIM CHEK JUN\n\n\nPL4\n\n\nsoctf-pl4-010\n\n\n\n\n\n\nLIM CHENG YIN, RYAN\n\n\nPL4\n\n\nsoctf-pl4-011\n\n\n\n\n\n\nLIM HAO XIANG, SEAN\n\n\nPL4\n\n\nsoctf-pl4-012\n\n\n\n\n\n\nLIM JIA WEI\n\n\nPL4\n\n\nsoctf-pl4-013\n\n\n\n\n\n\nLIM JIAYI, TAMELLY\n\n\nPL4\n\n\nsoctf-pl4-014\n\n\n\n\n\n\nLIM JUN KUANG, LIONEL\n\n\nPL4\n\n\nsoctf-pl4-015\n\n\n\n\n\n\nLIM LI LINCOLN\n\n\nPL4\n\n\nsoctf-pl4-016\n\n\n\n\n\n\nLIM SI YING\n\n\nPL4\n\n\nsoctf-pl4-017\n\n\n\n\n\n\nLIM TING WEI\n\n\nPL4\n\n\nsoctf-pl4-018\n\n\n\n\n\n\nLIM WEN HAN, EUGENE\n\n\nPL4\n\n\nsoctf-pl4-019\n\n\n\n\n\n\nLIM YAN TING\n\n\nPL4\n\n\nsoctf-pl4-020\n\n\n\n\n\n\nLIN JIAYUE\n\n\nPL4\n\n\nsoctf-pl4-021\n\n\n\n\n\n\nLING WEN JIAN\n\n\nPL4\n\n\nsoctf-pl4-022\n\n\n\n\n\n\nLIU JINGXUAN\n\n\nPL4\n\n\nsoctf-pl4-023\n\n\n\n\n\n\nLIU PEIZE\n\n\nPL5\n\n\nsoctf-pl5-003\n\n\n\n\n\n\nLIU SHIRU\n\n\nPL5\n\n\nsoctf-pl5-004\n\n\n\n\n\n\nLIU SONGTAO\n\n\nPL5\n\n\nsoctf-pl5-005\n\n\n\n\n\n\nLIU WEI JIE NICHOLAS\n\n\nPL5\n\n\nsoctf-pl5-006\n\n\n\n\n\n\nLOH CHING WEI, JOSHUA\n\n\nPL5\n\n\nsoctf-pl5-007\n\n\n\n\n\n\nLOH YONG ZEE\n\n\nPL5\n\n\nsoctf-pl5-008\n\n\n\n\n\n\nLOW EE TER\n\n\nPL5\n\n\nsoctf-pl5-009\n\n\n\n\n\n\nLOW JIA YEE\n\n\nPL5\n\n\nsoctf-pl5-010\n\n\n\n\n\n\nLOW SIU YUAN, FRANCIS\n\n\nPL5\n\n\nsoctf-pl5-012\n\n\n\n\n\n\nLUCAS FOO SOO QUAN\n\n\nPL5\n\n\nsoctf-pl5-013\n\n\n\n\n\n\nLYE JUN WEI ANANDA\n\n\nPL5\n\n\nsoctf-pl5-014\n\n\n\n\n\n\nMARC PHUA HSIAO MENG\n\n\nPL5\n\n\nsoctf-pl5-015\n\n\n\n\n\n\nMATTHEW NATHANAEL SUGIRI\n\n\nPL5\n\n\nsoctf-pl5-016\n\n\n\n\n\n\nMERVIN WEE MINGWEN\n\n\nPL5\n\n\nsoctf-pl5-017\n\n\n\n\n\n\nMICHELLE TOH HUI PING\n\n\nPL5\n\n\nsoctf-pl5-019\n\n\n\n\n\n\nMODAK SHANTANU BHARAT\n\n\nPL5\n\n\nsoctf-pl5-020\n\n\n\n\n\n\nMOHAMED RIYAS\n\n\nPL5\n\n\nsoctf-pl5-021\n\n\n\n\n\n\nMOHAMMAD YOUSUF MINHAJ ZIA\n\n\nPL5\n\n\nsoctf-pl5-022\n\n\n\n\n\n\nMUHAMMAD FAIRUZ B AMIRHAMZAH\n\n\nPL5\n\n\nsoctf-pl5-023\n\n\n\n\n\n\nMUHAMMAD HOZEFA ZUMKHAWALA\n\n\nPL6\n\n\nsoctf-pl6-003\n\n\n\n\n\n\nMUHAMMAD SHOLIHIN BIN KAMARUDIN\n\n\nPL6\n\n\nsoctf-pl6-004\n\n\n\n\n\n\nMUHHAMMAD NUR HAFIDZ BIN HUSSAIN\n\n\nPL6\n\n\nsoctf-pl6-005\n\n\n\n\n\n\nNATHAN YEO KEE HERN\n\n\nPL6\n\n\nsoctf-pl6-006\n\n\n\n\n\n\nNEO WEN HUI\n\n\nPL6\n\n\nsoctf-pl6-007\n\n\n\n\n\n\nNG JIE WU\n\n\nPL6\n\n\nsoctf-pl6-008\n\n\n\n\n\n\nNG JING KANG\n\n\nPL6\n\n\nsoctf-pl6-009\n\n\n\n\n\n\nNG JING KIAT\n\n\nPL6\n\n\nsoctf-pl6-010\n\n\n\n\n\n\nNG SHI QI, CARRIE\n\n\nPL6\n\n\nsoctf-pl6-011\n\n\n\n\n\n\nNG SIU HIAN\n\n\nPL6\n\n\nsoctf-pl6-012\n\n\n\n\n\n\nNG WEE KIAT\n\n\nPL6\n\n\nsoctf-pl6-013\n\n\n\n\n\n\nNG WEI JIE, BRANDON\n\n\nPL6\n\n\nsoctf-pl6-014\n\n\n\n\n\n\nNG ZI HUI\n\n\nPL6\n\n\nsoctf-pl6-015\n\n\n\n\n\n\nNGAN JI CHENG\n\n\nPL6\n\n\nsoctf-pl6-016\n\n\n\n\n\n\nNGUYEN THANH DUC\n\n\nPL6\n\n\nsoctf-pl6-017\n\n\n\n\n\n\nNGUYEN TIEN DAT\n\n\nPL6\n\n\nsoctf-pl6-018\n\n\n\n\n\n\nNIGEL TAN\n\n\nPL6\n\n\nsoctf-pl6-019\n\n\n\n\n\n\nNIGELLE LEO YUWEN\n\n\nPL6\n\n\nsoctf-pl6-020\n\n\n\n\n\n\nNISHANTH ELANGO\n\n\nPL6\n\n\nsoctf-pl6-021\n\n\n\n\n\n\nNYAN WUN PAING\n\n\nPL6\n\n\nsoctf-pl6-022\n\n\n\n\n\n\nOEI CHIU YAN REBECCA\n\n\nPL6\n\n\nsoctf-pl6-023\n\n\n\n\n\n\nONG YU XUAN\n\n\nPL6\n\n\nsoctf-pl6-024\n\n\n\n\n\n\nOUNG YONG SHENG KENNEDY\n\n\nPL6\n\n\nsoctf-pl6-025\n\n\n\n\n\n\nOW ZHENG KUAN\n\n\nPL6\n\n\nsoctf-pl6-026\n\n\n\n\n\n\nP PRADEEP\n\n\nPL6\n\n\nsoctf-pl6-027\n\n\n\n\n\n\nPANG JIA JUN VERNON\n\n\nPL6\n\n\nsoctf-pl6-030\n\n\n\n\n\n\nPARK SO HYUN\n\n\nPL6\n\n\nsoctf-pl6-031\n\n\n\n\n\n\nPARMAR VARUN SAMIR\n\n\nPL6\n\n\nsoctf-pl6-032\n\n\n\n\n\n\nPARVATHI RANJITH MENON\n\n\nESLab 1\n\n\npc2\n\n\n\n\n\n\nPATWARI RISHAB\n\n\nESLab 1\n\n\npc3\n\n\n\n\n\n\nPEI YAN BO\n\n\nESLab 1\n\n\npc5\n\n\n\n\n\n\nPHOON JIA JUIN\n\n\nESLab 1\n\n\npc6\n\n\n\n\n\n\nPOH CHOO LEONG, LINSTON\n\n\nESLab 1\n\n\npc8\n\n\n\n\n\n\nPONG LOONG BOB\n\n\nESLab 1\n\n\npc9\n\n\n\n\n\n\nPOON KAH ONN, BENJAMIN\n\n\nESLab 1\n\n\npc11\n\n\n\n\n\n\nPOW JING YONG\n\n\nESLab 1\n\n\npc12\n\n\n\n\n\n\nQIAN JIE\n\n\nESLab 1\n\n\npc13\n\n\n\n\n\n\nQUAH YOU JING KANE\n\n\nESLab 1\n\n\npc14\n\n\n\n\n\n\nQUEK AIK PENG\n\n\nESLab 1\n\n\npc15\n\n\n\n\n\n\nRAGHAV BHARDWAJ\n\n\nESLab 1\n\n\npc16\n\n\n\n\n\n\nRAJAMOHAN B PRIYAN\n\n\nESLab 1\n\n\npc17\n\n\n\n\n\n\nRAVEENDRAN AJEY ASHOK\n\n\nESLab 1\n\n\npc18\n\n\n\n\n\n\nRISHI MAHADEVAN\n\n\nESLab 1\n\n\npc19\n\n\n\n\n\n\nRUSDI HAIZIM B RAHIM\n\n\nESLab 1\n\n\npc20\n\n\n\n\n\n\nRYAN TAN YU\n\n\nESLab 1\n\n\npc21\n\n\n\n\n\n\nSAI GANESH SURESH\n\n\nESLab 1\n\n\npc22\n\n\n\n\n\n\nSCOTT FLOYD ZHEN-YAN SMAHON\n\n\nESLab 1\n\n\npc23\n\n\n\n\n\n\nSEE SHENG CHAO\n\n\nWSLab 2\n\n\nws2-004\n\n\n\n\n\n\nSENTHIL ARAAVIND\n\n\nESLab 2\n\n\npc2\n\n\n\n\n\n\nSHA LONG\n\n\nESLab 2\n\n\npc3\n\n\n\n\n\n\nSHANNON LEE\n\n\nESLab 2\n\n\npc5\n\n\n\n\n\n\nSHAWN WONG JUN KIT\n\n\nWSLab 2\n\n\nws2-003\n\n\n\n\n\n\nSHRIYA SAXENA\n\n\nESLab 2\n\n\npc8\n\n\n\n\n\n\nSIM YU JIE\n\n\nESLab 2\n\n\npc9\n\n\n\n\n\n\nSITI NADIAH BINTE MOHAMED RAMLI\n\n\nESLab 2\n\n\npc11\n\n\n\n\n\n\nSUTHER DAVID SAMUEL\n\n\nESLab 2\n\n\npc12\n\n\n\n\n\n\nTALAGADADIVI DURGA RUKMINI MANASWINI\n\n\nESLab 2\n\n\npc13\n\n\n\n\n\n\nTAM WEI IAN JOSHUA\n\n\nESLab 2\n\n\npc14\n\n\n\n\n\n\nTAN GUAN YEW\n\n\nESLab 2\n\n\npc15\n\n\n\n\n\n\nTAN KAI LI CATHERINE\n\n\nESLab 2\n\n\npc16\n\n\n\n\n\n\nTAN KOK JOON\n\n\nESLab 2\n\n\npc17\n\n\n\n\n\n\nTAN LI ANN PETER\n\n\nESLab 2\n\n\npc18\n\n\n\n\n\n\nTAN YEH HAN, JOHN\n\n\nESLab 2\n\n\npc19\n\n\n\n\n\n\nTAN YI XIANG\n\n\nESLab 2\n\n\npc20\n\n\n\n\n\n\nTAN ZHENG FU JUSTIN\n\n\nESLab 2\n\n\npc21\n\n\n\n\n\n\nTAN ZHENG WEN\n\n\nESLab 2\n\n\npc22\n\n\n\n\n\n\nTAY JIN WEN\n\n\nESLab 2\n\n\npc23\n\n\n\n\n\n\nTAY JING XUAN\n\n\nESLab 2\n\n\npc24\n\n\n\n\n\n\nTAY TZE-WEI, CALEB\n\n\nWSLab 1\n\n\nws1-004\n\n\n\n\n\n\nTAY YEE EN, RYAN\n\n\nWSLab 1\n\n\nws1-005\n\n\n\n\n\n\nTEH ZI HUAI\n\n\nWSLab 1\n\n\nws1-006\n\n\n\n\n\n\nTEO WEI JIE, SHAUN\n\n\nWSLab 1\n\n\nws1-007\n\n\n\n\n\n\nTOH YING YING JANICE\n\n\nWSLab 1\n\n\nws1-008\n\n\n\n\n\n\nTONG QI WEI\n\n\nWSLab 1\n\n\nws1-009\n\n\n\n\n\n\nTRAN MINH DUONG\n\n\nWSLab 1\n\n\nws1-010\n\n\n\n\n\n\nTRAN QUANG THANH\n\n\nWSLab 1\n\n\nws1-011\n\n\n\n\n\n\nTSHIN QI REN\n\n\nWSLab 1\n\n\nws1-012\n\n\n\n\n\n\nUMAR BIN MOIZ\n\n\nWSLab 1\n\n\nws1-013\n\n\n\n\n\n\nVASAVADA TEJAS SUDHIR\n\n\nWSLab 1\n\n\nws1-014\n\n\n\n\n\n\nVIDHYABHARATHI SOMASUNDARAM\n\n\nWSLab 1\n\n\nws1-015\n\n\n\n\n\n\nVIVIAN LEE BOON GEOK\n\n\nWSLab 1\n\n\nws1-016\n\n\n\n\n\n\nWANG ZICONG\n\n\nWSLab 1\n\n\nws1-017\n\n\n\n\n\n\nWEI FENG\n\n\nWSLab 1\n\n\nws1-018\n\n\n\n\n\n\nWENG KEXIN\n\n\nWSLab 1\n\n\nws1-019\n\n\n\n\n\n\nWONG JIN EN, SHANNON\n\n\nWSLab 1\n\n\nws1-020\n\n\n\n\n\n\nWONG REN-WEI, RYAN\n\n\nWSLab 1\n\n\nws1-021\n\n\n\n\n\n\nXUE ZHENGQING\n\n\nWSLab 1\n\n\nws1-022\n\n\n\n\n\n\nYANG AN QI\n\n\nWSLab 1\n\n\nws1-023\n\n\n\n\n\n\nYANG CHENGLONG\n\n\nWSLab 1\n\n\nws1-024\n\n\n\n\n\n\nYANG KAI ZE\n\n\nWSLab 3\n\n\nws3-004\n\n\n\n\n\n\nYANG ZI YUN\n\n\nWSLab 3\n\n\nws3-005\n\n\n\n\n\n\nYAP JIN FA\n\n\nWSLab 3\n\n\nws3-006\n\n\n\n\n\n\nYAP KESIN\n\n\nWSLab 3\n\n\nws3-007\n\n\n\n\n\n\nYE GUOQUAN\n\n\nWSLab 3\n\n\nws3-008\n\n\n\n\n\n\nYE TONG\n\n\nWSLab 3\n\n\nws3-009\n\n\n\n\n\n\nYEN PEI CHIH\n\n\nWSLab 3\n\n\nws3-010\n\n\n\n\n\n\nYEW JING HUI\n\n\nWSLab 3\n\n\nws3-011\n\n\n\n\n\n\nYU XIAOXUE\n\n\nWSLab 3\n\n\nws3-012\n\n\n\n\n\n\nYUAN JIAYI\n\n\nWSLab 3\n\n\nws3-013\n\n\n\n\n\n\nYUE JUN YI\n\n\nWSLab 3\n\n\nws3-014\n\n\n\n\n\n\nZHANG SHIYU\n\n\nWSLab 3\n\n\nws3-015\n\n\n\n\n\n\nZHANG YIHAN\n\n\nWSLab 3\n\n\nws3-016\n\n\n\n\n\n\nZHANG YIPING\n\n\nWSLab 3\n\n\nws3-017\n\n\n\n\n\n\nZHANG YUE HAN\n\n\nWSLab 3\n\n\nws3-018\n\n\n\n\n\n\nZHAO PENGFEI\n\n\nWSLab 3\n\n\nws3-019\n\n\n\n\n\n\nZHAO TIANQI\n\n\nWSLab 3\n\n\nws3-020\n\n\n\n\n\n\nZHENG KAINING\n\n\nWSLab 3\n\n\nws3-021\n\n\n\n\n\n\nZHU BO\n\n\nWSLab 3\n\n\nws3-022\n\n\n\n\n\n\nZHU YIJIE\n\n\nWSLab 3\n\n\nws3-023\n\n\n\n\n\n\nZOE WONG XIN LEI\n\n\nWSLab 3\n\n\nws3-024",
            "title": "Info About PE1"
        },
        {
            "location": "/pe1/index.html#practice-exam-1",
            "text": "",
            "title": "Practice Exam 1"
        },
        {
            "location": "/pe1/index.html#questions",
            "text": "Exam Paper  Click on  GitHub Link  to accept, run  get-pe01  and  submit-pe01  to solve this like any other assignments.",
            "title": "Questions"
        },
        {
            "location": "/pe1/index.html#basic-info",
            "text": "Date: 6 October, 2018 (Saturday)  Time: 9am to 12noon  Venue: Various programming labs  Scope: Units 1-12, Assignments 1-2, Tutorials 1-4  4 to  5 programming questions, very easy to hard   Criteria: Correctness and Style. One mark is allocated for programming style for each question.   Duration: 2 hours and 30 minutes  Open Book (You can bring analog references)",
            "title": "Basic Info"
        },
        {
            "location": "/pe1/index.html#lab-allocation",
            "text": "Every student is assigned to a programming lab.    Please see the allocation below.  You should acclimatize yourself to the use of the PC desktops in the lab assigned to you.  Special access has been given to students assigned to ES Lab 1 and 2 (Embedded System Teaching Lab 1 and 2)  Here are the  locatons for the respective labs",
            "title": "Lab Allocation"
        },
        {
            "location": "/pe1/index.html#special-restrictions",
            "text": "You will be issued a special account on the PE day to solve the exam questions.      There will be no Internet access.",
            "title": "Special Restrictions"
        },
        {
            "location": "/pe1/index.html#vim-configuration",
            "text": "Your default account will have the same  .vimrc  as  ~cs1010/.vimrc  on the CS1010 PE hosts.    You are free to edit this during the practical exams.    You, however, will not be able to download nor install  vim  plugins.",
            "title": "Vim Configuration"
        },
        {
            "location": "/pe1/index.html#czjqqkd4general-adviceczjqqkd5",
            "text": "Save your program regularly.  We will use setup every account with  ~/.vimrc  copied from  ~cs1010/.vimrc .  Thus, you can find the last saved version of your files under  ~/.backup  if you accidentally deleted your code.  Plan your time properly.  Do not spend excessive time on any task.  Read through all questions and solved those that you are confident to solve first.  There are five questions, from very easy to very hard.  Solve as many as you can.  I expect most students will be able to solve 3 out of the 5 questions within the time limit.  There is one mark allocated to style for each question.  As long as you keep your code clean, neat, and readable, you will get this one mark, almost for free.  Review the CS1010 style guide so that you know what is expected in terms of coding style.  Don't start typing your code right away.  Think about the solution first -- what variables are needed?  what is the control flow (using branches and loops)?  Draw out the flowchart if it helps.    Break down the problem into smaller ones if the problem is too complex to solve.  You are not allowed to start typing on the computer for the first 10 minutes of the practical exam, or until the invigilator announced that you can do so.  You will be given a question form to ask questions to clarify doubts about the question paper.  But note that you can only ask a boolean question (YES/NO answer).  Just like the assignments, you are not given all the test cases that we will be using during grading.  Please test your code against additional test cases, especially for boundary cases.",
            "title": "General Advice"
        },
        {
            "location": "/pe1/index.html#lab-and-seat-allocation",
            "text": "NAME  Venue  Seat Number      AARUSHI SINGH  PL1  soctf-imac215-002    ADELYN KOH JING YING  PL1  soctf-imac215-003    AHMAD MUDAAFI' B ZAINUDDIN  PL1  soctf-imac215-004    AI ZHENGWEI  PL1  soctf-imac215-005    ALEX TEO KANG JIE  PL1  soctf-imac215-008    AMIR AZHAR B AZIZAN  PL1  soctf-imac215-009    ANDREW LAU JIA JUN  PL1  soctf-imac215-010    ANG KENG SIANG  PL1  soctf-imac215-011    ANG KIANG YANG  PL1  soctf-imac215-012    AW CHIAN HAO  PL1  soctf-imac215-013    BALAM SAI ROHIT REDDY  PL1  soctf-imac215-014    BEATRICE CHAN TONG  PL1  soctf-imac215-015    BENEDICT YU CHENG EN  PL1  soctf-imac215-016    BENJAMIN CHIA SHAN HONG  PL1  soctf-imac215-017    CAI RONG  PL1  soctf-imac215-019    CHAN EE ZHENG, BENJAMIN  PL1  soctf-imac215-020    CHAN HIN, SEAN  PL1  soctf-imac215-021    CHAN WEI FONG, MAX  PL1  soctf-imac215-022    CHAN YEE CHONG PHILIP  PL1  soctf-imac215-023    CHAN YEW CHUN DANIEL  PL1  soctf-imac215-024    CHAN ZHI ZHENG, AMOS  PL1  soctf-imac215-025    CHANG HUI ZHEN  PL1  soctf-imac215-026    CHANG ZHONG KAI  PL1  soctf-imac215-027    CHEN CHAO  PL1  soctf-imac215-028    CHEN TONG  PL1  soctf-imac215-029    CHENG LE DA, CLEMENT  PL1  soctf-imac215-030    CHENG WANYIN  PL1  soctf-imac215-031    CHENG WEIXUAN  PL1  soctf-imac215-032    CHERYL NG YUN LIN  PL1  soctf-imac215-033    CHEW JUN KONG  PL1  soctf-imac215-034    CHIA BIING HANN  PL1  soctf-imac215-035    CHNG XIAN YI  WSLab 3  ws3-002    CHOI WONJAE  PL1  soctf-imac215-037    CHU JUI HUNG @JEFFERSON CHU  PL1  soctf-imac215-038    CHUA MAI FENG, CARL  PL1  soctf-imac215-039    CHUA WEN XUAN  PL1  soctf-imac215-040    CHUA ZONG WEI  PL1  soctf-imac215-043    CLAIRE CHAN YEN HWA  PL1  soctf-imac215-044    CYNTHIA LEE WENG YAN  PL1  soctf-imac215-045    DANIEL TAN WEE LIANG  PL2  soctf-pl2-002    DANISH B EDDIE  PL2  soctf-pl2-003    DARREN ONG  PL2  soctf-pl2-004    DEBBIE TAN JIA MIN  PL2  soctf-pl2-005    DING NING  PL2  soctf-pl2-006    DIVAKARAN HARITHA  PL2  soctf-pl2-007    EDMUND TEO WEI XIN  PL2  soctf-pl2-009    EU JING SEN  PL2  soctf-pl2-010    EVELYN YI-WEN CHEN  PL2  soctf-pl2-011    FATIN NABILAH BTE SUHAIMI  PL2  soctf-pl2-012    FOO CHI HEN  PL2  soctf-pl2-013    GINA QUAH JIE XI  PL2  soctf-pl2-014    GLEN WONG SHU ZE  PL2  soctf-pl2-016    GOH RUI PING SAMANTHA  PL2  soctf-pl2-017    GOH ZHEN HAO JOEY  PL2  soctf-pl2-018    GONDHALEKAR SUKRUT YOGESH  PL2  soctf-pl2-019    GREGORY TAN WEI YUAN  PL2  soctf-pl2-020    GUI XIXIAN  PL2  soctf-pl2-021    GUO HAOREN  PL2  soctf-pl2-022    HANS KURNIA WIDJAJA  PL2  soctf-pl2-023    HAO YUN  PL2  soctf-pl2-024    HASHIR ZAHIR  PL2  soctf-pl2-025    HENG HONG CHUAN  PL2  soctf-pl2-026    HO JING YANG DANIEL  PL2  soctf-pl2-028    HO SI SHI ANNETTE  PL2  soctf-pl2-029    HO WEI BIN, JERRY  PL2  soctf-pl2-030    HU XINYING  PL2  soctf-pl2-031    HUANG XUANKUN  PL2  soctf-pl2-032    IAN CHUA  PL2  soctf-pl2-033    ISABELLA CHEONG XIAO XUAN  PL2  soctf-pl2-035    IVAN ANDIKA LIE  PL2  soctf-pl2-036    JANEL ANG YEE HUEY  PL2  soctf-pl2-037    JASON SATHYA CITRO  PL2  soctf-pl2-038    JASPER ONG SHAO YONG  PL2  soctf-pl2-039    JAZHTEN LOW YONGSHEN  PL2  soctf-pl2-040    JERRY ZHANG ZHUORAN  PL2  soctf-pl2-042    JESS TEO XI ZHI  PL2  soctf-pl2-043    JOEL CHANG ZHI KAI  PL2  soctf-pl2-044    JOHN CUTHBERT KHOO TENG FONG  PL2  soctf-pl2-045    JOSEPH WONG YEFENG  PL2  soctf-pl2-046    JUSTIN CHIA JIA JIN  PL3  soctf-pl3-001    K ALAGES  PL3  soctf-pl3-002    KARAN SARAT  PL3  soctf-pl3-003    KARNATI SAI ABHISHEK  PL3  soctf-pl3-005    KEE KAH LOK  PL3  soctf-pl3-006    KEITH CHAN JUN KAI  PL3  soctf-pl3-007    KELVIN HARRIS  PL3  soctf-pl3-009    KEVIN PUTERA  PL3  soctf-pl3-010    KEZIA KEW KAI YUN  PL3  soctf-pl3-011    KHAIRUL IMAN NASRI B AZHARIE  PL3  soctf-pl3-013    KHOO TZE YANG RAYSON  PL3  soctf-pl3-014    KISHORE R  PL3  soctf-pl3-015    KWOK KUIN EK JEREMY  PL3  soctf-pl3-016    KYAWT KYAWT SAN  PL3  soctf-pl3-017    LAI WEN XUAN JEREMY  PL3  soctf-pl3-018    LAM TIAN WEI JUSTIN  PL3  soctf-pl3-019    LE HONG LONG  PL3  soctf-pl3-020    LEE HONG CHIEN, KENNETH  PL3  soctf-pl3-021    LEE LI XIN  WSLab 3  ws3-003    LEE RAIYAN BIN ZULKIFLI  PL3  soctf-pl3-023    LEE WEI HERN, JASON  PL3  soctf-pl3-025    LEE YUEYU  PL3  soctf-pl3-026    LEE ZHEN YU  PL4  soctf-pl4-002    LEOW YONG HENG  PL4  soctf-pl4-003    LEOW YONG KANG ANDREW  PL4  soctf-pl4-004    LI JIAYU  PL4  soctf-pl4-005    LI ZIHAN  PL4  soctf-pl4-006    LIAO LIXIN  PL4  soctf-pl4-007    LIAO TIANCHANG  PL4  soctf-pl4-008    LIM CHEE SENG BRIAN  PL4  soctf-pl4-009    LIM CHEK JUN  PL4  soctf-pl4-010    LIM CHENG YIN, RYAN  PL4  soctf-pl4-011    LIM HAO XIANG, SEAN  PL4  soctf-pl4-012    LIM JIA WEI  PL4  soctf-pl4-013    LIM JIAYI, TAMELLY  PL4  soctf-pl4-014    LIM JUN KUANG, LIONEL  PL4  soctf-pl4-015    LIM LI LINCOLN  PL4  soctf-pl4-016    LIM SI YING  PL4  soctf-pl4-017    LIM TING WEI  PL4  soctf-pl4-018    LIM WEN HAN, EUGENE  PL4  soctf-pl4-019    LIM YAN TING  PL4  soctf-pl4-020    LIN JIAYUE  PL4  soctf-pl4-021    LING WEN JIAN  PL4  soctf-pl4-022    LIU JINGXUAN  PL4  soctf-pl4-023    LIU PEIZE  PL5  soctf-pl5-003    LIU SHIRU  PL5  soctf-pl5-004    LIU SONGTAO  PL5  soctf-pl5-005    LIU WEI JIE NICHOLAS  PL5  soctf-pl5-006    LOH CHING WEI, JOSHUA  PL5  soctf-pl5-007    LOH YONG ZEE  PL5  soctf-pl5-008    LOW EE TER  PL5  soctf-pl5-009    LOW JIA YEE  PL5  soctf-pl5-010    LOW SIU YUAN, FRANCIS  PL5  soctf-pl5-012    LUCAS FOO SOO QUAN  PL5  soctf-pl5-013    LYE JUN WEI ANANDA  PL5  soctf-pl5-014    MARC PHUA HSIAO MENG  PL5  soctf-pl5-015    MATTHEW NATHANAEL SUGIRI  PL5  soctf-pl5-016    MERVIN WEE MINGWEN  PL5  soctf-pl5-017    MICHELLE TOH HUI PING  PL5  soctf-pl5-019    MODAK SHANTANU BHARAT  PL5  soctf-pl5-020    MOHAMED RIYAS  PL5  soctf-pl5-021    MOHAMMAD YOUSUF MINHAJ ZIA  PL5  soctf-pl5-022    MUHAMMAD FAIRUZ B AMIRHAMZAH  PL5  soctf-pl5-023    MUHAMMAD HOZEFA ZUMKHAWALA  PL6  soctf-pl6-003    MUHAMMAD SHOLIHIN BIN KAMARUDIN  PL6  soctf-pl6-004    MUHHAMMAD NUR HAFIDZ BIN HUSSAIN  PL6  soctf-pl6-005    NATHAN YEO KEE HERN  PL6  soctf-pl6-006    NEO WEN HUI  PL6  soctf-pl6-007    NG JIE WU  PL6  soctf-pl6-008    NG JING KANG  PL6  soctf-pl6-009    NG JING KIAT  PL6  soctf-pl6-010    NG SHI QI, CARRIE  PL6  soctf-pl6-011    NG SIU HIAN  PL6  soctf-pl6-012    NG WEE KIAT  PL6  soctf-pl6-013    NG WEI JIE, BRANDON  PL6  soctf-pl6-014    NG ZI HUI  PL6  soctf-pl6-015    NGAN JI CHENG  PL6  soctf-pl6-016    NGUYEN THANH DUC  PL6  soctf-pl6-017    NGUYEN TIEN DAT  PL6  soctf-pl6-018    NIGEL TAN  PL6  soctf-pl6-019    NIGELLE LEO YUWEN  PL6  soctf-pl6-020    NISHANTH ELANGO  PL6  soctf-pl6-021    NYAN WUN PAING  PL6  soctf-pl6-022    OEI CHIU YAN REBECCA  PL6  soctf-pl6-023    ONG YU XUAN  PL6  soctf-pl6-024    OUNG YONG SHENG KENNEDY  PL6  soctf-pl6-025    OW ZHENG KUAN  PL6  soctf-pl6-026    P PRADEEP  PL6  soctf-pl6-027    PANG JIA JUN VERNON  PL6  soctf-pl6-030    PARK SO HYUN  PL6  soctf-pl6-031    PARMAR VARUN SAMIR  PL6  soctf-pl6-032    PARVATHI RANJITH MENON  ESLab 1  pc2    PATWARI RISHAB  ESLab 1  pc3    PEI YAN BO  ESLab 1  pc5    PHOON JIA JUIN  ESLab 1  pc6    POH CHOO LEONG, LINSTON  ESLab 1  pc8    PONG LOONG BOB  ESLab 1  pc9    POON KAH ONN, BENJAMIN  ESLab 1  pc11    POW JING YONG  ESLab 1  pc12    QIAN JIE  ESLab 1  pc13    QUAH YOU JING KANE  ESLab 1  pc14    QUEK AIK PENG  ESLab 1  pc15    RAGHAV BHARDWAJ  ESLab 1  pc16    RAJAMOHAN B PRIYAN  ESLab 1  pc17    RAVEENDRAN AJEY ASHOK  ESLab 1  pc18    RISHI MAHADEVAN  ESLab 1  pc19    RUSDI HAIZIM B RAHIM  ESLab 1  pc20    RYAN TAN YU  ESLab 1  pc21    SAI GANESH SURESH  ESLab 1  pc22    SCOTT FLOYD ZHEN-YAN SMAHON  ESLab 1  pc23    SEE SHENG CHAO  WSLab 2  ws2-004    SENTHIL ARAAVIND  ESLab 2  pc2    SHA LONG  ESLab 2  pc3    SHANNON LEE  ESLab 2  pc5    SHAWN WONG JUN KIT  WSLab 2  ws2-003    SHRIYA SAXENA  ESLab 2  pc8    SIM YU JIE  ESLab 2  pc9    SITI NADIAH BINTE MOHAMED RAMLI  ESLab 2  pc11    SUTHER DAVID SAMUEL  ESLab 2  pc12    TALAGADADIVI DURGA RUKMINI MANASWINI  ESLab 2  pc13    TAM WEI IAN JOSHUA  ESLab 2  pc14    TAN GUAN YEW  ESLab 2  pc15    TAN KAI LI CATHERINE  ESLab 2  pc16    TAN KOK JOON  ESLab 2  pc17    TAN LI ANN PETER  ESLab 2  pc18    TAN YEH HAN, JOHN  ESLab 2  pc19    TAN YI XIANG  ESLab 2  pc20    TAN ZHENG FU JUSTIN  ESLab 2  pc21    TAN ZHENG WEN  ESLab 2  pc22    TAY JIN WEN  ESLab 2  pc23    TAY JING XUAN  ESLab 2  pc24    TAY TZE-WEI, CALEB  WSLab 1  ws1-004    TAY YEE EN, RYAN  WSLab 1  ws1-005    TEH ZI HUAI  WSLab 1  ws1-006    TEO WEI JIE, SHAUN  WSLab 1  ws1-007    TOH YING YING JANICE  WSLab 1  ws1-008    TONG QI WEI  WSLab 1  ws1-009    TRAN MINH DUONG  WSLab 1  ws1-010    TRAN QUANG THANH  WSLab 1  ws1-011    TSHIN QI REN  WSLab 1  ws1-012    UMAR BIN MOIZ  WSLab 1  ws1-013    VASAVADA TEJAS SUDHIR  WSLab 1  ws1-014    VIDHYABHARATHI SOMASUNDARAM  WSLab 1  ws1-015    VIVIAN LEE BOON GEOK  WSLab 1  ws1-016    WANG ZICONG  WSLab 1  ws1-017    WEI FENG  WSLab 1  ws1-018    WENG KEXIN  WSLab 1  ws1-019    WONG JIN EN, SHANNON  WSLab 1  ws1-020    WONG REN-WEI, RYAN  WSLab 1  ws1-021    XUE ZHENGQING  WSLab 1  ws1-022    YANG AN QI  WSLab 1  ws1-023    YANG CHENGLONG  WSLab 1  ws1-024    YANG KAI ZE  WSLab 3  ws3-004    YANG ZI YUN  WSLab 3  ws3-005    YAP JIN FA  WSLab 3  ws3-006    YAP KESIN  WSLab 3  ws3-007    YE GUOQUAN  WSLab 3  ws3-008    YE TONG  WSLab 3  ws3-009    YEN PEI CHIH  WSLab 3  ws3-010    YEW JING HUI  WSLab 3  ws3-011    YU XIAOXUE  WSLab 3  ws3-012    YUAN JIAYI  WSLab 3  ws3-013    YUE JUN YI  WSLab 3  ws3-014    ZHANG SHIYU  WSLab 3  ws3-015    ZHANG YIHAN  WSLab 3  ws3-016    ZHANG YIPING  WSLab 3  ws3-017    ZHANG YUE HAN  WSLab 3  ws3-018    ZHAO PENGFEI  WSLab 3  ws3-019    ZHAO TIANQI  WSLab 3  ws3-020    ZHENG KAINING  WSLab 3  ws3-021    ZHU BO  WSLab 3  ws3-022    ZHU YIJIE  WSLab 3  ws3-023    ZOE WONG XIN LEI  WSLab 3  ws3-024",
            "title": "Lab and Seat Allocation"
        },
        {
            "location": "/pe1-comments/index.html",
            "text": "PE1: Comments and Answer Keys\n\n\nvote\n\n\nComments\n\n\nThis is supposed to be a very easy, \"give-away\" question, but only 60% of students get full marks for this question.\n\n\nCommon mistakes include:\n\n\n\n\nUsing the wrong type\n.  Some students read integer values as \ndouble\n or read \nlong\n as \nlong long\n. These do not affect the correctness but it does not demonstrate that the students understand the differences between the different types.  There is a -0.5 penalty for each one.   A more serious error involves using \nint\n for the number of votes (-1) or \nlong\n for the percentage (-1).  \n\n\n\n\nInteger division\n.  Some students used integer division when calculating the percentage.  For instance:\n\n1\ndouble\n \npercentage\n \n=\n \n(\nm\n/\n(\nm\n+\nn\n))\n*\n100.0\n;\n\n\n\n\n\n\nThe computation of \nm/(m+n)\n is done entirely as \nlong\n integer.  You need to either cast \nm\n or \nn\n to double, or multiple \n100.0\n (a double) earlier:\n\n1\ndouble\n \npercentage\n \n=\n \n(\nm\n*\n100.0\n/\n(\nm\n+\nn\n));\n\n\n\n\n\n\n\n\n\n\nRedundant Cast\n.  Some studnets do not understand the needs for casting and simply cast everything:\n\n1\ndouble\n \npercentage\n \n=\n \n((\ndouble\n)\nm\n*\n(\ndouble\n)\n100.0\n/\n((\ndouble\n)\nm\n+\n(\ndouble\n)\nn\n));\n\n\n\n\n\n\nI decided not to deduct marks for this, but this is not the right way to write an arithmetic expression!\n\n\n\n\n\n\nRedundant Functions\n.  Some students wrote something like this:\n\n\n1\n2\n3\n4\n5\n6\n7\ndouble\n \npercentage_of_nixon\n(\nlong\n \nnixon\n,\n \nlong\n \ntotal\n)\n \n{\n\n    \nreturn\n \nnixon\n*\n100.0\n/\ntotal\n;\n\n\n}\n\n\n\ndouble\n \npercentage_of_mcneal\n(\nlong\n \nmcneal\n,\n \nlong\n \ntotal\n)\n \n{\n\n    \nreturn\n \nmcneal\n*\n100.0\n/\ntotal\n;\n\n\n}\n\n\n\n\n\n\n\nThis shows that students do not understand that functions are supposed to be reusable that there is only one function needed.  There is a -1 penalty for that.\n\n\n\n\n\n\nMisc.\n  Some students made simple mistakes like printing the numbers without a space in between or print the two numbers on different lines (-0.5), or didn't include the right headers (-1).\n\n\n\n\n\n\nSolution\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n#include\n \n\"cs1010.h\"\n\n\nint\n \nmain\n()\n\n\n{\n\n  \nlong\n \nmcneal\n \n=\n \ncs1010_read_long\n();\n\n  \nlong\n \nnixon\n \n=\n \ncs1010_read_long\n();\n\n  \nlong\n \ntotal\n \n=\n \nmcneal\n \n+\n \nnixon\n;\n\n\n  \ncs1010_print_double\n(\nmcneal\n*\n100.0\n/\ntotal\n);\n\n  \ncs1010_print_string\n(\n\" \"\n);\n\n  \ncs1010_println_double\n(\nnixon\n*\n100.0\n/\ntotal\n);\n\n\n}\n\n\n\n\n\n\n\nnewton\n\n\nComments\n\n\nNewton is another easy question that surprisingly many students are struggling with.  \n\n\n\n\n\n\nNeedless Careless Mistakes\n Many students wrote down the wrong formula for \nf(x)\nf(x)\n or \nf'(x)\nf'(x)\n, which I deduct 1 marks after a facepalm.  \n\n\n\n\n\n\nWrong Type\n Quite a few students read the inputs as \nlong\n instead of \ndouble\n.  There is a 1 mark deduction for this.  A few students used \nfloat\n instead of \ndouble\n.  As I have mentioned, you should never touch \nfloat\n at all, since its precision is \nlame\n low.  If you use \nfloat\n, you would not get the correct answer for some of the test cases due to floating point errors.  There is a 0.5 mark deduction for using \nfloat\n instead of \ndouble\n.\n\n\n\n\n\n\nUninitialized Variable\n There are also a number of students who got the following bugs:\n\n1\n2\n3\n4\n5\ndouble\n \nroot\n;\n\n\nwhile\n \n(\nfabs\n(\nf\n(\na\n,\n \nb\n,\n \nc\n,\n \nd\n,\n \nx\n))\n \n>=\n \n0.000000001\n)\n \n{\n\n  \n:\n\n\n}\n\n\nreturn\n \nroot\n;\n\n\n\n\n\n\nSuppose that the initial guess \nx\n is already close enough to the root, the loop is never entered, and the function returns \nroot\n uninitialized.  The lesson here is that always make sure you cover all possible cases.  Also, please think about what variables do you really need to solve a problem.  In this question, you do not any extra variable -- so \nroot\n is completely unnecessary.  The more variable you used, the more complex your code get, the more likely you introduce bugs into your code, as shown in the example above.\n\n\n\n\n\n\nTerminating Conditions\n Another common mistake is the terminating conditions.  A handful of you wrote something like this:\n    \n1\nwhile\n \n(\nfabs\n(\nf\n(\na\n,\n \nb\n,\n \nc\n,\n \nd\n,\n \nx\n)\n \n>=\n \n0.000000001\n))\n \n{\n\n\n\n\n\n\nHere, the code tries to pass a \ntrue\n or \nfalse\n expression to \nfabs\n, which the compiler warns.  A few of you, instead of fixing the parenthesis, change \nfabs\n to \nabs\n instead to silence the compiler >.<   \n\n\nOther mistakes include not setting the right threshold (some uses 0.001, or 0.00001 -- why oh why?) or use the wrong comparison:\n\n1\nwhile\n \n(\nfabs\n(\nf\n(\na\n,\n \nb\n,\n \nc\n,\n \nd\n,\n \nx\n)\n \n<\n \n0.000000001\n))\n \n{\n\n\n\n\n\n\nSome did not use \nfabs\n at all:\n\n1\nwhile\n \n(\nf\n(\na\n,\n \nb\n,\n \nc\n,\n \nd\n,\n \nx\n)\n \n>=\n \n0.000000001\n)\n \n{\n\n\n\n\n\n\nSome checked if the root is small enough, instead of the value of function is small enough:\n\n1\nwhile\n \n(\nfabs\n(\nx\n)\n \n>=\n \n0.000000001\n)\n \n{\n\n\n\n\n\n\nA small number of students hardcoded the number of steps (e.g., always loop 4 times), which works for the sample but not for the general cases.\n\n\nThere is a one mark deduction for all errors related to terminating conditions.\n\n\nOne strange thing some of you do is to use a \nfor\n loop for this question:\n\n1\nfor\n \n(\nlong\n \ni\n \n=\n \n0\n;\n \nfabs\n(\nx\n)\n \n>=\n \n0.000000001\n;\n \ni\n \n+=\n \n1\n)\n\n\n\n\n\n\nThe loop still terminates correctly, but the variable \ni\n is entirely useless.  No marks are deducted but I should have for not demonstrating that you know which loop to use.\n\n\n\n\n\n\nUse of pow()\n I did not deduct marks for this -- but using \npow\n for squaring and cubing is an overkill.  \npow\n is a general function that works even for floating point exponentiation.  So it is slower.  Some of you even wrote \npow(x, 1)\n and \npow(x, 0)\n.  Marks would have been deducted if efficiency is a criterion.\n\n\n\n\n\n\nAnswer\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n#include\n \n\"cs1010.h\"\n\n\n#include\n \n<math.h>\n\n\n\ndouble\n \nf\n(\ndouble\n \na\n,\n \ndouble\n \nb\n,\n \ndouble\n \nc\n,\n \ndouble\n \nd\n,\n \ndouble\n \nx\n)\n \n{\n\n  \nreturn\n \na\n*\nx\n*\nx\n*\nx\n \n+\n \nb\n*\nx\n*\nx\n \n+\n \nc\n*\nx\n \n+\n \nd\n;\n\n\n}\n\n\n\ndouble\n \nfp\n(\ndouble\n \na\n,\n \ndouble\n \nb\n,\n \ndouble\n \nc\n,\n \ndouble\n \nx\n)\n \n{\n\n  \nreturn\n \n3\n*\na\n*\nx\n*\nx\n \n+\n \n2\n*\nb\n*\nx\n \n+\n \nc\n;\n\n\n}\n\n\n\ndouble\n \nfind_root\n(\ndouble\n \na\n,\n \ndouble\n \nb\n,\n \ndouble\n \nc\n,\n \ndouble\n \nd\n,\n \ndouble\n \nx\n)\n \n{\n\n  \ndouble\n \nfx\n \n=\n \nf\n(\na\n,\n \nb\n,\n \nc\n,\n \nd\n,\n \nx\n);\n\n  \nwhile\n \n(\nfabs\n(\nfx\n)\n \n>=\n \n0.000000001\n)\n \n{\n\n    \ndouble\n \nfpx\n \n=\n \nfp\n(\na\n,\n \nb\n,\n \nc\n,\n \nx\n);\n\n    \nx\n \n-=\n \nfx\n/\nfpx\n;\n\n    \nfx\n \n=\n \nf\n(\na\n,\n \nb\n,\n \nc\n,\n \nd\n,\n \nx\n);\n\n  \n}\n\n  \nreturn\n \nx\n;\n\n\n}\n\n\n\nint\n \nmain\n()\n\n\n{\n\n  \ndouble\n \na\n \n=\n \ncs1010_read_double\n();\n\n  \ndouble\n \nb\n \n=\n \ncs1010_read_double\n();\n\n  \ndouble\n \nc\n \n=\n \ncs1010_read_double\n();\n\n  \ndouble\n \nd\n \n=\n \ncs1010_read_double\n();\n\n  \ndouble\n \nx\n \n=\n \ncs1010_read_double\n();\n\n\n  \nx\n \n=\n \nfind_root\n(\na\n,\n \nb\n,\n \nc\n,\n \nd\n,\n \nx\n);\n\n\n  \ncs1010_println_double\n(\nx\n);\n\n\n}\n\n\n\n\n\n\n\nGoldbach\n\n\nComments\n\n\nThis question is a little bit more tricky than \nnewton\n, but not much.  \n\n\n\n\n\n\nChecking For Prime\n The disappointing thing is that, even though you have gone through an exercise and an assignment that involves checking if a number is prime, with the solution given comparing different approaches, many of you still wrote the wrong function for checking prime, uses the wrong type, or wrote the slow version.  Since I deducted one mark for each bug, an incorrect \nis_prime\n might cost you 1-3 marks.  This is entirely unnecessary >.<\n\n\nTry to see if you can spot the bugs and why it fails in each of the following.  This is a good exam question that I might ask in a future semester -- don't tell your junior \nshush\n.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nbool\n \nis_prime\n(\nlong\n \nn\n)\n\n\n{\n\n  \nfor\n \n(\nlong\n \ni\n \n=\n \n1\n;\n \ni\n \n<=\n \nsqrt\n(\nn\n);\n \ni\n++\n)\n \n{\n\n    \nif\n \n(\nn\n \n%\n \ni\n \n==\n \n0\n)\n \n{\n\n      \nreturn\n \nfalse\n;\n\n    \n}\n\n  \n}\n\n  \nreturn\n \ntrue\n;\n\n\n}\n\n\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nbool\n \nis_prime\n(\nlong\n \nn\n)\n\n\n{\n\n  \nfor\n \n(\nlong\n \ni\n \n=\n \n2\n;\n \ni\n \n<\n \nsqrt\n(\nn\n);\n \ni\n++\n)\n \n{\n\n    \nif\n \n(\nn\n \n%\n \ni\n \n==\n \n0\n)\n \n{\n\n      \nreturn\n \nfalse\n;\n\n    \n}\n\n  \n}\n\n  \nreturn\n \ntrue\n;\n\n\n}\n\n\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nbool\n \nis_prime\n(\nlong\n \nn\n)\n\n\n{\n\n  \nfor\n \n(\nlong\n \ni\n \n=\n \n2\n;\n \ni\n \n<=\n \nceil\n(\nsqrt\n(\nn\n));\n \ni\n++\n)\n \n{\n\n    \nif\n \n(\nn\n \n%\n \ni\n \n==\n \n0\n)\n \n{\n\n      \nreturn\n \nfalse\n;\n\n    \n}\n\n  \n}\n\n  \nreturn\n \ntrue\n;\n\n\n}\n\n\n\n\n\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\nbool\n \nis_prime\n(\nlong\n \nn\n)\n\n\n{\n\n  \nfor\n \n(\nlong\n \ni\n \n=\n \n2\n;\n \ni\n \n<=\n \nsqrt\n(\nn\n);\n \ni\n++\n)\n \n{\n\n    \nif\n \n(\nn\n \n%\n \ni\n \n==\n \n0\n)\n \n{\n\n      \nreturn\n \nfalse\n;\n\n    \n}\n \nelse\n \n{\n\n      \nreturn\n \ntrue\n;\n\n    \n}\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\n\n\n\n\nAnother common mistake related to checking of prime is that the function should return a \nbool\n (since a number is either a prime or not).  Some students returned an integer from this function.  I deducted one mark for not demonstrating an understanding of boolean functions.\n\n\n\n\n\n\nUnnecessary Loops\n  This is another strange but common code that you have written.  I did not deduct marks since efficiency is not a criterion for PE1 -- but I am puzzled why you write code like this. \n\n\nLet's say I ask you this question: 31 plus what equals to 100?  Any primary school students can tell you, take 100, subtract 31, you get 69.  So 31 + 69 = 100.   \n\n\nThis is not many of you do to find the answer.  What you do is equivalent to:\n\n\n1\n2\n3\n4\n5\nfor\n \n(\nj\n \n=\n \n1\n;\n \nj\n \n<=\n \n100\n;\n \nj\n \n+=\n \n1\n)\n \n{\n\n  \nif\n \n(\n31\n \n+\n \nj\n \n==\n \n100\n)\n \n{\n\n    \ncs1010_println_long\n(\nj\n);\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\nEssentially, checking is 31 + 1 equal to 100?  is 31 + 2 equals to 100? etc. until you find an answer.  After that, you continue to check, is 31 + 70 equals to 100? is 31 + 71 equal to 100? and so on.\n\n\nThis is just silly >.<\n\n\nIn the context of \ngoldbach\n, the code you wrote is:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\nfor\n \n(\nlong\n \ni\n \n=\n \n0\n;\n \ni\n \n<=\n \nn\n/\n2\n;\n \ni\n \n+=\n \n1\n)\n \n{\n\n  \nif\n \n(\nis_prime\n(\ni\n))\n \n{\n\n    \nfor\n \n(\nlong\n \nj\n \n=\n \n0\n;\n \nj\n \n<\n \nn\n;\n \nj\n \n+=\n \n1\n)\n \n{\n\n      \nif\n \n(\ni\n \n+\n \nj\n \n==\n \nn\n)\n \n{\n\n        \nif\n \n(\nis_prime\n(\nj\n))\n \n{\n\n           \ncount\n \n+=\n \n1\n;\n\n        \n}\n\n      \n}\n\n    \n}\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\nCan you see where the silly loop appears above?\n\n\n\n\n\n\nShort Circuiting\n I have shown an example of short-circuiting in class, using exactly checking of prime as an example.  However, some of you still wrote code like the following.  This is another disappointment and I am tempted to deduct marks (but didn't).  The improper use of short-circuiting often occurs with the silly loop to solve \nn - i\n above.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nfor\n \n(\nlong\n \ni\n \n=\n \n0\n;\n \ni\n \n<=\n \nn\n/\n2\n;\n \ni\n \n+=\n \n1\n)\n \n{\n\n  \nif\n \n(\nis_prime\n(\ni\n))\n \n{\n\n    \nfor\n \n(\nlong\n \nj\n \n=\n \n0\n;\n \nj\n \n<\n \nn\n;\n \nj\n \n+=\n \n1\n)\n \n{\n\n      \nif\n \n(\nis_prime\n(\nj\n)\n \n&&\n \ni\n \n+\n \nj\n \n==\n \nn\n)\n \n{\n\n        \ncount\n \n+=\n \n1\n;\n\n      \n}\n\n    \n}\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\nHere, the code is spending lots of time checking if j is a prime.  After that, if i + j is not n, (which is likely since there is only one such j), we do nothing.  The effort in checking if j is prime is wasted.  Remember: do not do redundant work.\n\n\n1\n2\n3\n4\n5\n6\n7\nfor\n \n(\nlong\n \ni\n \n=\n \n0\n;\n \ni\n \n<=\n \nn\n/\n2\n;\n \ni\n \n+=\n \n1\n)\n \n{\n\n  \nfor\n \n(\nlong\n \nj\n \n=\n \n0\n;\n \nj\n \n<\n \nn\n;\n \nj\n \n+=\n \n1\n)\n \n{\n\n    \nif\n \n(\nis_prime\n(\ni\n)\n \n&&\n \nis_prime\n(\nj\n)\n \n&&\n \ni\n \n+\n \nj\n \n==\n \nn\n)\n \n{\n\n      \ncount\n \n+=\n \n1\n;\n\n    \n}\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\nThis is even worse -- note that the code above checks if i is prime, repeatedly, even if i does not change between Lines 3-5.  Remember: do not do repetitive work.\n\n\n\n\n\n\nDouble Counting\n Another common bug is to double count the number of pairs, as follows (e.g., count the pair (3,5) and (5,3) once each for input 8.).  Some students do realize that they are double counting and try to solve this by setting \ncount = count/2\n.  This does not work since not every pair gets double counted.  Example, (3, 3) is counted once if the input is 6.\n\n\n1\n2\n3\n4\n5\nfor\n \n(\nlong\n \ni\n \n=\n \n0\n;\n \ni\n \n<\n \nn\n;\n \ni\n \n+=\n \n1\n)\n \n{\n\n  \nif\n \n(\nis_prime\n(\ni\n)\n \n&&\n \nis_prime\n(\nn\n \n-\n \ni\n))\n \n{\n\n    \ncount\n \n+=\n \n1\n;\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\n\n\n\n\nAnswer\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n#include\n \n\"cs1010.h\"\n\n\n#include\n \n<math.h>\n\n\n#include\n \n<stdbool.h>\n\n\n\nbool\n \nis_prime\n(\nlong\n \nn\n)\n\n\n{\n\n  \nfor\n \n(\nint\n \ni\n \n=\n \n2\n;\n \ni\n \n<=\n \nsqrt\n(\nn\n);\n \ni\n \n+=\n \n1\n)\n \n{\n\n    \nif\n \n(\nn\n \n%\n \ni\n \n==\n \n0\n)\n \n{\n\n      \nreturn\n \nfalse\n;\n\n    \n}\n\n  \n}\n\n  \nreturn\n \ntrue\n;\n\n\n}\n\n\n\nlong\n \ncount_prime_pairs\n(\nlong\n \nn\n)\n\n\n{\n\n  \nlong\n \ncount\n \n=\n \n0\n;\n\n  \nfor\n \n(\nint\n \ni\n \n=\n \n2\n;\n \ni\n \n<=\n \nn\n/\n2\n;\n \ni\n \n+=\n \n1\n)\n \n{\n\n    \nif\n \n(\nis_prime\n(\ni\n)\n \n&&\n \nis_prime\n(\nn\n-\ni\n))\n \n{\n\n      \ncount\n \n+=\n \n1\n;\n\n    \n}\n\n  \n}\n\n  \nreturn\n \ncount\n;\n\n\n}\n\n\n\nint\n \nmain\n()\n\n\n{\n\n  \nlong\n \nn\n \n=\n \ncs1010_read_long\n();\n\n  \ncs1010_println_long\n(\ncount_prime_pairs\n(\nn\n));\n\n\n}\n\n\n\n\n\n\n\nDigits\n\n\nComments\n\n\nComing Soon!\n\n\nAnswer\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n#include\n \n\"cs1010.h\"\n\n\n\nlong\n \nlongest_consecutive_digits\n(\nlong\n \nn\n)\n\n\n{\n\n  \nlong\n \nlongest_count\n \n=\n \n-\n1\n;\n\n  \nlong\n \nlongest_digit\n;\n\n  \nlong\n \ncurrent_count\n \n=\n \n0\n;\n\n  \nlong\n \ncurrent_digit\n \n=\n \nn\n \n%\n \n10\n;\n\n\n  \ndo\n \n{\n\n    \n// Increase the counter if we see the same digit.\n\n    \n// Otherwise reset counter to 1.\n\n    \nif\n \n(\nn\n \n%\n \n10\n \n==\n \ncurrent_digit\n)\n \n{\n\n      \ncurrent_count\n \n+=\n \n1\n;\n\n    \n}\n \nelse\n \n{\n\n      \ncurrent_count\n \n=\n \n1\n;\n\n    \n}\n\n\n    \n// Checks if we find a longer (or equally long)\n\n    \n// consecutive sequence.  Update longest_digit\n\n    \n// and longest_count if so.\n\n    \nif\n \n(\ncurrent_count\n \n>\n \nlongest_count\n)\n \n{\n\n      \nlongest_digit\n \n=\n \ncurrent_digit\n;\n\n      \nlongest_count\n \n=\n \ncurrent_count\n;\n\n    \n}\n \nelse\n \nif\n \n(\ncurrent_count\n \n==\n \nlongest_count\n)\n \n{\n\n      \nif\n \n(\ncurrent_digit\n \n<\n \nlongest_digit\n)\n \n{\n\n        \nlongest_digit\n \n=\n \ncurrent_digit\n;\n\n      \n}\n\n    \n}\n\n\n    \n// Update the current digit to the last digit of n\n\n    \n// and shorten n by one digit.\n\n    \ncurrent_digit\n \n=\n \nn\n \n%\n \n10\n;\n\n    \nn\n \n=\n \nn\n \n/\n \n10\n;\n\n  \n}\n \nwhile\n \n(\nn\n \n>\n \n0\n);\n\n  \nreturn\n \nlongest_digit\n;\n\n\n}\n\n\n\nint\n \nmain\n()\n\n\n{\n\n  \nlong\n \nn\n \n=\n \ncs1010_read_long\n();\n\n  \ncs1010_println_long\n(\nlongest_consecutive_digits\n(\nn\n));\n\n\n}\n\n\n\n\n\n\n\nSquare\n\n\nComments\n\n\nComing Soon!\n\n\nAnswer\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n#include\n \n\"cs1010.h\"\n\n\n\n/**\n\n\n * Print a line of given width consisting of # only.\n\n\n *\n\n\n * @param[in] width The width of the line.\n\n\n */\n\n\nvoid\n \nprint_line\n(\nlong\n \nwidth\n)\n \n{\n\n  \nfor\n \n(\nlong\n \ni\n \n=\n \n0\n;\n \ni\n \n<\n \nwidth\n;\n \ni\n+=\n1\n)\n \n{\n\n    \ncs1010_print_string\n(\n\"#\"\n);\n\n  \n}\n\n\n}\n\n\n\n/**\n\n\n * Print a line of given width, consisting of \" \" except\n\n\n * the first and last characters, which is #.\n\n\n *\n\n\n * @param[in] width The width of the line.\n\n\n */\n\n\nvoid\n \nprint_border\n(\nlong\n \nwidth\n)\n \n{\n\n  \ncs1010_print_string\n(\n\"#\"\n);\n\n  \nfor\n \n(\nlong\n \ni\n \n=\n \n0\n;\n \ni\n \n<\n \nwidth\n \n-\n \n2\n;\n \ni\n+=\n1\n)\n \n{\n\n    \ncs1010_print_string\n(\n\" \"\n);\n\n  \n}\n\n  \ncs1010_print_string\n(\n\"#\"\n);\n\n\n}\n\n\n\n/**\n\n\n * Print one row of a concentric square, recursively.\n\n\n *\n\n\n * @param[in] row Which row of the square to draw.\n\n\n * @param[in] width The width of the square.\n\n\n */\n\n\nvoid\n \nprint_square\n(\nlong\n \nrow\n,\n \nlong\n \nwidth\n)\n \n{\n\n  \nif\n \n(\nwidth\n \n==\n \n1\n)\n \n{\n\n    \ncs1010_print_string\n(\n\"#\"\n);\n\n  \n}\n \nelse\n \nif\n \n(\nrow\n \n==\n \n0\n \n||\n \nrow\n \n==\n \nwidth\n \n-\n \n1\n)\n \n{\n\n    \nprint_line\n(\nwidth\n);\n\n  \n}\n \nelse\n \nif\n \n(\nrow\n \n==\n \n1\n \n||\n \nrow\n \n==\n \nwidth\n \n-\n \n2\n)\n \n{\n\n    \nprint_border\n(\nwidth\n);\n\n  \n}\n \nelse\n \n{\n\n    \ncs1010_print_string\n(\n\"# \"\n);\n\n    \nprint_square\n(\nrow\n \n-\n \n2\n,\n \nwidth\n \n-\n \n4\n);\n\n    \ncs1010_print_string\n(\n\" #\"\n);\n\n  \n}\n\n\n}\n\n\n\nint\n \nmain\n()\n\n\n{\n\n  \nlong\n \nwidth\n \n=\n \ncs1010_read_long\n();\n\n  \nfor\n \n(\nlong\n \nrow\n \n=\n \n0\n;\n \nrow\n \n<\n \nwidth\n;\n \nrow\n \n+=\n \n1\n)\n \n{\n\n    \nprint_square\n(\nrow\n,\n \nwidth\n);\n\n    \ncs1010_println_string\n(\n\"\"\n);\n\n  \n}\n\n\n}",
            "title": "PE1 Comments and Answers"
        },
        {
            "location": "/pe1-comments/index.html#pe1-comments-and-answer-keys",
            "text": "",
            "title": "PE1: Comments and Answer Keys"
        },
        {
            "location": "/pe1-comments/index.html#vote",
            "text": "",
            "title": "vote"
        },
        {
            "location": "/pe1-comments/index.html#comments",
            "text": "This is supposed to be a very easy, \"give-away\" question, but only 60% of students get full marks for this question.  Common mistakes include:   Using the wrong type .  Some students read integer values as  double  or read  long  as  long long . These do not affect the correctness but it does not demonstrate that the students understand the differences between the different types.  There is a -0.5 penalty for each one.   A more serious error involves using  int  for the number of votes (-1) or  long  for the percentage (-1).     Integer division .  Some students used integer division when calculating the percentage.  For instance: 1 double   percentage   =   ( m / ( m + n )) * 100.0 ;    The computation of  m/(m+n)  is done entirely as  long  integer.  You need to either cast  m  or  n  to double, or multiple  100.0  (a double) earlier: 1 double   percentage   =   ( m * 100.0 / ( m + n ));      Redundant Cast .  Some studnets do not understand the needs for casting and simply cast everything: 1 double   percentage   =   (( double ) m * ( double ) 100.0 / (( double ) m + ( double ) n ));    I decided not to deduct marks for this, but this is not the right way to write an arithmetic expression!    Redundant Functions .  Some students wrote something like this:  1\n2\n3\n4\n5\n6\n7 double   percentage_of_nixon ( long   nixon ,   long   total )   { \n     return   nixon * 100.0 / total ;  }  double   percentage_of_mcneal ( long   mcneal ,   long   total )   { \n     return   mcneal * 100.0 / total ;  }    This shows that students do not understand that functions are supposed to be reusable that there is only one function needed.  There is a -1 penalty for that.    Misc.   Some students made simple mistakes like printing the numbers without a space in between or print the two numbers on different lines (-0.5), or didn't include the right headers (-1).",
            "title": "Comments"
        },
        {
            "location": "/pe1-comments/index.html#solution",
            "text": "1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11 #include   \"cs1010.h\"  int   main ()  { \n   long   mcneal   =   cs1010_read_long (); \n   long   nixon   =   cs1010_read_long (); \n   long   total   =   mcneal   +   nixon ; \n\n   cs1010_print_double ( mcneal * 100.0 / total ); \n   cs1010_print_string ( \" \" ); \n   cs1010_println_double ( nixon * 100.0 / total );  }",
            "title": "Solution"
        },
        {
            "location": "/pe1-comments/index.html#newton",
            "text": "",
            "title": "newton"
        },
        {
            "location": "/pe1-comments/index.html#comments_1",
            "text": "Newton is another easy question that surprisingly many students are struggling with.      Needless Careless Mistakes  Many students wrote down the wrong formula for  f(x) f(x)  or  f'(x) f'(x) , which I deduct 1 marks after a facepalm.      Wrong Type  Quite a few students read the inputs as  long  instead of  double .  There is a 1 mark deduction for this.  A few students used  float  instead of  double .  As I have mentioned, you should never touch  float  at all, since its precision is  lame  low.  If you use  float , you would not get the correct answer for some of the test cases due to floating point errors.  There is a 0.5 mark deduction for using  float  instead of  double .    Uninitialized Variable  There are also a number of students who got the following bugs: 1\n2\n3\n4\n5 double   root ;  while   ( fabs ( f ( a ,   b ,   c ,   d ,   x ))   >=   0.000000001 )   { \n   :  }  return   root ;    Suppose that the initial guess  x  is already close enough to the root, the loop is never entered, and the function returns  root  uninitialized.  The lesson here is that always make sure you cover all possible cases.  Also, please think about what variables do you really need to solve a problem.  In this question, you do not any extra variable -- so  root  is completely unnecessary.  The more variable you used, the more complex your code get, the more likely you introduce bugs into your code, as shown in the example above.    Terminating Conditions  Another common mistake is the terminating conditions.  A handful of you wrote something like this:\n     1 while   ( fabs ( f ( a ,   b ,   c ,   d ,   x )   >=   0.000000001 ))   {    Here, the code tries to pass a  true  or  false  expression to  fabs , which the compiler warns.  A few of you, instead of fixing the parenthesis, change  fabs  to  abs  instead to silence the compiler >.<     Other mistakes include not setting the right threshold (some uses 0.001, or 0.00001 -- why oh why?) or use the wrong comparison: 1 while   ( fabs ( f ( a ,   b ,   c ,   d ,   x )   <   0.000000001 ))   {    Some did not use  fabs  at all: 1 while   ( f ( a ,   b ,   c ,   d ,   x )   >=   0.000000001 )   {    Some checked if the root is small enough, instead of the value of function is small enough: 1 while   ( fabs ( x )   >=   0.000000001 )   {    A small number of students hardcoded the number of steps (e.g., always loop 4 times), which works for the sample but not for the general cases.  There is a one mark deduction for all errors related to terminating conditions.  One strange thing some of you do is to use a  for  loop for this question: 1 for   ( long   i   =   0 ;   fabs ( x )   >=   0.000000001 ;   i   +=   1 )    The loop still terminates correctly, but the variable  i  is entirely useless.  No marks are deducted but I should have for not demonstrating that you know which loop to use.    Use of pow()  I did not deduct marks for this -- but using  pow  for squaring and cubing is an overkill.   pow  is a general function that works even for floating point exponentiation.  So it is slower.  Some of you even wrote  pow(x, 1)  and  pow(x, 0) .  Marks would have been deducted if efficiency is a criterion.",
            "title": "Comments"
        },
        {
            "location": "/pe1-comments/index.html#answer",
            "text": "1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33 #include   \"cs1010.h\"  #include   <math.h>  double   f ( double   a ,   double   b ,   double   c ,   double   d ,   double   x )   { \n   return   a * x * x * x   +   b * x * x   +   c * x   +   d ;  }  double   fp ( double   a ,   double   b ,   double   c ,   double   x )   { \n   return   3 * a * x * x   +   2 * b * x   +   c ;  }  double   find_root ( double   a ,   double   b ,   double   c ,   double   d ,   double   x )   { \n   double   fx   =   f ( a ,   b ,   c ,   d ,   x ); \n   while   ( fabs ( fx )   >=   0.000000001 )   { \n     double   fpx   =   fp ( a ,   b ,   c ,   x ); \n     x   -=   fx / fpx ; \n     fx   =   f ( a ,   b ,   c ,   d ,   x ); \n   } \n   return   x ;  }  int   main ()  { \n   double   a   =   cs1010_read_double (); \n   double   b   =   cs1010_read_double (); \n   double   c   =   cs1010_read_double (); \n   double   d   =   cs1010_read_double (); \n   double   x   =   cs1010_read_double (); \n\n   x   =   find_root ( a ,   b ,   c ,   d ,   x ); \n\n   cs1010_println_double ( x );  }",
            "title": "Answer"
        },
        {
            "location": "/pe1-comments/index.html#goldbach",
            "text": "",
            "title": "Goldbach"
        },
        {
            "location": "/pe1-comments/index.html#comments_2",
            "text": "This question is a little bit more tricky than  newton , but not much.      Checking For Prime  The disappointing thing is that, even though you have gone through an exercise and an assignment that involves checking if a number is prime, with the solution given comparing different approaches, many of you still wrote the wrong function for checking prime, uses the wrong type, or wrote the slow version.  Since I deducted one mark for each bug, an incorrect  is_prime  might cost you 1-3 marks.  This is entirely unnecessary >.<  Try to see if you can spot the bugs and why it fails in each of the following.  This is a good exam question that I might ask in a future semester -- don't tell your junior  shush .  1\n2\n3\n4\n5\n6\n7\n8\n9 bool   is_prime ( long   n )  { \n   for   ( long   i   =   1 ;   i   <=   sqrt ( n );   i ++ )   { \n     if   ( n   %   i   ==   0 )   { \n       return   false ; \n     } \n   } \n   return   true ;  }    1\n2\n3\n4\n5\n6\n7\n8\n9 bool   is_prime ( long   n )  { \n   for   ( long   i   =   2 ;   i   <   sqrt ( n );   i ++ )   { \n     if   ( n   %   i   ==   0 )   { \n       return   false ; \n     } \n   } \n   return   true ;  }    1\n2\n3\n4\n5\n6\n7\n8\n9 bool   is_prime ( long   n )  { \n   for   ( long   i   =   2 ;   i   <=   ceil ( sqrt ( n ));   i ++ )   { \n     if   ( n   %   i   ==   0 )   { \n       return   false ; \n     } \n   } \n   return   true ;  }     1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10 bool   is_prime ( long   n )  { \n   for   ( long   i   =   2 ;   i   <=   sqrt ( n );   i ++ )   { \n     if   ( n   %   i   ==   0 )   { \n       return   false ; \n     }   else   { \n       return   true ; \n     } \n   }  }      Another common mistake related to checking of prime is that the function should return a  bool  (since a number is either a prime or not).  Some students returned an integer from this function.  I deducted one mark for not demonstrating an understanding of boolean functions.    Unnecessary Loops   This is another strange but common code that you have written.  I did not deduct marks since efficiency is not a criterion for PE1 -- but I am puzzled why you write code like this.   Let's say I ask you this question: 31 plus what equals to 100?  Any primary school students can tell you, take 100, subtract 31, you get 69.  So 31 + 69 = 100.     This is not many of you do to find the answer.  What you do is equivalent to:  1\n2\n3\n4\n5 for   ( j   =   1 ;   j   <=   100 ;   j   +=   1 )   { \n   if   ( 31   +   j   ==   100 )   { \n     cs1010_println_long ( j ); \n   }  }    Essentially, checking is 31 + 1 equal to 100?  is 31 + 2 equals to 100? etc. until you find an answer.  After that, you continue to check, is 31 + 70 equals to 100? is 31 + 71 equal to 100? and so on.  This is just silly >.<  In the context of  goldbach , the code you wrote is:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11 for   ( long   i   =   0 ;   i   <=   n / 2 ;   i   +=   1 )   { \n   if   ( is_prime ( i ))   { \n     for   ( long   j   =   0 ;   j   <   n ;   j   +=   1 )   { \n       if   ( i   +   j   ==   n )   { \n         if   ( is_prime ( j ))   { \n            count   +=   1 ; \n         } \n       } \n     } \n   }  }    Can you see where the silly loop appears above?    Short Circuiting  I have shown an example of short-circuiting in class, using exactly checking of prime as an example.  However, some of you still wrote code like the following.  This is another disappointment and I am tempted to deduct marks (but didn't).  The improper use of short-circuiting often occurs with the silly loop to solve  n - i  above.  1\n2\n3\n4\n5\n6\n7\n8\n9 for   ( long   i   =   0 ;   i   <=   n / 2 ;   i   +=   1 )   { \n   if   ( is_prime ( i ))   { \n     for   ( long   j   =   0 ;   j   <   n ;   j   +=   1 )   { \n       if   ( is_prime ( j )   &&   i   +   j   ==   n )   { \n         count   +=   1 ; \n       } \n     } \n   }  }    Here, the code is spending lots of time checking if j is a prime.  After that, if i + j is not n, (which is likely since there is only one such j), we do nothing.  The effort in checking if j is prime is wasted.  Remember: do not do redundant work.  1\n2\n3\n4\n5\n6\n7 for   ( long   i   =   0 ;   i   <=   n / 2 ;   i   +=   1 )   { \n   for   ( long   j   =   0 ;   j   <   n ;   j   +=   1 )   { \n     if   ( is_prime ( i )   &&   is_prime ( j )   &&   i   +   j   ==   n )   { \n       count   +=   1 ; \n     } \n   }  }    This is even worse -- note that the code above checks if i is prime, repeatedly, even if i does not change between Lines 3-5.  Remember: do not do repetitive work.    Double Counting  Another common bug is to double count the number of pairs, as follows (e.g., count the pair (3,5) and (5,3) once each for input 8.).  Some students do realize that they are double counting and try to solve this by setting  count = count/2 .  This does not work since not every pair gets double counted.  Example, (3, 3) is counted once if the input is 6.  1\n2\n3\n4\n5 for   ( long   i   =   0 ;   i   <   n ;   i   +=   1 )   { \n   if   ( is_prime ( i )   &&   is_prime ( n   -   i ))   { \n     count   +=   1 ; \n   }  }",
            "title": "Comments"
        },
        {
            "location": "/pe1-comments/index.html#answer_1",
            "text": "1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30 #include   \"cs1010.h\"  #include   <math.h>  #include   <stdbool.h>  bool   is_prime ( long   n )  { \n   for   ( int   i   =   2 ;   i   <=   sqrt ( n );   i   +=   1 )   { \n     if   ( n   %   i   ==   0 )   { \n       return   false ; \n     } \n   } \n   return   true ;  }  long   count_prime_pairs ( long   n )  { \n   long   count   =   0 ; \n   for   ( int   i   =   2 ;   i   <=   n / 2 ;   i   +=   1 )   { \n     if   ( is_prime ( i )   &&   is_prime ( n - i ))   { \n       count   +=   1 ; \n     } \n   } \n   return   count ;  }  int   main ()  { \n   long   n   =   cs1010_read_long (); \n   cs1010_println_long ( count_prime_pairs ( n ));  }",
            "title": "Answer"
        },
        {
            "location": "/pe1-comments/index.html#digits",
            "text": "",
            "title": "Digits"
        },
        {
            "location": "/pe1-comments/index.html#comments_3",
            "text": "Coming Soon!",
            "title": "Comments"
        },
        {
            "location": "/pe1-comments/index.html#answer_2",
            "text": "1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43 #include   \"cs1010.h\"  long   longest_consecutive_digits ( long   n )  { \n   long   longest_count   =   - 1 ; \n   long   longest_digit ; \n   long   current_count   =   0 ; \n   long   current_digit   =   n   %   10 ; \n\n   do   { \n     // Increase the counter if we see the same digit. \n     // Otherwise reset counter to 1. \n     if   ( n   %   10   ==   current_digit )   { \n       current_count   +=   1 ; \n     }   else   { \n       current_count   =   1 ; \n     } \n\n     // Checks if we find a longer (or equally long) \n     // consecutive sequence.  Update longest_digit \n     // and longest_count if so. \n     if   ( current_count   >   longest_count )   { \n       longest_digit   =   current_digit ; \n       longest_count   =   current_count ; \n     }   else   if   ( current_count   ==   longest_count )   { \n       if   ( current_digit   <   longest_digit )   { \n         longest_digit   =   current_digit ; \n       } \n     } \n\n     // Update the current digit to the last digit of n \n     // and shorten n by one digit. \n     current_digit   =   n   %   10 ; \n     n   =   n   /   10 ; \n   }   while   ( n   >   0 ); \n   return   longest_digit ;  }  int   main ()  { \n   long   n   =   cs1010_read_long (); \n   cs1010_println_long ( longest_consecutive_digits ( n ));  }",
            "title": "Answer"
        },
        {
            "location": "/pe1-comments/index.html#square",
            "text": "",
            "title": "Square"
        },
        {
            "location": "/pe1-comments/index.html#comments_4",
            "text": "Coming Soon!",
            "title": "Comments"
        },
        {
            "location": "/pe1-comments/index.html#answer_3",
            "text": "1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55 #include   \"cs1010.h\"  /**   * Print a line of given width consisting of # only.   *   * @param[in] width The width of the line.   */  void   print_line ( long   width )   { \n   for   ( long   i   =   0 ;   i   <   width ;   i += 1 )   { \n     cs1010_print_string ( \"#\" ); \n   }  }  /**   * Print a line of given width, consisting of \" \" except   * the first and last characters, which is #.   *   * @param[in] width The width of the line.   */  void   print_border ( long   width )   { \n   cs1010_print_string ( \"#\" ); \n   for   ( long   i   =   0 ;   i   <   width   -   2 ;   i += 1 )   { \n     cs1010_print_string ( \" \" ); \n   } \n   cs1010_print_string ( \"#\" );  }  /**   * Print one row of a concentric square, recursively.   *   * @param[in] row Which row of the square to draw.   * @param[in] width The width of the square.   */  void   print_square ( long   row ,   long   width )   { \n   if   ( width   ==   1 )   { \n     cs1010_print_string ( \"#\" ); \n   }   else   if   ( row   ==   0   ||   row   ==   width   -   1 )   { \n     print_line ( width ); \n   }   else   if   ( row   ==   1   ||   row   ==   width   -   2 )   { \n     print_border ( width ); \n   }   else   { \n     cs1010_print_string ( \"# \" ); \n     print_square ( row   -   2 ,   width   -   4 ); \n     cs1010_print_string ( \" #\" ); \n   }  }  int   main ()  { \n   long   width   =   cs1010_read_long (); \n   for   ( long   row   =   0 ;   row   <   width ;   row   +=   1 )   { \n     print_square ( row ,   width ); \n     cs1010_println_string ( \"\" ); \n   }  }",
            "title": "Answer"
        },
        {
            "location": "/pe2/index.html",
            "text": "Practice Exam 2\n\n\nQuestions\n\n\n\n\n(post on sunday)\nExam Paper\n\n\n\n\nBasic Info\n\n\n\n\nDate: 10 November, 2018 (Saturday)\n\n\nTime: 1pm to 4pm\n\n\nVenue: Various programming labs\n\n\nScope: Units 1-24, Assignments 1-7, Tutorials 1-9\n\n\n5 programming questions, very easy to hard\n\n\nCriteria: Correctness, Style, Documentation, Efficient.  Allocation differs per question.\n\n\nDuration: 2 hours and 30 minutes\n\n\nOpen Book (You can bring analog references)\n\n\n\n\nLab Allocation\n\n\n\n\nEvery student is assigned to a programming lab.  \n\n\nPlease see the allocation below.\n\n\nSpecial access has been given to students assigned to ES Lab 1 and 2 (Embedded System Teaching Lab 1 and 2)\n\n\nHere are the \nlocatons for the respective labs\n\n\n\n\nSpecial Restrictions\n\n\n\n\n\n\nYou will be issued a special account on the PE day to solve the exam questions.  \n\n\n\n\n\n\nThere will be no Internet access.\n\n\n\n\n\n\nVim Configuration\n\n\nYour default account will have the same \n.vimrc\n as \n~cs1010/.vimrc\n on the CS1010 PE hosts.  \n\n\nYou are free to edit this during the practical exams.  \n\n\nYou, however, will not be able to download nor install \nvim\n plugins.\n\n\nGeneral Advice\n\n\n\n\nSave your program regularly.  We will use setup every account with \n~/.vimrc\n copied from \n~cs1010/.vimrc\n.  Thus, you can find the last saved version of your files under \n~/.backup\n if you accidentally deleted your code.\n\n\nPlan your time properly.  Do not spend excessive time on any task.  Read through all questions and solved those that you are confident to solve first.\n\n\nThere are five questions, from very easy to very hard.  Solve as many as you can.  I expect most students will be able to solve 3 out of the 5 questions within the time limit.\n\n\nPay attention to the marking criteria, which differs from question to question. \n \n\n\nDon't start typing your code right away.  Think about the solution first -- what variables are needed?  what is the control flow (using branches and loops)?  Draw out the flowchart if it helps.  \n\n\nBreak down the problem into smaller ones if the problem is too complex to solve.\n\n\nYou are not allowed to start typing on the computer for the first 10 minutes of the practical exam, or until the invigilator announced that you can do so.\n\n\nYou will be given a question form to ask questions to clarify doubts about the question paper.  But note that you can only ask a boolean question (YES/NO answer).\n\n\nJust like the assignments, you are not given all the test cases that we will be using during grading.  Please test your code against additional test cases, especially for boundary cases.\n\n\n\n\nLab and Seat Allocation\n\n\n\n\n\n\n\n\nNAME\n\n\nVenue\n\n\nSeat Number\n\n\n\n\n\n\n\n\n\n\nAARUSHI SINGH\n\n\nPL1\n\n\nsoctf-imac215-001\n\n\n\n\n\n\nAHMAD MUDAAFI' B ZAINUDDIN\n\n\nPL1\n\n\nsoctf-imac215-002\n\n\n\n\n\n\nAI ZHENGWEI\n\n\nPL1\n\n\nsoctf-imac215-003\n\n\n\n\n\n\nALEX TEO KANG JIE\n\n\nPL1\n\n\nsoctf-imac215-004\n\n\n\n\n\n\nAMIR AZHAR B AZIZAN\n\n\nPL1\n\n\nsoctf-imac215-005\n\n\n\n\n\n\nANDREW LAU JIA JUN\n\n\nPL1\n\n\nsoctf-imac215-006\n\n\n\n\n\n\nANG KENG SIANG\n\n\nPL1\n\n\nsoctf-imac215-007\n\n\n\n\n\n\nANG KIANG YANG\n\n\nPL1\n\n\nsoctf-imac215-008\n\n\n\n\n\n\nAW CHIAN HAO\n\n\nPL1\n\n\nsoctf-imac215-009\n\n\n\n\n\n\nBALAM SAI ROHIT REDDY\n\n\nPL1\n\n\nsoctf-imac215-010\n\n\n\n\n\n\nBEATRICE CHAN TONG\n\n\nPL1\n\n\nsoctf-imac215-011\n\n\n\n\n\n\nBENEDICT YU CHENG EN\n\n\nPL1\n\n\nsoctf-imac215-012\n\n\n\n\n\n\nBENJAMIN CHIA SHAN HONG\n\n\nPL1\n\n\nsoctf-imac215-013\n\n\n\n\n\n\nCAI RONG\n\n\nPL1\n\n\nsoctf-imac215-014\n\n\n\n\n\n\nCHAN EE ZHENG, BENJAMIN\n\n\nPL1\n\n\nsoctf-imac215-015\n\n\n\n\n\n\nCHAN HIN, SEAN\n\n\nPL1\n\n\nsoctf-imac215-016\n\n\n\n\n\n\nCHAN WEI FONG, MAX\n\n\nPL1\n\n\nsoctf-imac215-017\n\n\n\n\n\n\nCHAN YEE CHONG PHILIP\n\n\nPL1\n\n\nsoctf-imac215-018\n\n\n\n\n\n\nCHAN YEW CHUN DANIEL\n\n\nPL1\n\n\nsoctf-imac215-019\n\n\n\n\n\n\nCHAN ZHI ZHENG, AMOS\n\n\nPL1\n\n\nsoctf-imac215-020\n\n\n\n\n\n\nCHANG HUI ZHEN\n\n\nPL1\n\n\nsoctf-imac215-021\n\n\n\n\n\n\nCHANG ZHONG KAI\n\n\nPL1\n\n\nsoctf-imac215-022\n\n\n\n\n\n\nCHEN CHAO\n\n\nPL1\n\n\nsoctf-imac215-023\n\n\n\n\n\n\nCHEN TONG\n\n\nPL1\n\n\nsoctf-imac215-024\n\n\n\n\n\n\nCHENG LE DA, CLEMENT\n\n\nPL1\n\n\nsoctf-imac215-025\n\n\n\n\n\n\nCHENG WANYIN\n\n\nPL1\n\n\nsoctf-imac215-027\n\n\n\n\n\n\nCHENG WEIXUAN\n\n\nPL1\n\n\nsoctf-imac215-028\n\n\n\n\n\n\nCHERYL NG YUN LIN\n\n\nPL1\n\n\nsoctf-imac215-029\n\n\n\n\n\n\nCHEW JUN KONG\n\n\nPL1\n\n\nsoctf-imac215-030\n\n\n\n\n\n\nCHIA BIING HANN\n\n\nPL1\n\n\nsoctf-imac215-031\n\n\n\n\n\n\nCHNG XIAN YI\n\n\nPL1\n\n\nsoctf-imac215-032\n\n\n\n\n\n\nCHOI WONJAE\n\n\nPL1\n\n\nsoctf-imac215-034\n\n\n\n\n\n\nCHU JUI HUNG @JEFFERSON CHU\n\n\nPL1\n\n\nsoctf-imac215-035\n\n\n\n\n\n\nCHUA MAI FENG, CARL\n\n\nPL1\n\n\nsoctf-imac215-036\n\n\n\n\n\n\nCHUA WEN XUAN\n\n\nPL1\n\n\nsoctf-imac215-037\n\n\n\n\n\n\nCHUA ZONG WEI\n\n\nPL1\n\n\nsoctf-imac215-038\n\n\n\n\n\n\nCLAIRE CHAN YEN HWA\n\n\nPL1\n\n\nsoctf-imac215-039\n\n\n\n\n\n\nCYNTHIA LEE WENG YAN\n\n\nPL1\n\n\nsoctf-imac215-043\n\n\n\n\n\n\nDANIEL TAN WEE LIANG\n\n\nPL1\n\n\nsoctf-imac215-044\n\n\n\n\n\n\nDANISH B EDDIE\n\n\nPL1\n\n\nsoctf-imac215-045\n\n\n\n\n\n\nDARREN ONG\n\n\nPL2\n\n\nsoctf-pl2-001\n\n\n\n\n\n\nDEBBIE TAN JIA MIN\n\n\nPL2\n\n\nsoctf-pl2-002\n\n\n\n\n\n\nDING NING\n\n\nPL2\n\n\nsoctf-pl2-003\n\n\n\n\n\n\nDIVAKARAN HARITHA\n\n\nPL2\n\n\nsoctf-pl2-004\n\n\n\n\n\n\nEDMUND TEO WEI XIN\n\n\nPL2\n\n\nsoctf-pl2-005\n\n\n\n\n\n\nEU JING SEN\n\n\nPL2\n\n\nsoctf-pl2-006\n\n\n\n\n\n\nEVELYN YI-WEN CHEN\n\n\nPL2\n\n\nsoctf-pl2-007\n\n\n\n\n\n\nFATIN NABILAH BTE SUHAIMI\n\n\nPL2\n\n\nsoctf-pl2-009\n\n\n\n\n\n\nFOO CHI HEN\n\n\nPL2\n\n\nsoctf-pl2-010\n\n\n\n\n\n\nGINA QUAH JIE XI\n\n\nPL2\n\n\nsoctf-pl2-011\n\n\n\n\n\n\nGLEN WONG SHU ZE\n\n\nPL2\n\n\nsoctf-pl2-012\n\n\n\n\n\n\nGOH RUI PING SAMANTHA\n\n\nPL2\n\n\nsoctf-pl2-013\n\n\n\n\n\n\nGOH ZHEN HAO JOEY\n\n\nPL2\n\n\nsoctf-pl2-014\n\n\n\n\n\n\nGONDHALEKAR SUKRUT YOGESH\n\n\nPL2\n\n\nsoctf-pl2-014\n\n\n\n\n\n\nGREGORY TAN WEI YUAN\n\n\nPL2\n\n\nsoctf-pl2-016\n\n\n\n\n\n\nGUI XIXIAN\n\n\nPL2\n\n\nsoctf-pl2-017\n\n\n\n\n\n\nGUO HAOREN\n\n\nPL2\n\n\nsoctf-pl2-018\n\n\n\n\n\n\nHANS KURNIA WIDJAJA\n\n\nPL2\n\n\nsoctf-pl2-019\n\n\n\n\n\n\nHAO YUN\n\n\nPL2\n\n\nsoctf-pl2-020\n\n\n\n\n\n\nHASHIR ZAHIR\n\n\nPL2\n\n\nsoctf-pl2-022\n\n\n\n\n\n\nHENG HONG CHUAN\n\n\nPL2\n\n\nsoctf-pl2-023\n\n\n\n\n\n\nHO JING YANG DANIEL\n\n\nPL2\n\n\nsoctf-pl2-024\n\n\n\n\n\n\nHO SI SHI ANNETTE\n\n\nPL2\n\n\nsoctf-pl2-025\n\n\n\n\n\n\nHO WEI BIN, JERRY\n\n\nPL2\n\n\nsoctf-pl2-026\n\n\n\n\n\n\nHU XINYING\n\n\nPL2\n\n\nsoctf-pl2-028\n\n\n\n\n\n\nHUANG XUANKUN\n\n\nPL2\n\n\nsoctf-pl2-029\n\n\n\n\n\n\nIAN CHUA\n\n\nPL2\n\n\nsoctf-pl2-030\n\n\n\n\n\n\nISABELLA CHEONG XIAO XUAN\n\n\nPL2\n\n\nsoctf-pl2-031\n\n\n\n\n\n\nIVAN ANDIKA LIE\n\n\nPL2\n\n\nsoctf-pl2-032\n\n\n\n\n\n\nJANEL ANG YEE HUEY\n\n\nPL2\n\n\nsoctf-pl2-035\n\n\n\n\n\n\nJASON SATHYA CITRO\n\n\nPL2\n\n\nsoctf-pl2-036\n\n\n\n\n\n\nJASPER ONG SHAO YONG\n\n\nPL2\n\n\nsoctf-pl2-037\n\n\n\n\n\n\nJAZHTEN LOW YONGSHEN\n\n\nPL2\n\n\nsoctf-pl2-038\n\n\n\n\n\n\nJERRY ZHANG ZHUORAN\n\n\nPL2\n\n\nsoctf-pl2-039\n\n\n\n\n\n\nJESS TEO XI ZHI\n\n\nPL2\n\n\nsoctf-pl2-041\n\n\n\n\n\n\nJOEL CHANG ZHI KAI\n\n\nPL2\n\n\nsoctf-pl2-042\n\n\n\n\n\n\nJOHN CUTHBERT KHOO TENG FONG\n\n\nPL2\n\n\nsoctf-pl2-043\n\n\n\n\n\n\nJOSEPH WONG YEFENG\n\n\nPL2\n\n\nsoctf-pl2-044\n\n\n\n\n\n\nJUSTIN CHIA JIA JIN\n\n\nPL2\n\n\nsoctf-pl2-045\n\n\n\n\n\n\nK ALAGES\n\n\nPL2\n\n\nsoctf-pl2-046\n\n\n\n\n\n\nKARAN SARAT\n\n\nPL3\n\n\nsoctf-pl3-001\n\n\n\n\n\n\nKARNATI SAI ABHISHEK\n\n\nPL3\n\n\nsoctf-pl3-002\n\n\n\n\n\n\nKEE KAH LOK\n\n\nPL3\n\n\nsoctf-pl3-003\n\n\n\n\n\n\nKEITH CHAN JUN KAI\n\n\nPL3\n\n\nsoctf-pl3-004\n\n\n\n\n\n\nKELVIN HARRIS\n\n\nPL3\n\n\nsoctf-pl3-006\n\n\n\n\n\n\nKEVIN PUTERA\n\n\nPL3\n\n\nsoctf-pl3-007\n\n\n\n\n\n\nKEZIA KEW KAI YUN\n\n\nPL3\n\n\nsoctf-pl3-008\n\n\n\n\n\n\nKHAIRUL IMAN NASRI B AZHARIE\n\n\nPL3\n\n\nsoctf-pl3-010\n\n\n\n\n\n\nKHOO TZE YANG RAYSON\n\n\nPL3\n\n\nsoctf-pl3-011\n\n\n\n\n\n\nKISHORE R\n\n\nPL3\n\n\nsoctf-pl3-012\n\n\n\n\n\n\nKWOK KUIN EK JEREMY\n\n\nPL3\n\n\nsoctf-pl3-013\n\n\n\n\n\n\nKYAWT KYAWT SAN\n\n\nPL3\n\n\nsoctf-pl3-014\n\n\n\n\n\n\nLAI WEN XUAN JEREMY\n\n\nPL3\n\n\nsoctf-pl3-015\n\n\n\n\n\n\nLAM TIAN WEI JUSTIN\n\n\nPL3\n\n\nsoctf-pl3-016\n\n\n\n\n\n\nLE HONG LONG\n\n\nPL3\n\n\nsoctf-pl3-017\n\n\n\n\n\n\nLEE HONG CHIEN, KENNETH\n\n\nPL3\n\n\nsoctf-pl3-018\n\n\n\n\n\n\nLEE LI XIN\n\n\nPL3\n\n\nsoctf-pl3-019\n\n\n\n\n\n\nLEE RAIYAN BIN ZULKIFLI\n\n\nPL3\n\n\nsoctf-pl3-020\n\n\n\n\n\n\nLEE WEI HERN, JASON\n\n\nPL3\n\n\nsoctf-pl3-021\n\n\n\n\n\n\nLEE YUEYU\n\n\nPL3\n\n\nsoctf-pl3-022\n\n\n\n\n\n\nLEE ZHEN YU\n\n\nPL3\n\n\nsoctf-pl3-025\n\n\n\n\n\n\nLEOW YONG HENG\n\n\nPL3\n\n\nsoctf-pl3-026\n\n\n\n\n\n\nLEOW YONG KANG ANDREW\n\n\nPL4\n\n\nsoctf-pl4-001\n\n\n\n\n\n\nLI JIAYU\n\n\nPL4\n\n\nsoctf-pl4-002\n\n\n\n\n\n\nLI ZIHAN\n\n\nPL4\n\n\nsoctf-pl4-003\n\n\n\n\n\n\nLIAO LIXIN\n\n\nPL4\n\n\nsoctf-pl4-004\n\n\n\n\n\n\nLIAO TIANCHANG\n\n\nPL4\n\n\nsoctf-pl4-006\n\n\n\n\n\n\nLIM CHEE SENG BRIAN\n\n\nPL4\n\n\nsoctf-pl4-007\n\n\n\n\n\n\nLIM CHEK JUN\n\n\nPL4\n\n\nsoctf-pl4-008\n\n\n\n\n\n\nLIM CHENG YIN, RYAN\n\n\nPL4\n\n\nsoctf-pl4-010\n\n\n\n\n\n\nLIM HAO XIANG, SEAN\n\n\nPL4\n\n\nsoctf-pl4-011\n\n\n\n\n\n\nLIM JIA WEI\n\n\nPL4\n\n\nsoctf-pl4-012\n\n\n\n\n\n\nLIM JIAYI, TAMELLY\n\n\nPL4\n\n\nsoctf-pl4-014\n\n\n\n\n\n\nLIM JUN KUANG, LIONEL\n\n\nPL4\n\n\nsoctf-pl4-015\n\n\n\n\n\n\nLIM LI LINCOLN\n\n\nPL4\n\n\nsoctf-pl4-016\n\n\n\n\n\n\nLIM SI YING\n\n\nPL4\n\n\nsoctf-pl4-017\n\n\n\n\n\n\nLIM TING WEI\n\n\nPL4\n\n\nsoctf-pl4-018\n\n\n\n\n\n\nLIM WEN HAN, EUGENE\n\n\nPL4\n\n\nsoctf-pl4-019\n\n\n\n\n\n\nLIM YAN TING\n\n\nPL4\n\n\nsoctf-pl4-020\n\n\n\n\n\n\nLIN JIAYUE\n\n\nPL4\n\n\nsoctf-pl4-021\n\n\n\n\n\n\nLING WEN JIAN\n\n\nPL4\n\n\nsoctf-pl4-022\n\n\n\n\n\n\nLIU JINGXUAN\n\n\nPL4\n\n\nsoctf-pl4-023\n\n\n\n\n\n\nLIU PEIZE\n\n\nPL4\n\n\nsoctf-pl4-024\n\n\n\n\n\n\nLIU SHIRU\n\n\nPL4\n\n\nsoctf-pl4-025\n\n\n\n\n\n\nLIU SONGTAO\n\n\nPL5\n\n\nsoctf-pl5-001\n\n\n\n\n\n\nLIU WEI JIE NICHOLAS\n\n\nPL5\n\n\nsoctf-pl5-002\n\n\n\n\n\n\nLOH CHING WEI, JOSHUA\n\n\nPL5\n\n\nsoctf-pl5-003\n\n\n\n\n\n\nLOH YONG ZEE\n\n\nPL5\n\n\nsoctf-pl5-004\n\n\n\n\n\n\nLOW EE TER\n\n\nPL5\n\n\nsoctf-pl5-005\n\n\n\n\n\n\nLOW JIA YEE\n\n\nPL5\n\n\nsoctf-pl5-006\n\n\n\n\n\n\nLOW SIU YUAN, FRANCIS\n\n\nPL5\n\n\nsoctf-pl5-007\n\n\n\n\n\n\nLUCAS FOO SOO QUAN\n\n\nPL5\n\n\nsoctf-pl5-008\n\n\n\n\n\n\nLYE JUN WEI ANANDA\n\n\nPL5\n\n\nsoctf-pl5-009\n\n\n\n\n\n\nMARC PHUA HSIAO MENG\n\n\nPL5\n\n\nsoctf-pl5-010\n\n\n\n\n\n\nMATTHEW NATHANAEL SUGIRI\n\n\nPL5\n\n\nsoctf-pl5-011\n\n\n\n\n\n\nMERVIN WEE MINGWEN\n\n\nPL5\n\n\nsoctf-pl5-013\n\n\n\n\n\n\nMICHELLE TOH HUI PING\n\n\nPL5\n\n\nsoctf-pl5-014\n\n\n\n\n\n\nMODAK SHANTANU BHARAT\n\n\nPL5\n\n\nsoctf-pl5-015\n\n\n\n\n\n\nMOHAMED RIYAS\n\n\nPL5\n\n\nsoctf-pl5-016\n\n\n\n\n\n\nMOHAMMAD YOUSUF MINHAJ ZIA\n\n\nPL5\n\n\nsoctf-pl5-017\n\n\n\n\n\n\nMUHAMMAD FAIRUZ B AMIRHAMZAH\n\n\nPL5\n\n\nsoctf-pl5-018\n\n\n\n\n\n\nMUHAMMAD HOZEFA ZUMKHAWALA\n\n\nPL5\n\n\nsoctf-pl5-019\n\n\n\n\n\n\nMUHAMMAD SHOLIHIN BIN KAMARUDIN\n\n\nPL5\n\n\nsoctf-pl5-020\n\n\n\n\n\n\nMUHHAMMAD NUR HAFIDZ BIN HUSSAIN\n\n\nPL5\n\n\nsoctf-pl5-021\n\n\n\n\n\n\nNATHAN YEO KEE HERN\n\n\nPL5\n\n\nsoctf-pl5-022\n\n\n\n\n\n\nNEO WEN HUI\n\n\nPL5\n\n\nsoctf-pl5-023\n\n\n\n\n\n\nNG JIE WU\n\n\nWSLab 2\n\n\nws2-001\n\n\n\n\n\n\nNG JING KANG\n\n\nWSLab 2\n\n\nws2-002\n\n\n\n\n\n\nNG JING KIAT\n\n\nWSLab 2\n\n\nws2-003\n\n\n\n\n\n\nNG SHI QI, CARRIE\n\n\nWSLab 2\n\n\nws2-004\n\n\n\n\n\n\nNG SIU HIAN\n\n\nWSLab 2\n\n\nws2-005\n\n\n\n\n\n\nNG WEE KIAT\n\n\nWSLab 2\n\n\nws2-006\n\n\n\n\n\n\nNG WEI JIE, BRANDON\n\n\nWSLab 2\n\n\nws2-008\n\n\n\n\n\n\nNG ZI HUI\n\n\nWSLab 2\n\n\nws2-009\n\n\n\n\n\n\nNGAN JI CHENG\n\n\nWSLab 2\n\n\nws2-010\n\n\n\n\n\n\nNGUYEN THANH DUC\n\n\nWSLab 2\n\n\nws2-011\n\n\n\n\n\n\nNGUYEN TIEN DAT\n\n\nWSLab 2\n\n\nws2-012\n\n\n\n\n\n\nNIGEL TAN\n\n\nWSLab 2\n\n\nws2-014\n\n\n\n\n\n\nNIGELLE LEO YUWEN\n\n\nWSLab 2\n\n\nws2-015\n\n\n\n\n\n\nNISHANTH ELANGO\n\n\nWSLab 2\n\n\nws2-016\n\n\n\n\n\n\nNYAN WUN PAING\n\n\nWSLab 2\n\n\nws2-017\n\n\n\n\n\n\nOEI CHIU YAN REBECCA\n\n\nWSLab 2\n\n\nws2-019\n\n\n\n\n\n\nONG YU XUAN\n\n\nWSLab 2\n\n\nws2-020\n\n\n\n\n\n\nOUNG YONG SHENG KENNEDY\n\n\nWSLab 2\n\n\nws2-021\n\n\n\n\n\n\nOW ZHENG KUAN\n\n\nWSLab 2\n\n\nws2-022\n\n\n\n\n\n\nP PRADEEP\n\n\nWSLab 2\n\n\nws2-023\n\n\n\n\n\n\nPANG JIA JUN VERNON\n\n\nWSLab 2\n\n\nws2-024\n\n\n\n\n\n\nPARK SO HYUN\n\n\nESLab 2\n\n\npc1\n\n\n\n\n\n\nPARMAR VARUN SAMIR\n\n\nESLab 1\n\n\npc1\n\n\n\n\n\n\nPARVATHI RANJITH MENON\n\n\nESLab 1\n\n\npc2\n\n\n\n\n\n\nPATWARI RISHAB\n\n\nESLab 1\n\n\npc3\n\n\n\n\n\n\nPEI YAN BO\n\n\nESLab 1\n\n\npc4\n\n\n\n\n\n\nPHOON JIA JUIN\n\n\nESLab 1\n\n\npc5\n\n\n\n\n\n\nPOH CHOO LEONG, LINSTON\n\n\nESLab 1\n\n\npc6\n\n\n\n\n\n\nPONG LOONG BOB\n\n\nESLab 1\n\n\npc7\n\n\n\n\n\n\nPOON KAH ONN, BENJAMIN\n\n\nESLab 1\n\n\npc8\n\n\n\n\n\n\nPOW JING YONG\n\n\nESLab 1\n\n\npc9\n\n\n\n\n\n\nQIAN JIE\n\n\nESLab 1\n\n\npc10\n\n\n\n\n\n\nQUAH YOU JING KANE\n\n\nESLab 1\n\n\npc11\n\n\n\n\n\n\nQUEK AIK PENG\n\n\nESLab 1\n\n\npc12\n\n\n\n\n\n\nRAGHAV BHARDWAJ\n\n\nESLab 1\n\n\npc13\n\n\n\n\n\n\nRAJAMOHAN B PRIYAN\n\n\nESLab 1\n\n\npc14\n\n\n\n\n\n\nRAVEENDRAN AJEY ASHOK\n\n\nESLab 1\n\n\npc15\n\n\n\n\n\n\nRISHI MAHADEVAN\n\n\nESLab 1\n\n\npc16\n\n\n\n\n\n\nRUSDI HAIZIM B RAHIM\n\n\nESLab 1\n\n\npc17\n\n\n\n\n\n\nRYAN TAN YU\n\n\nESLab 1\n\n\npc18\n\n\n\n\n\n\nSAI GANESH SURESH\n\n\nESLab 1\n\n\npc19\n\n\n\n\n\n\nSCOTT FLOYD ZHEN-YAN SMAHON\n\n\nESLab 1\n\n\npc20\n\n\n\n\n\n\nSEE SHENG CHAO\n\n\nESLab 1\n\n\npc21\n\n\n\n\n\n\nSENTHIL ARAAVIND\n\n\nESLab 2\n\n\npc2\n\n\n\n\n\n\nSHA LONG\n\n\nESLab 2\n\n\npc3\n\n\n\n\n\n\nSHANNON LEE\n\n\nESLab 2\n\n\npc4\n\n\n\n\n\n\nSHAWN WONG JUN KIT\n\n\nESLab 2\n\n\npc5\n\n\n\n\n\n\nSHRIYA SAXENA\n\n\nESLab 2\n\n\npc6\n\n\n\n\n\n\nSIM YU JIE\n\n\nESLab 2\n\n\npc7\n\n\n\n\n\n\nSITI NADIAH BINTE MOHAMED RAMLI\n\n\nESLab 2\n\n\npc8\n\n\n\n\n\n\nSUTHER DAVID SAMUEL\n\n\nESLab 2\n\n\npc9\n\n\n\n\n\n\nTALAGADADIVI DURGA RUKMINI MANASWINI\n\n\nESLab 2\n\n\npc10\n\n\n\n\n\n\nTAM WEI IAN JOSHUA\n\n\nESLab 2\n\n\npc11\n\n\n\n\n\n\nTAN GUAN YEW\n\n\nESLab 2\n\n\npc12\n\n\n\n\n\n\nTAN KAI LI CATHERINE\n\n\nESLab 2\n\n\npc13\n\n\n\n\n\n\nTAN KOK JOON\n\n\nESLab 2\n\n\npc14\n\n\n\n\n\n\nTAN LI ANN PETER\n\n\nESLab 2\n\n\npc15\n\n\n\n\n\n\nTAN YEH HAN, JOHN\n\n\nESLab 2\n\n\npc16\n\n\n\n\n\n\nTAN YI XIANG\n\n\nESLab 2\n\n\npc17\n\n\n\n\n\n\nTAN ZHENG FU JUSTIN\n\n\nESLab 2\n\n\npc18\n\n\n\n\n\n\nTAN ZHENG WEN\n\n\nESLab 2\n\n\npc19\n\n\n\n\n\n\nTAY JIN WEN\n\n\nESLab 2\n\n\npc20\n\n\n\n\n\n\nTAY JING XUAN\n\n\nESLab 2\n\n\npc21\n\n\n\n\n\n\nTAY TZE-WEI, CALEB\n\n\nWSLab 1\n\n\nws1-001\n\n\n\n\n\n\nTAY YEE EN, RYAN\n\n\nWSLab 1\n\n\nws1-002\n\n\n\n\n\n\nTEH ZI HUAI\n\n\nWSLab 1\n\n\nws1-003\n\n\n\n\n\n\nTEO WEI JIE, SHAUN\n\n\nWSLab 1\n\n\nws1-004\n\n\n\n\n\n\nTOH YING YING JANICE\n\n\nWSLab 1\n\n\nws1-005\n\n\n\n\n\n\nTONG QI WEI\n\n\nWSLab 1\n\n\nws1-006\n\n\n\n\n\n\nTRAN MINH DUONG\n\n\nWSLab 1\n\n\nws1-008\n\n\n\n\n\n\nTRAN QUANG THANH\n\n\nWSLab 1\n\n\nws1-009\n\n\n\n\n\n\nTSHIN QI REN\n\n\nWSLab 1\n\n\nws1-010\n\n\n\n\n\n\nUMAR BIN MOIZ\n\n\nWSLab 1\n\n\nws1-011\n\n\n\n\n\n\nVASAVADA TEJAS SUDHIR\n\n\nWSLab 1\n\n\nws1-014\n\n\n\n\n\n\nVIDHYABHARATHI SOMASUNDARAM\n\n\nWSLab 1\n\n\nws1-015\n\n\n\n\n\n\nVIVIAN LEE BOON GEOK\n\n\nWSLab 1\n\n\nws1-016\n\n\n\n\n\n\nWANG ZICONG\n\n\nWSLab 1\n\n\nws1-017\n\n\n\n\n\n\nWEI FENG\n\n\nWSLab 1\n\n\nws1-018\n\n\n\n\n\n\nWENG KEXIN\n\n\nWSLab 1\n\n\nws1-019\n\n\n\n\n\n\nWONG JIN EN, SHANNON\n\n\nWSLab 1\n\n\nws1-020\n\n\n\n\n\n\nWONG REN-WEI, RYAN\n\n\nWSLab 1\n\n\nws1-021\n\n\n\n\n\n\nXUE ZHENGQING\n\n\nWSLab 1\n\n\nws1-022\n\n\n\n\n\n\nYANG AN QI\n\n\nWSLab 1\n\n\nws1-023\n\n\n\n\n\n\nYANG CHENGLONG\n\n\nWSLab 1\n\n\nws1-024\n\n\n\n\n\n\nYANG KAI ZE\n\n\nWSLab 3\n\n\nws3-001\n\n\n\n\n\n\nYANG ZI YUN\n\n\nWSLab 3\n\n\nws3-002\n\n\n\n\n\n\nYAP JIN FA\n\n\nWSLab 3\n\n\nws3-003\n\n\n\n\n\n\nYAP KESIN\n\n\nWSLab 3\n\n\nws3-004\n\n\n\n\n\n\nYE GUOQUAN\n\n\nWSLab 3\n\n\nws3-005\n\n\n\n\n\n\nYE TONG\n\n\nWSLab 3\n\n\nws3-006\n\n\n\n\n\n\nYEN PEI CHIH\n\n\nWSLab 3\n\n\nws3-008\n\n\n\n\n\n\nYEW JING HUI\n\n\nWSLab 3\n\n\nws3-009\n\n\n\n\n\n\nYU XIAOXUE\n\n\nWSLab 3\n\n\nws3-010\n\n\n\n\n\n\nYUAN JIAYI\n\n\nWSLab 3\n\n\nws3-011\n\n\n\n\n\n\nYUE JUN YI\n\n\nWSLab 3\n\n\nws3-012\n\n\n\n\n\n\nZHANG SHIYU\n\n\nWSLab 3\n\n\nws3-014\n\n\n\n\n\n\nZHANG YIHAN\n\n\nWSLab 3\n\n\nws3-015\n\n\n\n\n\n\nZHANG YIPING\n\n\nWSLab 3\n\n\nws3-016\n\n\n\n\n\n\nZHANG YUE HAN\n\n\nWSLab 3\n\n\nws3-017\n\n\n\n\n\n\nZHAO PENGFEI\n\n\nWSLab 3\n\n\nws3-019\n\n\n\n\n\n\nZHAO TIANQI\n\n\nWSLab 3\n\n\nws3-020\n\n\n\n\n\n\nZHENG KAINING\n\n\nWSLab 3\n\n\nws3-021\n\n\n\n\n\n\nZHU BO\n\n\nWSLab 3\n\n\nws3-022\n\n\n\n\n\n\nZHU YIJIE\n\n\nWSLab 3\n\n\nws3-023\n\n\n\n\n\n\nZOE WONG XIN LEI\n\n\nWSLab 3\n\n\nws3-024",
            "title": "Info About PE2"
        },
        {
            "location": "/pe2/index.html#practice-exam-2",
            "text": "",
            "title": "Practice Exam 2"
        },
        {
            "location": "/pe2/index.html#questions",
            "text": "(post on sunday) Exam Paper",
            "title": "Questions"
        },
        {
            "location": "/pe2/index.html#basic-info",
            "text": "Date: 10 November, 2018 (Saturday)  Time: 1pm to 4pm  Venue: Various programming labs  Scope: Units 1-24, Assignments 1-7, Tutorials 1-9  5 programming questions, very easy to hard  Criteria: Correctness, Style, Documentation, Efficient.  Allocation differs per question.  Duration: 2 hours and 30 minutes  Open Book (You can bring analog references)",
            "title": "Basic Info"
        },
        {
            "location": "/pe2/index.html#lab-allocation",
            "text": "Every student is assigned to a programming lab.    Please see the allocation below.  Special access has been given to students assigned to ES Lab 1 and 2 (Embedded System Teaching Lab 1 and 2)  Here are the  locatons for the respective labs",
            "title": "Lab Allocation"
        },
        {
            "location": "/pe2/index.html#special-restrictions",
            "text": "You will be issued a special account on the PE day to solve the exam questions.      There will be no Internet access.",
            "title": "Special Restrictions"
        },
        {
            "location": "/pe2/index.html#vim-configuration",
            "text": "Your default account will have the same  .vimrc  as  ~cs1010/.vimrc  on the CS1010 PE hosts.    You are free to edit this during the practical exams.    You, however, will not be able to download nor install  vim  plugins.",
            "title": "Vim Configuration"
        },
        {
            "location": "/pe2/index.html#general-advice",
            "text": "Save your program regularly.  We will use setup every account with  ~/.vimrc  copied from  ~cs1010/.vimrc .  Thus, you can find the last saved version of your files under  ~/.backup  if you accidentally deleted your code.  Plan your time properly.  Do not spend excessive time on any task.  Read through all questions and solved those that you are confident to solve first.  There are five questions, from very easy to very hard.  Solve as many as you can.  I expect most students will be able to solve 3 out of the 5 questions within the time limit.  Pay attention to the marking criteria, which differs from question to question.     Don't start typing your code right away.  Think about the solution first -- what variables are needed?  what is the control flow (using branches and loops)?  Draw out the flowchart if it helps.    Break down the problem into smaller ones if the problem is too complex to solve.  You are not allowed to start typing on the computer for the first 10 minutes of the practical exam, or until the invigilator announced that you can do so.  You will be given a question form to ask questions to clarify doubts about the question paper.  But note that you can only ask a boolean question (YES/NO answer).  Just like the assignments, you are not given all the test cases that we will be using during grading.  Please test your code against additional test cases, especially for boundary cases.",
            "title": "General Advice"
        },
        {
            "location": "/pe2/index.html#lab-and-seat-allocation",
            "text": "NAME  Venue  Seat Number      AARUSHI SINGH  PL1  soctf-imac215-001    AHMAD MUDAAFI' B ZAINUDDIN  PL1  soctf-imac215-002    AI ZHENGWEI  PL1  soctf-imac215-003    ALEX TEO KANG JIE  PL1  soctf-imac215-004    AMIR AZHAR B AZIZAN  PL1  soctf-imac215-005    ANDREW LAU JIA JUN  PL1  soctf-imac215-006    ANG KENG SIANG  PL1  soctf-imac215-007    ANG KIANG YANG  PL1  soctf-imac215-008    AW CHIAN HAO  PL1  soctf-imac215-009    BALAM SAI ROHIT REDDY  PL1  soctf-imac215-010    BEATRICE CHAN TONG  PL1  soctf-imac215-011    BENEDICT YU CHENG EN  PL1  soctf-imac215-012    BENJAMIN CHIA SHAN HONG  PL1  soctf-imac215-013    CAI RONG  PL1  soctf-imac215-014    CHAN EE ZHENG, BENJAMIN  PL1  soctf-imac215-015    CHAN HIN, SEAN  PL1  soctf-imac215-016    CHAN WEI FONG, MAX  PL1  soctf-imac215-017    CHAN YEE CHONG PHILIP  PL1  soctf-imac215-018    CHAN YEW CHUN DANIEL  PL1  soctf-imac215-019    CHAN ZHI ZHENG, AMOS  PL1  soctf-imac215-020    CHANG HUI ZHEN  PL1  soctf-imac215-021    CHANG ZHONG KAI  PL1  soctf-imac215-022    CHEN CHAO  PL1  soctf-imac215-023    CHEN TONG  PL1  soctf-imac215-024    CHENG LE DA, CLEMENT  PL1  soctf-imac215-025    CHENG WANYIN  PL1  soctf-imac215-027    CHENG WEIXUAN  PL1  soctf-imac215-028    CHERYL NG YUN LIN  PL1  soctf-imac215-029    CHEW JUN KONG  PL1  soctf-imac215-030    CHIA BIING HANN  PL1  soctf-imac215-031    CHNG XIAN YI  PL1  soctf-imac215-032    CHOI WONJAE  PL1  soctf-imac215-034    CHU JUI HUNG @JEFFERSON CHU  PL1  soctf-imac215-035    CHUA MAI FENG, CARL  PL1  soctf-imac215-036    CHUA WEN XUAN  PL1  soctf-imac215-037    CHUA ZONG WEI  PL1  soctf-imac215-038    CLAIRE CHAN YEN HWA  PL1  soctf-imac215-039    CYNTHIA LEE WENG YAN  PL1  soctf-imac215-043    DANIEL TAN WEE LIANG  PL1  soctf-imac215-044    DANISH B EDDIE  PL1  soctf-imac215-045    DARREN ONG  PL2  soctf-pl2-001    DEBBIE TAN JIA MIN  PL2  soctf-pl2-002    DING NING  PL2  soctf-pl2-003    DIVAKARAN HARITHA  PL2  soctf-pl2-004    EDMUND TEO WEI XIN  PL2  soctf-pl2-005    EU JING SEN  PL2  soctf-pl2-006    EVELYN YI-WEN CHEN  PL2  soctf-pl2-007    FATIN NABILAH BTE SUHAIMI  PL2  soctf-pl2-009    FOO CHI HEN  PL2  soctf-pl2-010    GINA QUAH JIE XI  PL2  soctf-pl2-011    GLEN WONG SHU ZE  PL2  soctf-pl2-012    GOH RUI PING SAMANTHA  PL2  soctf-pl2-013    GOH ZHEN HAO JOEY  PL2  soctf-pl2-014    GONDHALEKAR SUKRUT YOGESH  PL2  soctf-pl2-014    GREGORY TAN WEI YUAN  PL2  soctf-pl2-016    GUI XIXIAN  PL2  soctf-pl2-017    GUO HAOREN  PL2  soctf-pl2-018    HANS KURNIA WIDJAJA  PL2  soctf-pl2-019    HAO YUN  PL2  soctf-pl2-020    HASHIR ZAHIR  PL2  soctf-pl2-022    HENG HONG CHUAN  PL2  soctf-pl2-023    HO JING YANG DANIEL  PL2  soctf-pl2-024    HO SI SHI ANNETTE  PL2  soctf-pl2-025    HO WEI BIN, JERRY  PL2  soctf-pl2-026    HU XINYING  PL2  soctf-pl2-028    HUANG XUANKUN  PL2  soctf-pl2-029    IAN CHUA  PL2  soctf-pl2-030    ISABELLA CHEONG XIAO XUAN  PL2  soctf-pl2-031    IVAN ANDIKA LIE  PL2  soctf-pl2-032    JANEL ANG YEE HUEY  PL2  soctf-pl2-035    JASON SATHYA CITRO  PL2  soctf-pl2-036    JASPER ONG SHAO YONG  PL2  soctf-pl2-037    JAZHTEN LOW YONGSHEN  PL2  soctf-pl2-038    JERRY ZHANG ZHUORAN  PL2  soctf-pl2-039    JESS TEO XI ZHI  PL2  soctf-pl2-041    JOEL CHANG ZHI KAI  PL2  soctf-pl2-042    JOHN CUTHBERT KHOO TENG FONG  PL2  soctf-pl2-043    JOSEPH WONG YEFENG  PL2  soctf-pl2-044    JUSTIN CHIA JIA JIN  PL2  soctf-pl2-045    K ALAGES  PL2  soctf-pl2-046    KARAN SARAT  PL3  soctf-pl3-001    KARNATI SAI ABHISHEK  PL3  soctf-pl3-002    KEE KAH LOK  PL3  soctf-pl3-003    KEITH CHAN JUN KAI  PL3  soctf-pl3-004    KELVIN HARRIS  PL3  soctf-pl3-006    KEVIN PUTERA  PL3  soctf-pl3-007    KEZIA KEW KAI YUN  PL3  soctf-pl3-008    KHAIRUL IMAN NASRI B AZHARIE  PL3  soctf-pl3-010    KHOO TZE YANG RAYSON  PL3  soctf-pl3-011    KISHORE R  PL3  soctf-pl3-012    KWOK KUIN EK JEREMY  PL3  soctf-pl3-013    KYAWT KYAWT SAN  PL3  soctf-pl3-014    LAI WEN XUAN JEREMY  PL3  soctf-pl3-015    LAM TIAN WEI JUSTIN  PL3  soctf-pl3-016    LE HONG LONG  PL3  soctf-pl3-017    LEE HONG CHIEN, KENNETH  PL3  soctf-pl3-018    LEE LI XIN  PL3  soctf-pl3-019    LEE RAIYAN BIN ZULKIFLI  PL3  soctf-pl3-020    LEE WEI HERN, JASON  PL3  soctf-pl3-021    LEE YUEYU  PL3  soctf-pl3-022    LEE ZHEN YU  PL3  soctf-pl3-025    LEOW YONG HENG  PL3  soctf-pl3-026    LEOW YONG KANG ANDREW  PL4  soctf-pl4-001    LI JIAYU  PL4  soctf-pl4-002    LI ZIHAN  PL4  soctf-pl4-003    LIAO LIXIN  PL4  soctf-pl4-004    LIAO TIANCHANG  PL4  soctf-pl4-006    LIM CHEE SENG BRIAN  PL4  soctf-pl4-007    LIM CHEK JUN  PL4  soctf-pl4-008    LIM CHENG YIN, RYAN  PL4  soctf-pl4-010    LIM HAO XIANG, SEAN  PL4  soctf-pl4-011    LIM JIA WEI  PL4  soctf-pl4-012    LIM JIAYI, TAMELLY  PL4  soctf-pl4-014    LIM JUN KUANG, LIONEL  PL4  soctf-pl4-015    LIM LI LINCOLN  PL4  soctf-pl4-016    LIM SI YING  PL4  soctf-pl4-017    LIM TING WEI  PL4  soctf-pl4-018    LIM WEN HAN, EUGENE  PL4  soctf-pl4-019    LIM YAN TING  PL4  soctf-pl4-020    LIN JIAYUE  PL4  soctf-pl4-021    LING WEN JIAN  PL4  soctf-pl4-022    LIU JINGXUAN  PL4  soctf-pl4-023    LIU PEIZE  PL4  soctf-pl4-024    LIU SHIRU  PL4  soctf-pl4-025    LIU SONGTAO  PL5  soctf-pl5-001    LIU WEI JIE NICHOLAS  PL5  soctf-pl5-002    LOH CHING WEI, JOSHUA  PL5  soctf-pl5-003    LOH YONG ZEE  PL5  soctf-pl5-004    LOW EE TER  PL5  soctf-pl5-005    LOW JIA YEE  PL5  soctf-pl5-006    LOW SIU YUAN, FRANCIS  PL5  soctf-pl5-007    LUCAS FOO SOO QUAN  PL5  soctf-pl5-008    LYE JUN WEI ANANDA  PL5  soctf-pl5-009    MARC PHUA HSIAO MENG  PL5  soctf-pl5-010    MATTHEW NATHANAEL SUGIRI  PL5  soctf-pl5-011    MERVIN WEE MINGWEN  PL5  soctf-pl5-013    MICHELLE TOH HUI PING  PL5  soctf-pl5-014    MODAK SHANTANU BHARAT  PL5  soctf-pl5-015    MOHAMED RIYAS  PL5  soctf-pl5-016    MOHAMMAD YOUSUF MINHAJ ZIA  PL5  soctf-pl5-017    MUHAMMAD FAIRUZ B AMIRHAMZAH  PL5  soctf-pl5-018    MUHAMMAD HOZEFA ZUMKHAWALA  PL5  soctf-pl5-019    MUHAMMAD SHOLIHIN BIN KAMARUDIN  PL5  soctf-pl5-020    MUHHAMMAD NUR HAFIDZ BIN HUSSAIN  PL5  soctf-pl5-021    NATHAN YEO KEE HERN  PL5  soctf-pl5-022    NEO WEN HUI  PL5  soctf-pl5-023    NG JIE WU  WSLab 2  ws2-001    NG JING KANG  WSLab 2  ws2-002    NG JING KIAT  WSLab 2  ws2-003    NG SHI QI, CARRIE  WSLab 2  ws2-004    NG SIU HIAN  WSLab 2  ws2-005    NG WEE KIAT  WSLab 2  ws2-006    NG WEI JIE, BRANDON  WSLab 2  ws2-008    NG ZI HUI  WSLab 2  ws2-009    NGAN JI CHENG  WSLab 2  ws2-010    NGUYEN THANH DUC  WSLab 2  ws2-011    NGUYEN TIEN DAT  WSLab 2  ws2-012    NIGEL TAN  WSLab 2  ws2-014    NIGELLE LEO YUWEN  WSLab 2  ws2-015    NISHANTH ELANGO  WSLab 2  ws2-016    NYAN WUN PAING  WSLab 2  ws2-017    OEI CHIU YAN REBECCA  WSLab 2  ws2-019    ONG YU XUAN  WSLab 2  ws2-020    OUNG YONG SHENG KENNEDY  WSLab 2  ws2-021    OW ZHENG KUAN  WSLab 2  ws2-022    P PRADEEP  WSLab 2  ws2-023    PANG JIA JUN VERNON  WSLab 2  ws2-024    PARK SO HYUN  ESLab 2  pc1    PARMAR VARUN SAMIR  ESLab 1  pc1    PARVATHI RANJITH MENON  ESLab 1  pc2    PATWARI RISHAB  ESLab 1  pc3    PEI YAN BO  ESLab 1  pc4    PHOON JIA JUIN  ESLab 1  pc5    POH CHOO LEONG, LINSTON  ESLab 1  pc6    PONG LOONG BOB  ESLab 1  pc7    POON KAH ONN, BENJAMIN  ESLab 1  pc8    POW JING YONG  ESLab 1  pc9    QIAN JIE  ESLab 1  pc10    QUAH YOU JING KANE  ESLab 1  pc11    QUEK AIK PENG  ESLab 1  pc12    RAGHAV BHARDWAJ  ESLab 1  pc13    RAJAMOHAN B PRIYAN  ESLab 1  pc14    RAVEENDRAN AJEY ASHOK  ESLab 1  pc15    RISHI MAHADEVAN  ESLab 1  pc16    RUSDI HAIZIM B RAHIM  ESLab 1  pc17    RYAN TAN YU  ESLab 1  pc18    SAI GANESH SURESH  ESLab 1  pc19    SCOTT FLOYD ZHEN-YAN SMAHON  ESLab 1  pc20    SEE SHENG CHAO  ESLab 1  pc21    SENTHIL ARAAVIND  ESLab 2  pc2    SHA LONG  ESLab 2  pc3    SHANNON LEE  ESLab 2  pc4    SHAWN WONG JUN KIT  ESLab 2  pc5    SHRIYA SAXENA  ESLab 2  pc6    SIM YU JIE  ESLab 2  pc7    SITI NADIAH BINTE MOHAMED RAMLI  ESLab 2  pc8    SUTHER DAVID SAMUEL  ESLab 2  pc9    TALAGADADIVI DURGA RUKMINI MANASWINI  ESLab 2  pc10    TAM WEI IAN JOSHUA  ESLab 2  pc11    TAN GUAN YEW  ESLab 2  pc12    TAN KAI LI CATHERINE  ESLab 2  pc13    TAN KOK JOON  ESLab 2  pc14    TAN LI ANN PETER  ESLab 2  pc15    TAN YEH HAN, JOHN  ESLab 2  pc16    TAN YI XIANG  ESLab 2  pc17    TAN ZHENG FU JUSTIN  ESLab 2  pc18    TAN ZHENG WEN  ESLab 2  pc19    TAY JIN WEN  ESLab 2  pc20    TAY JING XUAN  ESLab 2  pc21    TAY TZE-WEI, CALEB  WSLab 1  ws1-001    TAY YEE EN, RYAN  WSLab 1  ws1-002    TEH ZI HUAI  WSLab 1  ws1-003    TEO WEI JIE, SHAUN  WSLab 1  ws1-004    TOH YING YING JANICE  WSLab 1  ws1-005    TONG QI WEI  WSLab 1  ws1-006    TRAN MINH DUONG  WSLab 1  ws1-008    TRAN QUANG THANH  WSLab 1  ws1-009    TSHIN QI REN  WSLab 1  ws1-010    UMAR BIN MOIZ  WSLab 1  ws1-011    VASAVADA TEJAS SUDHIR  WSLab 1  ws1-014    VIDHYABHARATHI SOMASUNDARAM  WSLab 1  ws1-015    VIVIAN LEE BOON GEOK  WSLab 1  ws1-016    WANG ZICONG  WSLab 1  ws1-017    WEI FENG  WSLab 1  ws1-018    WENG KEXIN  WSLab 1  ws1-019    WONG JIN EN, SHANNON  WSLab 1  ws1-020    WONG REN-WEI, RYAN  WSLab 1  ws1-021    XUE ZHENGQING  WSLab 1  ws1-022    YANG AN QI  WSLab 1  ws1-023    YANG CHENGLONG  WSLab 1  ws1-024    YANG KAI ZE  WSLab 3  ws3-001    YANG ZI YUN  WSLab 3  ws3-002    YAP JIN FA  WSLab 3  ws3-003    YAP KESIN  WSLab 3  ws3-004    YE GUOQUAN  WSLab 3  ws3-005    YE TONG  WSLab 3  ws3-006    YEN PEI CHIH  WSLab 3  ws3-008    YEW JING HUI  WSLab 3  ws3-009    YU XIAOXUE  WSLab 3  ws3-010    YUAN JIAYI  WSLab 3  ws3-011    YUE JUN YI  WSLab 3  ws3-012    ZHANG SHIYU  WSLab 3  ws3-014    ZHANG YIHAN  WSLab 3  ws3-015    ZHANG YIPING  WSLab 3  ws3-016    ZHANG YUE HAN  WSLab 3  ws3-017    ZHAO PENGFEI  WSLab 3  ws3-019    ZHAO TIANQI  WSLab 3  ws3-020    ZHENG KAINING  WSLab 3  ws3-021    ZHU BO  WSLab 3  ws3-022    ZHU YIJIE  WSLab 3  ws3-023    ZOE WONG XIN LEI  WSLab 3  ws3-024",
            "title": "Lab and Seat Allocation"
        },
        {
            "location": "/about/index.html",
            "text": "About CS1010\n\n\nModule Description\n\n\nThis module introduces the fundamental concepts of problem solving by computing and programming using an imperative programming language. It is the first and foremost introductory course to computing. It is also the first part of a three-part series on introductory programming and problem solving by computing, which also includes CS2030 and CS2040. Topics covered include problem solving by computing, writing pseudo-codes, basic problem formulation and problem solving, program development, coding, testing and debugging, fundamental programming constructs (variables, types, expressions, assignments, functions, control structures, etc.), fundamental data structures: arrays, strings and structures, simple file processing, and basic recursion. This module is appropriate for SoC students.\n\n\nWho/Where/When\n\n\n\n\nInstructor\n: Ooi Wei Tsang\n\n\nLecture Venue\n: \nI^3\nI^3\n Auditorium\n\n\nLecture Time\n: Every Tuesday, 4pm - 6pm\n\n\nOffice Hour\n: Every Wednesday, 4pm - 5pm\n\n\n\n\nTeaching Assistants\n:\n\n\n\n\nWu Biao\n\n\nYu Xiao Liang\n\n\nDou Rengan\n\n\n\n\n\n\n\n\nUndergraduate Discussion Leaders\n:\n\n\n\n\nArchana Pradeep\n\n\nAu Liang Jun\n\n\nChai Jie Feng (Jack)\n\n\nChua Jun Hui\n\n\nD David Livingston\n\n\nEvan Tay\n\n\nGu Wangfan\n\n\nHo Boon Wee Addison\n\n\nJeffery Kwoh Ji Hui\n\n\nJiang Qinhua\n\n\nJoanne Ong Cui FanG\n\n\nKerryn Eer\n\n\nKyle Timothy Ng Chu\n\n\nLim Heng Guang\n\n\nLin Si Jie\n\n\nNguyen Trong Truong Thanh\n\n\nOng Shu Peng (Metta)\n\n\nOng You Sheng Aaron\n\n\nQuek Shui Herng\n\n\nZhang Tianyang\n\n\n\n\n\n\n\n\nImportant Dates\n\n\n\n\nMidterm Assessment\n: Tuesday, 2 October, 2018 (4pm - 6pm), \nMPSH 1B\n\n\nFinal Assessment\n: Tuesday, 27 Nov, 2018 (9am - 11am)\n\n\nPractical Exam 1\n: Saturday, 6 October, 2018 (9am - 12noon)\n\n\nPractical Exam 2\n: Saturday, 10 November, 2018 \n(9am - 12noon)\n (1pm - 4pm)\n\n\n\n\nAssessment Weightage\n\n\n\n\nProgramming Assignments\n: 30%\n\n\nFinal Assessment\n: 30%\n\n\nMidterm Assessment\n: 15%\n\n\nPractical Exam 1\n: 10%\n\n\nPractical Exam 2\n: 15%",
            "title": "About CS1010"
        },
        {
            "location": "/about/index.html#about-cs1010",
            "text": "",
            "title": "About CS1010"
        },
        {
            "location": "/about/index.html#module-description",
            "text": "This module introduces the fundamental concepts of problem solving by computing and programming using an imperative programming language. It is the first and foremost introductory course to computing. It is also the first part of a three-part series on introductory programming and problem solving by computing, which also includes CS2030 and CS2040. Topics covered include problem solving by computing, writing pseudo-codes, basic problem formulation and problem solving, program development, coding, testing and debugging, fundamental programming constructs (variables, types, expressions, assignments, functions, control structures, etc.), fundamental data structures: arrays, strings and structures, simple file processing, and basic recursion. This module is appropriate for SoC students.",
            "title": "Module Description"
        },
        {
            "location": "/about/index.html#whowherewhen",
            "text": "Instructor : Ooi Wei Tsang  Lecture Venue :  I^3 I^3  Auditorium  Lecture Time : Every Tuesday, 4pm - 6pm  Office Hour : Every Wednesday, 4pm - 5pm   Teaching Assistants :   Wu Biao  Yu Xiao Liang  Dou Rengan     Undergraduate Discussion Leaders :   Archana Pradeep  Au Liang Jun  Chai Jie Feng (Jack)  Chua Jun Hui  D David Livingston  Evan Tay  Gu Wangfan  Ho Boon Wee Addison  Jeffery Kwoh Ji Hui  Jiang Qinhua  Joanne Ong Cui FanG  Kerryn Eer  Kyle Timothy Ng Chu  Lim Heng Guang  Lin Si Jie  Nguyen Trong Truong Thanh  Ong Shu Peng (Metta)  Ong You Sheng Aaron  Quek Shui Herng  Zhang Tianyang",
            "title": "Who/Where/When"
        },
        {
            "location": "/about/index.html#important-dates",
            "text": "Midterm Assessment : Tuesday, 2 October, 2018 (4pm - 6pm),  MPSH 1B  Final Assessment : Tuesday, 27 Nov, 2018 (9am - 11am)  Practical Exam 1 : Saturday, 6 October, 2018 (9am - 12noon)  Practical Exam 2 : Saturday, 10 November, 2018  (9am - 12noon)  (1pm - 4pm)",
            "title": "Important Dates"
        },
        {
            "location": "/about/index.html#assessment-weightage",
            "text": "Programming Assignments : 30%  Final Assessment : 30%  Midterm Assessment : 15%  Practical Exam 1 : 10%  Practical Exam 2 : 15%",
            "title": "Assessment Weightage"
        },
        {
            "location": "/outcomes/index.html",
            "text": "After taking CS1010, students should\n\n\n\n\nbe familiar with fundamental  programming concepts and methodology (variables, assignments, conditions, branches, loops, functions, recursions, structures);\n\n\nbe familiar with and appreciate good programming practice, and apply it to follow-up courses;\n\n\nbe able to apply problem-solving knowledge and skills to write small, well-documented, effective C programs;\n\n\nbe able to appreciate the use of simple data structure such as array, know their limitations to pave way for more complex data structures in the next course;\n\n\nknow the responsibilities of an ethical programmer;\n\n\nbe able to write simple programs in the corresponding programming language to solve a task, given the constraints on the inputs;\n\n\nbe able to manually trace through a program to identify logical errors;\n\n\nbe able to differentiate between logical errors, syntax errors, and run-time errors;\n\n\nbe exposed informally to the concept of code specification in the form of comments in the code, explaining what are the expected inputs and outputs and what are the assumptions;\n\n\nknow about what are some insecure functions to avoid;\n\n\nbe able to generate test cases on their own, with a focus on boundary/special cases;\n\n\nbe able to debug with printf or equivalent functions;\n\n\nbe aware of common strategies and good practices of debugging with printf or equivalent functions;\n\n\nbe able to identify opportunities to, and write, modularized code;\n\n\nbe exposed to a debugger;\n\n\nbe able to write code following good programming style (clear comments, naming convention, indentation, etc.);\n\n\nunderstand the different data types and that there exists a representation of each in the memory, as well as the limitation of the representations due to the limited number of bits;\n\n\ndevelop a simple mental model of how a program is executed (CPU runs the code on data that is stored in memory, function call leads to the creation of call frames, which can explain recursion and variable scoping, etc).  For interpreted language, understand the role of virtual machine/interpreter;\n\n\nbe able to understand at a high level the compilation process (from pre-processing to compiling to linking), where applicable;\n\n\nunderstand the concept of reusability and how a software application can be built on top of software libraries/packages (standard or third parties);\n\n\nbe able to implement bubble sort and insertion sort;\n\n\nbe able to implement linear search and binary search (both iterative and recursive versions);",
            "title": "Learning Outcomes"
        },
        {
            "location": "/schedule/index.html",
            "text": "Schedule\n\n\nThis is a tentative schedule for CS1010.\n\n\nLecture Schedule (Tentative)\n\n\n\n\n\n\n\n\nWeek\n\n\nStarting..\n\n\nTopics\n\n\nTutorial\n\n\nAssignment\n\n\n\n\n\n\n\n\n\n\n1\n\n\n2018-08-13\n\n\nUnits 1-2: Computational Problem Solving\n\n\n\n\n\n\n\n\n\n\n2\n\n\n2018-08-20\n\n\nUnits 3-4: Functions & Types\n\n\n\n\n\n\n\n\n\n\n3\n\n\n2018-08-27\n\n\nUnits 5-7: Basic C programs\n\n\nPS 1; Unix\n\n\n\n\n\n\n\n\n4\n\n\n2018-09-03\n\n\nUnits 8-9: Conditionals\n\n\nPS 3-5; Vim; ex01\n\n\nas01 Released\n\n\n\n\n\n\n5\n\n\n2018-09-10\n\n\nUnits 10-12 Loops\n\n\nPS 8-9\n\n\nas02 Released\n\n\n\n\n\n\n6\n\n\n2018-09-17\n\n\nUnits 13-16 Memory, Array, Strings\n\n\nPS 10-12\n\n\nas03 Released\n\n\n\n\n\n\n-\n\n\n2018-09-24\n\n\nBreak\n\n\n\n\n\n\n\n\n\n\n7\n\n\n2018-10-01\n\n\nMidterm & Practical Exam 1\n\n\n\n\nas04 Released\n\n\n\n\n\n\n8\n\n\n2018-10-08\n\n\nCall-by-Referece, nD-Array\n\n\n\n\nas05 Released\n\n\n\n\n\n\n9\n\n\n2018-10-15\n\n\nEfficiency, Macro, Searching, Sorting\n\n\n\n\nas06 Released\n\n\n\n\n\n\n10\n\n\n2018-10-22\n\n\nStruct, Enum, I/O\n\n\n\n\nas07 Released\n\n\n\n\n\n\n11\n\n\n2018-10-29\n\n\n\n\n\n\nas08 Released\n\n\n\n\n\n\n12\n\n\n2018-11-05\n\n\n\n\nPractical Exam 2\n\n\nas09 Released\n\n\n\n\n\n\n13\n\n\n2018-11-12\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTutorial Time / Venue\n\n\n(scroll horizontally to see the full table)\n\n\n\n\n\n\n\n\nDay/Time\n\n\nCOM1\nB108\n\n\nCOM1\nB109\n\n\nCOM1\nB111\n\n\nCOM1\nB112\n\n\nCOM1\n0120\n\n\nI3\n0336\n\n\nI3\n0338\n\n\nAS6\n0421\n\n\n\n\n\n\n\n\n\n\nMon\n1000\n\n\nC10\nJoanne\n\n\n\n\n\n\n\n\nC09\nEvan\n\n\n\n\n\n\n\n\n\n\n\n\nMon\n1400\n\n\n\n\n\n\n\n\nC1A\nXiao Liang\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTue\n1200\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n03\nAddison\n\n\n\n\n\n\n\n\nTue\n1400\n\n\n\n\n\n\n\n\n\n\n\n\nC03\nKyle\n\n\nC02\nThanh\n\n\n\n\n\n\n\n\nWed\n1000\n\n\nC07\nJun Hui\n\n\n\n\nC08\nShui Herng\n\n\n\n\n\n\n\n\nC06\nShu Peng\n\n\n11\nRengan\n\n\n\n\n\n\nWed\n1200\n\n\n\n\n\n\n\n\n\n\n\n\n10\nDavid\n\n\n07\nAaron\n\n\n\n\n\n\n\n\nWed\n1400\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n08\nTian Yang\n\n\n\n\n\n\n\n\nThu\n1000\n\n\n\n\n\n\n\n\n05\nJeffrey\n\n\n\n\n01\nSi Jie\n\n\n\n\n\n\n\n\n\n\nThu\n1200\n\n\n\n\n\n\nC11\nKerryn\n\n\nC04\nJiefeng\n\n\nC05\nQinhua\n\n\n\n\n\n\n12\nHeng Guang\n\n\n\n\n\n\nThu\n1400\n\n\n\n\n\n\n\n\n06\nArchana\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFri\n1200\n\n\n\n\n\n\n\n\n02\nLiang Jun\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFri\n1400\n\n\n\n\n\n\n\n\n04\nWangfan",
            "title": "Schedule"
        },
        {
            "location": "/schedule/index.html#schedule",
            "text": "This is a tentative schedule for CS1010.",
            "title": "Schedule"
        },
        {
            "location": "/schedule/index.html#lecture-schedule-tentative",
            "text": "Week  Starting..  Topics  Tutorial  Assignment      1  2018-08-13  Units 1-2: Computational Problem Solving      2  2018-08-20  Units 3-4: Functions & Types      3  2018-08-27  Units 5-7: Basic C programs  PS 1; Unix     4  2018-09-03  Units 8-9: Conditionals  PS 3-5; Vim; ex01  as01 Released    5  2018-09-10  Units 10-12 Loops  PS 8-9  as02 Released    6  2018-09-17  Units 13-16 Memory, Array, Strings  PS 10-12  as03 Released    -  2018-09-24  Break      7  2018-10-01  Midterm & Practical Exam 1   as04 Released    8  2018-10-08  Call-by-Referece, nD-Array   as05 Released    9  2018-10-15  Efficiency, Macro, Searching, Sorting   as06 Released    10  2018-10-22  Struct, Enum, I/O   as07 Released    11  2018-10-29    as08 Released    12  2018-11-05   Practical Exam 2  as09 Released    13  2018-11-12",
            "title": "Lecture Schedule (Tentative)"
        },
        {
            "location": "/schedule/index.html#tutorial-time-venue",
            "text": "(scroll horizontally to see the full table)     Day/Time  COM1 B108  COM1 B109  COM1 B111  COM1 B112  COM1 0120  I3 0336  I3 0338  AS6 0421      Mon 1000  C10 Joanne     C09 Evan       Mon 1400     C1A Xiao Liang        Tue 1200        03 Addison     Tue 1400       C03 Kyle  C02 Thanh     Wed 1000  C07 Jun Hui   C08 Shui Herng     C06 Shu Peng  11 Rengan    Wed 1200       10 David  07 Aaron     Wed 1400        08 Tian Yang     Thu 1000     05 Jeffrey   01 Si Jie      Thu 1200    C11 Kerryn  C04 Jiefeng  C05 Qinhua    12 Heng Guang    Thu 1400     06 Archana        Fri 1200     02 Liang Jun        Fri 1400     04 Wangfan",
            "title": "Tutorial Time / Venue"
        },
        {
            "location": "/accounts/index.html",
            "text": "CS1010 Accounts\n\n\nWe will be using a variety of services for CS1010.  To take CS1010, please make sure you have the following accounts:\n\n\nSoC UNIX Account\n\n\nYou can get one here: \nhttps://mysoc.nus.edu.sg/~newacct/\n\n\nThis account allows you to access SoC UNIX resources, including the main computing host running Solaris, \nsunfire\n, and computer clusters running Ubuntu / CentOS.  We will be using the compute clusters for CS1010 (details coming soon).\n\n\nGitHub Account\n\n\nCS1010 uses GitHub Classroom for programming assignment submissions and grading.  You should \nregister for a GitHub account\n if you do not have one. \n\n\nPiazza Account\n\n\nCS1010 uses Piazza for Q&A and discussion.  You should receive an email to register for Piazza.",
            "title": "Accounts"
        },
        {
            "location": "/accounts/index.html#cs1010-accounts",
            "text": "We will be using a variety of services for CS1010.  To take CS1010, please make sure you have the following accounts:",
            "title": "CS1010 Accounts"
        },
        {
            "location": "/accounts/index.html#soc-unix-account",
            "text": "You can get one here:  https://mysoc.nus.edu.sg/~newacct/  This account allows you to access SoC UNIX resources, including the main computing host running Solaris,  sunfire , and computer clusters running Ubuntu / CentOS.  We will be using the compute clusters for CS1010 (details coming soon).",
            "title": "SoC UNIX Account"
        },
        {
            "location": "/accounts/index.html#github-account",
            "text": "CS1010 uses GitHub Classroom for programming assignment submissions and grading.  You should  register for a GitHub account  if you do not have one.",
            "title": "GitHub Account"
        },
        {
            "location": "/accounts/index.html#piazza-account",
            "text": "CS1010 uses Piazza for Q&A and discussion.  You should receive an email to register for Piazza.",
            "title": "Piazza Account"
        },
        {
            "location": "/policies/index.html",
            "text": "Policies\n\n\nEmail Communication\n\n\n\n\n\n\nPlease use only your official NUS email for communication with the teaching staffs -- either the one with \n@u.nus.edu\n or \n@comp.nus.edu.sg\n.  \n\n\n\n\n\n\nPlease use email only for private matters.  Prefix your email subject with \n[CS1010]\n.\n\n\n\n\n\n\nPlease use \nPiazza\n for other matters related to the module.  If you email us privately and we feel that your questions/answers are useful to the rest of the class, we will publish it on Piazza, with anonymization when appropriate.\n\n\n\n\n\n\nLab Sessions\n\n\n\n\n\n\nAttendance is not compulsory at NUS, but we do take attendance during the tutorial sessions.\n\n\n\n\n\n\nYou should stick to your allocated time slot for tutorials.  If there is a strong reason for your to attend another tutorial session, please inform your undergraduate discussion leaders (UDLs).\n\n\n\n\n\n\nLate Submissions\n\n\n\n\n\n\nAll programming assignments must be submitted on time.  If you need an extension, please ask for one and provide a justification for approval.  Only academic reasons and compassionate reasons can be considered (e.g., representing NUS for a sports event is OK; Attending a wedding is not).\n\n\n\n\n\n\nFor late submission, there is a 1% penalty (of the total assessment grade) for every 5-minutes after the deadline, capped at 80%.  For example, if an assessment which was given 40 marks was submitted 100 minutes after the deadline, the student will get 32 marks instead (20% penalty).  If it is submitted 10 hours after the deadline, the student will get 8 marks (as the cap of 80% penalty has been reached).\n\n\n\n\n\n\nDiscussions and Plagiarism\n\n\n\n\n\n\nWe encourage discussions among students for programming assignments, but each student should be responsible for writing his/her own code and should give credits to others when appropriate.  \n\n\n\n\n\n\nNUS and School of Computing have a high standard on academic honesty and take any violation seriously.  In the context of computing modules, source code plagiarism -- copying code from another source and attributing it as one's own code -- is a serious violation.   Please read the page \nPreventing Plagiarism\n from the school's website to familiarize yourself with the policy.\n\n\n\n\n\n\nI adopt a \"no mercy\" policy when it comes to disciplinary action on plagiarism.  Both parties, the student who copied, and the student who allowed others to copy, will be penalized equally.\n\n\n\n\n\n\nScreencast\n\n\n\n\n\n\nScreencast will be recorded and posted online 3-4 days after the lecture.\nThis will be done on a 'best effort' basis and screencast will not be guaranteed to be available on time or at all.  \n\n\n\n\n\n\nPosting of screencast is meant to help students who attended the lecture to recap the content, or to help those who are not able to attend the lecture due to unexpected circumstances.  It does not mean that you should skip lecture.  \nResearch\n has shown that the effect of over-reliance on screencast is negative.\n\n\n\n\n\n\nModel Solutions and Slides\n\n\n\n\n\n\nSlides will be posted \nafter\n the class.  Note that slides are used as a \nvisual aid\n to assist me during lecture. It is not meant as summary of lectures nor a replacement of lecture notes.\n\n\n\n\n\n\nIn a module like CS1010, there is often not a single correct answer.  Hence, there is no model solution for this module.  Sample solutions may be posted (both good and bad ones) for discussion.  I strongly encourage students to discuss your solution with the teaching team, instead of just comparing your solution with the sample solution.\n\n\n\n\n\n\nGrading\n\n\n\n\nStudents will received the grades they deserve irrespective of how the other students in the class perform (i.e., no bell curve).\n\n\n\n\nOpen Book Assessment\n\n\n\n\n\n\nAll assessment, including practical exams, midterm test, and final assessment, are open book assessment -- you can bring in your notes or other \nanalog\n reference materials.\n\n\n\n\n\n\nThere is \nnothing to memorize\n for this class.",
            "title": "Policies"
        },
        {
            "location": "/policies/index.html#policies",
            "text": "",
            "title": "Policies"
        },
        {
            "location": "/policies/index.html#email-communication",
            "text": "Please use only your official NUS email for communication with the teaching staffs -- either the one with  @u.nus.edu  or  @comp.nus.edu.sg .      Please use email only for private matters.  Prefix your email subject with  [CS1010] .    Please use  Piazza  for other matters related to the module.  If you email us privately and we feel that your questions/answers are useful to the rest of the class, we will publish it on Piazza, with anonymization when appropriate.",
            "title": "Email Communication"
        },
        {
            "location": "/policies/index.html#lab-sessions",
            "text": "Attendance is not compulsory at NUS, but we do take attendance during the tutorial sessions.    You should stick to your allocated time slot for tutorials.  If there is a strong reason for your to attend another tutorial session, please inform your undergraduate discussion leaders (UDLs).",
            "title": "Lab Sessions"
        },
        {
            "location": "/policies/index.html#late-submissions",
            "text": "All programming assignments must be submitted on time.  If you need an extension, please ask for one and provide a justification for approval.  Only academic reasons and compassionate reasons can be considered (e.g., representing NUS for a sports event is OK; Attending a wedding is not).    For late submission, there is a 1% penalty (of the total assessment grade) for every 5-minutes after the deadline, capped at 80%.  For example, if an assessment which was given 40 marks was submitted 100 minutes after the deadline, the student will get 32 marks instead (20% penalty).  If it is submitted 10 hours after the deadline, the student will get 8 marks (as the cap of 80% penalty has been reached).",
            "title": "Late Submissions"
        },
        {
            "location": "/policies/index.html#discussions-and-plagiarism",
            "text": "We encourage discussions among students for programming assignments, but each student should be responsible for writing his/her own code and should give credits to others when appropriate.      NUS and School of Computing have a high standard on academic honesty and take any violation seriously.  In the context of computing modules, source code plagiarism -- copying code from another source and attributing it as one's own code -- is a serious violation.   Please read the page  Preventing Plagiarism  from the school's website to familiarize yourself with the policy.    I adopt a \"no mercy\" policy when it comes to disciplinary action on plagiarism.  Both parties, the student who copied, and the student who allowed others to copy, will be penalized equally.",
            "title": "Discussions and Plagiarism"
        },
        {
            "location": "/policies/index.html#screencast",
            "text": "Screencast will be recorded and posted online 3-4 days after the lecture.\nThis will be done on a 'best effort' basis and screencast will not be guaranteed to be available on time or at all.      Posting of screencast is meant to help students who attended the lecture to recap the content, or to help those who are not able to attend the lecture due to unexpected circumstances.  It does not mean that you should skip lecture.   Research  has shown that the effect of over-reliance on screencast is negative.",
            "title": "Screencast"
        },
        {
            "location": "/policies/index.html#model-solutions-and-slides",
            "text": "Slides will be posted  after  the class.  Note that slides are used as a  visual aid  to assist me during lecture. It is not meant as summary of lectures nor a replacement of lecture notes.    In a module like CS1010, there is often not a single correct answer.  Hence, there is no model solution for this module.  Sample solutions may be posted (both good and bad ones) for discussion.  I strongly encourage students to discuss your solution with the teaching team, instead of just comparing your solution with the sample solution.",
            "title": "Model Solutions and Slides"
        },
        {
            "location": "/policies/index.html#grading",
            "text": "Students will received the grades they deserve irrespective of how the other students in the class perform (i.e., no bell curve).",
            "title": "Grading"
        },
        {
            "location": "/policies/index.html#open-book-assessment",
            "text": "All assessment, including practical exams, midterm test, and final assessment, are open book assessment -- you can bring in your notes or other  analog  reference materials.    There is  nothing to memorize  for this class.",
            "title": "Open Book Assessment"
        },
        {
            "location": "/01-program/index.html",
            "text": "Unit 1: What is a Program?\n\n\nLearning Outcomes\n\n\nAfter this unit, students should:\n\n\n\n\nhave an idea of what is a program and how a program is executed by a computer\n\n\nunderstand the basic terminologies: machine code, assembly language, and higher-level programming languages\n\n\n\n\nWhat is a (computer) program?\n\n\nDespite all the wonderful and amazing things that computers can do, computers are not very smart. In fact, they are pretty dumb. Computers can only follow the instructions given by a human. A computer program is a sequence of step-by-step instructions given to computers to manipulate data in order to perform a certain task.\n\n\nProgramming is the art and science of writing a computer program, and that is what you will learn to do in CS1010.\n\n\nHow computer executes a program\n\n\nIn order to learn how to write a program, it is important to have an overview of how a computer executes a program.  You will learn in details how this is done in CS2100/CS2106 or EE2024/CG2271, but for CS1010, we will take a very simplistic and high-level view of this process.\n\n\nThe two important components of a computer we will discuss for CS1010 is the CPU, or \ncentral processing unit\n and the memory, which is a generalized term for where we store the data to be processed or manipulated by the CPU, as well as the instructions to do so.  A memory location is addressable using a \nmemory address\n.  \n\n\nThe instructions to the CPU comes in the form of \nmachine code\n, a sequence of bits (1s and 0s) that is interpreted and then followed by the CPU to do certain things.  These machine code could instruct the CPU, for instance, to compare if a particular number at a certain memory location is more than 0, to add one number to another, or to execute another instruction at another memory location.  The data stored in the memory is also stored as a sequence of 1s and 0s.\n\n\nFrom Machine Code to High-level Programming Language\n\n\nWhile it is possible for us, human, to write machine code directly, few actually do since it is challenging to do so. Different CPUs understand different sets of machine code; it is tedious to figure out where each piece of data is located in the memory (this is actually determined by the operating system).  The resulting code, even when it is correct and easy to read and understand by the machine, are often hard to decipher for a human.\nSimple operations such as comparing which number is bigger might require several instructions to perform.\n\n\nTo get around the readability problem, programmers can code in \nassembly language\n -- a human-readable form of machine code, where each instruction, instead of represented by 0s and 1s, is represented by a mnemonic (such as \ndecr\n, \nincr\n, \nstore\n, \nadd\n, etc.)\n\n\nWriting assembly code does not address the issues of machine-dependent code and the tediousness of programming.  Early programmers (in the fifties) understood this and designed \nhigh-level programming languages\n, where programmers can describe the operations that they wish to do in a language closer to their intention that is machine independent.  A program written in one of these programming languages is then \ncompiled\n into machine code for a specific CPU for execution using a compiler.\n\n\n\n\nThe first commercially available language is FORTRAN from IBM in the 1950s.  Among many early programming languages, C (birth year 1972) is the only one that is still popular and widely used today,  \nFor many reasons\n, C is the language of choice for CS1010.  \n\n\nThe Goals of CS1010\n\n\nThis brings us to the goals of CS1010.  First, you will learn the most important syntax element of the C programming language.  Second, you will learn how a C program behaves, in relation to how a program is executed and how data are stored and manipulated in memory.  Third, you will learn the various tools and techniques that will help you produce good and correct C programs.\n\n\nThe last, and the most important and challenging goal of CS1010, however, is that you will learn how to write programs to solve computational problems.  Learning to write a program that does what you want it to do is actually not difficult.  \nKnowing what you want your program to do is the more challenging part!",
            "title": "1. What is a Program?"
        },
        {
            "location": "/01-program/index.html#unit-1-what-is-a-program",
            "text": "",
            "title": "Unit 1: What is a Program?"
        },
        {
            "location": "/01-program/index.html#learning-outcomes",
            "text": "After this unit, students should:   have an idea of what is a program and how a program is executed by a computer  understand the basic terminologies: machine code, assembly language, and higher-level programming languages",
            "title": "Learning Outcomes"
        },
        {
            "location": "/01-program/index.html#what-is-a-computer-program",
            "text": "Despite all the wonderful and amazing things that computers can do, computers are not very smart. In fact, they are pretty dumb. Computers can only follow the instructions given by a human. A computer program is a sequence of step-by-step instructions given to computers to manipulate data in order to perform a certain task.  Programming is the art and science of writing a computer program, and that is what you will learn to do in CS1010.",
            "title": "What is a (computer) program?"
        },
        {
            "location": "/01-program/index.html#how-computer-executes-a-program",
            "text": "In order to learn how to write a program, it is important to have an overview of how a computer executes a program.  You will learn in details how this is done in CS2100/CS2106 or EE2024/CG2271, but for CS1010, we will take a very simplistic and high-level view of this process.  The two important components of a computer we will discuss for CS1010 is the CPU, or  central processing unit  and the memory, which is a generalized term for where we store the data to be processed or manipulated by the CPU, as well as the instructions to do so.  A memory location is addressable using a  memory address .    The instructions to the CPU comes in the form of  machine code , a sequence of bits (1s and 0s) that is interpreted and then followed by the CPU to do certain things.  These machine code could instruct the CPU, for instance, to compare if a particular number at a certain memory location is more than 0, to add one number to another, or to execute another instruction at another memory location.  The data stored in the memory is also stored as a sequence of 1s and 0s.",
            "title": "How computer executes a program"
        },
        {
            "location": "/01-program/index.html#from-machine-code-to-high-level-programming-language",
            "text": "While it is possible for us, human, to write machine code directly, few actually do since it is challenging to do so. Different CPUs understand different sets of machine code; it is tedious to figure out where each piece of data is located in the memory (this is actually determined by the operating system).  The resulting code, even when it is correct and easy to read and understand by the machine, are often hard to decipher for a human.\nSimple operations such as comparing which number is bigger might require several instructions to perform.  To get around the readability problem, programmers can code in  assembly language  -- a human-readable form of machine code, where each instruction, instead of represented by 0s and 1s, is represented by a mnemonic (such as  decr ,  incr ,  store ,  add , etc.)  Writing assembly code does not address the issues of machine-dependent code and the tediousness of programming.  Early programmers (in the fifties) understood this and designed  high-level programming languages , where programmers can describe the operations that they wish to do in a language closer to their intention that is machine independent.  A program written in one of these programming languages is then  compiled  into machine code for a specific CPU for execution using a compiler.   The first commercially available language is FORTRAN from IBM in the 1950s.  Among many early programming languages, C (birth year 1972) is the only one that is still popular and widely used today,   For many reasons , C is the language of choice for CS1010.",
            "title": "From Machine Code to High-level Programming Language"
        },
        {
            "location": "/01-program/index.html#the-goals-of-cs1010",
            "text": "This brings us to the goals of CS1010.  First, you will learn the most important syntax element of the C programming language.  Second, you will learn how a C program behaves, in relation to how a program is executed and how data are stored and manipulated in memory.  Third, you will learn the various tools and techniques that will help you produce good and correct C programs.  The last, and the most important and challenging goal of CS1010, however, is that you will learn how to write programs to solve computational problems.  Learning to write a program that does what you want it to do is actually not difficult.   Knowing what you want your program to do is the more challenging part!",
            "title": "The Goals of CS1010"
        },
        {
            "location": "/02-algo/index.html",
            "text": "Unit 2: Computational Problems and Algorithms\n\n\nLearning Outcomes:\n\n\nAfter this unit, students should:\n\n\n\n\nunderstand the basic terminologies: computational problem solving, algorithm, flowchart, debugging, testing, variables, value, assignment\n\n\nbe familiar with the algorithm to find the maximum among a list of numbers\n\n\nbe able to trace through flowcharts and updates of variables, and argue if a given algorithm is correct or incorrect\n\n\n\n\nComputational Problems\n\n\nSo, what is computational problem solving?  Let's start with the question, what is a \ncomputational problem\n?  \n\n\nA computational problem is a problem that can be solved step-by-step with a computer.  These problems usually have a well-defined input, constraints, and conditions that the output must satisfied.  Here are some types of computational problems:\n\n\n\n\n\n\nA \ndecision problem\n is one where the answer is yes or no.  For instance, \"given a number \nn\n, is \nn\n even?\" is a decision problem.  Some decision problems take more steps to solve than others.  For instance, \"given a number \nn\n, is \nn\n prime?\" takes more steps than just checking the parity of a number.\n\n\n\n\n\n\nA \nsearch problem\n is one where the solution consists of one or more values that satisfies a given condition.  For instance, we may want to compute a path from one geographical location to another on a map.\n\n\n\n\n\n\nA \ncounting problem\n is one where the answer is the number of solutions to a search problem.\n\n\n\n\n\n\nAn \noptimization problem\n is one where the solution is the \"best\" possible solution, where the \"best\" can be defined in a different way.  For instance, we may want to compute the fastest route from one location to another.\n\n\n\n\n\n\nQuestions such as \"what is the meaning of life?\" \"do I look good in this outfit?\"\n1\n are not computational problems, because they do not have well-defined input, constraints, and conditions that the output must satisfy.\n\n\nIn CS1010 (followed by CS2040C and CS3230), you will learn how to solve computational problems \ncomputationally\n -- this means that you learn to come up with step-by-step instructions meant for computers that you can translate into computer programs, to solve a given problem. \n\n\nExample: Finding the maximum\n\n\nLet's start with a simple problem.  Given a finite list \nL\nL\n of \nk\nk\n integers (\nk\nk\n > 0), find the integer with the maximum value from the list.\n\n\nFirst, let's consider if this is a computational problem.  The input is very well defined.  We know what an integer is.  We are told we have at least one, and we have a finite number of them\n2\n.\n\n\nSecond, let's consider the output.  What conditions must the output satisfy?  First, it has to be equal or larger than every other integer on the list.  Second, it must be an integer \nin\n the list.  This is well defined by the problem statement, so we can say that it is a computational problem.\n\n\nHere is an example.  Suppose the input consists of:\n\n\n4 1 -4 0 9 9 3 5 8\n\n\nThe output should be \n9\n.\n\n\nNow, you should pause reading and think about how you would solve this step-by-step.  \n\n\nAlgorithm\n\n\nOne way to solve this problem is to check through the integers in the list, one-by-one, and keep track of the maximum value so far.  When you reach the end of the list, your \"maximum value so far\" will also be the maximum for the whole list.  \n\n\nLet's look at an example:\n\n\n\n\n\n\n\n\nIntegers Scanned\n\n\nMaximum So Far\n\n\n\n\n\n\n\n\n\n\n4\n\n\n4\n\n\n\n\n\n\n4 1\n\n\n4\n\n\n\n\n\n\n4 1 -4\n\n\n4\n\n\n\n\n\n\n4 1 -4 0\n\n\n4\n\n\n\n\n\n\n4 1 -4 0 9\n\n\n9\n\n\n\n\n\n\n4 1 -4 0 9 9\n\n\n9\n\n\n\n\n\n\n4 1 -4 0 9 9 3\n\n\n9\n\n\n\n\n\n\n4 1 -4 0 9 9 3 5\n\n\n9\n\n\n\n\n\n\n4 1 -4 0 9 9 3 5 8\n\n\n9\n\n\n\n\n\n\n\n\nThe English description above, however, is not detailed enough for computers to understand.  What is the meaning of \"check one-by-one\"? \"keep track of maximum so far\"?  how to tell if we have reached \"the end of the list\"?\n\n\nLet's work out all the details.\n\n\nFirst, we need a concise way of representing the integers in the list.  Borrowing from mathematical notation, let's say that the list \nL\nL\n contains the integers \n\nl_0, l_1, ..., l_{k-1}\nl_0, l_1, ..., l_{k-1}\n. To \"check one-by-one,\" we introduce another notation \nl_i\nl_i\n, which is the integer currently being \"checked\".  We begin with \ni = 0\ni = 0\n, then \ni = 1\ni = 1\n, then \ni = 2\ni = 2\n, etc, until \ni = k-1\ni = k-1\n.  At every step, we increase \ni\ni\n by 1.\n\n\nSecond, we need a concise way of keeping track of the maximum so far.  We introduce another notation, \nm\nm\n, to represent the maximum value so far.  When \ni = 0\ni = 0\n, \nm = l_0\nm = l_0\n.  Since we only scan a single integer, it has to be the maximum.  When we check another integer \nl_i (i > 0)\nl_i (i > 0)\n, only two things can happen:\n\n\n\n\nif this \nl_i\nl_i\n is larger than \nm\nm\n, then \nl_i\nl_i\n has to be the maximum so far, so we update \nm\nm\n to be \nl_i\nl_i\n.\n\n\nif \nl_i\nl_i\n is equal to or smaller than \nm\nm\n, then \nm\nm\n is still the maximum value so far.\n\n\n\n\nWe keep doing the above and increase \ni\ni\n, until we reach the end of the list when (after increasing \ni\ni\n) we find that \ni\ni\n is \nk\nk\n.\n\n\nNow, we have enough details to describe step-by-step, how to find the maximum value from a list of integers.  Such steps, which the computer can take to solve a problem, is called an \nalgorithm\n.  \n\n\nFlowchart\n\n\nThere are different ways one can describe an algorithm.  The easiest way I find is to use a diagram called a \nflowchart\n.  The flowchart for the algorithm above looks like this.  A diamond box represents a \"question\" that can be true or false (yes or no), and we trace through the \"flow\" step by step, following the corresponding path depending on the answer. \n\n\n\n\nPlease spend some time to trace through the walkthrough above.  The snapshot of the values of the \ni\ni\n, \nl_i\nl_i\n, \nk\nk\n, and \nm\nm\n, at the point after \"is \ni\ni\n equals \nk\nk\n\" is shown in the table below \n(except for the first row, which shows the value just before entering \"is \ni\ni\n equals \nk\nk\n\")\n.\n\n\n\n\n\n\n\n\nIntegers Scanned\n\n\ni\ni\n\n\nl_i\nl_i\n\n\nk\nk\n\n\nMaximum So Far (\nm\nm\n)\n\n\n\n\n\n\n\n\n\n\n4\n\n\n1\n\n\n4\n \n1\n\n\n9\n\n\n4\n\n\n\n\n\n\n4 1\n\n\n1\n\n\n1\n\n\n9\n\n\n4\n\n\n\n\n\n\n4 1 -4\n\n\n2\n\n\n-4\n\n\n9\n\n\n4\n\n\n\n\n\n\n4 1 -4 0\n\n\n3\n\n\n0\n\n\n9\n\n\n4\n\n\n\n\n\n\n4 1 -4 0 9\n\n\n4\n\n\n9\n\n\n9\n\n\n4\n\n\n\n\n\n\n4 1 -4 0 9 9\n\n\n5\n\n\n9\n\n\n9\n\n\n9\n\n\n\n\n\n\n4 1 -4 0 9 9 3\n\n\n6\n\n\n3\n\n\n9\n\n\n9\n\n\n\n\n\n\n4 1 -4 0 9 9 3 5\n\n\n7\n\n\n5\n\n\n9\n\n\n9\n\n\n\n\n\n\n4 1 -4 0 9 9 3 5 8\n\n\n8\n\n\n8\n\n\n9\n\n\n9\n\n\n\n\n\n\n4 1 -4 0 9 9 3 5 8\n\n\n9\n\n\n``\n\n\n9\n\n\n9\n\n\n\n\n\n\n\n\nVariables\n\n\nThere are a few important things to take note here.  \nm\nm\n, \ni\ni\n, \nk\nk\n, and the list \nL\nL\n are what we called \nstates\n or \nvariables\n.  While in the above, we can think of them as mathematical variables which we can assign \nvalues\n to, in a computer program, a variable is a location in the memory which holds a value.  \n\n\nWe can perform two very basic operations on the variables: reading and writing.  In other words, we can set their values and we can retrieve their values. \n\n\nWe can \nassign\n the value of one variable to a constant (e.g., set \ni\ni\n to 1) or to the value of another variable (e.g., set \nm\nm\n to \nl_i\nl_i\n).  In the latter example, we first read the value of \nl_i\nl_i\n, from \nl_i\nl_i\n's memory location and then we write that value to the memory location of \nm\nm\n.  Once written, the value of \nm\nm\n will not change until the next time we update the value of \nm\nm\n.\n\n\nIt is important to note that, when \ni\ni\n changes, \nm\nm\n \ndoes not change automatically\n to the new \nl_i\nl_i\n  This behavior is different from that which you may be familiar with in spreadsheet software -- if you set the value of a cell, say \nA1\n to be \n=B1\n, when the value in cell \nB1\n changes, the value \nA1\n also changes automatically.\n\n\nWe can also compare the values of two variables.  We see two examples above: \"\ni\ni\n equals \nk\nk\n?\"  \"\nl_i > m\nl_i > m\n?\"  When we compare, we read the values of the variables from their memory location and checks their relations.\n\n\nWe can perform arithmetic operations on the variables: addition, subtraction, etc.  We see one example above: \"increment \ni\ni\n\".  This operation is actually an assignment operation in disguise.  We can write it as \"set \ni\ni\n to \ni\ni\n + 1\".  Here, you see that \ni\ni\n is referred to twice.  This operation reads the value from the memory location of \ni\ni\n, adds 1 to it, and then writes the resulting value back to the location of \ni\ni\n.\n\n\nBugs\n\n\nIf you follow the execution of the algorithm above, step-by-step, using the example input \n4 1 -4 0 9 9 3 5\n above, you will obtain the correct maximum value \nm\nm\n of \n9\n.  But does that mean that the algorithm is correct?  The answer is NO.  \n\n\nFor an algorithm to correctly solve the given problem, it has to produce the correct result for all valid inputs to the problem.  If we can find one counterexample, one input where the algorithm does not produce the correct output, then the algorithm is incorrect.  Note that I say \ndoes not produce the correct output\n, which means that either the algorithm  \nproduces the wrong output\n or \ndoes not produce any output at all\n.  \n\n\nIn this case, we say that the algorithm or the program has a \nbug\n.  A bug is a defect that causes the algorithm to behave incorrectly.  As a software developer, you will spend some time finding bugs in your code, a process known as \ndebugging\n.  A \ndebugger\n is a tool that helps programmers find bugs in their code.\n\n\nBefore we even start the process of debugging, we first have to know if our algorithm is correct.  Remember that an algorithm is correct only if it produces the correct output only all possible valid inputs.  So, one way to check if an algorithm is correct is to try it with all possible valid inputs.  For the problem we are solving above, however, even though the list is finite, there are infinitely many possible inputs, and so, it is impossible to try all possible valid inputs.  In practice, we \ncraft\n a smaller set of test inputs to check if the algorithm behaves correctly for these test inputs, and \nhope\n that it is correct for all possible inputs.  With experience, you will choose the right set of test inputs to maximize that chances that you will find a bug in your code.  There are also systematic ways of deriving test cases so that the test cases \ncover\n different paths of execution of the algorithm, but we won't be covering it in CS1010\n3\n.\n\n\nAnother way of checking if an algorithm is correct, is to reason about the behavior of the algorithm.  We will do this rather informally in CS1010, starting in 1-2 lectures from now.  You get to rigorously prove that an algorithm is correct in a higher level module (CS3230 Design and Analysis of Algorithms).\n\n\nFinally, even if an algorithm is correct, the corresponding program might not be.  Recall that an algorithm is a step-by-step process to solve a problem.  It is what you want your program to do.  You still have to write a program (in C, or other languages) to actually have the computer do what you want it to do (in other words, to \nimplement the algorithm\n). This process of translating the algorithm to a computer program, called \ncoding\n may introduce bugs as well.  But we will worry about this later when we learn to program.\n\n\nIn the problem set at the end of this lecture, you will see slight variations of the algorithm above.  You should check through them to see whether they are correct or not.\n\n\nProblem Set\n\n\nProblem 1.1\n\n\nThe following algorithms are slight variations of the one in the notes above.  The differences are highlighted in red.  Do they correctly find the maximum integer from a finite list of \nk\nk\n integers (\nk > 0\nk > 0\n)?  \n\n\nIf an algorithm is buggy, give a counter-example where the output is incorrect.  In addition, give an example input where the algorithm still produces the correct output, where possible.  \n\n\n(a). \n\n\n\n(b). \n\n\n\n\u00a9. \n\n\n\n(d). \n\n\n\n(e). \n\n\n\nProblem 1.2\n\n\nChange the algorithm above to find the minimum value instead of the maximum value from the given list \nL = \\{l_0, ..., l_{k-1}\\}\nL = \\{l_0, ..., l_{k-1}\\}\n. \nYou can also assume that the list \nL\nL\n is finite and \nk > 0\nk > 0\n for this question\n.\n\n\nProblem 1.3\n\n\nDraw the flowchart for an algorithm, that takes in a list of integers \nL = \\{l_0, ..., l_{k-1}\\}, k \\ge 0\nL = \\{l_0, ..., l_{k-1}\\}, k \\ge 0\n, and compute the \nsum\n of all the integers.  Think about what variable(s) do you need.\n\n\n\n\n\n\n\n\n\n\nThe answer is, by the way, always \"Yes.\"\u00a0\n\u21a9\n\n\n\n\n\n\nThink about why it is important to have a finite number of integers in the input.\u00a0\n\u21a9\n\n\n\n\n\n\nSoftware testing is a body of knowledge worthy of an advanced module by itself -- we offer one in CS4218.\u00a0\n\u21a9",
            "title": "2. Computational Problem &amp; Algorithms"
        },
        {
            "location": "/02-algo/index.html#unit-2-computational-problems-and-algorithms",
            "text": "",
            "title": "Unit 2: Computational Problems and Algorithms"
        },
        {
            "location": "/02-algo/index.html#learning-outcomes",
            "text": "After this unit, students should:   understand the basic terminologies: computational problem solving, algorithm, flowchart, debugging, testing, variables, value, assignment  be familiar with the algorithm to find the maximum among a list of numbers  be able to trace through flowcharts and updates of variables, and argue if a given algorithm is correct or incorrect",
            "title": "Learning Outcomes:"
        },
        {
            "location": "/02-algo/index.html#computational-problems",
            "text": "So, what is computational problem solving?  Let's start with the question, what is a  computational problem ?    A computational problem is a problem that can be solved step-by-step with a computer.  These problems usually have a well-defined input, constraints, and conditions that the output must satisfied.  Here are some types of computational problems:    A  decision problem  is one where the answer is yes or no.  For instance, \"given a number  n , is  n  even?\" is a decision problem.  Some decision problems take more steps to solve than others.  For instance, \"given a number  n , is  n  prime?\" takes more steps than just checking the parity of a number.    A  search problem  is one where the solution consists of one or more values that satisfies a given condition.  For instance, we may want to compute a path from one geographical location to another on a map.    A  counting problem  is one where the answer is the number of solutions to a search problem.    An  optimization problem  is one where the solution is the \"best\" possible solution, where the \"best\" can be defined in a different way.  For instance, we may want to compute the fastest route from one location to another.    Questions such as \"what is the meaning of life?\" \"do I look good in this outfit?\" 1  are not computational problems, because they do not have well-defined input, constraints, and conditions that the output must satisfy.  In CS1010 (followed by CS2040C and CS3230), you will learn how to solve computational problems  computationally  -- this means that you learn to come up with step-by-step instructions meant for computers that you can translate into computer programs, to solve a given problem.",
            "title": "Computational Problems"
        },
        {
            "location": "/02-algo/index.html#example-finding-the-maximum",
            "text": "Let's start with a simple problem.  Given a finite list  L L  of  k k  integers ( k k  > 0), find the integer with the maximum value from the list.  First, let's consider if this is a computational problem.  The input is very well defined.  We know what an integer is.  We are told we have at least one, and we have a finite number of them 2 .  Second, let's consider the output.  What conditions must the output satisfy?  First, it has to be equal or larger than every other integer on the list.  Second, it must be an integer  in  the list.  This is well defined by the problem statement, so we can say that it is a computational problem.  Here is an example.  Suppose the input consists of:  4 1 -4 0 9 9 3 5 8  The output should be  9 .  Now, you should pause reading and think about how you would solve this step-by-step.",
            "title": "Example: Finding the maximum"
        },
        {
            "location": "/02-algo/index.html#algorithm",
            "text": "One way to solve this problem is to check through the integers in the list, one-by-one, and keep track of the maximum value so far.  When you reach the end of the list, your \"maximum value so far\" will also be the maximum for the whole list.    Let's look at an example:     Integers Scanned  Maximum So Far      4  4    4 1  4    4 1 -4  4    4 1 -4 0  4    4 1 -4 0 9  9    4 1 -4 0 9 9  9    4 1 -4 0 9 9 3  9    4 1 -4 0 9 9 3 5  9    4 1 -4 0 9 9 3 5 8  9     The English description above, however, is not detailed enough for computers to understand.  What is the meaning of \"check one-by-one\"? \"keep track of maximum so far\"?  how to tell if we have reached \"the end of the list\"?  Let's work out all the details.  First, we need a concise way of representing the integers in the list.  Borrowing from mathematical notation, let's say that the list  L L  contains the integers  l_0, l_1, ..., l_{k-1} l_0, l_1, ..., l_{k-1} . To \"check one-by-one,\" we introduce another notation  l_i l_i , which is the integer currently being \"checked\".  We begin with  i = 0 i = 0 , then  i = 1 i = 1 , then  i = 2 i = 2 , etc, until  i = k-1 i = k-1 .  At every step, we increase  i i  by 1.  Second, we need a concise way of keeping track of the maximum so far.  We introduce another notation,  m m , to represent the maximum value so far.  When  i = 0 i = 0 ,  m = l_0 m = l_0 .  Since we only scan a single integer, it has to be the maximum.  When we check another integer  l_i (i > 0) l_i (i > 0) , only two things can happen:   if this  l_i l_i  is larger than  m m , then  l_i l_i  has to be the maximum so far, so we update  m m  to be  l_i l_i .  if  l_i l_i  is equal to or smaller than  m m , then  m m  is still the maximum value so far.   We keep doing the above and increase  i i , until we reach the end of the list when (after increasing  i i ) we find that  i i  is  k k .  Now, we have enough details to describe step-by-step, how to find the maximum value from a list of integers.  Such steps, which the computer can take to solve a problem, is called an  algorithm .",
            "title": "Algorithm"
        },
        {
            "location": "/02-algo/index.html#flowchart",
            "text": "There are different ways one can describe an algorithm.  The easiest way I find is to use a diagram called a  flowchart .  The flowchart for the algorithm above looks like this.  A diamond box represents a \"question\" that can be true or false (yes or no), and we trace through the \"flow\" step by step, following the corresponding path depending on the answer.    Please spend some time to trace through the walkthrough above.  The snapshot of the values of the  i i ,  l_i l_i ,  k k , and  m m , at the point after \"is  i i  equals  k k \" is shown in the table below  (except for the first row, which shows the value just before entering \"is  i i  equals  k k \") .     Integers Scanned  i i  l_i l_i  k k  Maximum So Far ( m m )      4  1  4   1  9  4    4 1  1  1  9  4    4 1 -4  2  -4  9  4    4 1 -4 0  3  0  9  4    4 1 -4 0 9  4  9  9  4    4 1 -4 0 9 9  5  9  9  9    4 1 -4 0 9 9 3  6  3  9  9    4 1 -4 0 9 9 3 5  7  5  9  9    4 1 -4 0 9 9 3 5 8  8  8  9  9    4 1 -4 0 9 9 3 5 8  9  ``  9  9",
            "title": "Flowchart"
        },
        {
            "location": "/02-algo/index.html#variables",
            "text": "There are a few important things to take note here.   m m ,  i i ,  k k , and the list  L L  are what we called  states  or  variables .  While in the above, we can think of them as mathematical variables which we can assign  values  to, in a computer program, a variable is a location in the memory which holds a value.    We can perform two very basic operations on the variables: reading and writing.  In other words, we can set their values and we can retrieve their values.   We can  assign  the value of one variable to a constant (e.g., set  i i  to 1) or to the value of another variable (e.g., set  m m  to  l_i l_i ).  In the latter example, we first read the value of  l_i l_i , from  l_i l_i 's memory location and then we write that value to the memory location of  m m .  Once written, the value of  m m  will not change until the next time we update the value of  m m .  It is important to note that, when  i i  changes,  m m   does not change automatically  to the new  l_i l_i   This behavior is different from that which you may be familiar with in spreadsheet software -- if you set the value of a cell, say  A1  to be  =B1 , when the value in cell  B1  changes, the value  A1  also changes automatically.  We can also compare the values of two variables.  We see two examples above: \" i i  equals  k k ?\"  \" l_i > m l_i > m ?\"  When we compare, we read the values of the variables from their memory location and checks their relations.  We can perform arithmetic operations on the variables: addition, subtraction, etc.  We see one example above: \"increment  i i \".  This operation is actually an assignment operation in disguise.  We can write it as \"set  i i  to  i i  + 1\".  Here, you see that  i i  is referred to twice.  This operation reads the value from the memory location of  i i , adds 1 to it, and then writes the resulting value back to the location of  i i .",
            "title": "Variables"
        },
        {
            "location": "/02-algo/index.html#bugs",
            "text": "If you follow the execution of the algorithm above, step-by-step, using the example input  4 1 -4 0 9 9 3 5  above, you will obtain the correct maximum value  m m  of  9 .  But does that mean that the algorithm is correct?  The answer is NO.    For an algorithm to correctly solve the given problem, it has to produce the correct result for all valid inputs to the problem.  If we can find one counterexample, one input where the algorithm does not produce the correct output, then the algorithm is incorrect.  Note that I say  does not produce the correct output , which means that either the algorithm   produces the wrong output  or  does not produce any output at all .    In this case, we say that the algorithm or the program has a  bug .  A bug is a defect that causes the algorithm to behave incorrectly.  As a software developer, you will spend some time finding bugs in your code, a process known as  debugging .  A  debugger  is a tool that helps programmers find bugs in their code.  Before we even start the process of debugging, we first have to know if our algorithm is correct.  Remember that an algorithm is correct only if it produces the correct output only all possible valid inputs.  So, one way to check if an algorithm is correct is to try it with all possible valid inputs.  For the problem we are solving above, however, even though the list is finite, there are infinitely many possible inputs, and so, it is impossible to try all possible valid inputs.  In practice, we  craft  a smaller set of test inputs to check if the algorithm behaves correctly for these test inputs, and  hope  that it is correct for all possible inputs.  With experience, you will choose the right set of test inputs to maximize that chances that you will find a bug in your code.  There are also systematic ways of deriving test cases so that the test cases  cover  different paths of execution of the algorithm, but we won't be covering it in CS1010 3 .  Another way of checking if an algorithm is correct, is to reason about the behavior of the algorithm.  We will do this rather informally in CS1010, starting in 1-2 lectures from now.  You get to rigorously prove that an algorithm is correct in a higher level module (CS3230 Design and Analysis of Algorithms).  Finally, even if an algorithm is correct, the corresponding program might not be.  Recall that an algorithm is a step-by-step process to solve a problem.  It is what you want your program to do.  You still have to write a program (in C, or other languages) to actually have the computer do what you want it to do (in other words, to  implement the algorithm ). This process of translating the algorithm to a computer program, called  coding  may introduce bugs as well.  But we will worry about this later when we learn to program.  In the problem set at the end of this lecture, you will see slight variations of the algorithm above.  You should check through them to see whether they are correct or not.",
            "title": "Bugs"
        },
        {
            "location": "/02-algo/index.html#problem-set",
            "text": "",
            "title": "Problem Set"
        },
        {
            "location": "/02-algo/index.html#problem-11",
            "text": "The following algorithms are slight variations of the one in the notes above.  The differences are highlighted in red.  Do they correctly find the maximum integer from a finite list of  k k  integers ( k > 0 k > 0 )?    If an algorithm is buggy, give a counter-example where the output is incorrect.  In addition, give an example input where the algorithm still produces the correct output, where possible.    (a).   (b).   \u00a9.   (d).   (e).",
            "title": "Problem 1.1"
        },
        {
            "location": "/02-algo/index.html#problem-12",
            "text": "Change the algorithm above to find the minimum value instead of the maximum value from the given list  L = \\{l_0, ..., l_{k-1}\\} L = \\{l_0, ..., l_{k-1}\\} .  You can also assume that the list  L L  is finite and  k > 0 k > 0  for this question .",
            "title": "Problem 1.2"
        },
        {
            "location": "/02-algo/index.html#problem-13",
            "text": "Draw the flowchart for an algorithm, that takes in a list of integers  L = \\{l_0, ..., l_{k-1}\\}, k \\ge 0 L = \\{l_0, ..., l_{k-1}\\}, k \\ge 0 , and compute the  sum  of all the integers.  Think about what variable(s) do you need.      The answer is, by the way, always \"Yes.\"\u00a0 \u21a9    Think about why it is important to have a finite number of integers in the input.\u00a0 \u21a9    Software testing is a body of knowledge worthy of an advanced module by itself -- we offer one in CS4218.\u00a0 \u21a9",
            "title": "Problem 1.3"
        },
        {
            "location": "/03-func/index.html",
            "text": "Unit 3: Functions\n\n\nLet's start with another problem.\n\n\nProblem: Finding the Range\n\n\nThe \nrange\n of a finite list of at least one integers \nL\nL\n is defined as the difference between the maximum and the minimum.  For example, the range for \n4 1 -4 0 9 9 3 5 8\n is \n13\n.  How do we find the range of a given list? \n\n\nTo find the range of a list, we can break the solution down into three subtasks: first find the maximum, then find the minimum, and finally, find the difference between the two.  \n\n\nFrom the previous lecture, you already know how to find the maximum and the minimum (from Problem 1.2)!  So, in expressing the algorithm to find the range, \nwe can refer to a previous solution to a sub-problem, which we assume we already know how to solve\n.  \n\n\nLet's call our solution to find the maximum value from a given list \nL\nL\n as \nmax\nmax\n.  \nmax\nmax\n takes as input (i) a list \nL\nL\n and (ii) \nk\nk\n, the number of integers in \nL\nL\n.  It produces, or \nreturns\n, the maximum value among the integers in \nL\nL\n.  Borrowing from mathematical notation, we use the notation \nmax(L, k)\nmax(L, k)\n to represent the maximum value of \nL\nL\n.  \n\n\nSuppose that \nmin(L,k)\nmin(L,k)\n returns the minimum value among the integers in \nL\nL\n, then, the algorithm to find the range of \nL\nL\n can be written in a single line: \n\n\n\n\nmax(L, k) - min(L, k)\n\n\nmax(L, k) - min(L, k)\n\n\n\n\nFunctions\n\n\nmax\nmax\n and \nmin\nmin\n are examples of a powerful and important concept with many names: \nfunction\n, \nprocedure\n, \nsubroutine\n, \nmethod\n, \nsubprogram\n.  In the context of CS1010, we will use the term \nfunction\n.  Functions allow us to solve a problem by thinking about the solution at a higher level.  For instance, in the example above, we no longer have to think about checking through the items in the list one-by-one and maintaining the maximum so far, or the minimum so far.  We just have to think about how to compute the range, assuming that we already know how to compute the maximum and the minimum value.\n\n\nSuch an assumption, that we already know how to solve a subproblem, is known as \nwishful thinking\n.  Sometimes, it is useful to solve a problem assuming that you know how to solve the subproblem first, then worry about solving the subproblem later.  \n\n\nFor instance, consider the following problem: Given a finite list of \nk\nk\n integers (\nk > 0\nk > 0\n), find the mean.  \n\n\nThe algorithm again, can be written in one line:\n\n\n\n\nsum(L, k) / k\n\n\nsum(L, k) / k\n\n\n\n\nif we assume that we have a function \nsum\nsum\n that can help us find the total of all \nk\nk\n integers.  It turns out, in this case, that you should also know how to solve the subproblem \nsum\nsum\n, since it is Problem 1.3 from last week.\n\n\nWe can then make this into a function itself, \nmean(L, k)\nmean(L, k)\n, which we can now use to solve other more complex problems.\n\n\nThinking in terms of functions also have another advantage: given a function, we only need to worry about \nwhat\n it does, but not \nhow\n it is done.   We can treat a function as a black box -- given an input, it will produce an output satisfying certain conditions.  Many programming languages, including C which we will be using in CS1010, come with a rich set of predefined functions that we can use to help us solve computational problems.  In CS1010, we will also provide you with some functions to help you with your lab assignments.  You will also define your own functions when solving problems with C.  In fact, a C program is just a collection of functions calling each other.\n\n\nProblem: Finding Standard Deviation\n\n\nLet's look at another problem: Given \nL\nL\n, a finite list of at least one integers, find the standard deviation of the integers in \nL\nL\n.  \n\n\nFirst, recall that the (population) standard deviation is given by \n\n\n\n\n\\sqrt{\\frac{\\sum_{i=0}^{k-1} (l_i - \\mu)^2}{k}}\n\n\n\\sqrt{\\frac{\\sum_{i=0}^{k-1} (l_i - \\mu)^2}{k}}\n\n\n\n\nwhere \n\\mu\n\\mu\n is the mean of the integers in \nL\nL\n.\n\n\nTo compute the standard deviation, we first need to compute \n\\mu\n\\mu\n, the mean.   We already know how to do that: \nmean(L, k)\nmean(L, k)\n.  Then, we need to compute \n\\sum_{i=0}^{k-1} (l_i - \\mu)^2\n\\sum_{i=0}^{k-1} (l_i - \\mu)^2\n.  We can break it down into two subproblems:\n\n\n\n\nGiven a list \nL\nL\n and a constant value \nx\nx\n, subtract \nx\nx\n from every number in \nL\nL\n, giving us a new list.\n\n\nGiven a list, square every number in the list, giving us a new list.\n\n\n\n\nFor now, let's apply wishful thinking and assume that we know how to compute the above two steps with functions \nsubstract(L, k, x)\nsubstract(L, k, x)\n and \nsquare(L, k)\nsquare(L, k)\n, then, the formula \n\\sum_{i=0}^{k-1} (l_i - \\mu)^2\n\\sum_{i=0}^{k-1} (l_i - \\mu)^2\n can be computed by the following steps:\n\n\n\n\nset \n\\mu\n\\mu\n to \nmean(L, k)\nmean(L, k)\n\n\nset \nL'\nL'\n to \nsubstract(L, k, \\mu)\nsubstract(L, k, \\mu)\n\n\nset \nL''\nL''\n to \nsquare(L', k)\nsquare(L', k)\n\n\nset \ntotal\ntotal\n to \nsum(L'', k)\nsum(L'', k)\n.\n\n\n\n\nWe can also write it in one line:\n\n\n\n\nset \ntotal\ntotal\n to \nsum(square(substract(L, k, mean(L, k)), k), k)\nsum(square(substract(L, k, mean(L, k)), k), k)\n\n\n\n\nNow, to compute the standard deviation, we need to divide \ntotal\ntotal\n by \nk\nk\n and find the square root.  But, finding \ntotal\ntotal\n and dividing the result by \nk\nk\n is just \nmean\nmean\n.  To compute square root, we again apply wishful thinking and assume that there is a function \nsqrt\nsqrt\n to do so.\n\n\nWe can now compute the standard deviation with one line: \n\n\n\n\nsqrt(mean(square(substract(L, k, mean(L, k)), k), k))\n\n\nsqrt(mean(square(substract(L, k, mean(L, k)), k), k))\n\n\n\n\nUsing functions, we can easily pass the output from one function as input to another, essentially chain the functions together, like Lego blocks, to solve problems.  We also see an example of \nreuse\n here -- \nmean\nmean\n is used twice with different inputs.\n\n\n\n\nReturning a list\n\n\nWhile the above one-liner is an elegant solution, when we actually implement this in C later, it will not so simple and elegant.  Let's worry about that later.\n\n\n\n\nNow that we have seen how to compute standard deviation by breaking it down the four subproblems, \nsqrt\nsqrt\n, \nmean\nmean\n, \nsquare\nsquare\n, and \nsubstract\nsubstract\n, we have to make sure that things we wish can be done can actually be done.  The C library, and many programming languages, provide a pre-defined method to compute \nsqrt\nsqrt\n.  We already know how to compute \nmean\nmean\n.  Computing \nsquare\nsquare\n can be done as follows:\n\n\n\n\nThe implementation for \nsubstract\nsubstract\n is similar.\n\n\nAnother Solution for Finding Maximum\n\n\nIn the previous lecture, you have seen an algorithm to find the maximum value from a list of integers, which involves checking the elements one-by-one and keeping track of the maximum value so far.\n\n\nNow that we have seen what a function is, we can use the concept of wishful thinking to help us solve this problem in a different way and more elegant way.\n\n\nLet's suppose that we have a function \nmax'(L, i, j)\nmax'(L, i, j)\n, that finds the maximum integer among the elements \nl_i, l_{i+1}, ... l_j\nl_i, l_{i+1}, ... l_j\n.  The function \nmax(L, k)\nmax(L, k)\n, which finds the maximum among all elements of \nL\nL\n, is therefore the same as \nmax'(L, 0, k-1)\nmax'(L, 0, k-1)\n.\n\n\nDo we know how to solve \nmax'(L, i, j)\nmax'(L, i, j)\n without checking the integers in \nL\nL\n one-by-one?  Well, if \ni\ni\n equals to \nj\nj\n, i.e., there is only one element in the range of \nl_i, ..., l_j\nl_i, ..., l_j\n, then yes, the function should return the value of \nl_i\nl_i\n.  But, what if there are multiple elements in the range? (i.e., \ni < j\ni < j\n)?  By wishful thinking, we assume that we already know how to solve smaller (as in a shorter list) problem -- \nmax'(L, i+1, j)\nmax'(L, i+1, j)\n, so the maximum value for the range of \nl_i, ..., l_j\nl_i, ..., l_j\n is the larger of the two: either \nl_i\nl_i\n, or \nmax'(L, i+1, j)\nmax'(L, i+1, j)\n.  We can express this algorithm as follows:\n\n\n\n\nLet's trace through the algorithm above, using our previous example: \n4 1 -4 0 9 9 3 5 8\n.  Given this list, we compare the first element, \n4\n, with the maximum of the rest of the list \n1 -4 0 9 9 3 5 8\n.  Since with wishful thinking, we know how to solve this already, we get \n9\n as maximum value of \n1 -4 0 9 9 3 5 8\n.  Comparing \n4\n and \n9\n, \n9\n is larger. Thus, the maximum value for the whole list is \n9\n.\n\n\nExample: Finding a Factorial\n\n\nLet us look at another example of a function before we move on to another topic.  Suppose we want to write a function \nfactorial(n)\nfactorial(n)\n for an integer \nn\nn\n (\nn \\ge 0\nn \\ge 0\n) that computes \nn!\nn!\n. Recall that \nn! = n \\times n - 1 \\times n - 2 \\times ... 2 \\times 1 = n \\times (n-1)!\nn! = n \\times n - 1 \\times n - 2 \\times ... 2 \\times 1 = n \\times (n-1)!\n.  As a special case, \n0!\n0!\n is defined to be \n1\n1\n.\n\n\nThe algorithm to do this can be expressed by the following diagram:\n\n\n\n\nLet's look at an example.  Let's say we want to compute \nfactorial(4)\nfactorial(4)\n.  We assume we know how to solve this for a smaller problem --  \nfactorial(3)\nfactorial(3)\n, which is 6.  \nfactorial(4)\nfactorial(4)\n is thus 4 \n\\times\n\\times\n 6, i.e., 24.\n\n\nRecursion: Function Calling Itself\n\n\nmax'\nmax'\n and \nfactorial\nfactorial\n are examples of functions which calls itself to solve a simpler version of the problem.  This is known as \nrecursion\n.  We will revisit this concept in much greater detail in the later part of CS1010.\n\n\nProblem Set\n\n\nProblem 3.1 : Getting MAD\n\n\nThe mean absolute deviation, or MAD, of a set of integers measures how spread out a set of data is.  The \nabsolute deviation\n is the absolute difference between an element in the list with the mean of values of the list.  The mean absolute deviation is the mean of all the absolute difference.  In other words, given \nL = \\{l_0, ... l_{k-1}\\}\nL = \\{l_0, ... l_{k-1}\\}\n, the MAD of \nL\nL\n is:\n\n\n\n\n\\frac{\\sum_{i=0}^{k-1} |l_i - \\mu|}{k}\n\n\n\\frac{\\sum_{i=0}^{k-1} |l_i - \\mu|}{k}\n\n\n\n\nHow do you find MAD by composing various functions we have seen?  Do you need a new function?\n\n\nProblem 3.2 : Ownself calls ownself\n\n\n(a) Give an algorithm for finding the sum of all the integers in the list \nL\nL\n with \nk\nk\n integers (\nk > 0\nk > 0\n) that is recursive.\n\n\n(b) The function \npow(i, j)\npow(i, j)\n computes \ni^j\ni^j\n.  Give an algorithm to compute \npow(i, j)\npow(i, j)\n recursively.",
            "title": "3. Functions"
        },
        {
            "location": "/03-func/index.html#unit-3-functions",
            "text": "Let's start with another problem.",
            "title": "Unit 3: Functions"
        },
        {
            "location": "/03-func/index.html#problem-finding-the-range",
            "text": "The  range  of a finite list of at least one integers  L L  is defined as the difference between the maximum and the minimum.  For example, the range for  4 1 -4 0 9 9 3 5 8  is  13 .  How do we find the range of a given list?   To find the range of a list, we can break the solution down into three subtasks: first find the maximum, then find the minimum, and finally, find the difference between the two.    From the previous lecture, you already know how to find the maximum and the minimum (from Problem 1.2)!  So, in expressing the algorithm to find the range,  we can refer to a previous solution to a sub-problem, which we assume we already know how to solve .    Let's call our solution to find the maximum value from a given list  L L  as  max max .   max max  takes as input (i) a list  L L  and (ii)  k k , the number of integers in  L L .  It produces, or  returns , the maximum value among the integers in  L L .  Borrowing from mathematical notation, we use the notation  max(L, k) max(L, k)  to represent the maximum value of  L L .    Suppose that  min(L,k) min(L,k)  returns the minimum value among the integers in  L L , then, the algorithm to find the range of  L L  can be written in a single line:    max(L, k) - min(L, k)  max(L, k) - min(L, k)",
            "title": "Problem: Finding the Range"
        },
        {
            "location": "/03-func/index.html#functions",
            "text": "max max  and  min min  are examples of a powerful and important concept with many names:  function ,  procedure ,  subroutine ,  method ,  subprogram .  In the context of CS1010, we will use the term  function .  Functions allow us to solve a problem by thinking about the solution at a higher level.  For instance, in the example above, we no longer have to think about checking through the items in the list one-by-one and maintaining the maximum so far, or the minimum so far.  We just have to think about how to compute the range, assuming that we already know how to compute the maximum and the minimum value.  Such an assumption, that we already know how to solve a subproblem, is known as  wishful thinking .  Sometimes, it is useful to solve a problem assuming that you know how to solve the subproblem first, then worry about solving the subproblem later.    For instance, consider the following problem: Given a finite list of  k k  integers ( k > 0 k > 0 ), find the mean.    The algorithm again, can be written in one line:   sum(L, k) / k  sum(L, k) / k   if we assume that we have a function  sum sum  that can help us find the total of all  k k  integers.  It turns out, in this case, that you should also know how to solve the subproblem  sum sum , since it is Problem 1.3 from last week.  We can then make this into a function itself,  mean(L, k) mean(L, k) , which we can now use to solve other more complex problems.  Thinking in terms of functions also have another advantage: given a function, we only need to worry about  what  it does, but not  how  it is done.   We can treat a function as a black box -- given an input, it will produce an output satisfying certain conditions.  Many programming languages, including C which we will be using in CS1010, come with a rich set of predefined functions that we can use to help us solve computational problems.  In CS1010, we will also provide you with some functions to help you with your lab assignments.  You will also define your own functions when solving problems with C.  In fact, a C program is just a collection of functions calling each other.",
            "title": "Functions"
        },
        {
            "location": "/03-func/index.html#problem-finding-standard-deviation",
            "text": "Let's look at another problem: Given  L L , a finite list of at least one integers, find the standard deviation of the integers in  L L .    First, recall that the (population) standard deviation is given by    \\sqrt{\\frac{\\sum_{i=0}^{k-1} (l_i - \\mu)^2}{k}}  \\sqrt{\\frac{\\sum_{i=0}^{k-1} (l_i - \\mu)^2}{k}}   where  \\mu \\mu  is the mean of the integers in  L L .  To compute the standard deviation, we first need to compute  \\mu \\mu , the mean.   We already know how to do that:  mean(L, k) mean(L, k) .  Then, we need to compute  \\sum_{i=0}^{k-1} (l_i - \\mu)^2 \\sum_{i=0}^{k-1} (l_i - \\mu)^2 .  We can break it down into two subproblems:   Given a list  L L  and a constant value  x x , subtract  x x  from every number in  L L , giving us a new list.  Given a list, square every number in the list, giving us a new list.   For now, let's apply wishful thinking and assume that we know how to compute the above two steps with functions  substract(L, k, x) substract(L, k, x)  and  square(L, k) square(L, k) , then, the formula  \\sum_{i=0}^{k-1} (l_i - \\mu)^2 \\sum_{i=0}^{k-1} (l_i - \\mu)^2  can be computed by the following steps:   set  \\mu \\mu  to  mean(L, k) mean(L, k)  set  L' L'  to  substract(L, k, \\mu) substract(L, k, \\mu)  set  L'' L''  to  square(L', k) square(L', k)  set  total total  to  sum(L'', k) sum(L'', k) .   We can also write it in one line:   set  total total  to  sum(square(substract(L, k, mean(L, k)), k), k) sum(square(substract(L, k, mean(L, k)), k), k)   Now, to compute the standard deviation, we need to divide  total total  by  k k  and find the square root.  But, finding  total total  and dividing the result by  k k  is just  mean mean .  To compute square root, we again apply wishful thinking and assume that there is a function  sqrt sqrt  to do so.  We can now compute the standard deviation with one line:    sqrt(mean(square(substract(L, k, mean(L, k)), k), k))  sqrt(mean(square(substract(L, k, mean(L, k)), k), k))   Using functions, we can easily pass the output from one function as input to another, essentially chain the functions together, like Lego blocks, to solve problems.  We also see an example of  reuse  here --  mean mean  is used twice with different inputs.   Returning a list  While the above one-liner is an elegant solution, when we actually implement this in C later, it will not so simple and elegant.  Let's worry about that later.   Now that we have seen how to compute standard deviation by breaking it down the four subproblems,  sqrt sqrt ,  mean mean ,  square square , and  substract substract , we have to make sure that things we wish can be done can actually be done.  The C library, and many programming languages, provide a pre-defined method to compute  sqrt sqrt .  We already know how to compute  mean mean .  Computing  square square  can be done as follows:   The implementation for  substract substract  is similar.",
            "title": "Problem: Finding Standard Deviation"
        },
        {
            "location": "/03-func/index.html#another-solution-for-finding-maximum",
            "text": "In the previous lecture, you have seen an algorithm to find the maximum value from a list of integers, which involves checking the elements one-by-one and keeping track of the maximum value so far.  Now that we have seen what a function is, we can use the concept of wishful thinking to help us solve this problem in a different way and more elegant way.  Let's suppose that we have a function  max'(L, i, j) max'(L, i, j) , that finds the maximum integer among the elements  l_i, l_{i+1}, ... l_j l_i, l_{i+1}, ... l_j .  The function  max(L, k) max(L, k) , which finds the maximum among all elements of  L L , is therefore the same as  max'(L, 0, k-1) max'(L, 0, k-1) .  Do we know how to solve  max'(L, i, j) max'(L, i, j)  without checking the integers in  L L  one-by-one?  Well, if  i i  equals to  j j , i.e., there is only one element in the range of  l_i, ..., l_j l_i, ..., l_j , then yes, the function should return the value of  l_i l_i .  But, what if there are multiple elements in the range? (i.e.,  i < j i < j )?  By wishful thinking, we assume that we already know how to solve smaller (as in a shorter list) problem --  max'(L, i+1, j) max'(L, i+1, j) , so the maximum value for the range of  l_i, ..., l_j l_i, ..., l_j  is the larger of the two: either  l_i l_i , or  max'(L, i+1, j) max'(L, i+1, j) .  We can express this algorithm as follows:   Let's trace through the algorithm above, using our previous example:  4 1 -4 0 9 9 3 5 8 .  Given this list, we compare the first element,  4 , with the maximum of the rest of the list  1 -4 0 9 9 3 5 8 .  Since with wishful thinking, we know how to solve this already, we get  9  as maximum value of  1 -4 0 9 9 3 5 8 .  Comparing  4  and  9 ,  9  is larger. Thus, the maximum value for the whole list is  9 .",
            "title": "Another Solution for Finding Maximum"
        },
        {
            "location": "/03-func/index.html#example-finding-a-factorial",
            "text": "Let us look at another example of a function before we move on to another topic.  Suppose we want to write a function  factorial(n) factorial(n)  for an integer  n n  ( n \\ge 0 n \\ge 0 ) that computes  n! n! . Recall that  n! = n \\times n - 1 \\times n - 2 \\times ... 2 \\times 1 = n \\times (n-1)! n! = n \\times n - 1 \\times n - 2 \\times ... 2 \\times 1 = n \\times (n-1)! .  As a special case,  0! 0!  is defined to be  1 1 .  The algorithm to do this can be expressed by the following diagram:   Let's look at an example.  Let's say we want to compute  factorial(4) factorial(4) .  We assume we know how to solve this for a smaller problem --   factorial(3) factorial(3) , which is 6.   factorial(4) factorial(4)  is thus 4  \\times \\times  6, i.e., 24.",
            "title": "Example: Finding a Factorial"
        },
        {
            "location": "/03-func/index.html#recursion-function-calling-itself",
            "text": "max' max'  and  factorial factorial  are examples of functions which calls itself to solve a simpler version of the problem.  This is known as  recursion .  We will revisit this concept in much greater detail in the later part of CS1010.",
            "title": "Recursion: Function Calling Itself"
        },
        {
            "location": "/03-func/index.html#problem-set",
            "text": "",
            "title": "Problem Set"
        },
        {
            "location": "/03-func/index.html#problem-31-getting-mad",
            "text": "The mean absolute deviation, or MAD, of a set of integers measures how spread out a set of data is.  The  absolute deviation  is the absolute difference between an element in the list with the mean of values of the list.  The mean absolute deviation is the mean of all the absolute difference.  In other words, given  L = \\{l_0, ... l_{k-1}\\} L = \\{l_0, ... l_{k-1}\\} , the MAD of  L L  is:   \\frac{\\sum_{i=0}^{k-1} |l_i - \\mu|}{k}  \\frac{\\sum_{i=0}^{k-1} |l_i - \\mu|}{k}   How do you find MAD by composing various functions we have seen?  Do you need a new function?",
            "title": "Problem 3.1 : Getting MAD"
        },
        {
            "location": "/03-func/index.html#problem-32-ownself-calls-ownself",
            "text": "(a) Give an algorithm for finding the sum of all the integers in the list  L L  with  k k  integers ( k > 0 k > 0 ) that is recursive.  (b) The function  pow(i, j) pow(i, j)  computes  i^j i^j .  Give an algorithm to compute  pow(i, j) pow(i, j)  recursively.",
            "title": "Problem 3.2 : Ownself calls ownself"
        },
        {
            "location": "/04-type/index.html",
            "text": "Unit 4: Types\n\n\nRecall from Unit 1 that machine code and data manipulated by machine code are all stored as a sequence of 1s and 0s in the memory.  Each unit of either 1 or 0 is known as a \nbit\n.  8 bits form a \nbyte\n.\n\n\nRemember from Unit 2 that a variable is a memory location that stores a value, as a sequence of bits.  The bits stored in the memory has no meaning by itself.  It has to be interpreted by the machine code.  Does a sequence of 1s and 0s represent an integer?  A pixel of an image?  A sound sample in an audio clip?  A month?   As a programmer, we have to tag the variable with its \ntype\n, so that the machine code knows how to interpret the sequence of bits.  In addition, the type also tells the machine code, how many bits \"belong\" to this variable.  The number of bits of a type is also known as the \nsize\n of a type.\n\n\nThe size of a type determines how many different values a variable of that type can hold.  For instance, a type of one bit can only hold two possible values (e.g., \n0\n or \n1\n, \ntrue\n or \nfalse\n, \nblack\n or \nwhite\n).  A type of two bits can hold four values, represented as \n00\n, \n01\n, \n10\n, \n11\n.  In general, a type of \nk\nk\n bits can hold \n2^k\n2^k\n values.\n\n\nIntegers\n\n\nTo represent integers, a type of 8 bits can represent 256 different values.  If the type only represents non-negative integers (called \nunsigned\n), then it can hold any value between 0 to 255.  If it represents both positive and negative integers (called \nsigned\n), it can hold any value between -128 to 127.  Depending on the needs (how much memory we have, how big is the number we need to represent), programmers have to decide on the size of the type used for a variable in their programs.  With 64 bits, a signed integer can store any value between -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807.  This might look big enough for you -- but we can't even fit the results from \nfactorial(21)\nfactorial(21)\n here!\n\nWe have to go to 128 bits to represent larger integers.\n\n\nCharacters\n\n\nTo represent a character (i.e., a symbol representing a letter, number, punctuation, etc), we use 8 bits for English characters.  The ASCII standard maps 127 binary sequences to common characters you can type on your keyboard (including 0-9, A-Z, a-z, all sorts of punctuations: <>?:\"{}!@#$%^&*()_+-=[]\\';/., and special characters like return and escape).  The unicode standard uses up to 32 bits per character, allowing many non-English letter characters (e.g., \nEmoticons\n, \nBraille\n, \nMahjong Tiles\n) to be represented.\n\n\nReal Numbers\n\n\nFor real numbers, because we need to represent a huge number of possible values, we normally use 32 bits or 64 bits.  In CS1231, you will learn that there are uncountably many possible real numbers.  But, no matter how many bits we use, we can only represent a finite number of possible values for real numbers.  Here, we run into a limit of digitizing information into 0s and 1s -- we can never represent all possible real numbers in a computer!  Because of this, programs that manipulate real numbers leads to weird answers (such as 0.1 + 0.2 is not exactly the same as 0.3) and so, we have to take special care when dealing with real numbers when writing programs (not just in C, but in many other languages as well).  Hence, if we only expect a variable to hold an integer, we should not choose a type that represents real numbers.\n\n\nThe details of how a sequence of bits can represent integers and real numbers (both positive and negative numbers) are covered in CS2100. \n\n\nYou should have also noticed that in the discussion above, we talk about types that are 8, 16, 32, 64, 128 bits -- all power of twos.  We do not have a type of size, say, 41 bits.  The reason for this has to do with how memory location is addressed.  This will again be explained in CS2100.\n\n\nType Declaration\n\n\nIn C, which we will use in CS1010, we have to associate \nevery\n variable with a type, and once a variable is \ndeclared\n with a type, the type cannot be changed\n1\n.\n\n\nWhen we write a function, we have to declare the types of each of the parameters and the return value as well.  \n\n\nTake the function \nmean(L, k)\nmean(L, k)\n as an example.  We have said that \nL\nL\n is a list\n2\n of integers.  So each element in \nL\nL\n should have an integer type (how many bits to use will depend on the range of numbers we want the program to possibly handle and how frugal we are about memory usage).  What about \nk\nk\n?  \nk\nk\n refers to the number of elements in \nL\nL\n, so it has to be an integer.  As for the value returned by \nmean(L, k)\nmean(L, k)\n, even when the inputs are all integers (and thus, the sum is an integer), the mean value can be a real number.  So we should choose a type that represents a real number for the return value.  \n\n\n\n\nImportance of Type\n\n\nChoosing a wrong type to represent a variable can lead to buggy code.  Suppose we say that \nmean(L, k)\nmean(L, k)\n returns an integer, then when we call \nmean\nmean\n on the input \n1 2 3 4\n, we will get \n2\n as the answer, instead of \n2.5\n as it should.\n\n\n\n\n\n\n\n\n\n\n\n\nThis behavior is known as static typing.  Some programming languages, such as Javascript and Python, are dynamically typed.  The type of a variable may change depending on the value the variable is assigned to.\u00a0\n\u21a9\n\n\n\n\n\n\nWe have not talked about how to represent a list yet.  I will do that in a later unit.\u00a0\n\u21a9",
            "title": "4. Types"
        },
        {
            "location": "/04-type/index.html#unit-4-types",
            "text": "Recall from Unit 1 that machine code and data manipulated by machine code are all stored as a sequence of 1s and 0s in the memory.  Each unit of either 1 or 0 is known as a  bit .  8 bits form a  byte .  Remember from Unit 2 that a variable is a memory location that stores a value, as a sequence of bits.  The bits stored in the memory has no meaning by itself.  It has to be interpreted by the machine code.  Does a sequence of 1s and 0s represent an integer?  A pixel of an image?  A sound sample in an audio clip?  A month?   As a programmer, we have to tag the variable with its  type , so that the machine code knows how to interpret the sequence of bits.  In addition, the type also tells the machine code, how many bits \"belong\" to this variable.  The number of bits of a type is also known as the  size  of a type.  The size of a type determines how many different values a variable of that type can hold.  For instance, a type of one bit can only hold two possible values (e.g.,  0  or  1 ,  true  or  false ,  black  or  white ).  A type of two bits can hold four values, represented as  00 ,  01 ,  10 ,  11 .  In general, a type of  k k  bits can hold  2^k 2^k  values.",
            "title": "Unit 4: Types"
        },
        {
            "location": "/04-type/index.html#integers",
            "text": "To represent integers, a type of 8 bits can represent 256 different values.  If the type only represents non-negative integers (called  unsigned ), then it can hold any value between 0 to 255.  If it represents both positive and negative integers (called  signed ), it can hold any value between -128 to 127.  Depending on the needs (how much memory we have, how big is the number we need to represent), programmers have to decide on the size of the type used for a variable in their programs.  With 64 bits, a signed integer can store any value between -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807.  This might look big enough for you -- but we can't even fit the results from  factorial(21) factorial(21)  here! \nWe have to go to 128 bits to represent larger integers.",
            "title": "Integers"
        },
        {
            "location": "/04-type/index.html#characters",
            "text": "To represent a character (i.e., a symbol representing a letter, number, punctuation, etc), we use 8 bits for English characters.  The ASCII standard maps 127 binary sequences to common characters you can type on your keyboard (including 0-9, A-Z, a-z, all sorts of punctuations: <>?:\"{}!@#$%^&*()_+-=[]\\';/., and special characters like return and escape).  The unicode standard uses up to 32 bits per character, allowing many non-English letter characters (e.g.,  Emoticons ,  Braille ,  Mahjong Tiles ) to be represented.",
            "title": "Characters"
        },
        {
            "location": "/04-type/index.html#real-numbers",
            "text": "For real numbers, because we need to represent a huge number of possible values, we normally use 32 bits or 64 bits.  In CS1231, you will learn that there are uncountably many possible real numbers.  But, no matter how many bits we use, we can only represent a finite number of possible values for real numbers.  Here, we run into a limit of digitizing information into 0s and 1s -- we can never represent all possible real numbers in a computer!  Because of this, programs that manipulate real numbers leads to weird answers (such as 0.1 + 0.2 is not exactly the same as 0.3) and so, we have to take special care when dealing with real numbers when writing programs (not just in C, but in many other languages as well).  Hence, if we only expect a variable to hold an integer, we should not choose a type that represents real numbers.  The details of how a sequence of bits can represent integers and real numbers (both positive and negative numbers) are covered in CS2100.   You should have also noticed that in the discussion above, we talk about types that are 8, 16, 32, 64, 128 bits -- all power of twos.  We do not have a type of size, say, 41 bits.  The reason for this has to do with how memory location is addressed.  This will again be explained in CS2100.",
            "title": "Real Numbers"
        },
        {
            "location": "/04-type/index.html#type-declaration",
            "text": "In C, which we will use in CS1010, we have to associate  every  variable with a type, and once a variable is  declared  with a type, the type cannot be changed 1 .  When we write a function, we have to declare the types of each of the parameters and the return value as well.    Take the function  mean(L, k) mean(L, k)  as an example.  We have said that  L L  is a list 2  of integers.  So each element in  L L  should have an integer type (how many bits to use will depend on the range of numbers we want the program to possibly handle and how frugal we are about memory usage).  What about  k k ?   k k  refers to the number of elements in  L L , so it has to be an integer.  As for the value returned by  mean(L, k) mean(L, k) , even when the inputs are all integers (and thus, the sum is an integer), the mean value can be a real number.  So we should choose a type that represents a real number for the return value.     Importance of Type  Choosing a wrong type to represent a variable can lead to buggy code.  Suppose we say that  mean(L, k) mean(L, k)  returns an integer, then when we call  mean mean  on the input  1 2 3 4 , we will get  2  as the answer, instead of  2.5  as it should.       This behavior is known as static typing.  Some programming languages, such as Javascript and Python, are dynamically typed.  The type of a variable may change depending on the value the variable is assigned to.\u00a0 \u21a9    We have not talked about how to represent a list yet.  I will do that in a later unit.\u00a0 \u21a9",
            "title": "Type Declaration"
        },
        {
            "location": "/05-first-c/index.html",
            "text": "Unit 5: First C Program\n\n\nIn this unit, we will write and compile your first C program.  You have already learned, conceptually, what is a variable, what is a type and what is a function.  Let's see how we apply these concepts to C.\n\n\nTo start, let's look at a simple snippet of C code:\n\n\n1\n2\n3\n4\nint\n \nsquare\n(\nint\n \nx\n)\n \n\n{\n\n  \nreturn\n \nx\n*\nx\n;\n\n\n}\n\n\n\n\n\n\n\nThe code above defines a function named \nsquare\n.  The word \nint\n appears \nbefore\n the name \nsquare\n.  \nint\n is used to signify an integer type.  Appearing before the name \nsquare\n tells the compiler that \nsquare\n is returning a value of type \nint\n.\n\n\nAfter the word \nsquare\n, we write the parameters to the function in parenthesis \n(\n and \n)\n.  In between \n(\n and \n)\n is \nint x\n: \nx\n is the name of the parameter, \nint\n is the type of that parameter.  \n\n\nTo summarize, in Line 1, \nint square(int x)\n defines a function named \nsquare\n that takes in an integer parameter \nx\n and is returning a value which is also an integer.\n\n\nThe next three lines are written in between curly brackets \n{\n and \n}\n.  You will see these used a lot in C and other programming languages with C-like syntaxes, such as Javascript, C++, and Java.  These curly brackets group a \nblock\n of \nstatements\n together.  In this example, this block defines how the function \nsquare\n computes the square of \nx\n, and what it returns.  This is sometimes called the \nbody of a function\n.\n\n\nIn this function body, there is only one statement \nreturn x*x;\n  within the block.  A \nstatement\n is a unit in a programming language that expresses either a command to be executed or declares a new variable or function.  The word \nreturn\n says that this function \nsquare\n should return the following value, computed as \nx*x\n (\nx\n multiply by \nx\n).  This statement is terminated by a semicolon \n;\n.\n\n\nYou also see that the line that starts with \nreturn\n is indented.  We use indentation extensively to indicate the body of a block.  Since we can have nested blocks, indentation makes our code easier to read and understand.\n\n\nThe words \nint\n and \nreturn\n that appear above are \nkeywords\n defined in the C programming language, and they are reserved for the special meaning that they represent (a type and a command to return a value from a function).  We cannot repurpose keywords in C.  For instance, we cannot introduce a variable called \nint\n.\n\n\nWe are now ready to write our first C program.  The first program computes the square of the hypotenuse of a right-angled triangle with a base of 4 and height of 3.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\nint\n \nsquare\n(\nint\n \nx\n)\n \n\n{\n\n  \nreturn\n \nx\n*\nx\n;\n\n\n}\n\n\n\nint\n \nmain\n()\n \n\n{\n\n  \nint\n \nhypotenuse_square\n;\n\n\n  \nhypotenuse_square\n \n=\n \nsquare\n(\n3\n)\n \n+\n \nsquare\n(\n4\n);\n\n  \nreturn\n \n0\n;\n\n\n}\n\n\n\n\n\n\n\nRemember that a C program consists of a bunch of functions, calling each other.  The most important function is called \nmain\n, and it is the \nentry point\n to the program.  It is where the operating system will begin to execute the program.  Every program must define \nexactly one function\n called \nmain\n.\n\n\n1\n2\n3\n4\nint\n \nmain\n()\n \n\n{\n\n  \n:\n\n\n}\n\n\n\n\n\n\n\nmain\n returns an integer to the operating system, to signal to the operating system whether the program exits successfully or not.  In this case, we always return \n0\n (success) assuming that nothing goes wrong for simplicity.  This is the second example where you see the keyword \nreturn\n in action.\n\n\nIn modern C, the main always return 0 when it exits.  So, we will skip this statement \nreturn 0;\n from now on.\n\n\nVariable Declaration\n\n\nIn the example above, you also see the lines\n\n\n1\nint\n \nhypotenuse_square\n;\n\n\n\n\n\n\n\nThis is declaration statement (terminated with a semicolon, again).  Each statement declares a variable with its corresponding type (\nint\n here).  We gave each variable a name, here we call the variable \nhypotenuse_square\n.\n\n\nRemember that \nall variables must be declared with its corresponding type before used in C\n.\n\n\nIn C, a function must be either defined or declared before used as well.  In the example above, we define \nsquare\n before \nmain\n.  If we switch the order of the two, the compiler will complain.  Unless we declare the function first.  Declaring a function means that we simply state the return type, the name, and the parameters, \nwithout\n the body.  Here is an example:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\nint\n \nsquare\n(\nint\n \nx\n);\n \n// declaring the function square\n\n\n\nint\n \nmain\n()\n \n\n{\n\n  \nint\n \nhypotenuse_square\n;\n\n\n  \nhypotenuse_square\n \n=\n \nsquare\n(\n3\n)\n \n+\n \nsquare\n(\n4\n);\n\n  \nreturn\n \n0\n;\n\n\n}\n\n\n\nint\n \nsquare\n(\nint\n \nx\n)\n  \n// defining the function square\n\n\n{\n\n  \nreturn\n \nx\n*\nx\n;\n\n\n}\n\n\n\n\n\n\n\nAssignment Statement\n\n\nThe next line of the code shows an example of an assignment statement.  \n\n\n1\n  \nhypotenuse_square\n \n=\n \nsquare\n(\n3\n)\n \n+\n \nsquare\n(\n4\n);\n\n\n\n\n\n\n\nAn assignment operator takes the form of:\n\n\n1\n  \nleft_hand_side\n \n=\n \nright_hand_side\n;\n\n\n\n\n\n\n\nThe \nleft_hand_side\n must be the name of a variable.  We first evaluate the \nright_hand_side\n of the assignment statement, find its value, then put the value into the variable named on the \nleft_hand_side\n.\n\n\nHere, on the right-hand side, we call the function \nsquare\n, which we defined earlier.  We call \nsquare\n with \narguments\n \n3\n and \n4\n respectively.   We use the operator \n+\n to add the two results together.  The right-hand side should give the value 25, which we then assign to the variable \nhypotenuse_square\n.\n\n\nNote that we use \n=\n equal sign for assignment, NOT for checking equality.  The C notation for checking for equality is \n==\n (we will come back to this later).\n\n\nRecap\n\n\nBefore we move on, let's recap some concepts:\n\n\n\n\nA C program consists of functions, invoking each other.\n\n\nEach function is defined by its returned type, followed by its name, its parameter(s) (within a pair of parenthesis) and its body (within a pair of curly brackets).  \n\n\nEach function must be defined or declared before it is used.  \n\n\nThe function body consists of one or more statements.  We have seen assignment statements (using the \n=\n operator) and return statements, using \nreturn\n as the keyword.\n\n\nEach variable must be declared before it is used.  A declaration starts with its type followed by its name.\n\n\n\n\nExample 2\n\n\nLet's change the program slightly, so that instead of computing the square of the hypotenuse, we compute the hypotenuse itself.  Recall that we said C provides a bunch of predefined functions, include \nsqrt\n, which computes the square root of a given number.  Since a square root of a number is not necessarily an integer, we need to use a variable with a type that can store a real number.  \n\n\nTo represent real numbers, we commonly use the type \nfloat\n (which is short for a floating point number -- named so due to how a real number is represented in bits).  A \nfloat\n type can store 32 bits.  To double the precision (64 bits), we can use the type \ndouble\n.  A \nlong double\n type can store either 80-bits or 128-bits, depending on the implementation.\n\n\nBut which one does \nsqrt\n returns?  To find out the exact \nspecification\n of a pre-defined function, we can consult the manual (or \nman\n for short) pages for the function.  \n\n\nIf you type \nman sqrt\n on the command line (or place the cursor on \nsqrt\n in \nvim\n and type \nK\n in command mode), you will see that the \nsqrt\n method has the following specification:\n\n\n1\ndouble\n \nsqrt\n(\ndouble\n \nx\n);\n\n\n\n\n\n\n\nThe \nsqrt\n function returns a \ndouble\n precision real number.  We can now modify the program above to the following:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\ndouble\n \nsqrt\n(\ndouble\n \nx\n);\n \n// not recommended\n\n\n\nlong\n \nsquare\n(\nlong\n \nx\n)\n \n\n{\n\n  \nreturn\n \nx\n*\nx\n;\n\n\n}\n\n\n\ndouble\n \nhypotenuse_of\n(\nlong\n \nbase\n,\n \nlong\n \nheight\n)\n \n\n{\n\n  \nreturn\n \nsqrt\n(\nsquare\n(\nbase\n)\n \n+\n \nsquare\n(\nheight\n));\n\n\n}\n\n\n\nint\n \nmain\n()\n \n\n{\n\n  \nhypotenuse_of\n(\n3\n,\n \n4\n);\n\n\n}\n\n\n\n\n\n\n\nNote that the first line declares the function \nsqrt\n, because we need to declare a function before it is used.  Since \nsqrt\n is pre-defined elsewhere, we do not have to supply the function body here.  Such practice of declaring a predefined function ourselves, however, is not recommended.  Different platform, compilers, libraries, may provide a different specification for the same function.  As such, it is better to use the declaration from the library that provides the predefined function itself.  A library usually provides one or more \nheader files\n, a set of files that contain function declarations, type definitions, and constant definitions.  In the case of \nsqrt\n, its declaration is contained in a header file called \nmath.h\n (which we found out through consulting the \nman\n pages).  To include this file, you add the line \n#include\n \n<math.h>\n at the top of the program.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n#include\n \n<math.h>\n\n\n\nlong\n \nsquare\n(\nlong\n \nx\n)\n \n\n{\n\n  \nreturn\n \nx\n*\nx\n;\n\n\n}\n\n\n\ndouble\n \nhypotenuse_of\n(\nlong\n \nbase\n,\n \nlong\n \nheight\n)\n \n\n{\n\n  \nreturn\n \nsqrt\n(\nsquare\n(\nbase\n)\n \n+\n \nsquare\n(\nheight\n));\n\n\n}\n\n\n\nint\n \nmain\n()\n \n\n{\n\n  \nhypotenuse_of\n(\n3\n,\n \n4\n);\n\n\n}\n\n\n\n\n\n\n\nYou might notice the same line appear in the man page for \nsqrt\n.  Thus, the man pages tell us which header file to include if you want to use a certain function.\n\n\n\n\nFile Extension\n\n\nThe convention for file extension for a C program is \n.c\n and for a C header file is \n.h\n.  Even though you are allowed to name the files with any extension you like, you should stick to the convention so that it is clear to other tools/programmers what is the purpose of each file.\n\n\n\n\nOther Types in C\n\n\nAn \nint\n variable is usually 32-bits long.  If we only need 16 bits, we use the type \nshort int\n, or just \nshort\n.  If we only need 8-bits, we use the type \nchar\n (short for character).\n\n\nNote that in the above, I said an \nint\n is \nusually\n 32 bits.  Remember (from \nUnit 1\n that a C program gets compiled into machine code for a specific CPU architecture.  The C standard only guarantees that an \nint\n is at least 16 bits.  Although most C compilers compile \nint\n to 32 bits, there is no guarantee!    \n\n\nIf we need something more than an \nint\n, we can use \nlong int\n, or just \nlong\n.  The C standard guarantees that a \nlong\n is at least 32 bits.  Depending on the implementation, it sometimes compiled to 32-bits, sometimes 64-bits.  To get even longer, we can use the type \nlong long int\n, or just \nlong long\n, which is guaranteed to be at least 64 bits\n1\n.\n\n\nSigned vs. Unsigned\n\n\nWe have seen earlier that the same sequence of bits, if interpreted as signed or unsigned, would result in a different value.  By default, all types in C refer to signed types.  If you want a variable that holds only non-negative integers, you can add the keyword \nunsigned\n to the front of the type.  Doing so would mean that the range of values you can store in the variable is doubled, without adding more bits (since the bit used to present the + or - sign is no longer needed).  \n\n\nFor instance, since we know that \nsquare\n can only return a non-zero integer, we can actually declare it as:\n\n\n1\n2\n3\n4\nunsigned\n \nlong\n \nsquare\n(\nlong\n \nx\n)\n \n\n{\n\n  \nreturn\n \nx\n*\nx\n;\n\n\n}\n\n\n\n\n\n\n\nFor most practical purposes in CS1010, a (signed) \nlong\n suffices.  We introduce the notion of \nsigned\n vs. \nunsigned\n for your information so that you know what they are when you come across them in others source code.  Mixing \nsigned\n and \nunsigned\n can lead to subtle bugs in your code.  As such, \nwe will only use signed \nlong\n for CS1010\n.  You may choose to use them appropriately in another context, especially for embedded system or low-level programming.\n\n\n\n\nUnsigned Real Numbers?\n\n\nThere are no \nunsigned\n versions of \nfloat\n and \ndouble\n.  To understand the reason, we have to go further into how floating points numbers are represented in bits.  That is a topic for another module.\n\n\n\n\nstdint.h\n\n\nSince the number of bits for \nint\n, \nlong\n, and \nlong long\n could differ, in order to write a C program that is portable (i.e., works on different platforms, architecture, operating systems), we have two options:\n\n\n\n\nDo not write a program that assumes a specific number of bits is used for a certain type, or\n\n\nUse the type defined in the header file \nstdint.h\n: \nint8_t\n, \nuint8_t\n, \nint16_t\n, \nuint16_t\n, \nint32_t\n, \nuint32_t\n, \nint64_t\n, \nuint64_t\n.  The suffix \n_t\n is a convention to indicate that this is a customized type (more on this in later units).  The prefix \nu\n indicates that the type is an unsigned type.  The numbers \n8\n, \n16\n, \n32\n, and \n64\n indicate the number of bits for each type.  Thus, \nuint32_t\n is guaranteed to be of size 32 bits, and can hold unsigned integer values from \n0\n0\n to \n2^{32}-1\n2^{32}-1\n.\n\n\n\n\nProblem Set 5\n\n\nProblem 5.1\n\n\nIn the example above, \nsqrt\n is declared to take in a parameter of type \ndouble\n .  But the argument that we pass in is the sum of two \nint\n, which is also an \nint\n.   Would this result in an error?  \n\n\nProblem 5.2\n\n\nConsider the following alternative definition of \nsquare\n\n\n1\n2\n3\n???\n \nsquare\n(\nuint16_t\n \nx\n)\n \n{\n\n    \nreturn\n \nx\n*\nx\n;\n\n\n}\n\n\n\n\n\n\n\nWhat should the return type of this \nsquare\n be, in order for the return type to be big enough to store all possible value for \nx*x\n?\n\n\n\n\n\n\n\n\n\n\nAdding more \nlong\n does not make the integer longer, i.e., there is no \nlong long long int\n.\u00a0\n\u21a9",
            "title": "5. First C Program"
        },
        {
            "location": "/05-first-c/index.html#unit-5-first-c-program",
            "text": "In this unit, we will write and compile your first C program.  You have already learned, conceptually, what is a variable, what is a type and what is a function.  Let's see how we apply these concepts to C.  To start, let's look at a simple snippet of C code:  1\n2\n3\n4 int   square ( int   x )   { \n   return   x * x ;  }    The code above defines a function named  square .  The word  int  appears  before  the name  square .   int  is used to signify an integer type.  Appearing before the name  square  tells the compiler that  square  is returning a value of type  int .  After the word  square , we write the parameters to the function in parenthesis  (  and  ) .  In between  (  and  )  is  int x :  x  is the name of the parameter,  int  is the type of that parameter.    To summarize, in Line 1,  int square(int x)  defines a function named  square  that takes in an integer parameter  x  and is returning a value which is also an integer.  The next three lines are written in between curly brackets  {  and  } .  You will see these used a lot in C and other programming languages with C-like syntaxes, such as Javascript, C++, and Java.  These curly brackets group a  block  of  statements  together.  In this example, this block defines how the function  square  computes the square of  x , and what it returns.  This is sometimes called the  body of a function .  In this function body, there is only one statement  return x*x;   within the block.  A  statement  is a unit in a programming language that expresses either a command to be executed or declares a new variable or function.  The word  return  says that this function  square  should return the following value, computed as  x*x  ( x  multiply by  x ).  This statement is terminated by a semicolon  ; .  You also see that the line that starts with  return  is indented.  We use indentation extensively to indicate the body of a block.  Since we can have nested blocks, indentation makes our code easier to read and understand.  The words  int  and  return  that appear above are  keywords  defined in the C programming language, and they are reserved for the special meaning that they represent (a type and a command to return a value from a function).  We cannot repurpose keywords in C.  For instance, we cannot introduce a variable called  int .  We are now ready to write our first C program.  The first program computes the square of the hypotenuse of a right-angled triangle with a base of 4 and height of 3.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12 int   square ( int   x )   { \n   return   x * x ;  }  int   main ()   { \n   int   hypotenuse_square ; \n\n   hypotenuse_square   =   square ( 3 )   +   square ( 4 ); \n   return   0 ;  }    Remember that a C program consists of a bunch of functions, calling each other.  The most important function is called  main , and it is the  entry point  to the program.  It is where the operating system will begin to execute the program.  Every program must define  exactly one function  called  main .  1\n2\n3\n4 int   main ()   { \n   :  }    main  returns an integer to the operating system, to signal to the operating system whether the program exits successfully or not.  In this case, we always return  0  (success) assuming that nothing goes wrong for simplicity.  This is the second example where you see the keyword  return  in action.  In modern C, the main always return 0 when it exits.  So, we will skip this statement  return 0;  from now on.",
            "title": "Unit 5: First C Program"
        },
        {
            "location": "/05-first-c/index.html#variable-declaration",
            "text": "In the example above, you also see the lines  1 int   hypotenuse_square ;    This is declaration statement (terminated with a semicolon, again).  Each statement declares a variable with its corresponding type ( int  here).  We gave each variable a name, here we call the variable  hypotenuse_square .  Remember that  all variables must be declared with its corresponding type before used in C .  In C, a function must be either defined or declared before used as well.  In the example above, we define  square  before  main .  If we switch the order of the two, the compiler will complain.  Unless we declare the function first.  Declaring a function means that we simply state the return type, the name, and the parameters,  without  the body.  Here is an example:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14 int   square ( int   x );   // declaring the function square  int   main ()   { \n   int   hypotenuse_square ; \n\n   hypotenuse_square   =   square ( 3 )   +   square ( 4 ); \n   return   0 ;  }  int   square ( int   x )    // defining the function square  { \n   return   x * x ;  }",
            "title": "Variable Declaration"
        },
        {
            "location": "/05-first-c/index.html#assignment-statement",
            "text": "The next line of the code shows an example of an assignment statement.    1    hypotenuse_square   =   square ( 3 )   +   square ( 4 );    An assignment operator takes the form of:  1    left_hand_side   =   right_hand_side ;    The  left_hand_side  must be the name of a variable.  We first evaluate the  right_hand_side  of the assignment statement, find its value, then put the value into the variable named on the  left_hand_side .  Here, on the right-hand side, we call the function  square , which we defined earlier.  We call  square  with  arguments   3  and  4  respectively.   We use the operator  +  to add the two results together.  The right-hand side should give the value 25, which we then assign to the variable  hypotenuse_square .  Note that we use  =  equal sign for assignment, NOT for checking equality.  The C notation for checking for equality is  ==  (we will come back to this later).",
            "title": "Assignment Statement"
        },
        {
            "location": "/05-first-c/index.html#recap",
            "text": "Before we move on, let's recap some concepts:   A C program consists of functions, invoking each other.  Each function is defined by its returned type, followed by its name, its parameter(s) (within a pair of parenthesis) and its body (within a pair of curly brackets).    Each function must be defined or declared before it is used.    The function body consists of one or more statements.  We have seen assignment statements (using the  =  operator) and return statements, using  return  as the keyword.  Each variable must be declared before it is used.  A declaration starts with its type followed by its name.",
            "title": "Recap"
        },
        {
            "location": "/05-first-c/index.html#example-2",
            "text": "Let's change the program slightly, so that instead of computing the square of the hypotenuse, we compute the hypotenuse itself.  Recall that we said C provides a bunch of predefined functions, include  sqrt , which computes the square root of a given number.  Since a square root of a number is not necessarily an integer, we need to use a variable with a type that can store a real number.    To represent real numbers, we commonly use the type  float  (which is short for a floating point number -- named so due to how a real number is represented in bits).  A  float  type can store 32 bits.  To double the precision (64 bits), we can use the type  double .  A  long double  type can store either 80-bits or 128-bits, depending on the implementation.  But which one does  sqrt  returns?  To find out the exact  specification  of a pre-defined function, we can consult the manual (or  man  for short) pages for the function.    If you type  man sqrt  on the command line (or place the cursor on  sqrt  in  vim  and type  K  in command mode), you will see that the  sqrt  method has the following specification:  1 double   sqrt ( double   x );    The  sqrt  function returns a  double  precision real number.  We can now modify the program above to the following:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16 double   sqrt ( double   x );   // not recommended  long   square ( long   x )   { \n   return   x * x ;  }  double   hypotenuse_of ( long   base ,   long   height )   { \n   return   sqrt ( square ( base )   +   square ( height ));  }  int   main ()   { \n   hypotenuse_of ( 3 ,   4 );  }    Note that the first line declares the function  sqrt , because we need to declare a function before it is used.  Since  sqrt  is pre-defined elsewhere, we do not have to supply the function body here.  Such practice of declaring a predefined function ourselves, however, is not recommended.  Different platform, compilers, libraries, may provide a different specification for the same function.  As such, it is better to use the declaration from the library that provides the predefined function itself.  A library usually provides one or more  header files , a set of files that contain function declarations, type definitions, and constant definitions.  In the case of  sqrt , its declaration is contained in a header file called  math.h  (which we found out through consulting the  man  pages).  To include this file, you add the line  #include   <math.h>  at the top of the program.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16 #include   <math.h>  long   square ( long   x )   { \n   return   x * x ;  }  double   hypotenuse_of ( long   base ,   long   height )   { \n   return   sqrt ( square ( base )   +   square ( height ));  }  int   main ()   { \n   hypotenuse_of ( 3 ,   4 );  }    You might notice the same line appear in the man page for  sqrt .  Thus, the man pages tell us which header file to include if you want to use a certain function.   File Extension  The convention for file extension for a C program is  .c  and for a C header file is  .h .  Even though you are allowed to name the files with any extension you like, you should stick to the convention so that it is clear to other tools/programmers what is the purpose of each file.",
            "title": "Example 2"
        },
        {
            "location": "/05-first-c/index.html#other-types-in-c",
            "text": "An  int  variable is usually 32-bits long.  If we only need 16 bits, we use the type  short int , or just  short .  If we only need 8-bits, we use the type  char  (short for character).  Note that in the above, I said an  int  is  usually  32 bits.  Remember (from  Unit 1  that a C program gets compiled into machine code for a specific CPU architecture.  The C standard only guarantees that an  int  is at least 16 bits.  Although most C compilers compile  int  to 32 bits, there is no guarantee!      If we need something more than an  int , we can use  long int , or just  long .  The C standard guarantees that a  long  is at least 32 bits.  Depending on the implementation, it sometimes compiled to 32-bits, sometimes 64-bits.  To get even longer, we can use the type  long long int , or just  long long , which is guaranteed to be at least 64 bits 1 .",
            "title": "Other Types in C"
        },
        {
            "location": "/05-first-c/index.html#signed-vs-unsigned",
            "text": "We have seen earlier that the same sequence of bits, if interpreted as signed or unsigned, would result in a different value.  By default, all types in C refer to signed types.  If you want a variable that holds only non-negative integers, you can add the keyword  unsigned  to the front of the type.  Doing so would mean that the range of values you can store in the variable is doubled, without adding more bits (since the bit used to present the + or - sign is no longer needed).    For instance, since we know that  square  can only return a non-zero integer, we can actually declare it as:  1\n2\n3\n4 unsigned   long   square ( long   x )   { \n   return   x * x ;  }    For most practical purposes in CS1010, a (signed)  long  suffices.  We introduce the notion of  signed  vs.  unsigned  for your information so that you know what they are when you come across them in others source code.  Mixing  signed  and  unsigned  can lead to subtle bugs in your code.  As such,  we will only use signed  long  for CS1010 .  You may choose to use them appropriately in another context, especially for embedded system or low-level programming.   Unsigned Real Numbers?  There are no  unsigned  versions of  float  and  double .  To understand the reason, we have to go further into how floating points numbers are represented in bits.  That is a topic for another module.",
            "title": "Signed vs. Unsigned"
        },
        {
            "location": "/05-first-c/index.html#stdinth",
            "text": "Since the number of bits for  int ,  long , and  long long  could differ, in order to write a C program that is portable (i.e., works on different platforms, architecture, operating systems), we have two options:   Do not write a program that assumes a specific number of bits is used for a certain type, or  Use the type defined in the header file  stdint.h :  int8_t ,  uint8_t ,  int16_t ,  uint16_t ,  int32_t ,  uint32_t ,  int64_t ,  uint64_t .  The suffix  _t  is a convention to indicate that this is a customized type (more on this in later units).  The prefix  u  indicates that the type is an unsigned type.  The numbers  8 ,  16 ,  32 , and  64  indicate the number of bits for each type.  Thus,  uint32_t  is guaranteed to be of size 32 bits, and can hold unsigned integer values from  0 0  to  2^{32}-1 2^{32}-1 .",
            "title": "stdint.h"
        },
        {
            "location": "/05-first-c/index.html#problem-set-5",
            "text": "",
            "title": "Problem Set 5"
        },
        {
            "location": "/05-first-c/index.html#problem-51",
            "text": "In the example above,  sqrt  is declared to take in a parameter of type  double  .  But the argument that we pass in is the sum of two  int , which is also an  int .   Would this result in an error?",
            "title": "Problem 5.1"
        },
        {
            "location": "/05-first-c/index.html#problem-52",
            "text": "Consider the following alternative definition of  square  1\n2\n3 ???   square ( uint16_t   x )   { \n     return   x * x ;  }    What should the return type of this  square  be, in order for the return type to be big enough to store all possible value for  x*x ?      Adding more  long  does not make the integer longer, i.e., there is no  long long long int .\u00a0 \u21a9",
            "title": "Problem 5.2"
        },
        {
            "location": "/06-cs1010-io/index.html",
            "text": "Unit 6: The CS1010 I/O Library\n\n\nOur first C program that computes the hypotenuse doesn't do much -- it simply computes \n\\sqrt(3^2 + 4^2)\n\\sqrt(3^2 + 4^2)\n.  The value to be computed is hard-coded, and the result computed is not displayed.\n\n\nTo make this program more general and useful, first, we need to compute the hypotenuse for any length of the base and the height of a right-angled triangle.  We cannot hardcode the length in the program.   We should read these values from the users.  Second, we need to output the result of the computation to the users.  In other words, to make the program more general and useful, we need to add input and output, or I/O, functions.\n\n\nStandard Input and Standard Output\n\n\nBefore we talk about how to read the input values and display the output values, we have to first talk about where an input comes from and where an output goes to.\n\n\nIn UNIX-flavored operating systems, an input is read from an abstract channel called the \nstandard input\n, or \nstdin\n for short, and an output is sent to an abstract channel called the \nstandard output\n, or \nstdout\n for short.  \n\n\nThe fact that these channels are abstract is a powerful concept -- when we write our code, we do not have to worry about where the inputs come from and where the outputs go to.  It will depend on how the user runs our program.  Thus, it allows the users of our program the flexibility to control where the data comes from or goes to.\n\n\nFor instance, the standard input, by default, reads from the keyboard.  But the user can choose to read from a file, using the redirection \n<\n operator \nfrom the command line\n or from the output of another process, using the pipe \n|\n operator \nfrom the command line\n.  Similarly, the standard output, by default, writes to the terminal.  But the user can choose to write to a file using the redirection \n>\n operator \non the command line\n or to the input of another process, using the pipe \n|\n operator, again, on the command line when invoking the program.  You will see how cool these are later.  But for the purpose of C programming, it suffices to know for now that we only need to read from \nstdin\n and write to \nstdout\n in our code, and we let the users decide where they come from / go to.\n\n\nNo \nprintf\n and \nscanf\n (yet)\n\n\nIn almost all articles and textbooks on C that I have seen, the \nscanf\n and \nprintf\n functions are taught as the standard C library functions to perform the input and output respectively.  The function \nscanf\n, however, is tricky to use correctly and securely.  The function \nprintf\n comes with many nuances, such as remembering the different conversion specifiers and modifiers.  I would rather not teach you \nscanf\n and \nprintf\n at this stage.  As such, CS1010 is providing you a library to perform I/O -- the library provides a small set of essential functions to read and write \nlong\n values, \ndouble\n values, space-separated words, and lines of text. \n\n\nYou can find the \ndocumentation for the CS1010 I/O Library here\n.  We will see how to use the library to improve our hypotenuse computation program here.\n\n\nUsing the CS1010 I/O Library\n\n\nLet's modify our earlier program to now read the base and height from \nstdin\n, compute the hypotenuse, and print the results out to \nstdout\n.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n#include\n \n<math.h>\n\n\n#include\n \n\"cs1010.h\"\n\n\n\nlong\n \nsquare\n(\nlong\n \nx\n)\n \n\n{\n\n  \nreturn\n \nx\n*\nx\n;\n\n\n}\n\n\n\ndouble\n \nhypotenuse_of\n(\nlong\n \nbase\n,\n \nlong\n \nheight\n)\n \n\n{\n\n  \nreturn\n \nsqrt\n(\nsquare\n(\nbase\n)\n \n+\n \nsquare\n(\nheight\n));\n\n\n}\n\n\n\nint\n \nmain\n()\n \n\n{\n\n  \ndouble\n \nhypotenuse\n;\n\n  \nlong\n \nbase\n \n=\n \ncs1010_read_long\n();\n\n  \nlong\n \nheight\n \n=\n \ncs1010_read_long\n();\n\n  \nhypotenuse\n \n=\n \nhypotenuse_of\n(\nbase\n,\n \nheight\n);\n\n  \ncs1010_println_double\n(\nhypotenuse\n);\n\n\n}\n\n\n\n\n\n\n\nThe first change you see (on Line 2) is to include the file \ncs1010.h\n, which includes the declaration of functions provided by the library.  On Lines 17 and 18, we introduce two new \nlong\n variables named \nbase\n and \nheight\n, which we initialized with the returned value from \ncs1010_read_long()\n.  The function \ncs1010_read_long\n reads a \nlong\n value from \nstdin\n and returns the value.  For now, we assume that the inputs are correctly passed to the program.\n\n\nFinally, on Line 20, we print the resulting hypotenuse to \nstdout\n using the library function \ncs1010_println_double\n.  Note that there are two versions of functions to print a \ndouble\n value: \ncs1010_println_double\n and \ncs1010_print_double\n.  The one with \nprintln\n prints a new line character so that the text that got printed after appears in the next line.\n\n\nRefer to \nCS1010 Compilation Guide\n on how to compile a program that uses the CS1010 I/O library.\n\n\nNote that the \nmain\n function above can be written as a single statement without any state and assignment.  The resulting code, however, is not necessarily easier to understand.\n\n1\n2\n3\n4\nint\n \nmain\n()\n \n\n{\n\n  \ncs1010_println_double\n(\nhypotenuse_of\n(\ncs1010_read_long\n(),\n \ncs1010_read_long\n()));\n\n\n}",
            "title": "6. CS1010 I/O Library"
        },
        {
            "location": "/06-cs1010-io/index.html#unit-6-the-cs1010-io-library",
            "text": "Our first C program that computes the hypotenuse doesn't do much -- it simply computes  \\sqrt(3^2 + 4^2) \\sqrt(3^2 + 4^2) .  The value to be computed is hard-coded, and the result computed is not displayed.  To make this program more general and useful, first, we need to compute the hypotenuse for any length of the base and the height of a right-angled triangle.  We cannot hardcode the length in the program.   We should read these values from the users.  Second, we need to output the result of the computation to the users.  In other words, to make the program more general and useful, we need to add input and output, or I/O, functions.",
            "title": "Unit 6: The CS1010 I/O Library"
        },
        {
            "location": "/06-cs1010-io/index.html#standard-input-and-standard-output",
            "text": "Before we talk about how to read the input values and display the output values, we have to first talk about where an input comes from and where an output goes to.  In UNIX-flavored operating systems, an input is read from an abstract channel called the  standard input , or  stdin  for short, and an output is sent to an abstract channel called the  standard output , or  stdout  for short.    The fact that these channels are abstract is a powerful concept -- when we write our code, we do not have to worry about where the inputs come from and where the outputs go to.  It will depend on how the user runs our program.  Thus, it allows the users of our program the flexibility to control where the data comes from or goes to.  For instance, the standard input, by default, reads from the keyboard.  But the user can choose to read from a file, using the redirection  <  operator  from the command line  or from the output of another process, using the pipe  |  operator  from the command line .  Similarly, the standard output, by default, writes to the terminal.  But the user can choose to write to a file using the redirection  >  operator  on the command line  or to the input of another process, using the pipe  |  operator, again, on the command line when invoking the program.  You will see how cool these are later.  But for the purpose of C programming, it suffices to know for now that we only need to read from  stdin  and write to  stdout  in our code, and we let the users decide where they come from / go to.",
            "title": "Standard Input and Standard Output"
        },
        {
            "location": "/06-cs1010-io/index.html#no-printf-and-scanf-yet",
            "text": "In almost all articles and textbooks on C that I have seen, the  scanf  and  printf  functions are taught as the standard C library functions to perform the input and output respectively.  The function  scanf , however, is tricky to use correctly and securely.  The function  printf  comes with many nuances, such as remembering the different conversion specifiers and modifiers.  I would rather not teach you  scanf  and  printf  at this stage.  As such, CS1010 is providing you a library to perform I/O -- the library provides a small set of essential functions to read and write  long  values,  double  values, space-separated words, and lines of text.   You can find the  documentation for the CS1010 I/O Library here .  We will see how to use the library to improve our hypotenuse computation program here.",
            "title": "No printf and scanf (yet)"
        },
        {
            "location": "/06-cs1010-io/index.html#using-the-cs1010-io-library",
            "text": "Let's modify our earlier program to now read the base and height from  stdin , compute the hypotenuse, and print the results out to  stdout .   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21 #include   <math.h>  #include   \"cs1010.h\"  long   square ( long   x )   { \n   return   x * x ;  }  double   hypotenuse_of ( long   base ,   long   height )   { \n   return   sqrt ( square ( base )   +   square ( height ));  }  int   main ()   { \n   double   hypotenuse ; \n   long   base   =   cs1010_read_long (); \n   long   height   =   cs1010_read_long (); \n   hypotenuse   =   hypotenuse_of ( base ,   height ); \n   cs1010_println_double ( hypotenuse );  }    The first change you see (on Line 2) is to include the file  cs1010.h , which includes the declaration of functions provided by the library.  On Lines 17 and 18, we introduce two new  long  variables named  base  and  height , which we initialized with the returned value from  cs1010_read_long() .  The function  cs1010_read_long  reads a  long  value from  stdin  and returns the value.  For now, we assume that the inputs are correctly passed to the program.  Finally, on Line 20, we print the resulting hypotenuse to  stdout  using the library function  cs1010_println_double .  Note that there are two versions of functions to print a  double  value:  cs1010_println_double  and  cs1010_print_double .  The one with  println  prints a new line character so that the text that got printed after appears in the next line.  Refer to  CS1010 Compilation Guide  on how to compile a program that uses the CS1010 I/O library.  Note that the  main  function above can be written as a single statement without any state and assignment.  The resulting code, however, is not necessarily easier to understand. 1\n2\n3\n4 int   main ()   { \n   cs1010_println_double ( hypotenuse_of ( cs1010_read_long (),   cs1010_read_long ()));  }",
            "title": "Using the CS1010 I/O Library"
        },
        {
            "location": "/07-arithmetic-ops/index.html",
            "text": "Unit 7: Arithmetic Operations\n\n\nYou have seen the \n+\n operator in the previous units.  You can use \n+\n to add two variables, a value and a variable, or two values:\n\n\n1\n2\n3\n4\n5\n6\nlong\n \na\n \n=\n \n1\n;\n\n\nlong\n \nb\n \n=\n \n2\n;\n\n\nlong\n \nc\n \n=\n \n3\n;\n\n\na\n \n=\n \nb\n \n+\n \nc\n;\n \n// add two variables\n\n\nb\n \n=\n \na\n \n+\n \n4\n;\n \n// add a variable to a value\n\n\nc\n \n=\n \n5\n \n+\n \n6\n;\n \n// add two values\n\n\n\n\n\n\n\nYou can also use \n+\n on values returned by functions:\n\n\n1\nhypotenuse\n \n=\n \nsqrt\n(\nsquare\n(\nbase\n)\n \n+\n \nsquare\n(\nheight\n));\n\n\n\n\n\n\n\nYou have also seen the multiplication operator \n*\n.  It can be used in the same way as the \n+\n operator.  Three other useful operators are:\n\n\n\n\n/\n - division (e.g., \ndouble half_x = x / 2;\n)\n\n\n-\n - subtraction (e.g., \nlong deducted = income - 100\n)\n\n\n%\n - modulo (e.g, \nlong last_digit = number % 10\n);\n\n\n\n\nThe \n+\n, \n-\n, \n*\n, and \n/\n operators work on both integer types (\nchar\n, \nshort\n, \nint\n, \nlong\n, \nlong long\n) and real numbers (\nfloat\n, \ndouble\n).  The module operator \n%\n works only on integer types.\n\n\nOperator Precedence\n\n\nWe can chain the operations together to form expressions such as:\n\n\n1\n2\n3\nlong\n \nb\n \n=\n \n10\n;\n\n\nlong\n \nc\n \n=\n \n2\n;\n\n\nlong\n \na\n \n=\n \nb\n \n+\n \n2\n \n*\n \nc\n \n/\n \n4\n;\n\n\n\n\n\n\n\nWhen we have multiple operations appearing, however, it becomes harder to trace the sequence of evaluation.  What is the value of \na\n after the three lines above are executed?\n\n\nC actually has well-defined rules to the order of evaluation for the operators: \n*\n, \n/\n, and \n%\n take precedence over \n+\n and \n-\n, and the operators are evaluated from left to right.  \n\n\nThus, in the example above, \na\n will be 11 instead of 6 after the execution.\n\n\nTo change the order of execution, we can add parenthesis to the expression.  For instance:\n\n\n1\n2\nlong\n \na\n \n=\n \n(\nb\n \n+\n \n2\n)\n \n*\n \nc\n \n/\n \n4\n;\n \n// 6\n\n\nlong\n \na\n \n=\n \nb\n \n+\n \n(\n2\n \n*\n \nc\n \n/\n \n4\n);\n \n// 11\n\n\n\n\n\n\n\nThe expression in the parenthesis will be evaluated first.  To make your code easier to understand, \nyou should add parenthesis even if the order of evaluation is from left to right\n to make the order of evaluation explicit.\n\n\nCompound Operators\n\n\nIt is common to modify the value of a variable and store new value back to the same variable.  For example,\n\n\n1\n2\nindex\n \n=\n \nindex\n \n+\n \n1\n;\n  \n// increment the variable index\n\n\nage\n \n=\n \nage\n \n*\n \n2\n;\n  \n// double the variable age\n\n\n\n\n\n\n\nC provides \ncompound operators\n that simplify the expressions above.  For example,\n\n\n1\n2\nindex\n \n+=\n \n1\n;\n\n\nage\n \n*=\n \n2\n;\n\n\n\n\n\n\n\nThe syntax for a compound operator is \nop=\n, where \nop\n can be \n+\n, \n-\n, \n*\n, \n/\n, \n%\n, or other binary operators.  The statement:\n\n\n1\na op= b;\n\n\n\n\n\n\nmodifies \na\n the same way as:\n\n\n1\na = a op b\n\n\n\n\n\n\nCommon Mistakes Using Arithmetic Operations\n\n\nIt is important to remember that, when arithmetic operations in C is performed on a sequence of bits, where the value that it can represent is limited and is determined by its type.  A common mistake for beginner programmers is to forget this fact and treat the arithmetic operations as the same as the ones seen in mathematics.  \n\n\nLet's look at two common gotchas.\n\n\nOverflow\n\n\nConsider the following code:\n\n\n1\n2\nuint8_t\n \nc\n \n=\n \n255\n;\n\n\nc\n \n+=\n \n1\n;\n\n\n\n\n\n\n\nWhat is the value of variable \nc\n after the operation above?\n\n\nHere, we are adding one to the value 255, so \nc\n must store the value 256, right?\n\n\nIt turns out that after the execution above, \nc\n contains the value 0.  The variable \nc\n is of the type \nuint8_t\n, which is the unsigned 8-bit integer.  Being 8-bit, the variable can store values from 0 to 255.  When we add 1 to 255, even though we get the result 256, mathematically, we cannot store 256 in \nc\n -- there is not enough bits!  In this case, the value stored is \"wrap around\", and we get the value 0 instead.\n\n\nThe variable \nc\n above is unsigned. It gets trickier if \nc\n is signed.  In the case of overflowing signed integer, the behavior depends on the compiler and is undefined in the C standard.\n\n\nInteger Division\n\n\nNow, let's consider the following code:\n\n\n1\ndouble\n \nhalf\n \n=\n \n3\n/\n2\n;\n\n\n\n\n\n\n\nWhat is the value of variable \nhalf\n after the operation above?\n\n\nIt got to be 1.5, right?  \n\n\nIt turns out that, after executing the code above, the value of \nhalf\n is 1.0.  \n\n\nTo understand this, first, let's see what happen when we assign a floating point number to an integer type:\n\n\n1\nint\n \nx\n \n=\n \n1.5\n;\n\n\n\n\n\n\n\nC truncates the floating number and only stores the integer part of the value, 1 in this case, in \nx\n.\n\n\nSecond, when we perform an arithmetic operation, the resulting value will be an integer if both values are integer types.  If one of the operands is a floating point number, the result will be a floating point number\n1\n.\n\n\nSince 3 and 2 are both integers, the resulting value 1.5 are stored in an integer, which causes it to become 1.  We then store 1 into a \ndouble\n variable, causing the value of \nhalf\n to become \n1.0\n.\n\n\nBecause of this limitation, the operation \n/\n is sometimes also known as integer division when both operands are integers.  \n\n\nIn order to get the result 1.5 as expected, we can write either:\n\n1\ndouble\n \nhalf\n \n=\n \n3\n/\n2.0\n;\n\n\n\n\n\n\nor \n\n\n1\ndouble\n \nhalf\n \n=\n \n3\n/\n(\ndouble\n)\n2\n;\n\n\n\n\n\n\n\nThe second fix above explicitly convert the type, or \ncast\n the type of value 2 into a \ndouble\n.\n\n\nAvoid Increment / Decrement Operator\n\n\nIf you read C code in other places, you will certainly come across the increment or decrement operator, \n++\n or \n--\n.  The operators add one and minus one from the operand respectively.  So, the statement\n\n\n1\nindex\n \n+=\n \n1\n;\n\n\n\n\n\n\n\ncan be further shortened into \n\n\n1\nindex++;\n\n\n\n\n\n\nand the statement\n\n\n1\nindex\n \n-=\n \n1\n;\n\n\n\n\n\n\n\ncan be further shorten into \n\n\n1\nindex--;\n\n\n\n\n\n\nUsing these two operators only shorten your code by two characters per statement, but introduces several issues.  As such, we \nban the use of both increment and decrement operator in CS1010\n.\n\n\nSo, why aren't \n++\n and \n--\n welcomed in CS1010?  The \n++\n and \n--\n operators not only modify the value of the operand, it also returns a value.  We can write \nj = i++;\n to both increment \ni\n and assign the pre-incremented value of \ni\n to \nj\n.  In C, we can also write \nj = ++i;\n, which again, increment \ni\n, and assign the post-incremented value of \ni\n to \nj\n.  Things get tricky, when we write \ni = i++;\n, it is not clear how to interpret this.  The C standard leaves this behavior undefined and leaves it to the compiler to define its behavior.  Wei Tsang thinks that introducing all these complexities just to save two characters is not warranted.\n\n\n\n\n\n\n\n\n\n\nThe actual rules used by C, called \ninteger promotion\n and \nusual arithmetic conversion\n, are much more complex and are outside the scope of CS1010.  You should take a note of this, however, and in a later part of your study or career, if you need to delve deeper into writing or debugging C code, take a look at \nthis\n.\u00a0\n\u21a9",
            "title": "7. Arithmetic Operations"
        },
        {
            "location": "/07-arithmetic-ops/index.html#unit-7-arithmetic-operations",
            "text": "You have seen the  +  operator in the previous units.  You can use  +  to add two variables, a value and a variable, or two values:  1\n2\n3\n4\n5\n6 long   a   =   1 ;  long   b   =   2 ;  long   c   =   3 ;  a   =   b   +   c ;   // add two variables  b   =   a   +   4 ;   // add a variable to a value  c   =   5   +   6 ;   // add two values    You can also use  +  on values returned by functions:  1 hypotenuse   =   sqrt ( square ( base )   +   square ( height ));    You have also seen the multiplication operator  * .  It can be used in the same way as the  +  operator.  Three other useful operators are:   /  - division (e.g.,  double half_x = x / 2; )  -  - subtraction (e.g.,  long deducted = income - 100 )  %  - modulo (e.g,  long last_digit = number % 10 );   The  + ,  - ,  * , and  /  operators work on both integer types ( char ,  short ,  int ,  long ,  long long ) and real numbers ( float ,  double ).  The module operator  %  works only on integer types.",
            "title": "Unit 7: Arithmetic Operations"
        },
        {
            "location": "/07-arithmetic-ops/index.html#operator-precedence",
            "text": "We can chain the operations together to form expressions such as:  1\n2\n3 long   b   =   10 ;  long   c   =   2 ;  long   a   =   b   +   2   *   c   /   4 ;    When we have multiple operations appearing, however, it becomes harder to trace the sequence of evaluation.  What is the value of  a  after the three lines above are executed?  C actually has well-defined rules to the order of evaluation for the operators:  * ,  / , and  %  take precedence over  +  and  - , and the operators are evaluated from left to right.    Thus, in the example above,  a  will be 11 instead of 6 after the execution.  To change the order of execution, we can add parenthesis to the expression.  For instance:  1\n2 long   a   =   ( b   +   2 )   *   c   /   4 ;   // 6  long   a   =   b   +   ( 2   *   c   /   4 );   // 11    The expression in the parenthesis will be evaluated first.  To make your code easier to understand,  you should add parenthesis even if the order of evaluation is from left to right  to make the order of evaluation explicit.",
            "title": "Operator Precedence"
        },
        {
            "location": "/07-arithmetic-ops/index.html#compound-operators",
            "text": "It is common to modify the value of a variable and store new value back to the same variable.  For example,  1\n2 index   =   index   +   1 ;    // increment the variable index  age   =   age   *   2 ;    // double the variable age    C provides  compound operators  that simplify the expressions above.  For example,  1\n2 index   +=   1 ;  age   *=   2 ;    The syntax for a compound operator is  op= , where  op  can be  + ,  - ,  * ,  / ,  % , or other binary operators.  The statement:  1 a op= b;   modifies  a  the same way as:  1 a = a op b",
            "title": "Compound Operators"
        },
        {
            "location": "/07-arithmetic-ops/index.html#common-mistakes-using-arithmetic-operations",
            "text": "It is important to remember that, when arithmetic operations in C is performed on a sequence of bits, where the value that it can represent is limited and is determined by its type.  A common mistake for beginner programmers is to forget this fact and treat the arithmetic operations as the same as the ones seen in mathematics.    Let's look at two common gotchas.",
            "title": "Common Mistakes Using Arithmetic Operations"
        },
        {
            "location": "/07-arithmetic-ops/index.html#overflow",
            "text": "Consider the following code:  1\n2 uint8_t   c   =   255 ;  c   +=   1 ;    What is the value of variable  c  after the operation above?  Here, we are adding one to the value 255, so  c  must store the value 256, right?  It turns out that after the execution above,  c  contains the value 0.  The variable  c  is of the type  uint8_t , which is the unsigned 8-bit integer.  Being 8-bit, the variable can store values from 0 to 255.  When we add 1 to 255, even though we get the result 256, mathematically, we cannot store 256 in  c  -- there is not enough bits!  In this case, the value stored is \"wrap around\", and we get the value 0 instead.  The variable  c  above is unsigned. It gets trickier if  c  is signed.  In the case of overflowing signed integer, the behavior depends on the compiler and is undefined in the C standard.",
            "title": "Overflow"
        },
        {
            "location": "/07-arithmetic-ops/index.html#integer-division",
            "text": "Now, let's consider the following code:  1 double   half   =   3 / 2 ;    What is the value of variable  half  after the operation above?  It got to be 1.5, right?    It turns out that, after executing the code above, the value of  half  is 1.0.    To understand this, first, let's see what happen when we assign a floating point number to an integer type:  1 int   x   =   1.5 ;    C truncates the floating number and only stores the integer part of the value, 1 in this case, in  x .  Second, when we perform an arithmetic operation, the resulting value will be an integer if both values are integer types.  If one of the operands is a floating point number, the result will be a floating point number 1 .  Since 3 and 2 are both integers, the resulting value 1.5 are stored in an integer, which causes it to become 1.  We then store 1 into a  double  variable, causing the value of  half  to become  1.0 .  Because of this limitation, the operation  /  is sometimes also known as integer division when both operands are integers.    In order to get the result 1.5 as expected, we can write either: 1 double   half   =   3 / 2.0 ;    or   1 double   half   =   3 / ( double ) 2 ;    The second fix above explicitly convert the type, or  cast  the type of value 2 into a  double .",
            "title": "Integer Division"
        },
        {
            "location": "/07-arithmetic-ops/index.html#avoid-increment-decrement-operator",
            "text": "If you read C code in other places, you will certainly come across the increment or decrement operator,  ++  or  -- .  The operators add one and minus one from the operand respectively.  So, the statement  1 index   +=   1 ;    can be further shortened into   1 index++;   and the statement  1 index   -=   1 ;    can be further shorten into   1 index--;   Using these two operators only shorten your code by two characters per statement, but introduces several issues.  As such, we  ban the use of both increment and decrement operator in CS1010 .  So, why aren't  ++  and  --  welcomed in CS1010?  The  ++  and  --  operators not only modify the value of the operand, it also returns a value.  We can write  j = i++;  to both increment  i  and assign the pre-incremented value of  i  to  j .  In C, we can also write  j = ++i; , which again, increment  i , and assign the post-incremented value of  i  to  j .  Things get tricky, when we write  i = i++; , it is not clear how to interpret this.  The C standard leaves this behavior undefined and leaves it to the compiler to define its behavior.  Wei Tsang thinks that introducing all these complexities just to save two characters is not warranted.      The actual rules used by C, called  integer promotion  and  usual arithmetic conversion , are much more complex and are outside the scope of CS1010.  You should take a note of this, however, and in a later part of your study or career, if you need to delve deeper into writing or debugging C code, take a look at  this .\u00a0 \u21a9",
            "title": "Avoid Increment / Decrement Operator"
        },
        {
            "location": "/08-if-else/index.html",
            "text": "Unit 8: Conditional Statement\n\n\nSo far the C programs that we have written has a straightforward \nexecution path\n.  The execution flows from top to bottom in \nmain\n, jumping to a function being called (or \ncallee\n), and back to the caller when the function returns.\n\n\nWe have, however, seen a few examples so far where the execution path can \nbranch\n off to either one of two paths, depends on a condition:\n\n\n\n\nIn the algorithm to compute the \nmax(L, k)\nmax(L, k)\n, we check if \nl_i > m\nl_i > m\n, and update \nm\nm\n only if this is true.  \n\n\nIn the algorithm to compute the \nfactorial(n)\nfactorial(n)\n, we check if \nn\nn\n equals 0, and return 1 if it is true, otherwise, we return \nn \\times factorial(n-1)\nn \\times factorial(n-1)\n.\n\n\n\n\nWe are not ready to write C code that processes a list yet, so let's use the \nfactorial(n)\nfactorial(n)\n function as an example.  In C, the \nfactorial(n)\nfactorial(n)\n would look like this:\n\n\n1\n2\n3\n4\n5\n6\n7\nlong\n \nfactorial\n(\nlong\n \nn\n)\n \n\n{\n\n  \nif\n \n(\nn\n \n==\n \n0\n)\n \n{\n\n    \nreturn\n \n1\n;\n\n  \n}\n\n  \nreturn\n \nn\n \n*\n \nfactorial\n(\nn\n \n-\n \n1\n);\n\n\n}\n\n\n\n\n\n\n\n\n\nIn this example, you see a new C keyword \nif\n.  This keyword is used at the beginning of a conditional block of code.  The general syntax is:\n\n\n1\n2\n3\nif\n \n(\n<\nlogical\n \nexpression\n>\n)\n \n{\n \n  \n\"true block\"\n:\n \nstatements\n \nto\n \nbe\n \nexecuted\n \nif\n \nexpression\n \nevaluates\n \nto\n \ntrue\n\n\n}\n\n\n\n\n\n\n\nThe \nif\n keyword is followed by a \nlogical expression\n in parenthesis.  This is followed by a block of statements (in curly braces \n{\n and \n}\n).  If the logical expression is true, then the statements are executed, otherwise, they are skipped.  For this reason, the group of statements is known as a \ntrue block\n.\n\n\nComparison Operator\n\n\nThe logical expression \nn == 0\n is true if the variable \nn\n holds the value of \n0\n.  \n\n\n\n\n==\n vs \n=\n\n\nNote that use of TWO \n=\n signs.  This is often confused by newbie programmers with a single \n=\n sign, which is used for assignment.  A common bug is to write\n\n\n1\n2\n3\n  \nif\n \n(\nn\n \n=\n \n0\n)\n \n{\n\n     \n:\n\n  \n}\n\n\n\n\n\n\n\n\n\nThe \n==\n is known as a \ncomparison operator\n.  It compares if the left-hand side has the same value as the right-hand side. Other comparison operators include \n>\n (greater than), \n<\n (less than), \n>=\n (greater or equal to), \n<=\n (less than or equal to), and \n!=\n (not equal).\n\n\nIn other words, the function \nfactorial\n will exit and return \n1\n if the parameter \nn\n equals to \n0\n.  The rest of the code (particularly, Line \n5\n 6) will be skipped.\n\n\nWhat if \nn\n is not \n0\n?  The block that contains Line 3 \nreturn 1;\n will be skipped, and Line \n5\n 6 \nreturn n * factorial(n - 1);\n will be executed instead, which is what we intended for the \nfactorial\n function to do.\n\n\nExample: Max of two numbers\n\n\nLet's switch to another example: suppose we have three variables, \nx\n, \ny\n, and \nmax\n, and we want to set \nmax\n to the maximum of \nx\n and \ny\n.\n\n\nConsider the following code snippet:\n\n\n1\n2\n3\n4\n5\n6\nif\n \n(\nx\n \n>\n \ny\n)\n \n{\n\n  \nmax\n \n=\n \nx\n;\n\n\n}\n \n\nif\n \n(\nx\n \n<\n \ny\n)\n \n{\n\n  \nmax\n \n=\n \ny\n;\n\n\n}\n\n\n\n\n\n\n\nTake a moment to understand the code above, and see if you can figure out what is wrong.\n\n\nWhen we think about writing conditionals, we have to exhaustively reason about what are all the possible scenarios that could occur.  In this example, we need to think about what are the possible relationships between \nx\n and \ny\n when we compare \nx\n an \ny\n.  There are actually three possibilities!\n\n\n\n\nx > y\n: in this case, \nx\n is larger and we set \nmax\n to \nx\n\n\ny > x\n: in this case, \ny\n is larger and we set \nmax\n to \ny\n\n\nx == y\n: in this case, both are equally large, so the maximum of the two can be either \nx\n or \ny\n.\n\n\n\n\nIn the code above, \nmax\n is not set properly if \nx == y\n!\n\n\nThe following code adds the third case and arbitrarily chooses to set \nmax\n to \ny\n if both \nx\n and \ny\n have the same value.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nif\n \n(\nx\n \n>\n \ny\n)\n \n{\n\n  \nmax\n \n=\n \nx\n;\n\n\n}\n \n\nif\n \n(\nx\n \n<\n \ny\n)\n \n{\n\n  \nmax\n \n=\n \ny\n;\n\n\n}\n\n\nif\n \n(\nx\n \n==\n \ny\n)\n \n{\n\n  \nmax\n \n=\n \ny\n;\n\n\n}\n\n\n\n\n\n\n\nElse\n\n\nThe code snippet above now correctly sets \nmax\n to the maximum of \nx\n and \ny\n.\nThe code, however, is not very satisfying, since we compare between \nx\n and \ny\n three times.   Let's see how we can reduce the number of comparisons to one.  We are going to do some \nrefactoring\n of the code above.\n\n\nFirst, observe that the \"true block\" for \nx < y\n and \nx == y\n are the same, and we can combine it into a single comparison \nx <= y\n.\n\n\n1\n2\n3\n4\n5\n6\nif\n \n(\nx\n \n>\n \ny\n)\n \n{\n\n  \nmax\n \n=\n \nx\n;\n\n\n}\n \n\nif\n \n(\nx\n \n<=\n \ny\n)\n \n{\n\n  \nmax\n \n=\n \ny\n;\n\n\n}\n\n\n\n\n\n\n\nSecond, observe that if \nx > y\n is false, then \nx <= y\n must be true.  We say that \nx > y\n and \nx <= y\n are \nnegation\n (or opposite) of each other.  So, the check for \nx <= y\n is redundant -- checking \nx > y\n is enough to tell us if \nx <= y\n.  We can re-write the code above as:\n\n\n1\n2\n3\n4\n5\nif\n \n(\nx\n \n>\n \ny\n)\n \n{\n\n  \nmax\n \n=\n \nx\n;\n\n\n}\n \nelse\n \n{\n\n  \nmax\n \n=\n \ny\n;\n\n\n}\n\n\n\n\n\n\n\nThe word \nelse\n as seen above is another C keyword -- it must be used in conjunction with \nif\n to indicate an alternate path of execution if the logical expression is false.\n\n\n1\n2\n3\n4\n5\nif\n \n(\n<\nlogical\n \nexpression\n>\n)\n \n{\n \n  \n\"true block\"\n:\n \nstatements\n \nto\n \nbe\n \nexecuted\n \nif\n \nexpression\n \nevaluates\n \nto\n \ntrue\n\n\n}\n \nelse\n \n{\n\n  \n\"false block\"\n:\n \nstatements\n \nto\n \nbe\n \nexecuted\n \nif\n \nexpression\n \nevaluates\n \nto\n \nfalse\n\n\n}\n\n\n\n\n\n\n\nNested Else-If\n\n\nThe example above considers \ntwo\n possible execution paths only.  In some situations, we may need to consider more than two execution paths.  Take the following problem for example.  You are given the numerical score for an assignment, ranged between 0 and 10.  Print out the letter grade of the assignment according to the table below:\n\n\n\n\n\n\n\n\nScore\n\n\nLetter Grade\n\n\n\n\n\n\n\n\n\n\n8 or higher\n\n\nA\n\n\n\n\n\n\nLess than 8 but 5 or higher\n\n\nB\n\n\n\n\n\n\nLess than 5 but 3 or higher\n\n\nC\n\n\n\n\n\n\nLess than 3\n\n\nD\n\n\n\n\n\n\n\n\nSince the \nif\n-\nelse\n statement only allows branching into two possibilities, we can branch into multiple possibilities by nesting the \nif\n-\nelse\n statements hierarchically.  We can first break the table down into three tables, each containing only two rows, with one row a negation of the other row.\n\n\n\n\n\n\n\n\nScore\n\n\nLetter Grade\n\n\n\n\n\n\n\n\n\n\n8 or higher\n\n\nA\n\n\n\n\n\n\nLess than 8\n\n\nSee Table 1\n\n\n\n\n\n\n\n\nTable 1 (less than 8)\n\n\n\n\n\n\n\n\nScore\n\n\nLetter Grade\n\n\n\n\n\n\n\n\n\n\n5 or higher\n\n\nB\n\n\n\n\n\n\nLess than 5\n\n\nSee Table 2\n\n\n\n\n\n\n\n\nTable 2 (less than 5)\n\n\n\n\n\n\n\n\nScore\n\n\nLetter Grade\n\n\n\n\n\n\n\n\n\n\n3 or higher\n\n\nC\n\n\n\n\n\n\nLess than 3\n\n\nD\n\n\n\n\n\n\n\n\nThe tables above can then be written into the following function:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\nvoid\n \nprint_score\n(\ndouble\n \nscore\n)\n \n\n{\n\n  \nif\n \n(\nscore\n \n>=\n \n8\n)\n \n{\n\n    \ncs1010_println_string\n(\n\"A\"\n);\n\n  \n}\n \nelse\n \n{\n\n    \n// Table 1\n\n    \nif\n \n(\nscore\n \n>=\n \n5\n)\n \n{\n\n      \ncs1010_println_string\n(\n\"B\"\n);\n\n    \n}\n \nelse\n \n{\n\n      \n// Table 2\n\n      \nif\n \n(\nscore\n \n>=\n \n3\n)\n \n{\n\n        \ncs1010_println_string\n(\n\"C\"\n);\n\n      \n}\n \nelse\n \n{\n\n        \ncs1010_println_string\n(\n\"D\"\n);\n\n      \n}\n\n    \n}\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\nThere are three nested \nif\n-\nelse\n in the function above.  Note how I use indentation to clearly indicate the nesting of blocks.  Such nesting or indentation is not required by C standard, but is a commonly accepted coding practice, and is required for CS1010.\n\n\nThe code below compiles perfectly but is not as easy to read by a human as the above.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\nvoid\n \nprint_score\n(\ndouble\n \nscore\n)\n \n\n{\n\n  \nif\n \n(\nscore\n \n>=\n \n8\n)\n \n{\n\n    \ncs1010_println_string\n(\n\"A\"\n);\n \n}\n \nelse\n \n{\n \n// Table 1 \n\n    \nif\n \n(\nscore\n \n>=\n \n5\n)\n \n{\n \ncs1010_println_string\n(\n\"B\"\n);\n\n  \n}\n \nelse\n \n{\n \n// Table 2\n\n\nif\n \n(\nscore\n \n>=\n \n3\n)\n \n{\n\n  \ncs1010_println_string\n(\n\"C\"\n);\n\n      \n}\n \nelse\n \n{\n\n        \ncs1010_println_string\n(\n\"D\"\n);\n\n    \n}\n \n}\n \n}\n \n}\n\n\n// Don't write code like this.\n\n\n\n\n\n\n\nThere are also a couple of \"first\" in the sample code above:\n\n\n\n\nYou see the keyword \nvoid\n for the first time.  \nvoid\n is a special type that indicates nothing.  The function \nprint_score\n does not return anything, it accepts an input \nscore\n and print something to screen.  As such, we say that the return type of \nprint_score\n is \nvoid\n.\n\n\nYou see \nstrings\n for the first time (\n\"A\"\n, etc.).  A \nstring\n basically is a sequence of characters.  We use double quotes \n\"\n to mark the beginning and the end of a string, and use the CS1010 I/O library function \ncs1010_println_string\n to print a string to the screen. \n\n\n\n\nYou can imagine that as the number of possible letter grades increases (NUS has 11), we will have many nested \nif\n-\nelse\n, and the code gets complicated.  To reduce the number of nesting, we can write \nelse if\n directly, without nesting:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\nvoid\n \nprint_score\n(\ndouble\n \nscore\n)\n \n\n{\n\n  \nif\n \n(\nscore\n \n>=\n \n8\n)\n \n{\n\n    \ncs1010_println_string\n(\n\"A\"\n);\n\n  \n}\n \nelse\n \nif\n \n(\nscore\n \n>=\n \n5\n)\n \n{\n\n    \ncs1010_println_string\n(\n\"B\"\n);\n\n  \n}\n \nelse\n \nif\n \n(\nscore\n \n>=\n \n3\n)\n \n{\n\n    \ncs1010_println_string\n(\n\"C\"\n);\n\n  \n}\n \nelse\n \n{\n\n    \ncs1010_println_string\n(\n\"D\"\n);\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\nThe above code is easier to read, but has exactly the same flow as the one with nested \nif\n-\nelse\n earlier.\n\n\nAvoid Skipping the Curly Braces\n\n\nThe C standard says that, if the block contains only one statement, we can skip the curly braces \n{\n and \n}\n.  In the example above, we can write:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\nvoid\n \nprint_score\n(\ndouble\n \nscore\n)\n \n\n{\n\n  \nif\n \n(\nscore\n \n>=\n \n8\n)\n \n    \ncs1010_println_string\n(\n\"A\"\n);\n\n  \nelse\n \nif\n \n(\nscore\n \n>=\n \n5\n)\n\n    \ncs1010_println_string\n(\n\"B\"\n);\n\n  \nelse\n \nif\n \n(\nscore\n \n>=\n \n3\n)\n\n    \ncs1010_println_string\n(\n\"C\"\n);\n\n  \nelse\n\n    \ncs1010_println_string\n(\n\"D\"\n);\n\n\n}\n\n\n\n\n\n\n\nDespite being allowed by the C standard, this is considered a bad practice, and should be avoided.  Imagine some time later, you go back to this code, and want to write something extra:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\nvoid\n \nprint_score\n(\ndouble\n \nscore\n)\n \n\n{\n\n  \nif\n \n(\nscore\n \n>=\n \n8\n)\n \n    \ncs1010_println_string\n(\n\"A\"\n);\n\n  \nelse\n \nif\n \n(\nscore\n \n>=\n \n5\n)\n\n    \ncs1010_println_string\n(\n\"B\"\n);\n\n  \nelse\n \nif\n \n(\nscore\n \n>=\n \n3\n)\n\n    \ncs1010_println_string\n(\n\"C\"\n);\n\n  \nelse\n\n    \ncs1010_println_string\n(\n\"You can do better!\"\n);\n\n    \ncs1010_println_string\n(\n\"D\"\n);\n\n\n}\n\n\n\n\n\n\n\nWhat would be printed?\n\n\nThe famous \nApple \ngoto fail\n bug\n wouldn't have happened in the there is a pair of curly braces added!\n\n\nAlternatively, if you have code like this:\n\n\n1\n2\n3\n4\n5\nif\n \n(\nscore\n \n>=\n \n8\n)\n\n  \nif\n \n(\nlate_penalty\n \n!=\n \n0\n)\n \n      \ncs1010_println_string\n(\n\"late submission\"\n);\n\n\nelse\n \n  \ncs1010_println_string\n(\n\"you can do better!\"\n);\n\n\n\n\n\n\n\nIt might look like \nyou can do better!\n will be printed if \nscore\n is less than 8, but actually, \nyou can do better!\n will be printed if the \nscore\n is larger or equal to 8 and there is no late penalty, which is not what is intended.\n\n\nConditional Operator\n\n\nThe conditional operator consists of two special characters \n?\n and \n:\n and is used in the format of:\n\n\n1\ncondition ? true expression : false expression;\n\n\n\n\n\n\nIf the \ncondition\n evaluates to true, then the \ntrue expression\n will be evaluated and returned, otherwise, the \nfalse expression\n will be evaluated and returned.\n\n\nThe conditional operator allows us to replace\n\n\n1\n2\n3\n4\n5\nif\n \n(\nx\n \n>\n \ny\n)\n \n{\n\n  \nmax\n \n=\n \nx\n;\n\n\n}\n \nelse\n \n{\n\n  \nmax\n \n=\n \ny\n;\n\n\n}\n\n\n\n\n\n\n\nwith a single line:\n\n\n1\nmax = (x > y) ? x : y;\n\n\n\n\n\n\nWe can nest the conditional operator as well, but it does not necessarily make your code easier to read once you start nesting them up.  We do not encourage you to nest the conditional operator in CS1010 and to limit its usage to simple cases above.\n\n\nComparing Real Numbers\n\n\nRecall that we said \nreal numbers cannot be represented exactly in computers\n.  Comparing real numbers, therefore, becomes a little bit trickier in programming.  The \nif\n statement\n\n\n1\n2\n3\n4\n5\ndouble\n \nexpected_value\n \n=\n \n0.3\n;\n\n\ndouble\n \nsum\n \n=\n \n0.1\n \n+\n \n0.2\n;\n\n\nif\n \n(\nsum\n \n==\n \nexpected_value\n)\n \n{\n\n \n:\n\n\n}\n\n\n\n\n\n\n\nwould not be evaluated as \ntrue\n as expected!\n\n\nThus, to compare real numbers, we normally allow some errors in comparisons -- we want the absolute difference between \nsum\n and \nexpected_value\n to be small enough.\n\n\n1\n2\n3\n4\n5\ndouble\n \nexpected_value\n \n=\n \n0.3\n;\n\n\ndouble\n \nsum\n \n=\n \n0.1\n \n+\n \n0.2\n;\n\n\nif\n \n(\nfabs\n(\nsum\n \n-\n \nexpected_value\n)\n \n<\n \n0.000001\n)\n \n{\n\n \n:\n\n\n}\n\n\n\n\n\n\n\nProblem Sets\n\n\nProblem 8.1\n\n\n(a) Do the following two functions behave the same way?  Explain.\n\n\n1\n2\n3\n4\n5\n6\n7\nlong\n \nfactorial\n(\nlong\n \nn\n)\n \n\n{\n\n  \nif\n \n(\nn\n \n==\n \n0\n)\n \n{\n\n    \nreturn\n \n1\n;\n\n  \n}\n\n  \nreturn\n \nn\n \n*\n \nfactorial\n(\nn\n \n-\n \n1\n);\n\n\n}\n\n\n\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\nlong\n \nfactorial\n(\nlong\n \nn\n)\n \n\n{\n\n  \nif\n \n(\nn\n \n==\n \n0\n)\n \n{\n\n    \nreturn\n \n1\n;\n\n  \n}\n \nelse\n \n{\n\n    \nreturn\n \nn\n \n*\n \nfactorial\n(\nn\n \n-\n \n1\n);\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\n(b) How about:\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nlong\n \nfactorial\n(\nlong\n \nn\n)\n \n\n{\n\n  \nlong\n \nresult\n;\n\n  \nif\n \n(\nn\n \n==\n \n0\n)\n \n{\n\n    \nresult\n \n=\n \n1\n;\n\n  \n}\n\n  \nresult\n \n=\n \nn\n \n*\n \nfactorial\n(\nn\n \n-\n \n1\n);\n\n  \nreturn\n \nresult\n;\n\n\n}\n\n\n\n\n\n\n\nand \n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\nlong\n \nfactorial\n(\nlong\n \nn\n)\n \n\n{\n\n  \nlong\n \nresult\n;\n\n  \nif\n \n(\nn\n \n==\n \n0\n)\n \n{\n\n    \nresult\n \n=\n \n1\n;\n\n  \n}\n \nelse\n \n{\n\n    \nresult\n \n=\n \nn\n \n*\n \nfactorial\n(\nn\n \n-\n \n1\n);\n\n  \n}\n\n  \nreturn\n \nresult\n;\n\n\n}\n\n\n\n\n\n\n\nProblem 8.2\n\n\nDraw the flowchart for the code snippet\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nif\n \n(\nx\n \n>\n \ny\n)\n \n{\n\n  \nmax\n \n=\n \nx\n;\n\n\n}\n \n\nif\n \n(\nx\n \n<\n \ny\n)\n \n{\n\n  \nmax\n \n=\n \ny\n;\n\n\n}\n\n\nif\n \n(\nx\n \n==\n \ny\n)\n \n{\n\n  \nmax\n \n=\n \ny\n;\n\n\n}\n\n\n\n\n\n\n\nand\n\n\n1\n2\n3\n4\n5\nif\n \n(\nx\n \n>\n \ny\n)\n \n{\n\n  \nmax\n \n=\n \nx\n;\n\n\n}\n \nelse\n \n{\n\n  \nmax\n \n=\n \ny\n;\n\n\n}\n\n\n\n\n\n\n\nProblem 8.3\n\n\nSuppose we break down the table below in a slightly different way.\n\n\n\n\n\n\n\n\nScore\n\n\nLetter Grade\n\n\n\n\n\n\n\n\n\n\n8 or higher\n\n\nA\n\n\n\n\n\n\nLess than 8 but 5 or higher\n\n\nB\n\n\n\n\n\n\nLess than 5 but 3 or higher\n\n\nC\n\n\n\n\n\n\nLess than 3\n\n\nD\n\n\n\n\n\n\n\n\nWe rewrite the tables into three smaller tables, as:\n\n\n\n\n\n\n\n\nScore\n\n\nLetter Grade\n\n\n\n\n\n\n\n\n\n\n5 or higher\n\n\nSee Table 3\n\n\n\n\n\n\nLess than 5\n\n\nSee Table 4\n\n\n\n\n\n\n\n\nwhere Table 3 (5 or higher) is\n\n\n\n\n\n\n\n\nScore\n\n\nLetter Grade\n\n\n\n\n\n\n\n\n\n\n8 or higher\n\n\nA\n\n\n\n\n\n\nLess than 8\n\n\nB\n\n\n\n\n\n\n\n\nand Table 4 (less than 5) is\n\n\n\n\n\n\n\n\nScore\n\n\nLetter Grade\n\n\n\n\n\n\n\n\n\n\n3 or higher\n\n\nC\n\n\n\n\n\n\nLess than 3\n\n\nD\n\n\n\n\n\n\n\n\nWrite the corresponding \nif\n-\nelse\n statements to print out the letter grade based on the tables above.\n\n\nAppendix: Code From Lecture\n\n\nHere are the C files that Wei Tsang wrote during the lecture.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n#include\n \n\"cs1010.h\"\n\n\n\nlong\n \nfactorial\n(\nlong\n \nn\n)\n\n\n{\n\n  \nif\n \n(\nn\n \n==\n \n0\n)\n \n{\n\n    \nreturn\n \n1\n;\n\n  \n}\n \n  \nreturn\n \nn\n \n*\n \nfactorial\n(\nn\n-\n1\n);\n\n\n}\n\n\n\nint\n \nmain\n()\n\n\n{\n\n  \nlong\n \nn\n \n=\n \ncs1010_read_long\n();\n\n  \nlong\n \nfac\n \n=\n \nfactorial\n(\nn\n);\n\n  \ncs1010_println_long\n(\nfac\n);\n\n\n}\n\n\n\n\n\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n#include\n \n\"cs1010.h\"\n\n\n\nlong\n \nmax\n(\nlong\n \nx\n,\n \nlong\n \ny\n)\n\n\n{\n\n  \nif\n \n(\nx\n \n>\n \ny\n)\n \n{\n\n    \nreturn\n \nx\n;\n\n  \n}\n \nelse\n \n{\n\n    \nreturn\n \ny\n;\n\n  \n}\n\n  \n// alternatively, using the conditional operator ? :\n\n  \n// return (x > y) ? x : y;\n\n\n}\n\n\n\nint\n \nmain\n()\n\n\n{\n\n  \nlong\n \nx\n \n=\n \ncs1010_read_long\n();\n\n  \nlong\n \ny\n \n=\n \ncs1010_read_long\n();\n\n  \nlong\n \nm\n \n=\n \nmax\n(\nx\n,\n \ny\n);\n\n  \ncs1010_println_long\n(\nm\n);\n\n\n}\n\n\n\n\n\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n#include\n \n\"cs1010.h\"\n\n\n\nvoid\n \nprint_score\n(\ndouble\n \nx\n)\n\n\n{\n\n  \nif\n \n(\nx\n \n>=\n \n8\n)\n\n    \ncs1010_println_string\n(\n\"A\"\n);\n\n  \nelse\n \nif\n \n(\nx\n \n>=\n \n5\n)\n\n    \ncs1010_println_string\n(\n\"B\"\n);\n\n  \nelse\n \nif\n \n(\nx\n \n>=\n \n3\n)\n\n    \ncs1010_println_string\n(\n\"C\"\n);\n\n  \nelse\n\n    \ncs1010_println_string\n(\n\"D\"\n);\n\n\n}\n\n\n\nint\n \nmain\n()\n\n\n{\n\n  \ndouble\n \nscore\n \n=\n \ncs1010_read_double\n();\n\n  \nprint_score\n(\nscore\n);\n\n\n}",
            "title": "8. If Else"
        },
        {
            "location": "/08-if-else/index.html#unit-8-conditional-statement",
            "text": "So far the C programs that we have written has a straightforward  execution path .  The execution flows from top to bottom in  main , jumping to a function being called (or  callee ), and back to the caller when the function returns.  We have, however, seen a few examples so far where the execution path can  branch  off to either one of two paths, depends on a condition:   In the algorithm to compute the  max(L, k) max(L, k) , we check if  l_i > m l_i > m , and update  m m  only if this is true.    In the algorithm to compute the  factorial(n) factorial(n) , we check if  n n  equals 0, and return 1 if it is true, otherwise, we return  n \\times factorial(n-1) n \\times factorial(n-1) .   We are not ready to write C code that processes a list yet, so let's use the  factorial(n) factorial(n)  function as an example.  In C, the  factorial(n) factorial(n)  would look like this:  1\n2\n3\n4\n5\n6\n7 long   factorial ( long   n )   { \n   if   ( n   ==   0 )   { \n     return   1 ; \n   } \n   return   n   *   factorial ( n   -   1 );  }     In this example, you see a new C keyword  if .  This keyword is used at the beginning of a conditional block of code.  The general syntax is:  1\n2\n3 if   ( < logical   expression > )   {  \n   \"true block\" :   statements   to   be   executed   if   expression   evaluates   to   true  }    The  if  keyword is followed by a  logical expression  in parenthesis.  This is followed by a block of statements (in curly braces  {  and  } ).  If the logical expression is true, then the statements are executed, otherwise, they are skipped.  For this reason, the group of statements is known as a  true block .",
            "title": "Unit 8: Conditional Statement"
        },
        {
            "location": "/08-if-else/index.html#comparison-operator",
            "text": "The logical expression  n == 0  is true if the variable  n  holds the value of  0 .     ==  vs  =  Note that use of TWO  =  signs.  This is often confused by newbie programmers with a single  =  sign, which is used for assignment.  A common bug is to write  1\n2\n3    if   ( n   =   0 )   { \n      : \n   }     The  ==  is known as a  comparison operator .  It compares if the left-hand side has the same value as the right-hand side. Other comparison operators include  >  (greater than),  <  (less than),  >=  (greater or equal to),  <=  (less than or equal to), and  !=  (not equal).  In other words, the function  factorial  will exit and return  1  if the parameter  n  equals to  0 .  The rest of the code (particularly, Line  5  6) will be skipped.  What if  n  is not  0 ?  The block that contains Line 3  return 1;  will be skipped, and Line  5  6  return n * factorial(n - 1);  will be executed instead, which is what we intended for the  factorial  function to do.",
            "title": "Comparison Operator"
        },
        {
            "location": "/08-if-else/index.html#example-max-of-two-numbers",
            "text": "Let's switch to another example: suppose we have three variables,  x ,  y , and  max , and we want to set  max  to the maximum of  x  and  y .  Consider the following code snippet:  1\n2\n3\n4\n5\n6 if   ( x   >   y )   { \n   max   =   x ;  }   if   ( x   <   y )   { \n   max   =   y ;  }    Take a moment to understand the code above, and see if you can figure out what is wrong.  When we think about writing conditionals, we have to exhaustively reason about what are all the possible scenarios that could occur.  In this example, we need to think about what are the possible relationships between  x  and  y  when we compare  x  an  y .  There are actually three possibilities!   x > y : in this case,  x  is larger and we set  max  to  x  y > x : in this case,  y  is larger and we set  max  to  y  x == y : in this case, both are equally large, so the maximum of the two can be either  x  or  y .   In the code above,  max  is not set properly if  x == y !  The following code adds the third case and arbitrarily chooses to set  max  to  y  if both  x  and  y  have the same value.  1\n2\n3\n4\n5\n6\n7\n8\n9 if   ( x   >   y )   { \n   max   =   x ;  }   if   ( x   <   y )   { \n   max   =   y ;  }  if   ( x   ==   y )   { \n   max   =   y ;  }",
            "title": "Example: Max of two numbers"
        },
        {
            "location": "/08-if-else/index.html#else",
            "text": "The code snippet above now correctly sets  max  to the maximum of  x  and  y .\nThe code, however, is not very satisfying, since we compare between  x  and  y  three times.   Let's see how we can reduce the number of comparisons to one.  We are going to do some  refactoring  of the code above.  First, observe that the \"true block\" for  x < y  and  x == y  are the same, and we can combine it into a single comparison  x <= y .  1\n2\n3\n4\n5\n6 if   ( x   >   y )   { \n   max   =   x ;  }   if   ( x   <=   y )   { \n   max   =   y ;  }    Second, observe that if  x > y  is false, then  x <= y  must be true.  We say that  x > y  and  x <= y  are  negation  (or opposite) of each other.  So, the check for  x <= y  is redundant -- checking  x > y  is enough to tell us if  x <= y .  We can re-write the code above as:  1\n2\n3\n4\n5 if   ( x   >   y )   { \n   max   =   x ;  }   else   { \n   max   =   y ;  }    The word  else  as seen above is another C keyword -- it must be used in conjunction with  if  to indicate an alternate path of execution if the logical expression is false.  1\n2\n3\n4\n5 if   ( < logical   expression > )   {  \n   \"true block\" :   statements   to   be   executed   if   expression   evaluates   to   true  }   else   { \n   \"false block\" :   statements   to   be   executed   if   expression   evaluates   to   false  }",
            "title": "Else"
        },
        {
            "location": "/08-if-else/index.html#nested-else-if",
            "text": "The example above considers  two  possible execution paths only.  In some situations, we may need to consider more than two execution paths.  Take the following problem for example.  You are given the numerical score for an assignment, ranged between 0 and 10.  Print out the letter grade of the assignment according to the table below:     Score  Letter Grade      8 or higher  A    Less than 8 but 5 or higher  B    Less than 5 but 3 or higher  C    Less than 3  D     Since the  if - else  statement only allows branching into two possibilities, we can branch into multiple possibilities by nesting the  if - else  statements hierarchically.  We can first break the table down into three tables, each containing only two rows, with one row a negation of the other row.     Score  Letter Grade      8 or higher  A    Less than 8  See Table 1     Table 1 (less than 8)     Score  Letter Grade      5 or higher  B    Less than 5  See Table 2     Table 2 (less than 5)     Score  Letter Grade      3 or higher  C    Less than 3  D     The tables above can then be written into the following function:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18 void   print_score ( double   score )   { \n   if   ( score   >=   8 )   { \n     cs1010_println_string ( \"A\" ); \n   }   else   { \n     // Table 1 \n     if   ( score   >=   5 )   { \n       cs1010_println_string ( \"B\" ); \n     }   else   { \n       // Table 2 \n       if   ( score   >=   3 )   { \n         cs1010_println_string ( \"C\" ); \n       }   else   { \n         cs1010_println_string ( \"D\" ); \n       } \n     } \n   }  }    There are three nested  if - else  in the function above.  Note how I use indentation to clearly indicate the nesting of blocks.  Such nesting or indentation is not required by C standard, but is a commonly accepted coding practice, and is required for CS1010.  The code below compiles perfectly but is not as easy to read by a human as the above.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12 void   print_score ( double   score )   { \n   if   ( score   >=   8 )   { \n     cs1010_println_string ( \"A\" );   }   else   {   // Table 1  \n     if   ( score   >=   5 )   {   cs1010_println_string ( \"B\" ); \n   }   else   {   // Table 2  if   ( score   >=   3 )   { \n   cs1010_println_string ( \"C\" ); \n       }   else   { \n         cs1010_println_string ( \"D\" ); \n     }   }   }   }  // Don't write code like this.    There are also a couple of \"first\" in the sample code above:   You see the keyword  void  for the first time.   void  is a special type that indicates nothing.  The function  print_score  does not return anything, it accepts an input  score  and print something to screen.  As such, we say that the return type of  print_score  is  void .  You see  strings  for the first time ( \"A\" , etc.).  A  string  basically is a sequence of characters.  We use double quotes  \"  to mark the beginning and the end of a string, and use the CS1010 I/O library function  cs1010_println_string  to print a string to the screen.    You can imagine that as the number of possible letter grades increases (NUS has 11), we will have many nested  if - else , and the code gets complicated.  To reduce the number of nesting, we can write  else if  directly, without nesting:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12 void   print_score ( double   score )   { \n   if   ( score   >=   8 )   { \n     cs1010_println_string ( \"A\" ); \n   }   else   if   ( score   >=   5 )   { \n     cs1010_println_string ( \"B\" ); \n   }   else   if   ( score   >=   3 )   { \n     cs1010_println_string ( \"C\" ); \n   }   else   { \n     cs1010_println_string ( \"D\" ); \n   }  }    The above code is easier to read, but has exactly the same flow as the one with nested  if - else  earlier.",
            "title": "Nested Else-If"
        },
        {
            "location": "/08-if-else/index.html#avoid-skipping-the-curly-braces",
            "text": "The C standard says that, if the block contains only one statement, we can skip the curly braces  {  and  } .  In the example above, we can write:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11 void   print_score ( double   score )   { \n   if   ( score   >=   8 )  \n     cs1010_println_string ( \"A\" ); \n   else   if   ( score   >=   5 ) \n     cs1010_println_string ( \"B\" ); \n   else   if   ( score   >=   3 ) \n     cs1010_println_string ( \"C\" ); \n   else \n     cs1010_println_string ( \"D\" );  }    Despite being allowed by the C standard, this is considered a bad practice, and should be avoided.  Imagine some time later, you go back to this code, and want to write something extra:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12 void   print_score ( double   score )   { \n   if   ( score   >=   8 )  \n     cs1010_println_string ( \"A\" ); \n   else   if   ( score   >=   5 ) \n     cs1010_println_string ( \"B\" ); \n   else   if   ( score   >=   3 ) \n     cs1010_println_string ( \"C\" ); \n   else \n     cs1010_println_string ( \"You can do better!\" ); \n     cs1010_println_string ( \"D\" );  }    What would be printed?  The famous  Apple  goto fail  bug  wouldn't have happened in the there is a pair of curly braces added!  Alternatively, if you have code like this:  1\n2\n3\n4\n5 if   ( score   >=   8 ) \n   if   ( late_penalty   !=   0 )  \n       cs1010_println_string ( \"late submission\" );  else  \n   cs1010_println_string ( \"you can do better!\" );    It might look like  you can do better!  will be printed if  score  is less than 8, but actually,  you can do better!  will be printed if the  score  is larger or equal to 8 and there is no late penalty, which is not what is intended.",
            "title": "Avoid Skipping the Curly Braces"
        },
        {
            "location": "/08-if-else/index.html#conditional-operator",
            "text": "The conditional operator consists of two special characters  ?  and  :  and is used in the format of:  1 condition ? true expression : false expression;   If the  condition  evaluates to true, then the  true expression  will be evaluated and returned, otherwise, the  false expression  will be evaluated and returned.  The conditional operator allows us to replace  1\n2\n3\n4\n5 if   ( x   >   y )   { \n   max   =   x ;  }   else   { \n   max   =   y ;  }    with a single line:  1 max = (x > y) ? x : y;   We can nest the conditional operator as well, but it does not necessarily make your code easier to read once you start nesting them up.  We do not encourage you to nest the conditional operator in CS1010 and to limit its usage to simple cases above.",
            "title": "Conditional Operator"
        },
        {
            "location": "/08-if-else/index.html#comparing-real-numbers",
            "text": "Recall that we said  real numbers cannot be represented exactly in computers .  Comparing real numbers, therefore, becomes a little bit trickier in programming.  The  if  statement  1\n2\n3\n4\n5 double   expected_value   =   0.3 ;  double   sum   =   0.1   +   0.2 ;  if   ( sum   ==   expected_value )   { \n  :  }    would not be evaluated as  true  as expected!  Thus, to compare real numbers, we normally allow some errors in comparisons -- we want the absolute difference between  sum  and  expected_value  to be small enough.  1\n2\n3\n4\n5 double   expected_value   =   0.3 ;  double   sum   =   0.1   +   0.2 ;  if   ( fabs ( sum   -   expected_value )   <   0.000001 )   { \n  :  }",
            "title": "Comparing Real Numbers"
        },
        {
            "location": "/08-if-else/index.html#problem-sets",
            "text": "",
            "title": "Problem Sets"
        },
        {
            "location": "/08-if-else/index.html#problem-81",
            "text": "(a) Do the following two functions behave the same way?  Explain.  1\n2\n3\n4\n5\n6\n7 long   factorial ( long   n )   { \n   if   ( n   ==   0 )   { \n     return   1 ; \n   } \n   return   n   *   factorial ( n   -   1 );  }    1\n2\n3\n4\n5\n6\n7\n8 long   factorial ( long   n )   { \n   if   ( n   ==   0 )   { \n     return   1 ; \n   }   else   { \n     return   n   *   factorial ( n   -   1 ); \n   }  }    (b) How about:  1\n2\n3\n4\n5\n6\n7\n8\n9 long   factorial ( long   n )   { \n   long   result ; \n   if   ( n   ==   0 )   { \n     result   =   1 ; \n   } \n   result   =   n   *   factorial ( n   -   1 ); \n   return   result ;  }    and    1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10 long   factorial ( long   n )   { \n   long   result ; \n   if   ( n   ==   0 )   { \n     result   =   1 ; \n   }   else   { \n     result   =   n   *   factorial ( n   -   1 ); \n   } \n   return   result ;  }",
            "title": "Problem 8.1"
        },
        {
            "location": "/08-if-else/index.html#problem-82",
            "text": "Draw the flowchart for the code snippet  1\n2\n3\n4\n5\n6\n7\n8\n9 if   ( x   >   y )   { \n   max   =   x ;  }   if   ( x   <   y )   { \n   max   =   y ;  }  if   ( x   ==   y )   { \n   max   =   y ;  }    and  1\n2\n3\n4\n5 if   ( x   >   y )   { \n   max   =   x ;  }   else   { \n   max   =   y ;  }",
            "title": "Problem 8.2"
        },
        {
            "location": "/08-if-else/index.html#problem-83",
            "text": "Suppose we break down the table below in a slightly different way.     Score  Letter Grade      8 or higher  A    Less than 8 but 5 or higher  B    Less than 5 but 3 or higher  C    Less than 3  D     We rewrite the tables into three smaller tables, as:     Score  Letter Grade      5 or higher  See Table 3    Less than 5  See Table 4     where Table 3 (5 or higher) is     Score  Letter Grade      8 or higher  A    Less than 8  B     and Table 4 (less than 5) is     Score  Letter Grade      3 or higher  C    Less than 3  D     Write the corresponding  if - else  statements to print out the letter grade based on the tables above.",
            "title": "Problem 8.3"
        },
        {
            "location": "/08-if-else/index.html#appendix-code-from-lecture",
            "text": "Here are the C files that Wei Tsang wrote during the lecture.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16 #include   \"cs1010.h\"  long   factorial ( long   n )  { \n   if   ( n   ==   0 )   { \n     return   1 ; \n   }  \n   return   n   *   factorial ( n - 1 );  }  int   main ()  { \n   long   n   =   cs1010_read_long (); \n   long   fac   =   factorial ( n ); \n   cs1010_println_long ( fac );  }     1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20 #include   \"cs1010.h\"  long   max ( long   x ,   long   y )  { \n   if   ( x   >   y )   { \n     return   x ; \n   }   else   { \n     return   y ; \n   } \n   // alternatively, using the conditional operator ? : \n   // return (x > y) ? x : y;  }  int   main ()  { \n   long   x   =   cs1010_read_long (); \n   long   y   =   cs1010_read_long (); \n   long   m   =   max ( x ,   y ); \n   cs1010_println_long ( m );  }     1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19 #include   \"cs1010.h\"  void   print_score ( double   x )  { \n   if   ( x   >=   8 ) \n     cs1010_println_string ( \"A\" ); \n   else   if   ( x   >=   5 ) \n     cs1010_println_string ( \"B\" ); \n   else   if   ( x   >=   3 ) \n     cs1010_println_string ( \"C\" ); \n   else \n     cs1010_println_string ( \"D\" );  }  int   main ()  { \n   double   score   =   cs1010_read_double (); \n   print_score ( score );  }",
            "title": "Appendix: Code From Lecture"
        },
        {
            "location": "/09-logical-exp/index.html",
            "text": "Unit 9: Logical Expression\n\n\nRepresenting a Boolean Value\n\n\nYou have seen some basic logical expressions in \nUnit 8\n. \nn == 0\n, \nx > y\n, \ny > x\n, are all logical expressions.  They evaluate to either true or false.\n\n\nWe call a type that can contain either true or false as a Boolean data type, named after \nGeorge Boole\n, a mathematician.\n\n\nThe Boolean data type in C named \nbool\n.  It can hold two values: \ntrue\n or \nfalse\n.  All three of \nbool\n, \ntrue\n, and \nfalse\n are keywords introduced in modern C.  To use them, you need to include the file \nstdbool.h\n at the top of your program.  \n\n\nUse \nbool\n is considered a cleaner way of representing true and false in C.  Classically,  C defines the numeric value 0 to be false, and everything else to be true.  So, you can write code like this:\n\n\n1\n2\n3\n4\n5\n// x and y are long.\n\n\nlong\n \nis_diff\n \n=\n \nx\n \n-\n \ny\n;\n\n\nif\n \n(\nis_diff\n)\n \n{\n\n  \ncs1010_println_string\n(\n\"x and y store different values.\"\n);\n\n\n}\n\n\n\n\n\n\n\nThe above is harder to understand and should be avoided.  A cleaner way is to write:\n\n\n1\n2\n3\n4\nbool\n \nis_diff\n \n=\n \nx\n \n!=\n \ny\n;\n\n\nif\n \n(\nis_diff\n)\n \n{\n\n  \ncs1010_println_string\n(\n\"x and y store different values.\"\n);\n\n\n}\n\n\n\n\n\n\n\nAlthough not required by C, we will name a \nbool\n variable with a prefix \nis_\n or \nhas_\n as a convention.  \n\n\nThe code above can also be written as:\n\n1\n2\n3\n4\nbool\n \nis_diff\n \n=\n \nx\n \n!=\n \ny\n;\n\n\nif\n \n(\nis_diff\n \n==\n \ntrue\n)\n \n{\n\n  \ncs1010_println_string\n(\n\"x and y store different values.\"\n);\n\n\n}\n\n\n\n\n\n\nThe comparison with \ntrue\n is redundant, however, and should be skipped.\n\n\nLogical Operators\n\n\nJust like we can perform arithmetic operations on integers and real numbers, we can perform logical operations on boolean values.  These allow us to write complex logical expressions.\n\n\nConsider the example problem: Write a function that, given the birth year of a person, determine if he or she belongs to Generation Z, defined as someone whose birth is between 1995 and 2005, inclusive. \n\n\nWe can write the function as follows using what we have known:\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nbool\n \nis_gen_z\n(\nlong\n \nbirth_year\n)\n \n\n{\n\n  \nif\n \n(\nbirth_year\n \n>=\n \n1995\n)\n \n{\n\n    \nif\n \n(\nbirth_year\n \n<=\n \n2005\n)\n \n{\n\n      \nreturn\n \ntrue\n;\n\n    \n}\n \n  \n}\n\n  \nreturn\n \nfalse\n;\n\n\n}\n\n\n\n\n\n\nTo be in Generation Z, both conditions \nbirth_year >= 1995\n and \nbirth_year <= 2005\n must be true.  We can use the logical AND \n&&\n operator to simplify the code above to:\n\n\n1\n2\n3\n4\n5\n6\n7\nbool\n \nis_gen_z\n(\nlong\n \nbirth_year\n)\n \n\n{\n\n  \nif\n \n((\nbirth_year\n \n>=\n \n1995\n)\n \n&&\n \n(\nbirth_year\n \n<=\n \n2005\n))\n \n{\n\n    \nreturn\n \ntrue\n;\n\n  \n}\n\n  \nreturn\n \nfalse\n;\n\n\n}\n\n\n\n\n\n\n\nor simply:\n\n1\n2\n3\n4\nbool\n \nis_gen_z\n(\nlong\n \nbirth_year\n)\n \n\n{\n\n  \nreturn\n \n((\nbirth_year\n \n>=\n \n1995\n)\n \n&&\n \n(\nbirth_year\n \n<=\n \n2005\n));\n\n\n}\n\n\n\n\n\n\nThe AND operator, \n&&\n, evaluates to true if and only if both operands are true.\n\n\n\n\nCommon Error\n\n\nA common mistake by a new C programmer is to write \n1995 <= birth_year <= 2005\n as the logical expression.  Unfortunately, in C, we cannot chain the comparison operators together.\n\n\n\n\nWhat if we want to write a function to determine if someone is NOT part of Generation Z?   This means that they are born \neither\n before 1995 \nor\n after 2005.  To have an expression that evaluates to true if either one of two expressions is true, we can use the OR operator, \n||\n.\n\n\n1\n2\n3\n4\nbool\n \nis_not_gen_z\n(\nlong\n \nbirth_year\n)\n \n\n{\n\n  \nreturn\n \n((\nbirth_year\n \n<\n \n1995\n)\n \n||\n \n(\nbirth_year\n \n>\n \n2005\n));\n\n\n}\n\n\n\n\n\n\n\nGenerally, we prefer to write functions that check for the positives, as it is generally easier to think in terms of the positives.  So the example \nis_not_gen_z\n above is for illustration purposes only, we do not encourage you to write functions that check for the negatives.   In any case, if we want to check if someone is not a Generation Z, we can use the \n!\n NOT operator.\n\n\n1\n2\n3\nif\n \n(\n!\nis_gen_z\n(\nbirth_year\n))\n \n{\n\n     \n:\n\n\n}\n\n\n\n\n\n\n\nThis operator can be used as part of the boolean expression:\n\n\n1\n2\n3\n4\nbool\n \nis_not_gen_z\n(\nlong\n \nbirth_year\n)\n \n\n{\n\n  \nreturn\n \n!\n((\nbirth_year\n \n>=\n \n1995\n)\n \n&&\n \n(\nbirth_year\n \n<=\n \n2005\n));\n\n\n}\n\n\n\n\n\n\n\nShort Circuiting\n\n\nWhen evaluating the logical expressions that involve \n&&\n and \n||\n, C uses \"short-circuiting\".  This means that, if we already know, for sure, that a logical expression is true or is false, there is no need to continue the evaluation.  The corresponding \ntrue\n and \nfalse\n value will be returned.\n\n\nConsider the following:\n\n1\n2\n3\n4\nbool\n \nis_gen_z\n(\nlong\n \nbirth_year\n)\n \n\n{\n\n  \nreturn\n \n((\nbirth_year\n \n>=\n \n1995\n)\n \n&&\n \n(\nbirth_year\n \n<=\n \n2005\n));\n\n\n}\n\n\n\n\n\n\nIf the argument \nbirth_year\n is \n1970\n, then, the expression \n(birth_year >= 1995)\n already evaluates to \nfalse\n, and the whole statement is false.  We do not need to evaluate the second expression \n(birth_year <= 2005)\n.  \n\n\nSimilarly, for \n\n1\n2\n3\n4\nbool\n \nis_not_gen_z\n(\nlong\n \nbirth_year\n)\n \n\n{\n\n  \nreturn\n \n((\nbirth_year\n \n<\n \n1995\n)\n \n||\n \n(\nbirth_year\n \n>\n \n2005\n));\n\n\n}\n\n\n\n\n\n\nWhen \nbirth_year\n is \n1970\n, the expression \n(birth_year < 1995)\n is \ntrue\n, so we know that the whole statement is \ntrue\n.  There is no need to check if \n(birth_year > 2005)\n.\n\n\nIn both examples above, the savings due to short-circuiting is not much -- since we are basically comparing two numbers, and there is no \nside effects\n in comparing \nbirth_year\n to \n2005\n.  But, let's suppose that we introduce two functions with side effects (of printing to screen):\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\nbool\n \nnot_too_old\n(\nlong\n \nbirth_year\n)\n\n\n{\n\n  \nif\n \n(\nbirth_year\n \n>=\n \n1995\n)\n \n{\n\n    \ncs1010_print_string\n(\n\"not too old..\"\n);\n\n    \nreturn\n \ntrue\n;\n\n  \n}\n\n  \ncs1010_print_string\n(\n\"too old..\"\n);\n\n  \nreturn\n \nfalse\n;\n\n\n}\n\n\n\nbool\n \nnot_too_young\n(\nlong\n \nbirth_year\n)\n\n\n{\n\n  \nif\n \n(\nbirth_year\n \n<=\n \n2005\n)\n \n{\n\n    \ncs1010_print_string\n(\n\"not too young..\"\n);\n\n    \nreturn\n \ntrue\n;\n\n  \n}\n\n  \ncs1010_print_string\n(\n\"too young..\"\n);\n\n  \nreturn\n \nfalse\n;\n\n\n}\n\n\n\nbool\n \nis_gen_z\n(\nlong\n \nbirth_year\n)\n \n\n{\n\n  \nreturn\n \nnot_too_old\n(\nbirth_year\n)\n \n&&\n \nnot_too_young\n(\nbirth_year\n);\n\n\n}\n\n\n\n\n\n\n\nWhen we call \nis_gen_z(1984)\n, you might expect \ntoo old..not too young..\n to be printed, but due to short-circuiting, the code only prints \ntoo old..\n.\n\n\nAnother reason to keep short-circuiting in mind is that the order of the logical expressions matter: we would want to put the logical expression that involves more work in the second half of the expression.  Take the following example:\n\n\n1\n2\n3\nif\n \n(\nnumber\n \n<\n \n100000\n \n&&\n \nis_prime\n(\nnumber\n))\n \n{\n\n    \n:\n\n\n}\n\n\n\n\n\n\n\nChecking whether a number is below 100,000 is easier than checking if a number is prime.  So, we can skip checking for primality if the \nnumber\n is too big.  Compare this to:\n\n\n1\n2\n3\nif\n \n(\nis_prime\n(\nnumber\n)\n \n&&\n \nnumber\n \n<\n \n100000\n)\n \n{\n\n    \n:\n\n\n}\n\n\n\n\n\n\n\nSuppose \nnumber\n is a gigantic integer, then we would have spent lots of effort checking if \nnumber\n is a prime, only to find out that it is too big anyway!\n\n\nProblem Sets\n\n\nProblem 9.1\n\n\nGiven two \nbool\n variables, \na\n and \nb\n, there are four possible combinations of \ntrue\n \nfalse\n values.  What are the values of \na && b\n, \na || b\n, and \n!a\n for each of these combinations?  Fill in the table below.\n\n\n\n\n\n\n\n\na\n\n\nb\n\n\na && b\n\n\na || b\n\n\n!a\n\n\n\n\n\n\n\n\n\n\ntrue\n\n\ntrue\n\n\n\n\n\n\n\n\n\n\n\n\ntrue\n\n\nfalse\n\n\n\n\n\n\n\n\n\n\n\n\nfalse\n\n\ntrue\n\n\n\n\n\n\n\n\n\n\n\n\nfalse\n\n\nfalse\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nProblem 9.2\n\n\nConsider the function below, which aims to return the maximum value given three numbers.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\nlong\n \nmax_of_three\n(\nlong\n \na\n,\n \nlong\n \nb\n,\n \nlong\n \nc\n)\n \n\n{\n\n  \nlong\n \nmax\n \n=\n \n0\n;\n\n  \nif\n \n((\na\n \n>\n \nb\n)\n \n&&\n \n(\na\n \n>\n \nc\n))\n \n{\n\n    \n// a is larger than b and c\n\n    \nmax\n \n=\n \na\n;\n\n  \n}\n\n  \nif\n \n((\nb\n \n>\n \na\n)\n \n&&\n \n(\nb\n \n>\n \nc\n))\n \n{\n\n    \n// b is larger than a and c\n\n    \nmax\n \n=\n \nb\n;\n\n  \n}\n\n  \nif\n \n((\nc\n \n>\n \na\n)\n \n&&\n \n(\nc\n \n>\n \nb\n))\n \n{\n\n    \n// c is larger than a and b\n\n    \nmax\n \n=\n \nc\n;\n\n  \n}\n\n  \nreturn\n \nmax\n;\n\n\n}\n\n\n\n\n\n\n\n(a) What is wrong with the code above?\n\n\n(b) Give a sample test value of \na\n, \nb\n, and \nc\n that would expose the bug.\n\n\n(C) Fix the code above to remove the bug.\n\n\n(d) Replace the three \nif\n statements in the code above with \nif\n-\nelse\n statements.  Draw the corresponding flowchart.\n\n\nProblem 9.3\n\n\nWrite a function that takes in a blood pressure measurement, and prints either \nlow\n, \nideal\n, \npre-high\n, and \nhigh\n depending on the input values.  The blood pressure is given as two \nlong\n values, the systolic and the diastolic.  The text to be printed depends on the range, depicted in the figure below.\n\n\n1\n2\n3\n4\nvoid\n \nprint_blood_pressure\n(\nlong\n \nsystolic\n,\n \nlong\n \ndiastolic\n)\n\n\n{\n\n  \n:\n\n\n}\n\n\n\n\n\n\n\n\n\nThe figure does not say how to classify the data if the values fall exactly on the boundary of two regions.  In this case, you can classify it to either region.\n\n\nAppendix: Code from Lecture\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n#include\n \n\"cs1010.h\"\n\n\n#include\n \n<stdbool.h>\n\n\n\nbool\n \nis_gen_z\n(\nlong\n \nyear\n)\n\n\n{\n\n  \nreturn\n \n((\nyear\n \n>=\n \n1995\n)\n \n&&\n \n(\nyear\n \n<=\n \n2005\n));\n\n\n}\n\n\n\nbool\n \nis_not_gen_z\n(\nlong\n \nyear\n)\n\n\n{\n\n  \nreturn\n \n((\nyear\n \n<\n \n1995\n)\n \n||\n \n(\nyear\n \n>\n \n2005\n));\n\n\n}\n\n\n\nint\n \nmain\n()\n\n\n{\n\n  \nlong\n \nyear\n \n=\n \ncs1010_read_long\n();\n\n  \nif\n \n(\nis_gen_z\n(\nyear\n))\n \n{\n\n    \ncs1010_println_string\n(\n\"Z!\"\n);\n\n  \n}\n \nelse\n \n{\n\n    \ncs1010_println_string\n(\n\"Not Z!\"\n);\n\n  \n}\n\n\n}",
            "title": "9. Logical Expression"
        },
        {
            "location": "/09-logical-exp/index.html#unit-9-logical-expression",
            "text": "",
            "title": "Unit 9: Logical Expression"
        },
        {
            "location": "/09-logical-exp/index.html#representing-a-boolean-value",
            "text": "You have seen some basic logical expressions in  Unit 8 .  n == 0 ,  x > y ,  y > x , are all logical expressions.  They evaluate to either true or false.  We call a type that can contain either true or false as a Boolean data type, named after  George Boole , a mathematician.  The Boolean data type in C named  bool .  It can hold two values:  true  or  false .  All three of  bool ,  true , and  false  are keywords introduced in modern C.  To use them, you need to include the file  stdbool.h  at the top of your program.    Use  bool  is considered a cleaner way of representing true and false in C.  Classically,  C defines the numeric value 0 to be false, and everything else to be true.  So, you can write code like this:  1\n2\n3\n4\n5 // x and y are long.  long   is_diff   =   x   -   y ;  if   ( is_diff )   { \n   cs1010_println_string ( \"x and y store different values.\" );  }    The above is harder to understand and should be avoided.  A cleaner way is to write:  1\n2\n3\n4 bool   is_diff   =   x   !=   y ;  if   ( is_diff )   { \n   cs1010_println_string ( \"x and y store different values.\" );  }    Although not required by C, we will name a  bool  variable with a prefix  is_  or  has_  as a convention.    The code above can also be written as: 1\n2\n3\n4 bool   is_diff   =   x   !=   y ;  if   ( is_diff   ==   true )   { \n   cs1010_println_string ( \"x and y store different values.\" );  }    The comparison with  true  is redundant, however, and should be skipped.",
            "title": "Representing a Boolean Value"
        },
        {
            "location": "/09-logical-exp/index.html#logical-operators",
            "text": "Just like we can perform arithmetic operations on integers and real numbers, we can perform logical operations on boolean values.  These allow us to write complex logical expressions.  Consider the example problem: Write a function that, given the birth year of a person, determine if he or she belongs to Generation Z, defined as someone whose birth is between 1995 and 2005, inclusive.   We can write the function as follows using what we have known: 1\n2\n3\n4\n5\n6\n7\n8\n9 bool   is_gen_z ( long   birth_year )   { \n   if   ( birth_year   >=   1995 )   { \n     if   ( birth_year   <=   2005 )   { \n       return   true ; \n     }  \n   } \n   return   false ;  }    To be in Generation Z, both conditions  birth_year >= 1995  and  birth_year <= 2005  must be true.  We can use the logical AND  &&  operator to simplify the code above to:  1\n2\n3\n4\n5\n6\n7 bool   is_gen_z ( long   birth_year )   { \n   if   (( birth_year   >=   1995 )   &&   ( birth_year   <=   2005 ))   { \n     return   true ; \n   } \n   return   false ;  }    or simply: 1\n2\n3\n4 bool   is_gen_z ( long   birth_year )   { \n   return   (( birth_year   >=   1995 )   &&   ( birth_year   <=   2005 ));  }    The AND operator,  && , evaluates to true if and only if both operands are true.   Common Error  A common mistake by a new C programmer is to write  1995 <= birth_year <= 2005  as the logical expression.  Unfortunately, in C, we cannot chain the comparison operators together.   What if we want to write a function to determine if someone is NOT part of Generation Z?   This means that they are born  either  before 1995  or  after 2005.  To have an expression that evaluates to true if either one of two expressions is true, we can use the OR operator,  || .  1\n2\n3\n4 bool   is_not_gen_z ( long   birth_year )   { \n   return   (( birth_year   <   1995 )   ||   ( birth_year   >   2005 ));  }    Generally, we prefer to write functions that check for the positives, as it is generally easier to think in terms of the positives.  So the example  is_not_gen_z  above is for illustration purposes only, we do not encourage you to write functions that check for the negatives.   In any case, if we want to check if someone is not a Generation Z, we can use the  !  NOT operator.  1\n2\n3 if   ( ! is_gen_z ( birth_year ))   { \n      :  }    This operator can be used as part of the boolean expression:  1\n2\n3\n4 bool   is_not_gen_z ( long   birth_year )   { \n   return   ! (( birth_year   >=   1995 )   &&   ( birth_year   <=   2005 ));  }",
            "title": "Logical Operators"
        },
        {
            "location": "/09-logical-exp/index.html#short-circuiting",
            "text": "When evaluating the logical expressions that involve  &&  and  || , C uses \"short-circuiting\".  This means that, if we already know, for sure, that a logical expression is true or is false, there is no need to continue the evaluation.  The corresponding  true  and  false  value will be returned.  Consider the following: 1\n2\n3\n4 bool   is_gen_z ( long   birth_year )   { \n   return   (( birth_year   >=   1995 )   &&   ( birth_year   <=   2005 ));  }    If the argument  birth_year  is  1970 , then, the expression  (birth_year >= 1995)  already evaluates to  false , and the whole statement is false.  We do not need to evaluate the second expression  (birth_year <= 2005) .    Similarly, for  1\n2\n3\n4 bool   is_not_gen_z ( long   birth_year )   { \n   return   (( birth_year   <   1995 )   ||   ( birth_year   >   2005 ));  }    When  birth_year  is  1970 , the expression  (birth_year < 1995)  is  true , so we know that the whole statement is  true .  There is no need to check if  (birth_year > 2005) .  In both examples above, the savings due to short-circuiting is not much -- since we are basically comparing two numbers, and there is no  side effects  in comparing  birth_year  to  2005 .  But, let's suppose that we introduce two functions with side effects (of printing to screen):   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24 bool   not_too_old ( long   birth_year )  { \n   if   ( birth_year   >=   1995 )   { \n     cs1010_print_string ( \"not too old..\" ); \n     return   true ; \n   } \n   cs1010_print_string ( \"too old..\" ); \n   return   false ;  }  bool   not_too_young ( long   birth_year )  { \n   if   ( birth_year   <=   2005 )   { \n     cs1010_print_string ( \"not too young..\" ); \n     return   true ; \n   } \n   cs1010_print_string ( \"too young..\" ); \n   return   false ;  }  bool   is_gen_z ( long   birth_year )   { \n   return   not_too_old ( birth_year )   &&   not_too_young ( birth_year );  }    When we call  is_gen_z(1984) , you might expect  too old..not too young..  to be printed, but due to short-circuiting, the code only prints  too old.. .  Another reason to keep short-circuiting in mind is that the order of the logical expressions matter: we would want to put the logical expression that involves more work in the second half of the expression.  Take the following example:  1\n2\n3 if   ( number   <   100000   &&   is_prime ( number ))   { \n     :  }    Checking whether a number is below 100,000 is easier than checking if a number is prime.  So, we can skip checking for primality if the  number  is too big.  Compare this to:  1\n2\n3 if   ( is_prime ( number )   &&   number   <   100000 )   { \n     :  }    Suppose  number  is a gigantic integer, then we would have spent lots of effort checking if  number  is a prime, only to find out that it is too big anyway!",
            "title": "Short Circuiting"
        },
        {
            "location": "/09-logical-exp/index.html#problem-sets",
            "text": "",
            "title": "Problem Sets"
        },
        {
            "location": "/09-logical-exp/index.html#problem-91",
            "text": "Given two  bool  variables,  a  and  b , there are four possible combinations of  true   false  values.  What are the values of  a && b ,  a || b , and  !a  for each of these combinations?  Fill in the table below.     a  b  a && b  a || b  !a      true  true       true  false       false  true       false  false",
            "title": "Problem 9.1"
        },
        {
            "location": "/09-logical-exp/index.html#problem-92",
            "text": "Consider the function below, which aims to return the maximum value given three numbers.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17 long   max_of_three ( long   a ,   long   b ,   long   c )   { \n   long   max   =   0 ; \n   if   (( a   >   b )   &&   ( a   >   c ))   { \n     // a is larger than b and c \n     max   =   a ; \n   } \n   if   (( b   >   a )   &&   ( b   >   c ))   { \n     // b is larger than a and c \n     max   =   b ; \n   } \n   if   (( c   >   a )   &&   ( c   >   b ))   { \n     // c is larger than a and b \n     max   =   c ; \n   } \n   return   max ;  }    (a) What is wrong with the code above?  (b) Give a sample test value of  a ,  b , and  c  that would expose the bug.  (C) Fix the code above to remove the bug.  (d) Replace the three  if  statements in the code above with  if - else  statements.  Draw the corresponding flowchart.",
            "title": "Problem 9.2"
        },
        {
            "location": "/09-logical-exp/index.html#problem-93",
            "text": "Write a function that takes in a blood pressure measurement, and prints either  low ,  ideal ,  pre-high , and  high  depending on the input values.  The blood pressure is given as two  long  values, the systolic and the diastolic.  The text to be printed depends on the range, depicted in the figure below.  1\n2\n3\n4 void   print_blood_pressure ( long   systolic ,   long   diastolic )  { \n   :  }     The figure does not say how to classify the data if the values fall exactly on the boundary of two regions.  In this case, you can classify it to either region.",
            "title": "Problem 9.3"
        },
        {
            "location": "/09-logical-exp/index.html#appendix-code-from-lecture",
            "text": "1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22 #include   \"cs1010.h\"  #include   <stdbool.h>  bool   is_gen_z ( long   year )  { \n   return   (( year   >=   1995 )   &&   ( year   <=   2005 ));  }  bool   is_not_gen_z ( long   year )  { \n   return   (( year   <   1995 )   ||   ( year   >   2005 ));  }  int   main ()  { \n   long   year   =   cs1010_read_long (); \n   if   ( is_gen_z ( year ))   { \n     cs1010_println_string ( \"Z!\" ); \n   }   else   { \n     cs1010_println_string ( \"Not Z!\" ); \n   }  }",
            "title": "Appendix: Code from Lecture"
        },
        {
            "location": "/10-assert/index.html",
            "text": "Unit 10: Assertion\n\n\nAn assertion is a logical expression that must always be true for the program to be correct.  We can write assertions either as part of the comment for the code, or use the \nassert()\n macro in C.  Let's look at what is assertion first.  We will introduce the use of \nassert()\n later.\n\n\nTo get started, let's first look at the most trivial assertion:\n\n\n1\n2\nlong\n \nx\n \n=\n \n1\n;\n\n\n// { x == 1 }\n\n\n\n\n\n\n\nThe line above initialize the variable \nx\n to be \n1\n.  The next line, a comment, uses the curly braces \n{\n and \n}\n with a logical expression in between, to indicate that \nx\n must be equals to \n1\n after the assignment.  We use the curly braces as a notation in CS1010, following \nC. A. R. Hoare\n's notation, but this is not part of any C standard.\n\n\nThe assertion above is kind of trivial and not very meaningful. \n\n\nLet's revisit this snippet:\n\n\n1\n2\n3\n4\n5\nif\n \n(\nx\n \n>\n \ny\n)\n \n{\n\n  \nmax\n \n=\n \nx\n;\n\n\n}\n \nelse\n \n{\n\n  \nmax\n \n=\n \ny\n;\n\n\n}\n\n\n\n\n\n\n\nLet's consider the true block and the false block.  Inside the true block, since \nx > y\n, we can assert that, well, \nx > y\n, and inside the false block, we have the negation, so \nx <= y\n.\n\n\n1\n2\n3\n4\n5\n6\n7\nif\n \n(\nx\n \n>\n \ny\n)\n \n{\n\n  \n// { x > y }\n\n  \nmax\n \n=\n \nx\n;\n\n\n}\n \nelse\n \n{\n\n  \n// { x <= y }\n\n  \nmax\n \n=\n \ny\n;\n\n\n}\n\n\n\n\n\n\n\nLet's now consider what happens after initializing \nmax\n to either \nx\n or \ny\n.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nif\n \n(\nx\n \n>\n \ny\n)\n \n{\n\n  \n// { x > y }\n\n  \nmax\n \n=\n \nx\n;\n\n  \n// { max == x && max > y }\n\n\n}\n \nelse\n \n{\n\n  \n// { x <= y }\n\n  \nmax\n \n=\n \ny\n;\n\n  \n// { max >= x && max == y }\n\n\n}\n\n\n\n\n\n\n\nThe assertion on Line 4 consists of two parts: \nmax == x\n which is the result of the assignment (the trivial assertion), but since inside this block, \nx > y\n, we must have \nmax > y\n to be true as well.\n\n\nSimilarly, we can argue the assertion in Line 8 to be true.  \n\n\nWhat can we assert after we exit from the \nif\n-\nelse\n block?  We have either \nmax == x && max > y\n or \nmax >= x && max == y\n.  This is exactly the property we are looking for in \nmax\n when we set it to the maximum of \nx\n and \ny\n!  \n\n\nLet's look at another example:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n  \nif\n \n(\nscore\n \n>=\n \n8\n)\n \n{\n\n    \ncs1010_println_string\n(\n\"A\"\n);\n\n  \n}\n \nelse\n \n{\n\n    \nif\n \n(\nscore\n \n>=\n \n5\n)\n \n{\n\n      \ncs1010_println_string\n(\n\"B\"\n);\n\n    \n}\n \nelse\n \n{\n\n      \nif\n \n(\nscore\n \n>=\n \n3\n)\n \n{\n\n        \ncs1010_println_string\n(\n\"C\"\n);\n\n      \n}\n \nelse\n \n{\n\n        \ncs1010_println_string\n(\n\"D\"\n);\n\n      \n}\n\n    \n}\n\n  \n}\n\n\n\n\n\n\n\nLet's focus on the case of printing \nC\n.  We should print \nC\n if \nscore\n is less than 5 but is 3 or higher.  Let's check if this is correct by finding out what we can assert wrt \nscore\n just before printing \nC\n.  We first add the assert condition to all the true blocks and the false block by negating the \nif\n condition.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n  \nif\n \n(\nscore\n \n>=\n \n8\n)\n \n{\n\n    \ncs1010_println_string\n(\n\"A\"\n);\n\n  \n}\n \nelse\n \n{\n\n    \nif\n \n(\nscore\n \n>=\n \n5\n)\n \n{\n\n      \n// { score >= 5 }\n\n      \ncs1010_println_string\n(\n\"B\"\n);\n\n    \n}\n \nelse\n \n{\n\n      \n// { score < 5 }\n\n      \nif\n \n(\nscore\n \n>=\n \n3\n)\n \n{\n\n        \n// { score < 5 && score >= 3 }\n\n        \ncs1010_println_string\n(\n\"C\"\n);\n\n      \n}\n \nelse\n \n{\n\n        \n// { score < 5 && score < 3 }\n\n        \ncs1010_println_string\n(\n\"D\"\n);\n\n      \n}\n\n    \n}\n\n  \n}\n\n\n\n\n\n\n\nWe can see that, we are printing \nC\n when \nscore < 5 && score >= 3\n, which is what we want.  \n\n\nNote that the last assert \nscore < 5 && score < 3\n can be simplified to \nscore < 3\n.\n\n\nDe Morgan's Law\n\n\nTo write an assertion for the false block, it is useful to know the De Morgan's law, which tells us how to negate some logical expression.  Suppose we have two logical expressions \ne1\n and \ne2\n. \n\n\n\n\n!(e1 && e2)\n is the same as \n(!e1) || (!e2)\n\n\n!(e1 || e2)\n is the same as \n(!e1) && (!e2)\n\n\n\n\nWe have actually seen it in action.  Recall the expression for Generation Z: \n\n\n(birth_year >= 1995) && (birth_year <= 2005)\n.  \n\n\nTo check for NOT Generation Z, we can write it as \n\n\n!((birth_year >= 1995) && (birth_year <= 2005))\n, \n\n\nwhich according to De Morgan's law, is the same as \n\n\n!(birth_year >= 1995) || !(birth_year <= 2005)\n, \n\n\nwhich is just \n\n\n(birth_year < 1995) || (birth_year > 2005)\n, \n\n\nexactly as we have written before!\n\n\nProblem Set 10\n\n\nProblem 10.1\n\n\nNegate the following logical expression, then apply De Morgan's Law to simplify the resulting expression.  Assume all variable names mentioned are boolean variables.\n\n\n(a) \n(x > 1) && (y != 10)\n\n\n(b) \n!eating && drinking\n\n\n(C) \n(has_cs2030 || has_cs2113) && has_cs2040c\n\n\nProblem 10.2\n\n\nIn the code below, replace \n???\n with the appropriate assertion.  What will be printed?\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\nlong\n \nscore\n \n=\n \n4\n;\n\n\nif\n \n(\nsomething\n)\n \n{\n\n  \nscore\n \n=\n \n10\n;\n\n\n}\n \nelse\n \n{\n\n  \nscore\n \n=\n \n0\n;\n\n\n}\n\n\n// { ??? }\n\n\n\nif\n \n(\nscore\n \n==\n \n4\n)\n \n{\n\n    \nscore\n \n=\n \n1\n;\n\n\n}\n \nelse\n \n{\n\n    \nscore\n \n+=\n \n10\n;\n\n\n}\n\n\n// { ??? }\n\n\n\nif\n \n(\nscore\n \n>=\n \n10\n)\n \n{\n\n    \ncs1010_println_string\n(\n\"ok\"\n);\n\n\n}\n \nelse\n \n{\n\n    \ncs1010_println_string\n(\n\"failed\"\n);\n\n\n}",
            "title": "10. Assertion"
        },
        {
            "location": "/10-assert/index.html#unit-10-assertion",
            "text": "An assertion is a logical expression that must always be true for the program to be correct.  We can write assertions either as part of the comment for the code, or use the  assert()  macro in C.  Let's look at what is assertion first.  We will introduce the use of  assert()  later.  To get started, let's first look at the most trivial assertion:  1\n2 long   x   =   1 ;  // { x == 1 }    The line above initialize the variable  x  to be  1 .  The next line, a comment, uses the curly braces  {  and  }  with a logical expression in between, to indicate that  x  must be equals to  1  after the assignment.  We use the curly braces as a notation in CS1010, following  C. A. R. Hoare 's notation, but this is not part of any C standard.  The assertion above is kind of trivial and not very meaningful.   Let's revisit this snippet:  1\n2\n3\n4\n5 if   ( x   >   y )   { \n   max   =   x ;  }   else   { \n   max   =   y ;  }    Let's consider the true block and the false block.  Inside the true block, since  x > y , we can assert that, well,  x > y , and inside the false block, we have the negation, so  x <= y .  1\n2\n3\n4\n5\n6\n7 if   ( x   >   y )   { \n   // { x > y } \n   max   =   x ;  }   else   { \n   // { x <= y } \n   max   =   y ;  }    Let's now consider what happens after initializing  max  to either  x  or  y .  1\n2\n3\n4\n5\n6\n7\n8\n9 if   ( x   >   y )   { \n   // { x > y } \n   max   =   x ; \n   // { max == x && max > y }  }   else   { \n   // { x <= y } \n   max   =   y ; \n   // { max >= x && max == y }  }    The assertion on Line 4 consists of two parts:  max == x  which is the result of the assignment (the trivial assertion), but since inside this block,  x > y , we must have  max > y  to be true as well.  Similarly, we can argue the assertion in Line 8 to be true.    What can we assert after we exit from the  if - else  block?  We have either  max == x && max > y  or  max >= x && max == y .  This is exactly the property we are looking for in  max  when we set it to the maximum of  x  and  y !    Let's look at another example:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13    if   ( score   >=   8 )   { \n     cs1010_println_string ( \"A\" ); \n   }   else   { \n     if   ( score   >=   5 )   { \n       cs1010_println_string ( \"B\" ); \n     }   else   { \n       if   ( score   >=   3 )   { \n         cs1010_println_string ( \"C\" ); \n       }   else   { \n         cs1010_println_string ( \"D\" ); \n       } \n     } \n   }    Let's focus on the case of printing  C .  We should print  C  if  score  is less than 5 but is 3 or higher.  Let's check if this is correct by finding out what we can assert wrt  score  just before printing  C .  We first add the assert condition to all the true blocks and the false block by negating the  if  condition.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17    if   ( score   >=   8 )   { \n     cs1010_println_string ( \"A\" ); \n   }   else   { \n     if   ( score   >=   5 )   { \n       // { score >= 5 } \n       cs1010_println_string ( \"B\" ); \n     }   else   { \n       // { score < 5 } \n       if   ( score   >=   3 )   { \n         // { score < 5 && score >= 3 } \n         cs1010_println_string ( \"C\" ); \n       }   else   { \n         // { score < 5 && score < 3 } \n         cs1010_println_string ( \"D\" ); \n       } \n     } \n   }    We can see that, we are printing  C  when  score < 5 && score >= 3 , which is what we want.    Note that the last assert  score < 5 && score < 3  can be simplified to  score < 3 .",
            "title": "Unit 10: Assertion"
        },
        {
            "location": "/10-assert/index.html#de-morgans-law",
            "text": "To write an assertion for the false block, it is useful to know the De Morgan's law, which tells us how to negate some logical expression.  Suppose we have two logical expressions  e1  and  e2 .    !(e1 && e2)  is the same as  (!e1) || (!e2)  !(e1 || e2)  is the same as  (!e1) && (!e2)   We have actually seen it in action.  Recall the expression for Generation Z:   (birth_year >= 1995) && (birth_year <= 2005) .    To check for NOT Generation Z, we can write it as   !((birth_year >= 1995) && (birth_year <= 2005)) ,   which according to De Morgan's law, is the same as   !(birth_year >= 1995) || !(birth_year <= 2005) ,   which is just   (birth_year < 1995) || (birth_year > 2005) ,   exactly as we have written before!",
            "title": "De Morgan's Law"
        },
        {
            "location": "/10-assert/index.html#problem-set-10",
            "text": "",
            "title": "Problem Set 10"
        },
        {
            "location": "/10-assert/index.html#problem-101",
            "text": "Negate the following logical expression, then apply De Morgan's Law to simplify the resulting expression.  Assume all variable names mentioned are boolean variables.  (a)  (x > 1) && (y != 10)  (b)  !eating && drinking  (C)  (has_cs2030 || has_cs2113) && has_cs2040c",
            "title": "Problem 10.1"
        },
        {
            "location": "/10-assert/index.html#problem-102",
            "text": "In the code below, replace  ???  with the appropriate assertion.  What will be printed?   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20 long   score   =   4 ;  if   ( something )   { \n   score   =   10 ;  }   else   { \n   score   =   0 ;  }  // { ??? }  if   ( score   ==   4 )   { \n     score   =   1 ;  }   else   { \n     score   +=   10 ;  }  // { ??? }  if   ( score   >=   10 )   { \n     cs1010_println_string ( \"ok\" );  }   else   { \n     cs1010_println_string ( \"failed\" );  }",
            "title": "Problem 10.2"
        },
        {
            "location": "/11-loop/index.html",
            "text": "Unit 11: Loops\n\n\nIn \nUnit 8\n, you were introduced to writing code that follows one of two possible execution paths using the \nif\n-\nelse\n statements, using a logical expression to decide which path to take.\n\n\nSometimes, we want to execute one of the branches repeatedly (or interatively), over-and-over again, until a certain logical condition is met.  You have seen this construct in the \nmax\nmax\n and \nsum\nsum\n example, where we repeatedly go through the numbers in the list until \ni == k\ni == k\n.\n\n\nWriting Loops\n\n\nTo write a loop, we need to think about the following four questions:\n\n\n\n\nwhat do we want to do repeatedly?\n\n\nwhat do we need to set up before repeating the above?\n\n\nwhat changes from one repetition to another?  \n\n\nhow to decide if we should stop repeating (or conversely, to continue repeating?)\n\n\n\n\nThere is a fifth question that is as important as the above but is harder to answer (and not necessary for writing simple loops), so we will leave it to \nUnit 12\n.\n\n\nLet's revisit the example of \nmax\n.  Here is the answer to the questions:\n\n\n\n\n\n\nWhat do we want to do repeatedly?  We want to compare the element \nl_i\nl_i\n to \nm\nm\n, and update \nm\nm\n to \nl_i\nl_i\n if \nl_i > m\nl_i > m\n.\n\n\n\n\n\n\nWhat do we need to set up before repeating the above?  We need to have some initial value of \nm\nm\n and \ni\ni\n.  We set it up as \nm = l_0\nm = l_0\n and \ni = 1\ni = 1\n.\n\n\n\n\n\n\nWhat would be different each time we repeat the above?  Every time we repeat, \ni\ni\n will be different.  To be more precise, \ni\ni\n is one more than before.\n\n\n\n\n\n\nHow to decide if we should continue repeating the above?  We stop when there is no more element to compare, i.e., \ni\ni\n equals \nk\nk\n.  In other words, we continue if \ni < k\ni < k\n.\n\n\n\n\n\n\n\n\nLet's consider another example.  We have seen how to compute factorial recursively.  Let's try to compute factorial using a loop.\n\n\nRecall that \nn! = n \\times n-1 \\times n-2 .. 2 \\times 1\nn! = n \\times n-1 \\times n-2 .. 2 \\times 1\n.  Given \nn\nn\n, how do we find \nn!\nn!\n using a loop?  \n\n\nThe idea to solve this with a loop is to start with the value \nn\nn\n, and repeatedly multiply another value \ni\ni\n, starting with \ni = n - 1\ni = n - 1\n, then \ni = n - 2\ni = n - 2\n, etc, until \ni = 2\ni = 2\n.  We do not need to multiple with \ni = 1\ni = 1\n since it does not change the value.\n\n\nLike any other problem, we need to consider what are the variables we need to maintain.  In this case, we should maintain the partial product of the factorial and a variable \ni\ni\n that corresponds to value to multiple into the partial product.\n\n\n\n\nWhat do we want to do repeatedly?  Multiply \ni\ni\n into the partial product. \n\n\nWhat do we need to set up before repeating the above?  We set up the partial product to be \nn\nn\n and \ni\ni\n to be \nn - 1\nn - 1\n.\n\n\nWhat changes from one repetition to another?  \ni\ni\n would decrease by one every time we repeat the above.\n\n\nHow to decide if we should stop repeating (or conversely, to continue repeating?)  We can stop when we have multiplied \ni = 2\ni = 2\n to the partial product.\n\n\n\n\nWe can express the algorithm above using the following flowchart:\n\n\n\n\nA \nfor\n loop\n\n\nC provides three ways to write a loop.  Let's start with a simple one first, a \nfor\n loop.  \n\n\nThe \nfor\n loop in C has the following syntax:\n\n\n1\n2\n3\nfor\n \n(\n<\ninitialize\n>\n;\n \n<\ncondition\n>\n;\n \n<\nupdate\n>\n)\n \n{\n\n    \n<\nbody\n>\n\n\n}\n\n\n\n\n\n\n\nThere are four components, corresponding to the four questions above:\n\n\n\n\nThe \ninitialize\n statement set up the loop (i.e., \"What do we need to set up before repeating the above?\").  \n\n\nThe \ncondition\n statement indicates when we should stop repeating.  If it evaluates to \ntrue\n, it will cause the loop to continue, otherwise, the loop stops.\n\n\nThe \nupdate\n statement is executed after every loop.  (i.e., \"What changes from one repetition to another?\")\n\n\nThe \nbody\n statement is the action that we want to do repeatedly.  \n\n\n\n\n\n\nFor the \ninitialize\n and \nupdate\n statement, even though C allows us to include multiple initializations and multiple updates, it makes the code harder to read and understand.  C also allows us to have empty statements for \ninitialize\n, \ncondition\n and/or \nupdate\n.  As such, in CS1010, we will stick to performing one initialization and one update only.\n\n\nFor example, in the setup phase for factorial, we should initialize the partial product to \nn\nn\n and \ni\ni\n to \nn - 1\nn - 1\n, that's two assignments.  We commonly choose the index which we increment or decrement as we loop, hence we choose to initialize \ni\ni\n in the \ninitialize\n statement of the \nfor\n loop, and leave the initialization of \nproduct\n to a separate assignment before the \nfor\n loop.\n\n\nHere is the example for computing the factorial:\n\n\n1\n2\n3\n4\n5\n6\n7\n8\nlong\n \nfactorial\n(\nlong\n \nn\n)\n \n\n{\n\n    \nlong\n \nproduct\n \n=\n \nn\n;\n\n    \nfor\n \n(\nlong\n \ni\n \n=\n \nn\n-\n1\n;\n \ni\n \n>=\n \n2\n;\n \ni\n \n-=\n \n1\n)\n \n{\n\n        \nproduct\n \n*=\n \ni\n;\n\n    \n}\n\n    \nreturn\n \nproduct\n;\n\n\n}\n\n\n\n\n\n\n\nThe code above is almost correct.  We only need to handle the special case when \nn\n is 0.  The complete code for the function is thus:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\nlong\n \nfactorial\n(\nlong\n \nn\n)\n \n\n{\n\n    \nif\n \n(\nn\n \n==\n \n0\n)\n \n{\n\n        \nreturn\n \n1\n;\n\n    \n}\n\n    \nlong\n \nproduct\n \n=\n \nn\n;\n\n    \nfor\n \n(\nlong\n \ni\n \n=\n \nn\n-\n1\n;\n \ni\n \n>=\n \n2\n;\n \ni\n \n-=\n \n1\n)\n \n{\n\n        \nproduct\n \n*=\n \ni\n;\n\n    \n}\n\n    \nreturn\n \nproduct\n;\n\n\n}\n\n\n\n\n\n\n\nwhile\n Loop\n\n\nThe second way to write a loop in C is to use a \nwhile\n loop.  The while loop looks like this:\n\n\n1\n2\n3\nwhile\n \n(\n<\ncondition\n>\n)\n \n{\n\n    \n<\nbody\n>\n\n\n}\n\n\n\n\n\n\n\nThe statements in \n<body>\n will be executed if \n<condition>\n is true.  \n\n\nNote that the syntax of the \nwhile\n loop above does not contain the \n<initialize>\n and the \n<update>\n component.  When we write the loop, however, we still need to think about them, and add them to the appropriate place in the code, as follows:\n\n\n1\n2\n3\n4\n5\n<\ninitialize\n>\n\n\nwhile\n \n(\n<\ncondition\n>\n)\n \n{\n\n    \n<\nbody\n>\n\n    \n<\nupdate\n>\n\n\n}\n\n\n\n\n\n\n\nThe corresponding flowchart for \nwhile\n is:\n\n\n\n\nCompare the flowchart for \nwhile\n to the flowchart for \nfor\n earlier.  You will see that they are exactly the same!\n\n\nHere is the \nwhile\n version of the \nfactorial\n function:\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\nlong\n \nfactorial\n(\nlong\n \nn\n)\n \n\n{\n\n    \nif\n \n(\nn\n \n==\n \n0\n)\n \n{\n\n        \nreturn\n \n1\n;\n\n    \n}\n\n    \nlong\n \nproduct\n \n=\n \nn\n;\n\n    \nlong\n \ni\n \n=\n \nn\n \n-\n \n1\n;\n\n    \nwhile\n \n(\ni\n \n>=\n \n2\n)\n \n{\n\n        \nproduct\n \n*=\n \ni\n;\n\n        \ni\n \n-=\n \n1\n;\n\n    \n}\n\n    \nreturn\n \nproduct\n;\n\n\n}\n\n\n\n\n\n\nIn the \nwhile\n loop, however, we can be more flexible in terms of what we want to do inside the loop.  Technically, there is no difference between \nupdate\n and \nbody\n since they are just a bunch of C statements.  We can interleave \n<update>\n and \n<body>\n or execute \n<update>\n first before \n<body>\n, depending on the algorithm.  With \nfor\n loop, there is no such flexibility as \n<update>\n has to be executed after \n<body>\n.\n\n\nA \ndo-while\n loop\n\n\nThe third way we can write a loop in C is to use a \ndo-while\n loop.  The \ndo-while\n loop is very similar to \nwhile\n, except that the body of the loop is guaranteed to be executed at least once.  \n\n\n1\n2\n3\n4\n5\n<\ninitialize\n>\n\n\ndo\n \n{\n\n    \n<\nbody\n>\n\n    \n<\nupdate\n>\n\n\n}\n \nwhile\n \n(\n<\ncondition\n>\n);\n\n\n\n\n\n\n\n\n\nSimilar to the \nwhile\n loop, the \n<body>\n component and \n<update>\n component in the loop does not have to be in order.\n\n\n\n\nThere is a semicolor \n;\n after a \ndo-while\n loop.\n\n\n\n\nLet's look at an example where using \ndo-while\n is more natural than \nwhile\n.  \n\n\nExample: Guess a Number\n\n\nLet's write a program that plays a game with the user.  The program generates a random integer number between 1 and 100.  The user will guess what that number is.  If the user guesses correctly, the program congratulates the user.  Otherwise, the program tells the user whether the guess is too high or too low, and let the user guess again.  This process repeats until the guess is correct.\n\n\nNote that, here, the user needs to guess at least once, so it is more natural to use a \ndo\n-\nwhile\n loop than a \nwhile\n or a \nfor\n.\n\n\nAnswering The Four Questions\n\n\n\n\nWhat do we want to do repeatedly?  We want to read the guess from the user and respond back to the user.\n\n\nWhat do we need to set up before repeating the above?  We need to generate a random integer between 1 and 100.\n\n\nWhat changes from one repetition to another?  The guess \nmay\n be different.\n\n\nHow to decide if we should continue repeating the above?  We stop when the guess is correct.\n\n\n\n\nDesigning the Flowchart\n\n\nHere is the flowchart of the steps described above.  \n\n\n\n\nThe C code\n\n\nThe entire corresponding program is shown below:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n#include\n \n<stdlib.h>\n\n\n#include\n \n<sys/times.h>\n\n\n#include\n \n\"cs1010.h\"\n\n\n\nint\n \nmain\n()\n\n\n{\n\n  \n// Initialize the random number generator\n\n  \nsrandom\n(\ntimes\n(\n0\n));\n\n\n  \n// Generate a random number between 1 and 100\n\n  \nlong\n \nanswer\n \n=\n \n(\nrandom\n()\n \n%\n \n100\n)\n \n+\n \n1\n;\n\n\n  \nlong\n \nguess\n;\n\n  \ndo\n \n{\n\n    \n// Read guess and feedback to user\n\n    \nguess\n \n=\n \ncs1010_read_long\n();\n\n    \nif\n \n(\nguess\n \n>\n \nanswer\n)\n \n{\n\n      \ncs1010_println_string\n(\n\"too high\"\n);\n\n    \n}\n \nelse\n \nif\n \n(\nguess\n \n<\n \nanswer\n)\n \n{\n\n      \ncs1010_println_string\n(\n\"too low\"\n);\n\n    \n}\n\n  \n}\n \nwhile\n \n(\nguess\n \n!=\n \nanswer\n);\n\n\n  \n// { guess == answer }\n\n  \ncs1010_println_string\n(\n\"you got it.  congrats!\"\n);\n\n\n}\n\n\n\n\n\n\n\nI will not go into details of what \nsrandom(times(0))\n means.  You can look it up on your own if you are interested (InfoSec students may want to do this as generating good random number is key to keeping systems secure).  \n\n\nThe function \nrandom()\n generates a random integer, which we limit to 0 to 99 by modulo-ing it with 100.  We then add 1 to it to a number between 1 and 100, inclusive.\n\n\nProblem Set\n\n\nProblem 11.1\n\n\nHere is another version of the \nfactorial\n function:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\nlong\n \nfactorial\n(\nlong\n \nn\n)\n \n\n{\n\n    \nlong\n \ni\n \n=\n \nn\n \n-\n \n1\n;\n\n    \nlong\n \nproduct\n;\n\n    \nfor\n \n(\nproduct\n \n=\n \nn\n;\n \ni\n \n>=\n \n2\n;\n \nproduct\n \n*=\n \ni\n)\n\n    \n{\n\n        \ni\n \n-=\n \n1\n;\n\n    \n}\n\n    \nreturn\n \nproduct\n;\n\n\n}\n\n\n\n\n\n\n\nDoes this code runs correctly?  If it is incorrect, explain what is wrong and suggest a fix.  (Hint: translate this to the corresponding flowchart and trace through the flowchart).\n\n\nProblem 11.2\n\n\n(a) Rewrite the \"Guess A Number\" program so that it shows the user the number of guesses made before the correct guess is entered.\n\n\n(b) Rewrite the \"Guess A Number\" program with a \nwhile\n loop.\n\n\n(C) Extend the \"Guess A Number\" program so that it plays the game for five rounds with the user, and at the end, shows the user the average number of guesses over five rounds.  (Hint: you should put the loop that reads the guess and prints feedback to the user into another function.)\n\n\n(d) What is the optimal strategy to play the game?\n\n\nProblem 11.3\n\n\nTrace the following algorithms:\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nlong\n \nmystery\n(\nlong\n \nn\n,\n \nlong\n \nk\n)\n \n{\n\n    \nlong\n \nsomething\n \n=\n \nn\n;\n\n    \nlong\n \ncount\n \n=\n \n-\n1\n;\n\n    \nwhile\n \n(\nsomething\n \n>=\n \n1\n)\n \n{\n\n        \nsomething\n \n/=\n \nk\n;\n \n        \ncount\n \n+=\n \n1\n;\n\n    \n}\n\n    \nreturn\n \ncount\n;\n\n\n}\n\n\n\n\n\n\n\n(a) \nWhat is the return value when \n\n\n\n\nn\n is 8 and \nk\n is 2?  \n\n\nn\n is 81 and \nk\n is 3?  \n\n\nn\n is 100 and \nk\n is 5?\n\n\n\n\nAnswer these questions by reading the code first, instead of trying it out on a computer (you can verify later).\n\n\n(b)\nWhat is the mathematical expression that our mystery function here is trying to compute based on the examples above?\n\n\n(C)\nGive a pair of inputs that would cause the function to return the wrong answer.\n\n\n(d) \nGive a pair of inputs that would cause the function to loop forever.",
            "title": "11. Loops"
        },
        {
            "location": "/11-loop/index.html#unit-11-loops",
            "text": "In  Unit 8 , you were introduced to writing code that follows one of two possible execution paths using the  if - else  statements, using a logical expression to decide which path to take.  Sometimes, we want to execute one of the branches repeatedly (or interatively), over-and-over again, until a certain logical condition is met.  You have seen this construct in the  max max  and  sum sum  example, where we repeatedly go through the numbers in the list until  i == k i == k .",
            "title": "Unit 11: Loops"
        },
        {
            "location": "/11-loop/index.html#writing-loops",
            "text": "To write a loop, we need to think about the following four questions:   what do we want to do repeatedly?  what do we need to set up before repeating the above?  what changes from one repetition to another?    how to decide if we should stop repeating (or conversely, to continue repeating?)   There is a fifth question that is as important as the above but is harder to answer (and not necessary for writing simple loops), so we will leave it to  Unit 12 .  Let's revisit the example of  max .  Here is the answer to the questions:    What do we want to do repeatedly?  We want to compare the element  l_i l_i  to  m m , and update  m m  to  l_i l_i  if  l_i > m l_i > m .    What do we need to set up before repeating the above?  We need to have some initial value of  m m  and  i i .  We set it up as  m = l_0 m = l_0  and  i = 1 i = 1 .    What would be different each time we repeat the above?  Every time we repeat,  i i  will be different.  To be more precise,  i i  is one more than before.    How to decide if we should continue repeating the above?  We stop when there is no more element to compare, i.e.,  i i  equals  k k .  In other words, we continue if  i < k i < k .     Let's consider another example.  We have seen how to compute factorial recursively.  Let's try to compute factorial using a loop.  Recall that  n! = n \\times n-1 \\times n-2 .. 2 \\times 1 n! = n \\times n-1 \\times n-2 .. 2 \\times 1 .  Given  n n , how do we find  n! n!  using a loop?    The idea to solve this with a loop is to start with the value  n n , and repeatedly multiply another value  i i , starting with  i = n - 1 i = n - 1 , then  i = n - 2 i = n - 2 , etc, until  i = 2 i = 2 .  We do not need to multiple with  i = 1 i = 1  since it does not change the value.  Like any other problem, we need to consider what are the variables we need to maintain.  In this case, we should maintain the partial product of the factorial and a variable  i i  that corresponds to value to multiple into the partial product.   What do we want to do repeatedly?  Multiply  i i  into the partial product.   What do we need to set up before repeating the above?  We set up the partial product to be  n n  and  i i  to be  n - 1 n - 1 .  What changes from one repetition to another?   i i  would decrease by one every time we repeat the above.  How to decide if we should stop repeating (or conversely, to continue repeating?)  We can stop when we have multiplied  i = 2 i = 2  to the partial product.   We can express the algorithm above using the following flowchart:",
            "title": "Writing Loops"
        },
        {
            "location": "/11-loop/index.html#a-for-loop",
            "text": "C provides three ways to write a loop.  Let's start with a simple one first, a  for  loop.    The  for  loop in C has the following syntax:  1\n2\n3 for   ( < initialize > ;   < condition > ;   < update > )   { \n     < body >  }    There are four components, corresponding to the four questions above:   The  initialize  statement set up the loop (i.e., \"What do we need to set up before repeating the above?\").    The  condition  statement indicates when we should stop repeating.  If it evaluates to  true , it will cause the loop to continue, otherwise, the loop stops.  The  update  statement is executed after every loop.  (i.e., \"What changes from one repetition to another?\")  The  body  statement is the action that we want to do repeatedly.      For the  initialize  and  update  statement, even though C allows us to include multiple initializations and multiple updates, it makes the code harder to read and understand.  C also allows us to have empty statements for  initialize ,  condition  and/or  update .  As such, in CS1010, we will stick to performing one initialization and one update only.  For example, in the setup phase for factorial, we should initialize the partial product to  n n  and  i i  to  n - 1 n - 1 , that's two assignments.  We commonly choose the index which we increment or decrement as we loop, hence we choose to initialize  i i  in the  initialize  statement of the  for  loop, and leave the initialization of  product  to a separate assignment before the  for  loop.  Here is the example for computing the factorial:  1\n2\n3\n4\n5\n6\n7\n8 long   factorial ( long   n )   { \n     long   product   =   n ; \n     for   ( long   i   =   n - 1 ;   i   >=   2 ;   i   -=   1 )   { \n         product   *=   i ; \n     } \n     return   product ;  }    The code above is almost correct.  We only need to handle the special case when  n  is 0.  The complete code for the function is thus:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11 long   factorial ( long   n )   { \n     if   ( n   ==   0 )   { \n         return   1 ; \n     } \n     long   product   =   n ; \n     for   ( long   i   =   n - 1 ;   i   >=   2 ;   i   -=   1 )   { \n         product   *=   i ; \n     } \n     return   product ;  }",
            "title": "A for loop"
        },
        {
            "location": "/11-loop/index.html#while-loop",
            "text": "The second way to write a loop in C is to use a  while  loop.  The while loop looks like this:  1\n2\n3 while   ( < condition > )   { \n     < body >  }    The statements in  <body>  will be executed if  <condition>  is true.    Note that the syntax of the  while  loop above does not contain the  <initialize>  and the  <update>  component.  When we write the loop, however, we still need to think about them, and add them to the appropriate place in the code, as follows:  1\n2\n3\n4\n5 < initialize >  while   ( < condition > )   { \n     < body > \n     < update >  }    The corresponding flowchart for  while  is:   Compare the flowchart for  while  to the flowchart for  for  earlier.  You will see that they are exactly the same!  Here is the  while  version of the  factorial  function:  1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13 long   factorial ( long   n )   { \n     if   ( n   ==   0 )   { \n         return   1 ; \n     } \n     long   product   =   n ; \n     long   i   =   n   -   1 ; \n     while   ( i   >=   2 )   { \n         product   *=   i ; \n         i   -=   1 ; \n     } \n     return   product ;  }    In the  while  loop, however, we can be more flexible in terms of what we want to do inside the loop.  Technically, there is no difference between  update  and  body  since they are just a bunch of C statements.  We can interleave  <update>  and  <body>  or execute  <update>  first before  <body> , depending on the algorithm.  With  for  loop, there is no such flexibility as  <update>  has to be executed after  <body> .",
            "title": "while Loop"
        },
        {
            "location": "/11-loop/index.html#a-do-while-loop",
            "text": "The third way we can write a loop in C is to use a  do-while  loop.  The  do-while  loop is very similar to  while , except that the body of the loop is guaranteed to be executed at least once.    1\n2\n3\n4\n5 < initialize >  do   { \n     < body > \n     < update >  }   while   ( < condition > );     Similar to the  while  loop, the  <body>  component and  <update>  component in the loop does not have to be in order.   There is a semicolor  ;  after a  do-while  loop.   Let's look at an example where using  do-while  is more natural than  while .",
            "title": "A do-while loop"
        },
        {
            "location": "/11-loop/index.html#example-guess-a-number",
            "text": "Let's write a program that plays a game with the user.  The program generates a random integer number between 1 and 100.  The user will guess what that number is.  If the user guesses correctly, the program congratulates the user.  Otherwise, the program tells the user whether the guess is too high or too low, and let the user guess again.  This process repeats until the guess is correct.  Note that, here, the user needs to guess at least once, so it is more natural to use a  do - while  loop than a  while  or a  for .",
            "title": "Example: Guess a Number"
        },
        {
            "location": "/11-loop/index.html#answering-the-four-questions",
            "text": "What do we want to do repeatedly?  We want to read the guess from the user and respond back to the user.  What do we need to set up before repeating the above?  We need to generate a random integer between 1 and 100.  What changes from one repetition to another?  The guess  may  be different.  How to decide if we should continue repeating the above?  We stop when the guess is correct.",
            "title": "Answering The Four Questions"
        },
        {
            "location": "/11-loop/index.html#designing-the-flowchart",
            "text": "Here is the flowchart of the steps described above.",
            "title": "Designing the Flowchart"
        },
        {
            "location": "/11-loop/index.html#the-c-code",
            "text": "The entire corresponding program is shown below:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26 #include   <stdlib.h>  #include   <sys/times.h>  #include   \"cs1010.h\"  int   main ()  { \n   // Initialize the random number generator \n   srandom ( times ( 0 )); \n\n   // Generate a random number between 1 and 100 \n   long   answer   =   ( random ()   %   100 )   +   1 ; \n\n   long   guess ; \n   do   { \n     // Read guess and feedback to user \n     guess   =   cs1010_read_long (); \n     if   ( guess   >   answer )   { \n       cs1010_println_string ( \"too high\" ); \n     }   else   if   ( guess   <   answer )   { \n       cs1010_println_string ( \"too low\" ); \n     } \n   }   while   ( guess   !=   answer ); \n\n   // { guess == answer } \n   cs1010_println_string ( \"you got it.  congrats!\" );  }    I will not go into details of what  srandom(times(0))  means.  You can look it up on your own if you are interested (InfoSec students may want to do this as generating good random number is key to keeping systems secure).    The function  random()  generates a random integer, which we limit to 0 to 99 by modulo-ing it with 100.  We then add 1 to it to a number between 1 and 100, inclusive.",
            "title": "The C code"
        },
        {
            "location": "/11-loop/index.html#problem-set",
            "text": "",
            "title": "Problem Set"
        },
        {
            "location": "/11-loop/index.html#problem-111",
            "text": "Here is another version of the  factorial  function:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10 long   factorial ( long   n )   { \n     long   i   =   n   -   1 ; \n     long   product ; \n     for   ( product   =   n ;   i   >=   2 ;   product   *=   i ) \n     { \n         i   -=   1 ; \n     } \n     return   product ;  }    Does this code runs correctly?  If it is incorrect, explain what is wrong and suggest a fix.  (Hint: translate this to the corresponding flowchart and trace through the flowchart).",
            "title": "Problem 11.1"
        },
        {
            "location": "/11-loop/index.html#problem-112",
            "text": "(a) Rewrite the \"Guess A Number\" program so that it shows the user the number of guesses made before the correct guess is entered.  (b) Rewrite the \"Guess A Number\" program with a  while  loop.  (C) Extend the \"Guess A Number\" program so that it plays the game for five rounds with the user, and at the end, shows the user the average number of guesses over five rounds.  (Hint: you should put the loop that reads the guess and prints feedback to the user into another function.)  (d) What is the optimal strategy to play the game?",
            "title": "Problem 11.2"
        },
        {
            "location": "/11-loop/index.html#problem-113",
            "text": "Trace the following algorithms:  1\n2\n3\n4\n5\n6\n7\n8\n9 long   mystery ( long   n ,   long   k )   { \n     long   something   =   n ; \n     long   count   =   - 1 ; \n     while   ( something   >=   1 )   { \n         something   /=   k ;  \n         count   +=   1 ; \n     } \n     return   count ;  }    (a) \nWhat is the return value when    n  is 8 and  k  is 2?    n  is 81 and  k  is 3?    n  is 100 and  k  is 5?   Answer these questions by reading the code first, instead of trying it out on a computer (you can verify later).  (b)\nWhat is the mathematical expression that our mystery function here is trying to compute based on the examples above?  (C)\nGive a pair of inputs that would cause the function to return the wrong answer.  (d) \nGive a pair of inputs that would cause the function to loop forever.",
            "title": "Problem 11.3"
        },
        {
            "location": "/12-invariant/index.html",
            "text": "Unit 12: Reasoning About Loops\n\n\nUsing Assertions\n\n\nWe have seen how we can use assertions to reason about the state of our program at different points of execution for conditional \nif\n-\nelse\n statements.  We can apply the same techniques to loops.  Take the simple program below:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\nlong\n \ncount\n(\nlong\n \nn\n)\n \n{\n\n  \nlong\n \ny\n \n=\n \n0\n;\n\n  \nlong\n \nx\n \n=\n \nn\n;\n\n  \nwhile\n \n(\nx\n \n>\n \n0\n)\n \n{\n\n    \n// line A\n\n    \nx\n \n-=\n \n1\n;\n\n    \n// line B\n\n    \nif\n \n(\nx\n \n%\n \n5\n \n==\n \n0\n)\n \n{\n\n      \n// line C\n\n      \ny\n \n+=\n \n1\n;\n\n    \n}\n\n  \n}\n\n  \n// line D\n\n  \nreturn\n \ny\n;\n\n\n}\n\n\n\n\n\n\n\nBefore we continue, study this program and try to analyze what the function is counting and returning.\n\n\nTo do this more systematically, we can use assertions.  Let's ask ourselves: what can be said about the variables \nx\n and \ny\n at Lines A, B, C?  Let starts with \nx\n first.\n\n\n\n\nLine A is the first line after entering the loop, so we can reason that to enter the loop (the first time or subsequent times), \nx > 0\n and \nx <= n\n (since we initialize the \nx\n to \nn\n).\n\n\nAt Line B, we decrease \nx\n by 1, so \nx >= 0 && x < n\n must be true.\n\n\nAt Line C, \nx % 5 == 0\n (i.e., x is multiple of 5) must \nalso\n be true (since it is in the true block of the \nif\n block).\n\n\nAt Line D, we already exit from the loop, and the only way to exit here is that \nx > 0\n is false.  So we know that \nx <= 0\n.\n\n\n\n\nLet's annotate the code with the assertions:\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\nlong\n \ncount\n(\nlong\n \nn\n)\n \n{\n\n  \nlong\n \ny\n \n=\n \n0\n;\n\n  \nlong\n \nx\n \n=\n \nn\n;\n\n  \nwhile\n \n(\nx\n \n>\n \n0\n)\n \n{\n\n    \n// { x > 0 && x <= n }\n\n    \nx\n \n-=\n \n1\n;\n\n    \n// { (x >= 0) && (x < n) }\n\n    \nif\n \n(\nx\n \n%\n \n5\n \n==\n \n0\n)\n \n{\n\n      \n// { (x >= 0) && (x < n) && x is multiple of 5 }\n\n      \ny\n \n+=\n \n1\n;\n\n    \n}\n\n  \n}\n\n  \n// { x <= 0 }\n\n  \nreturn\n \ny\n;\n\n\n}\n\n\n\n\n\n\nWhat can be said about \ny\n?  It should be clear now that we increment \ny\n for every value between 0 and \nn-1\n (inclusive) that is a multiple of 5, based on the condition on Line C.  That is, it is counting the number of multiple of 5s between 0 and n-1.\n\n\nLoop Invariant\n\n\nIn the last unit, we say that there are actually five questions that we have to think about when designing loops.  The fifth question is: what is the \nloop invariant\n?  A loop invariant is an assertion that is true before the loop, during the loop, and after the loop.  Thinking about the loop invariant is helpful to convince ourselves that a loop is correct, or to identify bugs in a loop.\n\n\nLet's see an example of a loop invariant.  Consider the example of calculating a factorial using a loop as before.  To make the invariant simpler, let's tweak the loop slightly and start looping from \ni\n equals 1 up to \nn\n.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\nlong\n \nfactorial\n(\nlong\n \nn\n)\n \n\n{\n\n  \nif\n \n(\nn\n \n==\n \n0\n)\n \n{\n\n      \nreturn\n \n1\n;\n\n  \n}\n\n  \nlong\n \nproduct\n \n=\n \n1\n;\n\n  \nlong\n \ni\n \n=\n \n1\n;\n\n  \n// Line A\n\n  \nwhile\n \n(\ni\n \n<\n \nn\n)\n \n{\n\n    \ni\n \n+=\n \n1\n;\n\n    \nproduct\n \n*=\n \ni\n;\n\n    \n// Line B\n\n  \n}\n\n  \n// Line C\n\n  \nreturn\n \nproduct\n;\n\n\n}\n\n\n\n\n\n\n\nThe loop invariant for each line A, B, and C are the same: \n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\nlong\n \nfactorial\n(\nlong\n \nn\n)\n \n\n{\n\n  \nif\n \n(\nn\n \n==\n \n0\n)\n \n{\n\n      \nreturn\n \n1\n;\n\n  \n}\n\n  \nlong\n \nproduct\n \n=\n \n1\n;\n\n  \nlong\n \ni\n \n=\n \n1\n;\n\n  \n// A: { product == i! }\n\n  \nwhile\n \n(\ni\n \n<\n \nn\n)\n \n{\n\n    \ni\n \n+=\n \n1\n;\n\n    \nproduct\n \n*=\n \ni\n;\n\n    \n// B: { product == i! }\n\n  \n}\n\n  \n// C: { product == i! }\n\n  \nreturn\n \nproduct\n;\n\n\n}\n\n\n\n\n\n\n\nIn Line A, the assertion is obvious.  Let's look at Line B.  Since, at the beginning of the loop (before Line 10) we have \nproduct == i!\n, after Line 10, we have \nproduct == (i-1)!\n (since we have incremented \ni\n).  After Line 11, we have \nproduct == i * (i - 1)! == i!\n again.  The assertion remains true once we exit the loop.\n\n\nThe key here is that after we exit the loop, we can also assert that \ni == n\n, and so combining \nproduct == i! && i == n\n we have \nproduct == n!\n, which is what we want.\n\n\nProblem Set 12\n\n\nProblem 12.1\n\n\n1\n2\n3\n4\n5\n6\nlong\n \ni\n \n=\n \n10\n;\n\n\nlong\n \nj\n \n=\n \n0\n;\n\n\nwhile\n \n(\ni\n \n!=\n \n0\n)\n \n{\n\n    \ni\n \n-=\n \n1\n;\n\n    \nj\n \n+=\n \n1\n;\n\n\n}\n\n\n\n\n\n\n\n(a) Trace through the program.  What is the value of \nj\n when the loop exits?\n\n\n(b) Do you recognize any pattern on the relationship of \ni\n and \nj\n?\n\n\n(C) What is the loop invariant?",
            "title": "12. Reasoning About Loops"
        },
        {
            "location": "/12-invariant/index.html#unit-12-reasoning-about-loops",
            "text": "",
            "title": "Unit 12: Reasoning About Loops"
        },
        {
            "location": "/12-invariant/index.html#using-assertions",
            "text": "We have seen how we can use assertions to reason about the state of our program at different points of execution for conditional  if - else  statements.  We can apply the same techniques to loops.  Take the simple program below:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15 long   count ( long   n )   { \n   long   y   =   0 ; \n   long   x   =   n ; \n   while   ( x   >   0 )   { \n     // line A \n     x   -=   1 ; \n     // line B \n     if   ( x   %   5   ==   0 )   { \n       // line C \n       y   +=   1 ; \n     } \n   } \n   // line D \n   return   y ;  }    Before we continue, study this program and try to analyze what the function is counting and returning.  To do this more systematically, we can use assertions.  Let's ask ourselves: what can be said about the variables  x  and  y  at Lines A, B, C?  Let starts with  x  first.   Line A is the first line after entering the loop, so we can reason that to enter the loop (the first time or subsequent times),  x > 0  and  x <= n  (since we initialize the  x  to  n ).  At Line B, we decrease  x  by 1, so  x >= 0 && x < n  must be true.  At Line C,  x % 5 == 0  (i.e., x is multiple of 5) must  also  be true (since it is in the true block of the  if  block).  At Line D, we already exit from the loop, and the only way to exit here is that  x > 0  is false.  So we know that  x <= 0 .   Let's annotate the code with the assertions:  1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15 long   count ( long   n )   { \n   long   y   =   0 ; \n   long   x   =   n ; \n   while   ( x   >   0 )   { \n     // { x > 0 && x <= n } \n     x   -=   1 ; \n     // { (x >= 0) && (x < n) } \n     if   ( x   %   5   ==   0 )   { \n       // { (x >= 0) && (x < n) && x is multiple of 5 } \n       y   +=   1 ; \n     } \n   } \n   // { x <= 0 } \n   return   y ;  }    What can be said about  y ?  It should be clear now that we increment  y  for every value between 0 and  n-1  (inclusive) that is a multiple of 5, based on the condition on Line C.  That is, it is counting the number of multiple of 5s between 0 and n-1.",
            "title": "Using Assertions"
        },
        {
            "location": "/12-invariant/index.html#loop-invariant",
            "text": "In the last unit, we say that there are actually five questions that we have to think about when designing loops.  The fifth question is: what is the  loop invariant ?  A loop invariant is an assertion that is true before the loop, during the loop, and after the loop.  Thinking about the loop invariant is helpful to convince ourselves that a loop is correct, or to identify bugs in a loop.  Let's see an example of a loop invariant.  Consider the example of calculating a factorial using a loop as before.  To make the invariant simpler, let's tweak the loop slightly and start looping from  i  equals 1 up to  n .   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16 long   factorial ( long   n )   { \n   if   ( n   ==   0 )   { \n       return   1 ; \n   } \n   long   product   =   1 ; \n   long   i   =   1 ; \n   // Line A \n   while   ( i   <   n )   { \n     i   +=   1 ; \n     product   *=   i ; \n     // Line B \n   } \n   // Line C \n   return   product ;  }    The loop invariant for each line A, B, and C are the same:    1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16 long   factorial ( long   n )   { \n   if   ( n   ==   0 )   { \n       return   1 ; \n   } \n   long   product   =   1 ; \n   long   i   =   1 ; \n   // A: { product == i! } \n   while   ( i   <   n )   { \n     i   +=   1 ; \n     product   *=   i ; \n     // B: { product == i! } \n   } \n   // C: { product == i! } \n   return   product ;  }    In Line A, the assertion is obvious.  Let's look at Line B.  Since, at the beginning of the loop (before Line 10) we have  product == i! , after Line 10, we have  product == (i-1)!  (since we have incremented  i ).  After Line 11, we have  product == i * (i - 1)! == i!  again.  The assertion remains true once we exit the loop.  The key here is that after we exit the loop, we can also assert that  i == n , and so combining  product == i! && i == n  we have  product == n! , which is what we want.",
            "title": "Loop Invariant"
        },
        {
            "location": "/12-invariant/index.html#problem-set-12",
            "text": "",
            "title": "Problem Set 12"
        },
        {
            "location": "/12-invariant/index.html#problem-121",
            "text": "1\n2\n3\n4\n5\n6 long   i   =   10 ;  long   j   =   0 ;  while   ( i   !=   0 )   { \n     i   -=   1 ; \n     j   +=   1 ;  }    (a) Trace through the program.  What is the value of  j  when the loop exits?  (b) Do you recognize any pattern on the relationship of  i  and  j ?  (C) What is the loop invariant?",
            "title": "Problem 12.1"
        },
        {
            "location": "/13-call-stack/index.html",
            "text": "Unit 13: Call Stack\n\n\nIn this unit, we will delve deeper into how variables are stored in the memory and what happens when we call a function.\n\n\nStack Frame\n\n\nModern OS typically divide the memory into several regions.  The region that we are concerned with for now is called the \ncall stack\n.\n\nEvery function invocation causes the OS to allocate some memory on the call stack to store (among other things) the parameters passed into the function and the variables declared and used in the function.  The memory allocated to each function call is called a \nstack frame\n.  When a function returns, the stack frame is deallocated and freed up for other uses.\n\n\nLet's start with the following simple program as an example.\n\n\n1\n2\n3\n4\n5\nint\n \nmain\n()\n\n\n{\n\n  \nlong\n \nx\n \n=\n \n1\n;\n\n  \nlong\n \ny\n;\n\n\n}\n\n\n\n\n\n\n\nWhen the OS runs the program above, it invokes, or calls, the function \nmain\n.  A new stack frame is created for \nmain()\n.  There are two variables \nx\n and \ny\n declared in \nmain\n.  Recall from \nUnit 2\n that a variable is a location in the memory which holds a value.  Thus, the stack frame of \nmain\n will include these two variables.  We initialize \nx\n to 1 in the code above, so the value 1 will be placed in the memory location of \nx\n.  The variable \ny\n remains uninitialized, so it will contain whatever value that happens to be in the memory at that time.\n\n\n\n\nNow, let's consider the program\n1\n:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\nlong\n \nadd\n(\nlong\n \na\n,\n \nlong\n \nb\n)\n \n{\n\n  \nlong\n \nsum\n;\n\n  \nsum\n \n=\n \na\n \n+\n \nb\n;\n\n  \nreturn\n \nsum\n;\n\n\n}\n\n\n\nint\n \nmain\n()\n\n\n{\n\n  \nlong\n \nx\n \n=\n \n1\n;\n\n  \nlong\n \ny\n;\n\n  \ny\n \n=\n \nadd\n(\nx\n,\n \n10\n);\n\n\n}\n\n\n\n\n\n\n\nNow, the program invokes the function \nadd\n with two parameters, using \nx\n and 10 as arguments.  What the OS does when \nadd\n is called, is that it allocates another stack frame for \nadd\n.  We can visualize the stack frame for \nadd\n as being placed on top of the stack frame of \nmain\n.  The stack frame for \nadd\n includes two variables corresponding to the parameters \na\n, \nb\n, and the variable \nsum\n declared in the function \nadd\n.\n\n\nWhen the stack frame for \nadd\n is created, \nsum\n is uninitialized, but \na\n is initialized to whatever the value of \nx\n is when the function is invoked (1 in this example), and \nb\n is initialized to 10, since that is the argument passed into \nadd\n.\n\n\n\n\nAfter the stack frame for \nadd\n is set up, the code is executed.  The memory location for \nsum\n is then initialized to the sum of \na\n and \nb\n (11 in this example), and the return statement is executed.  \n\n\n\n\nWhen a function returns, the stack frame for \nsum\n is removed.  The variables \nsum\n, \na\n, \nb\n crumble into dust and no longer exist in the memory.  The value of the variable being returned (\nsum\n in this case) is then copied back to the stack frame of the \nmain\n (the \ncallee\n caller).  In this example, this value is copied into the memory location of \ny\n.\n\n\n\n\nWhat would happen if we change the value of \na\n within \nadd\n?\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\nlong\n \nadd\n(\nlong\n \na\n,\n \nlong\n \nb\n)\n \n{\n\n  \nsum\n \n=\n \na\n \n+\n \nb\n;\n\n  \na\n \n=\n \n42\n;\n  \n// change a\n\n  \nreturn\n \nsum\n;\n\n\n}\n\n\n\nint\n \nmain\n()\n\n\n{\n\n  \nlong\n \nx\n \n=\n \n1\n;\n\n  \nlong\n \ny\n;\n\n  \ny\n \n=\n \nadd\n(\nx\n,\n \n10\n);\n\n\n}\n\n\n\n\n\n\n\nIn this example, we change the value of \na\n in the call stack of \nadd\n to 42.  This has no effect on any variable in \nmain\n, since the changes apply only within the stack frame of \nadd\n.\n\n\nA common bug by beginners is to try to write a function this way:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\nvoid\n \nadd\n(\nlong\n \nsum\n,\n \nlong\n \na\n,\n \nlong\n \nb\n)\n \n{\n\n  \nsum\n \n=\n \na\n \n+\n \nb\n;\n\n\n}\n\n\n\nint\n \nmain\n()\n\n\n{\n\n  \nlong\n \nx\n \n=\n \n1\n;\n\n  \nlong\n \nsum\n;\n\n  \nadd\n(\nsum\n,\n \nx\n,\n \n10\n);\n\n\n}\n\n\n\n\n\n\n\nHere, there are actually two versions of \nsum\n, one in the stack frame of \nmain\n, the other in the stack frame of \nadd\n.  When we change \nsum\n in \nadd\n, we are changing a local copy which will eventually get deleted.  The assignment to \nsum\n in Line 2 has no effect on the variable \nsum\n on Line 8 of \nmain\n.\n\n\nThis explanation explains why a function is a black box, we can only pass in parameters and get a value in return.  Nothing else gets in and out.  There are no \"side effects\" -- whatever happen in the function, stays in the function and does not affect the caller (excepts if it reads or writes to the standard input/output).   Such a function is sometimes called a \"pure function\".\n\n\nAutomatic Variable\n\n\nBecause of the way the memory for the variables are automatically allocated and deallocated when a function is invoked and when the function returns, we call these variables \nautomatic variables\n.  \n\n\nThere are two other types of variables, \nglobal variable\n, which we have mentioned is a very very bad programming practice in Lecture 5 and is banned from CS1010, and \nstatic variable\n, which could be useful in rare occasion but we shouldn't concern ourselves with this type of variable in CS1010 for the moment.\n\n\nStack Size\n\n\nThe OS typically reserves a limited amount of memory for each program for the stack.  You can find out, on your system, what is the maximum allocated stack size with the command\n\n1\nulimit -s\n\n\n\n\n\nOn our CS1010 PE hosts, the limit is 8 MB.  \n\n\nProblem Set 13\n\n\nProblem 13.1\n\n\nTrace through what gets stored in the call stack when we run the following programs:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n#include\n \n<math.h>\n\n\n\nlong\n \nsquare\n(\nlong\n \nx\n)\n\n\n{\n\n  \nreturn\n \nx\n*\nx\n;\n\n\n}\n\n\n\ndouble\n \nhypotenuse_of\n(\nlong\n \nbase\n,\n \nlong\n \nheight\n)\n\n\n{\n\n  \nreturn\n \nsqrt\n(\nsquare\n(\nbase\n)\n \n+\n \nsquare\n(\nheight\n));\n\n\n}\n\n\n\nint\n \nmain\n()\n\n\n{\n\n  \nhypotenuse_of\n(\n3\n,\n \n4\n);\n\n\n}\n\n\n\n\n\n\n\nProblem 13.2\n\n\nTrace through what gets stored in the call stack when we run the following programs:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n#include\n \n\"cs1010.h\"\n\n\n\nlong\n \nfactorial\n(\nlong\n \nn\n)\n\n\n{\n\n  \nif\n \n(\nn\n \n==\n \n0\n)\n \n{\n\n    \nreturn\n \n1\n;\n\n  \n}\n\n  \nreturn\n \nfactorial\n(\nn\n-\n1\n)\n \n*\n \nn\n;\n\n\n}\n\n\n\nint\n \nmain\n()\n\n\n{\n\n  \nfactorial\n(\n3\n);\n\n\n}\n\n\n\n\n\n\n\nProblem 13.3\n\n\nWhat will be printed by the program below?\nTrace through what gets stored in the call stack when we run the following programs:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n#include\n \n\"cs1010.h\"\n\n\n\nvoid\n \nincr\n(\nlong\n \nx\n)\n \n{\n\n    \nx\n \n+=\n \n1\n;\n\n\n}\n\n\n\nint\n \nmain\n()\n\n\n{\n\n    \nlong\n \nx\n \n=\n \n10\n;\n\n    \nincr\n(\nx\n);\n\n    \nincr\n(\nx\n);\n\n    \ncs1010_print_long\n(\nx\n);\n\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe variable \nsum\n is not necessary and the function can be better written as a one-liner \nreturn a + b;\n.  But I introduce the additional variable \nsum\n here to make the example more meaningful in explaining about stack frame.\u00a0\n\u21a9",
            "title": "13. Call Stack"
        },
        {
            "location": "/13-call-stack/index.html#unit-13-call-stack",
            "text": "In this unit, we will delve deeper into how variables are stored in the memory and what happens when we call a function.",
            "title": "Unit 13: Call Stack"
        },
        {
            "location": "/13-call-stack/index.html#stack-frame",
            "text": "Modern OS typically divide the memory into several regions.  The region that we are concerned with for now is called the  call stack . \nEvery function invocation causes the OS to allocate some memory on the call stack to store (among other things) the parameters passed into the function and the variables declared and used in the function.  The memory allocated to each function call is called a  stack frame .  When a function returns, the stack frame is deallocated and freed up for other uses.  Let's start with the following simple program as an example.  1\n2\n3\n4\n5 int   main ()  { \n   long   x   =   1 ; \n   long   y ;  }    When the OS runs the program above, it invokes, or calls, the function  main .  A new stack frame is created for  main() .  There are two variables  x  and  y  declared in  main .  Recall from  Unit 2  that a variable is a location in the memory which holds a value.  Thus, the stack frame of  main  will include these two variables.  We initialize  x  to 1 in the code above, so the value 1 will be placed in the memory location of  x .  The variable  y  remains uninitialized, so it will contain whatever value that happens to be in the memory at that time.   Now, let's consider the program 1 :   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12 long   add ( long   a ,   long   b )   { \n   long   sum ; \n   sum   =   a   +   b ; \n   return   sum ;  }  int   main ()  { \n   long   x   =   1 ; \n   long   y ; \n   y   =   add ( x ,   10 );  }    Now, the program invokes the function  add  with two parameters, using  x  and 10 as arguments.  What the OS does when  add  is called, is that it allocates another stack frame for  add .  We can visualize the stack frame for  add  as being placed on top of the stack frame of  main .  The stack frame for  add  includes two variables corresponding to the parameters  a ,  b , and the variable  sum  declared in the function  add .  When the stack frame for  add  is created,  sum  is uninitialized, but  a  is initialized to whatever the value of  x  is when the function is invoked (1 in this example), and  b  is initialized to 10, since that is the argument passed into  add .   After the stack frame for  add  is set up, the code is executed.  The memory location for  sum  is then initialized to the sum of  a  and  b  (11 in this example), and the return statement is executed.     When a function returns, the stack frame for  sum  is removed.  The variables  sum ,  a ,  b  crumble into dust and no longer exist in the memory.  The value of the variable being returned ( sum  in this case) is then copied back to the stack frame of the  main  (the  callee  caller).  In this example, this value is copied into the memory location of  y .   What would happen if we change the value of  a  within  add ?   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12 long   add ( long   a ,   long   b )   { \n   sum   =   a   +   b ; \n   a   =   42 ;    // change a \n   return   sum ;  }  int   main ()  { \n   long   x   =   1 ; \n   long   y ; \n   y   =   add ( x ,   10 );  }    In this example, we change the value of  a  in the call stack of  add  to 42.  This has no effect on any variable in  main , since the changes apply only within the stack frame of  add .  A common bug by beginners is to try to write a function this way:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10 void   add ( long   sum ,   long   a ,   long   b )   { \n   sum   =   a   +   b ;  }  int   main ()  { \n   long   x   =   1 ; \n   long   sum ; \n   add ( sum ,   x ,   10 );  }    Here, there are actually two versions of  sum , one in the stack frame of  main , the other in the stack frame of  add .  When we change  sum  in  add , we are changing a local copy which will eventually get deleted.  The assignment to  sum  in Line 2 has no effect on the variable  sum  on Line 8 of  main .  This explanation explains why a function is a black box, we can only pass in parameters and get a value in return.  Nothing else gets in and out.  There are no \"side effects\" -- whatever happen in the function, stays in the function and does not affect the caller (excepts if it reads or writes to the standard input/output).   Such a function is sometimes called a \"pure function\".",
            "title": "Stack Frame"
        },
        {
            "location": "/13-call-stack/index.html#automatic-variable",
            "text": "Because of the way the memory for the variables are automatically allocated and deallocated when a function is invoked and when the function returns, we call these variables  automatic variables .    There are two other types of variables,  global variable , which we have mentioned is a very very bad programming practice in Lecture 5 and is banned from CS1010, and  static variable , which could be useful in rare occasion but we shouldn't concern ourselves with this type of variable in CS1010 for the moment.",
            "title": "Automatic Variable"
        },
        {
            "location": "/13-call-stack/index.html#stack-size",
            "text": "The OS typically reserves a limited amount of memory for each program for the stack.  You can find out, on your system, what is the maximum allocated stack size with the command 1 ulimit -s   On our CS1010 PE hosts, the limit is 8 MB.",
            "title": "Stack Size"
        },
        {
            "location": "/13-call-stack/index.html#problem-set-13",
            "text": "",
            "title": "Problem Set 13"
        },
        {
            "location": "/13-call-stack/index.html#problem-131",
            "text": "Trace through what gets stored in the call stack when we run the following programs:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16 #include   <math.h>  long   square ( long   x )  { \n   return   x * x ;  }  double   hypotenuse_of ( long   base ,   long   height )  { \n   return   sqrt ( square ( base )   +   square ( height ));  }  int   main ()  { \n   hypotenuse_of ( 3 ,   4 );  }",
            "title": "Problem 13.1"
        },
        {
            "location": "/13-call-stack/index.html#problem-132",
            "text": "Trace through what gets stored in the call stack when we run the following programs:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14 #include   \"cs1010.h\"  long   factorial ( long   n )  { \n   if   ( n   ==   0 )   { \n     return   1 ; \n   } \n   return   factorial ( n - 1 )   *   n ;  }  int   main ()  { \n   factorial ( 3 );  }",
            "title": "Problem 13.2"
        },
        {
            "location": "/13-call-stack/index.html#problem-133",
            "text": "What will be printed by the program below?\nTrace through what gets stored in the call stack when we run the following programs:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13 #include   \"cs1010.h\"  void   incr ( long   x )   { \n     x   +=   1 ;  }  int   main ()  { \n     long   x   =   10 ; \n     incr ( x ); \n     incr ( x ); \n     cs1010_print_long ( x );  }        The variable  sum  is not necessary and the function can be better written as a one-liner  return a + b; .  But I introduce the additional variable  sum  here to make the example more meaningful in explaining about stack frame.\u00a0 \u21a9",
            "title": "Problem 13.3"
        },
        {
            "location": "/14-pointers/index.html",
            "text": "Unit 14: Memory Addresses or Pointers\n\n\nEvery memory location has an address.  Unlike many higher level languages, such as Java, Python, and JavaScript, C allows us direct access to memory addresses.  This empowers programmers to do wonderful things that cannot be done in other languages.  But, it is also dangerous at the same time -- using it improperly can lead to bugs that are hard to track down and debug.\n\n\nThe Address-of Operator\n\n\nC has an operator called \"address-of\", denoted by \n&\n.  This operator, returns, well, the address of a variable.\n\n\nWe can type cast the address of a variable into \nlong\n and print it out to examine its value.  Consider this:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n#include\n \n\"cs1010.h\"\n\n\n\nvoid\n \nadd\n(\nlong\n \nsum\n,\n \nlong\n \na\n,\n \nlong\n \nb\n)\n \n{\n\n  \nsum\n \n=\n \na\n \n+\n \nb\n;\n\n  \ncs1010_println_long\n((\nlong\n)\n&\nsum\n);\n\n\n}\n\n\n\nint\n \nmain\n()\n\n\n{\n\n  \nlong\n \nx\n \n=\n \n1\n;\n\n  \nlong\n \nsum\n;\n\n  \nadd\n(\nsum\n,\n \nx\n,\n \n10\n);\n\n  \ncs1010_println_long\n((\nlong\n)\n&\nsum\n);\n\n\n}\n\n\n\n\n\n\n\nRunning the program above prints something like this:\n\n1\n2\n140723025685528\n140723025685552\n\n\n\n\n\nYour results will most likely be different, since the OS allocates different regions of the memory to this program every time it is run.  \n\n\n\n\nThe Deference Operator\n\n\nThe dereference operator is the reversed of address-of, and is denoted by \n*\n.  I call it \"location-of-address\".  We use this operator in two places:\n\n\n\n\nto declare an \"address\" variable, and\n\n\nto reference the location of an address.\n\n\n\n\nWe can declare a variable that is an address type.  We need to tell C the type of the variable this address is referencing.  For instance,\n\n\n1\ndouble\n \n*\naddr\n;\n\n\n\n\n\n\n\ndeclares a variable \naddr\n that is an address to a variable of type \ndouble\n.  The way to read this is that \n*addr\n, or location-of-address \naddr\n is of type \ndouble\n, so \naddr\n is an address of a location containing a \ndouble\n.\n\n\n\n\nCommon Bug\n\n\nIt is possible to write as\n\n1\ndouble\n*\n \naddr\n;\n\n\n\n\n\ntoo, but this is not recommended.  Suppose you want to declare two addresses, you might write,\n\n1\ndouble\n*\n \nfrom_addr\n,\n \nto_addr\n;\n\n\n\n\n\nthinking that both \nfrom_addr\n and \nto_addr\n are of type \ndouble*\n.  But, actually, C treats \nto_addr\n as a \ndouble\n, not an address of a \ndouble\n!  In any case, if you follow CS1010 style, you shouldn't be declaring two variables in one line.\n\n\n\n\nAnother name for a variable of type address is \npointer\n.  We can visualize a pointer as pointing to some location in the memory.\n\n\nChanging the Value via Pointer\n\n\nSuppose we declare a pointer to a \ndouble\n variable (or, for short, a \ndouble\n pointer):\n\n1\ndouble\n \n*\naddr\n;\n\n\n\n\n\n\nWe can use \n*addr\n just like a normal \ndouble\n variable:\n\n1\n*\naddr\n \n=\n \n1.0\n;\n\n\n\n\n\n\nThe line above means that, \nwe take the address stored in addr, go to the location at that address, and store the value 1.0 in the location.\n\n\nThis is where things can get dangerous.  You could be changing the value in a memory location that you do not mean to.  If you are lucky, your program crashes with a \nsegmentation fault\n error\n1\n. We say that your program has segfault.  If you are unlucky, your program runs normally but produces incorrect output occasionally.\n\n\n\n\nSo, \nalways make sure that your pointer is pointing to the right location before dereferencing and writing to the location.\n\n\nIn the code above, if we write:\n\n1\n2\ndouble\n \n*\naddr\n;\n\n\n*\naddr\n \n=\n \n1.0\n;\n\n\n\n\n\n\nback-to-back, the program will almost certainly segfault, because the pointer variable \naddr\n is not initialized, so it is pointing to the location of whatever address happens to be in the memory at that time.\n\n\nWe should point addr to a value location first, like this:\n\n1\n2\n3\n4\ndouble\n \nc\n;\n\n\ndouble\n \n*\naddr\n;\n\n\naddr\n \n=\n \n&\nc\n;\n\n\n*\naddr\n \n=\n \n1.0\n;\n\n\n\n\n\n\n\n\nOf course, the above could be simply written as:\n\n1\ndouble\n \nc\n \n=\n \n1.0\n;\n\n\n\n\n\n\nI am just doing it the complicated way (which you should avoid unless you have good reasons to do so) to demonstrate the concept of pointers.\n\n\nBasic Rules About Using Pointers\n\n\n\n\n\n\nWhen we use pointers, it must point to the variable of the same type as that declared by the pointer.  For instance,\n\n\n1\n2\n3\n4\n5\ndouble\n \npi\n \n=\n \n3.1415926\n;\n\n\nlong\n \nradius\n \n=\n \n5\n;\n\n\ndouble\n \n*\naddr\n;\n\n\naddr\n \n=\n \n&\npi\n;\n \n// ok\n\n\naddr\n \n=\n \n&\nradius\n;\n \n// not ok\n\n\n\n\n\n\n\nLine 4 above would lead to a compilation error since we try to point a \ndouble\n pointer to a \nlong\n.  \n\n\n\n\n\n\nWe cannot change the address of a variable.  For instance\n\n\n1\n2\n3\nlong\n \nx\n \n=\n \n1\n;\n\n\nlong\n \ny\n \n=\n \n2\n;\n\n\n&\nx\n \n=\n \n&\ny\n;\n\n\n\n\n\n\n\nWe try to set the address of \nx\n to be the address of \ny\n.  This is not allowed since allocation of variables in the memory is determined by the OS, a process we have no control over.\n\n\n\n\n\n\nWe can perform arithmetic operations on pointers, but not in the way you expect.\n\n\nSuppose we have a pointer:\n\n1\n2\n3\n4\n5\nlong\n \nx\n;\n\n\nlong\n \n*\nptr\n;\n\n\nx\n \n=\n \n1\n;\n\n\nptr\n \n=\n \n&\nx\n;\n\n\nptr\n \n+=\n \n1\n;\n\n\n\n\n\n\nSuppose that \nx\n is stored in memory address 1000, after Line 4, \nptr\n would have the value of 1000.\nAfter the line \nptr += 1\n, using normal arithmetic operation, we would think that \nptr\n will have the value of 1001.  However, the semantic for arithmetic operation is different for pointers.  The \n+\n operation for \nptr\n causes the \nptr\n variable to move forward by the size of the variable pointed to by the pointer.  In this example, \nptr\n points to \nlong\n, assuming that \nlong\n is 8 bytes, after \nptr += 1\n, \nptr\n will have the value of 1008.\n\n\nWe can only do addition and subtraction for pointers.\n\n\n\n\n\n\nPointer of Pointer (of Pointer..)\n\n\nA pointer variable is also stored in the memory, so it itself has an address too.\n\n\n1\n2\n3\nlong\n \nx\n;\n\n\nlong\n \n*\nptr\n;\n\n\nptr\n \n=\n \n&\nx\n;\n\n\n\n\n\n\n\nFor instance, in the above, \nptr\n would have a memory location allocated on the stack too, and so it itself has an address, and we can have a variable \nptrptr\n referring to the address of \nptr\n.  What would the type of this variable be?  Since \nptr\n is an address of \nlong\n, \nptrptr\n is an address of an address of \nlong\n, and can be written as:\n\n\n1\n2\n3\n4\n5\nlong\n \nx\n;\n\n\nlong\n \n*\nptr\n;\n\n\nlong\n \n**\nptrptr\n;\n\n\nptr\n \n=\n \n&\nx\n;\n\n\nptrptr\n \n=\n \n&\nptr\n;\n\n\n\n\n\n\n\nThis deference can go on since \nptrptr\n is also a variable and have been allocated in some memory location on the stack.  We rarely need to dereference more than twice in practice, but if the situation arises, such multiple layers of dereferencing is possible.\n\n\nThe \nNULL\n Pointer\n\n\nNULL\n is a special value that is used to indicate that a pointer is pointing to nothing.  In C, \nNULL\n is actually 0 (i.e., pointing to memory location 0).\n\n\nWe use \nNULL\n to indicate that the pointer is invalid, typically to mean that we have not initialized the pointer or to flag an error condition.\n\n\n\n\nBillion Dollar Mistakes\n\n\nSir Tony Hoare (the same one whom we met when we talked about \nAssertion\n) also invented the null pointer.  He called it his billion-dollar mistake.  Quoting from him: \"I couldn't resist the temptation to put in a null reference, simply because it was so easy to implement. This has led to innumerable errors, vulnerabilities, and system crashes, which have probably caused a billion dollars of pain and damage in the last forty years.\"  As you start to use pointers in CS1010, you will see why it is a pain.\n\n\n\n\nProblem Set 14\n\n\nProblem 14.1\n\n\nSketch the content of the memory while tracing through the following code.  What would be printed?\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\nlong\n \n*\nptr1\n;\n\n\nlong\n \n*\nptr2\n;\n\n\nlong\n \nx\n;\n\n\nlong\n \ny\n;\n\n\n\nptr1\n \n=\n \n&\nx\n;\n\n\nptr2\n \n=\n \n&\ny\n;\n\n\n\n*\nptr1\n \n=\n \n123\n;\n\n\n*\nptr2\n \n=\n \n-\n1\n;\n\n\n\ncs1010_println_long\n(\nx\n);\n\n\ncs1010_println_long\n(\ny\n);\n\n\ncs1010_println_long\n(\n*\nptr1\n);\n\n\ncs1010_println_long\n(\n*\nptr2\n);\n\n\n\n// ptr1 = ptr1; // <-- typo in the first version of this question \ud83d\ude05\n\n\nptr1\n \n=\n \nptr2\n;\n\n\n*\nptr1\n \n=\n \n1946\n;\n\n\n\ncs1010_println_long\n(\nx\n);\n\n\ncs1010_println_long\n(\ny\n);\n\n\ncs1010_println_long\n(\n*\nptr1\n);\n\n\ncs1010_println_long\n(\n*\nptr2\n);\n\n\n\ny\n \n=\n \n10\n;\n\n\n\ncs1010_println_long\n(\nx\n);\n\n\ncs1010_println_long\n(\ny\n);\n\n\ncs1010_println_long\n(\n*\nptr1\n);\n\n\ncs1010_println_long\n(\n*\nptr2\n);\n\n\n\n\n\n\n\nProblem 14.2\n\n\nWhat is wrong with both programs below?\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\ndouble\n \n*\naddr_of\n(\ndouble\n \nx\n)\n\n\n{\n\n  \nreturn\n \n&\nx\n;\n\n\n}\n\n\n\nint\n \nmain\n()\n\n\n{\n\n  \ndouble\n \nc\n \n=\n \n0.0\n;\n\n  \ndouble\n \n*\nptr\n;\n\n\n  \nptr\n \n=\n \naddr_of\n(\nc\n);\n\n  \n*\nptr\n \n=\n \n10\n;\n\n\n}\n\n\n\n\n\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\ndouble\n \n*\ntriple_of\n(\ndouble\n \nx\n)\n\n\n{\n\n  \ndouble\n \ntriple\n \n=\n \n3\n \n*\n \nx\n;\n\n  \nreturn\n \n&\ntriple\n;\n\n\n}\n\n\n\nint\n \nmain\n()\n\n\n{\n\n  \ndouble\n \n*\nptr\n;\n\n\n  \nptr\n \n=\n \ntriple_of\n(\n10\n);\n\n  \ncs1010_println_double\n(\n*\nptr\n);\n\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nI leave it to the later OS classes CG2271 / CS2106 to explain the term \"segmentation\" and \"fault\".  Interested students can always google and \nread on Wikipedia\n.\u00a0\n\u21a9",
            "title": "14. Pointers"
        },
        {
            "location": "/14-pointers/index.html#unit-14-memory-addresses-or-pointers",
            "text": "Every memory location has an address.  Unlike many higher level languages, such as Java, Python, and JavaScript, C allows us direct access to memory addresses.  This empowers programmers to do wonderful things that cannot be done in other languages.  But, it is also dangerous at the same time -- using it improperly can lead to bugs that are hard to track down and debug.",
            "title": "Unit 14: Memory Addresses or Pointers"
        },
        {
            "location": "/14-pointers/index.html#the-address-of-operator",
            "text": "C has an operator called \"address-of\", denoted by  & .  This operator, returns, well, the address of a variable.  We can type cast the address of a variable into  long  and print it out to examine its value.  Consider this:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14 #include   \"cs1010.h\"  void   add ( long   sum ,   long   a ,   long   b )   { \n   sum   =   a   +   b ; \n   cs1010_println_long (( long ) & sum );  }  int   main ()  { \n   long   x   =   1 ; \n   long   sum ; \n   add ( sum ,   x ,   10 ); \n   cs1010_println_long (( long ) & sum );  }    Running the program above prints something like this: 1\n2 140723025685528\n140723025685552   Your results will most likely be different, since the OS allocates different regions of the memory to this program every time it is run.",
            "title": "The Address-of Operator"
        },
        {
            "location": "/14-pointers/index.html#the-deference-operator",
            "text": "The dereference operator is the reversed of address-of, and is denoted by  * .  I call it \"location-of-address\".  We use this operator in two places:   to declare an \"address\" variable, and  to reference the location of an address.   We can declare a variable that is an address type.  We need to tell C the type of the variable this address is referencing.  For instance,  1 double   * addr ;    declares a variable  addr  that is an address to a variable of type  double .  The way to read this is that  *addr , or location-of-address  addr  is of type  double , so  addr  is an address of a location containing a  double .   Common Bug  It is possible to write as 1 double *   addr ;   \ntoo, but this is not recommended.  Suppose you want to declare two addresses, you might write, 1 double *   from_addr ,   to_addr ;   \nthinking that both  from_addr  and  to_addr  are of type  double* .  But, actually, C treats  to_addr  as a  double , not an address of a  double !  In any case, if you follow CS1010 style, you shouldn't be declaring two variables in one line.   Another name for a variable of type address is  pointer .  We can visualize a pointer as pointing to some location in the memory.",
            "title": "The Deference Operator"
        },
        {
            "location": "/14-pointers/index.html#changing-the-value-via-pointer",
            "text": "Suppose we declare a pointer to a  double  variable (or, for short, a  double  pointer): 1 double   * addr ;    We can use  *addr  just like a normal  double  variable: 1 * addr   =   1.0 ;    The line above means that,  we take the address stored in addr, go to the location at that address, and store the value 1.0 in the location.  This is where things can get dangerous.  You could be changing the value in a memory location that you do not mean to.  If you are lucky, your program crashes with a  segmentation fault  error 1 . We say that your program has segfault.  If you are unlucky, your program runs normally but produces incorrect output occasionally.   So,  always make sure that your pointer is pointing to the right location before dereferencing and writing to the location.  In the code above, if we write: 1\n2 double   * addr ;  * addr   =   1.0 ;    back-to-back, the program will almost certainly segfault, because the pointer variable  addr  is not initialized, so it is pointing to the location of whatever address happens to be in the memory at that time.  We should point addr to a value location first, like this: 1\n2\n3\n4 double   c ;  double   * addr ;  addr   =   & c ;  * addr   =   1.0 ;     Of course, the above could be simply written as: 1 double   c   =   1.0 ;    I am just doing it the complicated way (which you should avoid unless you have good reasons to do so) to demonstrate the concept of pointers.",
            "title": "Changing the Value via Pointer"
        },
        {
            "location": "/14-pointers/index.html#basic-rules-about-using-pointers",
            "text": "When we use pointers, it must point to the variable of the same type as that declared by the pointer.  For instance,  1\n2\n3\n4\n5 double   pi   =   3.1415926 ;  long   radius   =   5 ;  double   * addr ;  addr   =   & pi ;   // ok  addr   =   & radius ;   // not ok    Line 4 above would lead to a compilation error since we try to point a  double  pointer to a  long .      We cannot change the address of a variable.  For instance  1\n2\n3 long   x   =   1 ;  long   y   =   2 ;  & x   =   & y ;    We try to set the address of  x  to be the address of  y .  This is not allowed since allocation of variables in the memory is determined by the OS, a process we have no control over.    We can perform arithmetic operations on pointers, but not in the way you expect.  Suppose we have a pointer: 1\n2\n3\n4\n5 long   x ;  long   * ptr ;  x   =   1 ;  ptr   =   & x ;  ptr   +=   1 ;    Suppose that  x  is stored in memory address 1000, after Line 4,  ptr  would have the value of 1000.\nAfter the line  ptr += 1 , using normal arithmetic operation, we would think that  ptr  will have the value of 1001.  However, the semantic for arithmetic operation is different for pointers.  The  +  operation for  ptr  causes the  ptr  variable to move forward by the size of the variable pointed to by the pointer.  In this example,  ptr  points to  long , assuming that  long  is 8 bytes, after  ptr += 1 ,  ptr  will have the value of 1008.  We can only do addition and subtraction for pointers.",
            "title": "Basic Rules About Using Pointers"
        },
        {
            "location": "/14-pointers/index.html#pointer-of-pointer-of-pointer",
            "text": "A pointer variable is also stored in the memory, so it itself has an address too.  1\n2\n3 long   x ;  long   * ptr ;  ptr   =   & x ;    For instance, in the above,  ptr  would have a memory location allocated on the stack too, and so it itself has an address, and we can have a variable  ptrptr  referring to the address of  ptr .  What would the type of this variable be?  Since  ptr  is an address of  long ,  ptrptr  is an address of an address of  long , and can be written as:  1\n2\n3\n4\n5 long   x ;  long   * ptr ;  long   ** ptrptr ;  ptr   =   & x ;  ptrptr   =   & ptr ;    This deference can go on since  ptrptr  is also a variable and have been allocated in some memory location on the stack.  We rarely need to dereference more than twice in practice, but if the situation arises, such multiple layers of dereferencing is possible.",
            "title": "Pointer of Pointer (of Pointer..)"
        },
        {
            "location": "/14-pointers/index.html#the-null-pointer",
            "text": "NULL  is a special value that is used to indicate that a pointer is pointing to nothing.  In C,  NULL  is actually 0 (i.e., pointing to memory location 0).  We use  NULL  to indicate that the pointer is invalid, typically to mean that we have not initialized the pointer or to flag an error condition.   Billion Dollar Mistakes  Sir Tony Hoare (the same one whom we met when we talked about  Assertion ) also invented the null pointer.  He called it his billion-dollar mistake.  Quoting from him: \"I couldn't resist the temptation to put in a null reference, simply because it was so easy to implement. This has led to innumerable errors, vulnerabilities, and system crashes, which have probably caused a billion dollars of pain and damage in the last forty years.\"  As you start to use pointers in CS1010, you will see why it is a pain.",
            "title": "The NULL Pointer"
        },
        {
            "location": "/14-pointers/index.html#problem-set-14",
            "text": "",
            "title": "Problem Set 14"
        },
        {
            "location": "/14-pointers/index.html#problem-141",
            "text": "Sketch the content of the memory while tracing through the following code.  What would be printed?   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31 long   * ptr1 ;  long   * ptr2 ;  long   x ;  long   y ;  ptr1   =   & x ;  ptr2   =   & y ;  * ptr1   =   123 ;  * ptr2   =   - 1 ;  cs1010_println_long ( x );  cs1010_println_long ( y );  cs1010_println_long ( * ptr1 );  cs1010_println_long ( * ptr2 );  // ptr1 = ptr1; // <-- typo in the first version of this question \ud83d\ude05  ptr1   =   ptr2 ;  * ptr1   =   1946 ;  cs1010_println_long ( x );  cs1010_println_long ( y );  cs1010_println_long ( * ptr1 );  cs1010_println_long ( * ptr2 );  y   =   10 ;  cs1010_println_long ( x );  cs1010_println_long ( y );  cs1010_println_long ( * ptr1 );  cs1010_println_long ( * ptr2 );",
            "title": "Problem 14.1"
        },
        {
            "location": "/14-pointers/index.html#problem-142",
            "text": "What is wrong with both programs below?   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13 double   * addr_of ( double   x )  { \n   return   & x ;  }  int   main ()  { \n   double   c   =   0.0 ; \n   double   * ptr ; \n\n   ptr   =   addr_of ( c ); \n   * ptr   =   10 ;  }     1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13 double   * triple_of ( double   x )  { \n   double   triple   =   3   *   x ; \n   return   & triple ;  }  int   main ()  { \n   double   * ptr ; \n\n   ptr   =   triple_of ( 10 ); \n   cs1010_println_double ( * ptr );  }        I leave it to the later OS classes CG2271 / CS2106 to explain the term \"segmentation\" and \"fault\".  Interested students can always google and  read on Wikipedia .\u00a0 \u21a9",
            "title": "Problem 14.2"
        },
        {
            "location": "/15-array/index.html",
            "text": "Unit 15: Array\n\n\nWe now look at the first of the two compound data types in C --  arrays.  \n\n\nA variable can be declared to be of an array, in which case it can hold one or more values.  An array variable can only store values of the \nsame\n type \nT\nT\n.  We say that the array variable is an array of \nT\nT\n.  For instance, we can declare a variable \nmarks\n to be an array of \nlong\n, in which case, \nmarks\n can hold one or more \nlong\n values.  \n\n\nArray Declaration\n\n\nThe declaration syntax for an array in C takes the following form:\n\n\n1\nlong\n \nmarks\n[\n10\n];\n\n\n\n\n\n\n\nWe use the square bracket \n[\n and \n]\n to indicate that the variable \nmarks\n is an array.  The number \n10\n indicates that \nmarks\n holds 10 \nlong\n values.\n\n\nOnce declared, the variables in the array are uninitialized and will contain whatever value happened to be in the memory at that time.\n\n\nAccessing the Array Elements\n\n\nWe can access the array elements using the index of the element, starting from 0.  For instance, to initialize the marks for the first three students to 1, 2, 4, respectively, we can write:\n\n\n1\n2\n3\n4\nlong\n \nmarks\n[\n10\n];\n\n\nmarks\n[\n0\n]\n \n=\n \n1\n;\n\n\nmarks\n[\n1\n]\n \n=\n \n2\n;\n\n\nmarks\n[\n2\n]\n \n=\n \n4\n;\n\n\n\n\n\n\n\nArray Initialization\n\n\nInitializing a large array using the method above could be tedious.  Alternatively, we can initialize an array using a list of values when we declare the array.  \n\n\n1\nlong\n \nmarks\n[\n10\n]\n \n=\n \n{\n1\n,\n \n2\n,\n \n3\n,\n \n1\n,\n \n5\n,\n \n10\n,\n \n10\n,\n \n4\n,\n \n5\n,\n \n3\n,\n \n};\n\n\n\n\n\n\n\nIf we do not specify a value during initialization, it will be set to 0 by default.  \n\n\n1\n2\nlong\n \nmarks\n[\n10\n]\n \n=\n \n{\n1\n,\n \n2\n,\n \n3\n,\n \n1\n,\n \n5\n,\n \n10\n,\n \n10\n,\n \n4\n,\n \n};\n\n\n// marks[8] and marks[9] are both initialized to 0\n\n\n\n\n\n\n\nNote that, after the declaration, we can no longer using this technique to reinitialized or initialize the array.\n\n\n1\n2\nlong\n \nmarks\n[\n10\n];\n\n\nmarks\n \n=\n \n{\n1\n,\n \n2\n,\n \n3\n,\n \n1\n,\n \n5\n,\n \n10\n,\n \n10\n,\n \n4\n,\n \n5\n,\n \n3\n,\n \n};\n  \n// error\n\n\n\n\n\n\n\nExample 1: Array As Lookup Table\n\n\nOne way the array is useful is that it can be used as a lookup table.\n\n\nConsider the following function \ndays()\n, which, given a month, return the number of days from the 1\nst\n of January until the 1\nst\n of the month.  So \ndays(1)\n returns 0, \ndays(2)\n returns 31 (since January has 31 days), \ndays(3)\n returns 31 + 28 = 59 (assuming non-leap year), etc.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\nlong\n \ndays\n(\nlong\n \nmonth\n)\n\n\n{\n\n  \nlong\n \ndays_since\n \n=\n \n0\n;\n\n  \nif\n \n(\nmonth\n \n==\n \n2\n)\n \n{\n\n    \ndays_since\n \n=\n \n31\n;\n\n  \n}\n \nelse\n \nif\n \n(\nmonth\n \n==\n \n3\n)\n \n{\n\n    \ndays_since\n \n=\n \n31\n \n+\n \n28\n;\n\n  \n}\n \nelse\n \nif\n \n(\nmonth\n \n==\n \n4\n)\n \n{\n\n    \ndays_since\n \n=\n \n31\n \n+\n \n28\n \n+\n \n31\n;\n\n  \n}\n \nelse\n \nif\n \n(\nmonth\n \n==\n \n5\n)\n \n{\n\n    \ndays_since\n \n=\n \n31\n \n+\n \n28\n \n+\n \n31\n \n+\n \n30\n;\n\n  \n}\n \nelse\n \nif\n \n(\nmonth\n \n==\n \n6\n)\n \n{\n\n    \ndays_since\n \n=\n \n31\n \n+\n \n28\n \n+\n \n31\n \n+\n \n30\n \n+\n \n31\n;\n\n  \n}\n \nelse\n \nif\n \n(\nmonth\n \n==\n \n7\n)\n \n{\n\n    \ndays_since\n \n=\n \n31\n \n+\n \n28\n \n+\n \n31\n \n+\n \n30\n \n+\n \n31\n \n+\n \n30\n;\n\n  \n}\n \nelse\n \nif\n \n(\nmonth\n \n==\n \n8\n)\n \n{\n\n    \ndays_since\n \n=\n \n31\n \n+\n \n28\n \n+\n \n31\n \n+\n \n30\n \n+\n \n31\n \n+\n \n30\n \n+\n \n31\n;\n\n  \n}\n \nelse\n \nif\n \n(\nmonth\n \n==\n \n9\n)\n \n{\n\n    \ndays_since\n \n=\n \n31\n \n+\n \n28\n \n+\n \n31\n \n+\n \n30\n \n+\n \n31\n \n+\n \n30\n \n+\n \n31\n \n+\n \n31\n;\n\n  \n}\n \nelse\n \nif\n \n(\nmonth\n \n==\n \n10\n)\n \n{\n\n    \ndays_since\n \n=\n \n31\n \n+\n \n28\n \n+\n \n31\n \n+\n \n30\n \n+\n \n31\n \n+\n \n30\n \n+\n \n31\n \n+\n \n31\n \n+\n \n30\n;\n\n  \n}\n \nelse\n \nif\n \n(\nmonth\n \n==\n \n11\n)\n \n{\n\n    \ndays_since\n \n=\n \n31\n \n+\n \n28\n \n+\n \n31\n \n+\n \n30\n \n+\n \n31\n \n+\n \n30\n \n+\n \n31\n \n+\n \n31\n \n+\n \n30\n \n+\n \n31\n;\n\n  \n}\n \nelse\n \nif\n \n(\nmonth\n \n==\n \n12\n)\n \n{\n\n    \ndays_since\n \n=\n \n31\n \n+\n \n28\n \n+\n \n31\n \n+\n \n30\n \n+\n \n31\n \n+\n \n30\n \n+\n \n31\n \n+\n \n31\n \n+\n \n30\n \n+\n \n31\n \n+\n \n30\n;\n\n  \n}\n\n  \nreturn\n \ndays_since\n;\n\n\n}\n\n\n\n\n\n\n\nThe code is ugly and bug-prone.  Consider an alternative solution using an array.\n\n\n1\nlong\n \ndays_in_month\n[\n12\n]\n \n=\n \n{\n31\n,\n \n28\n,\n \n31\n,\n \n30\n,\n \n31\n,\n \n30\n,\n \n31\n,\n \n31\n,\n \n30\n,\n \n31\n,\n \n30\n,\n \n31\n};\n\n\n\n\n\n\n\nThe array above is initialized with the number of days in a month.  \ndays_in_month[0]\n stores the number of days in January, \ndays_in_month[1]\n stores the number of days in February, etc.\n\n\nThe code above can then be written as:\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nlong\n \ndays\n(\nlong\n \nmonth\n)\n\n\n{\n\n  \nlong\n \ndays_in_month\n[\n12\n]\n \n=\n \n{\n31\n,\n \n28\n,\n \n31\n,\n \n30\n,\n \n31\n,\n \n30\n,\n \n31\n,\n \n31\n,\n \n30\n,\n \n31\n,\n \n30\n,\n \n31\n};\n\n  \nlong\n \ndays_since\n \n=\n \n0\n;\n\n  \nfor\n \n(\nlong\n \ni\n \n=\n \n0\n;\n \ni\n \n<\n \nmonth\n \n-\n \n1\n;\n \ni\n \n+=\n \n1\n)\n \n{\n\n    \ndays_since\n \n+=\n \ndays_in_month\n[\ni\n];\n\n  \n}\n\n  \nreturn\n \ndays_since\n;\n\n\n}\n\n\n\n\n\n\n\nExample 2: Array As List\n\n\nWe can now revisit the flowchart for \nmax\nmax\n and write the corresponding code.  The code would look like this:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\nlong\n \nmax\n(\nlong\n \nlist\n[],\n \nlong\n \nlength\n)\n\n\n{\n\n  \nlong\n \nmax_so_far\n \n=\n \nlist\n[\n0\n];\n\n  \nfor\n \n(\nlong\n \ni\n \n=\n \n1\n;\n \ni\n \n!=\n \nlength\n;\n \ni\n \n+=\n \n1\n)\n \n{\n\n    \nif\n \n(\nlist\n[\ni\n]\n \n>\n \nmax_so_far\n)\n \n{\n\n      \nmax_so_far\n \n=\n \nlist\n[\ni\n];\n\n    \n}\n\n  \n}\n\n  \nreturn\n \nmax_so_far\n;\n\n\n}\n\n\n\n\n\n\n\nPlease see the \nAppendix\n for the complete code\n\n\nNote that, in the type of the array passed into the function above, we only need to use \n[]\n without specifying the length.  It is also almost always necessary to pass in the number of elements in the array together with the array so that we know how many elements are there to process.  To understand why, we have to understand something called \narray decay\n.\n\n\nArray and Pointers\n\n\nThe relationship between array and pointer can be confusing to beginners.  Some might even think that arrays are pointers due to the way they are passed around and used.  But \narrays are not pointers\n.  The relationship between the two, boils down to a very simple rule, as follows.\n\n\nIn C, the name of the variable of an array is treated differently from a non-array variable.  If we declare an array\n\n\n1\ntype\n \nname\n[\nnum_of_elems\n];\n\n\n\n\n\n\n\nthen any reference to \nname\n is a synonym to \n&name[0]\n whenever we need the value of the array.  In other words, \nname\n is the pointer to the first element in the array.  This is known as the \"array decay\" operation.\n\n\nThere are several implications of this.\n\n\nFirst, it is not possible to compare two arrays or assign one array to another.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\nlong\n \na\n[\n2\n]\n \n=\n \n{\n0\n,\n \n1\n};\n\n\nlong\n \nb\n[\n2\n]\n \n=\n \n{\n0\n,\n \n1\n};\n\n\n\nif\n \n(\na\n \n==\n \nb\n)\n \n{\n  \n// always false\n\n  \n:\n\n\n}\n\n\n\nb\n \n=\n \na\n;\n \n// not possible\n\n\n\n\n\n\n\nLine 4 above is equivalent to comparing \n&a[0]\n to \n&b[0]\n, due to array decay, and therefore is always false (since the array elements do not have the same memory address).\n\n\nLine 8 above is equivalent to assigning \n&a[0]\n to \n&b[0]\n, as we seen in (Unit 14)[14-pointers.md], we cannot change the memory address of a variable since this is determined by the OS.\n\n\nSecond, the expression \nname[i]\n is actually the same as \n*(name + i)\n.  Although we should always write \nname[i]\n as it is easier to understand, internally, this translates to accessing the value stored at the i-th location after the first element of the array.  (Revisit \nUnit 14\n if you are unfamiliar with pointer arithmetic).\n\n\nThird, when we pass an array into a function, we are only passing in the address of the first element.\n\n\nConsider the example below:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\nlong\n \nmax\n(\nlong\n \nlist\n[],\n \nlong\n \nlength\n)\n\n\n{\n\n  \nlong\n \nmax_so_far\n \n=\n \nlist\n[\n0\n];\n\n  \nfor\n \n(\nlong\n \ni\n \n=\n \n1\n;\n \ni\n \n!=\n \nlength\n;\n \ni\n \n+=\n \n1\n)\n \n{\n\n    \nif\n \n(\nlist\n[\ni\n]\n \n>\n \nmax_so_far\n)\n \n{\n\n      \nmax_so_far\n \n=\n \nlist\n[\ni\n];\n\n    \n}\n\n  \n}\n\n  \nreturn\n \nmax_so_far\n;\n\n\n}\n\n\n\nint\n \nmain\n()\n\n\n{\n\n  \nlong\n \na\n[\n10\n]\n \n=\n \n{\n1\n,\n \n2\n,\n \n3\n,\n \n4\n,\n \n1\n,\n \n9\n,\n \n10\n,\n \n44\n,\n \n-\n1\n,\n \n-\n5\n};\n\n  \ncs1010_println_long\n(\nmax\n(\na\n,\n \n10\n));\n\n\n}\n\n\n\n\n\n\n\nOn Line 14, we pass \na\n into the function \nmax\n.  Due to array decay, we are not passing in the whole array, but only the \n&a[0]\n.  Inside \nmax\n, we no longer have access to the whole array, but only the address of the first element.  Luckily, due to pointer arithmetic and equivalence of \nlist[i]\n to \n*(list + i)\n, we can still access the elements of the array.  \n\n\nDue to this, the size of \nlist\n in the function parameter does not matter, and we need to pass in the size of the array \nlength\n to \nmax\n so that inside \nmax\n we know the size of the array that we are dealing with.\n\n\nArray decay also means that, when passing in an array as an argument to a function, we can very well write it as:\n\n\n1\n2\n3\n4\nlong\n \nmax\n(\nlong\n \n*\nlist\n,\n \nlong\n \nlength\n)\n\n\n{\n\n    \n:\n\n\n}\n\n\n\n\n\n\n\nFor readability, however, we should convey to the reader of the code that \nlist\n is an array and not just a pointer to \nlong\n, thus we should still use the \n[]\n notation.\n\n\nAnother implication of array decay when passing an array into a function, is that it is possible to write programs that behave incorrectly, without any compiler error or warning.  Consider the following:\n\n\n1\n2\n3\n4\n5\nint\n \nmain\n()\n\n\n{\n\n  \nlong\n \na\n \n=\n \n0\n;\n\n  \nprintf\n(\n\"%ld\n\\n\n\"\n,\n \nmax\n(\n&\na\n,\n \n10\n));\n\n\n}\n\n\n\n\n\n\n\nThe compiler \nclang\n would happily compile this and generate an executable.  When executed, it would print a gibberish to the standard output.\n\n\nOther Facts About Arrays\n\n\nVariable Length Array\n\n\nWe can also declare an array where the number of elements depends on the value of a variable.\n\n\n1\n2\nlong\n \nnum_of_students\n \n=\n \n10\n;\n\n\nlong\n \nmarks\n[\nnum_of_students\n];\n\n\n\n\n\n\n\nSuch arrays, where the number of elements (or length) depends on the value of a variable, are sometimes called \nvariable-length array\n.  This is a misnomer since once the array is created, the length is fixed.  Changing the value of the variable \nnum_of_students\n above will not change the length of \nmarks\n.  \n\n\nSkipping Elements During Initialization\n\n\nIf we have a large array, and we want most of it to be initialized to 0, and only some non-zero, we can use \nelement designators\n, putting the index of the element we want to initialize to non-zero in square brackets \n[\n and \n]\n.\n\n\n1\nlong\n \nvector\n[\n100\n]\n \n=\n \n{\n1\n,\n \n[\n5\n]\n \n=\n \n2\n,\n \n3\n,\n \n[\n99\n]\n \n=\n \n-\n1\n};\n\n\n\n\n\n\n\nAn earlier version of this note has a typo, initializing \n[100] = -1\n instead.\n\n\nThis statement initializes \nvector[0]\n to 1, \nvector[5]\n to 2, \nvector[6]\n to 3, and \nvector[99]\n to -1.  The rest of the elements will be 0.\n\n\nSkipping the Size in Declaration\n\n\nIf you supply an initialization list, the number of elements already indicates the length to the compiler, so you can skip the length.\n\n\n1\nlong\n \nmarks\n[]\n \n=\n \n{\n1\n,\n \n3\n,\n \n2\n,\n \n8\n,\n \n5\n,}\n\n\n\n\n\n\n\nThis makes it easy to add or remove items from the array, without having to remember to keep the array length consistent.  \n\n\nDetermining the Number of Elements in the Array\n\n\nC provides a \nsizeof\n operator, which returns the number of bytes allocated to a type.  We can use \nsizeof long\n for instance, to determine the number of bytes allocated to \nlong\n on a platform.  We can also use \nsizeof\n on a variable instead of the type.  This becomes useful to determine, programmatically, the length of an array (esp if the array length is skipped in the array declaration).  We can calculate the number of elements in \nmarks\n with \n\n\n1\nlong\n \nnum_of_elem\n \n=\n \nsizeof\n \nmarks\n/\nsizeof\n \nmarks\n[\n0\n];\n\n\n\n\n\n\n\nNote that array decay does not apply for only two operators: the \nsizeof\n operator, and the address-of \n&\n operator.  So the expression above works as intended.\n\n\nDynamically Allocated Array\n\n\nIt is often not possible to determine the length of the array beforehand.  So, it is useful to be able to allocate an array with a length that is determined during runtime (not hard-coding the length of the array in the program).\n\n\nFor instance, if I want to keep a \nmarks\n array for a module, it is unclear how big I should set the array to.  How big is big enough?  While I can use a variable-length array for this purpose, it is not ideal -- if the system does not have enough memory to store the array, the program would simply crash with a segfault and there is no way to recover from this.\n\n\nFor this reason, it is useful to request memory from the OS which we will manage ourselves in our program.  Unlike memory space on the call stack which is managed entirely by the OS, there is another region of memory called the \nheap\n, which we can use.  We can request for memory from \nheap\n using the method \ncalloc()\n and return the memory back to the heap when we are done with \nfree()\n.  We will visit these in more details later, but this shallow understanding is enough for now.\n\n\nCS1010 I/O Library\n\n\nTo wrap up this unit, we will look at the CS1010 library functions that help us read in an array of either \nlong\n values or \ndouble\n values.  These functions, \ncs1010_read_long_array\n or \ncs1010_read_double_array\n takes in a parameter, which is the number of elements to read, and it returns a pointer to the array allocated within the function.\n\n\nFor instance, to read in an array of 100 integers, we can write:\n\n\n1\n2\n3\n4\n5\nlong\n \n*\nmarks\n;\n\n\nmarks\n \n=\n \ncs1010_read_long_array\n(\n100\n);\n\n\nfor\n \n(\nlong\n \ni\n \n=\n \n0\n;\n \ni\n \n<\n \n100\n;\n \ni\n \n+=\n \n1\n)\n \n{\n\n  \ncs1010_println_long\n(\nmarks\n[\ni\n]);\n\n\n}\n\n\n\n\n\n\n\nThis should be straightforward enough.  There are, however, two cases to consider.  What if the OS failed to allocate the memory for our array?  In this case, marks would be \nNULL\n and access \nmarks[i]\n would cause a segfault. Second, we must return the memory allocated to us back to the OS once we are done.  To let go of this memory, we call the function \nfree\n.  The complete code looks like this:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\nlong\n \n*\nmarks\n;\n\n\nmarks\n \n=\n \ncs1010_read_long_array\n(\n100\n);\n\n\nif\n \n(\nmarks\n \n==\n \nNULL\n)\n \n{\n\n  \n// signal error and return\n\n\n}\n\n\n\nfor\n \n(\nlong\n \ni\n \n=\n \n0\n;\n \ni\n \n<\n \n100\n;\n \ni\n \n+=\n \n1\n)\n \n{\n\n  \ncs1010_println_long\n(\nmarks\n[\ni\n]);\n\n\n}\n\n\n// do other things to marks \n\n  \n:\n\n\nfree\n(\nmarks\n);\n\n\n\n\n\n\n\nProblem Set 15\n\n\nProblem 15.1\n\n\nWrite the function \naverage\n that takes an array of \nk\nk\n integers and \nk\nk\n and returns the average of the \nk\nk\n values in the array.\n\n\nProblem 15.2\n\n\nExplain why the following would lead to senseless output:\n\n\n1\n2\n3\n4\n5\nint\n \nmain\n()\n\n\n{\n\n  \nlong\n \na\n \n=\n \n0\n;\n\n  \nprintf\n(\n\"%ld\n\\n\n\"\n,\n \nmax\n(\n&\na\n,\n \n10\n));\n\n\n}\n\n\n\n\n\n\n\nHow about the following? Would the output be correct?\n\n\n1\n2\n3\n4\n5\nint\n \nmain\n()\n\n\n{\n\n  \nlong\n \na\n \n=\n \n0\n;\n\n  \nprintf\n(\n\"%ld\n\\n\n\"\n,\n \nmax\n(\n&\na\n,\n \n1\n));\n \n// change 10 to 1\n\n\n}\n\n\n\n\n\n\n\nProblem 15.3\n\n\nExplain how the following code iterates through every element in the list, when called with an array of length \nlength\n as the first argument.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\nlong\n \nmax\n(\nlong\n \n*\nlist\n,\n \nlong\n \nlength\n)\n\n\n{\n\n  \nlong\n \nmax_so_far\n;\n\n  \nlong\n \n*\ncurr\n;\n\n\n  \nmax_so_far\n \n=\n \n*\nlist\n;\n\n  \ncurr\n \n=\n \nlist\n \n+\n \n1\n;\n\n  \nfor\n \n(\nlong\n \ni\n \n=\n \n1\n;\n \ni\n \n!=\n \nlength\n;\n \ni\n \n+=\n \n1\n)\n \n{\n\n    \nif\n \n(\n*\ncurr\n \n>\n \nmax_so_far\n)\n \n{\n\n      \nmax_so_far\n \n=\n \n*\ncurr\n;\n\n    \n}\n\n    \ncurr\n \n+=\n \n1\n;\n\n  \n}\n\n  \nreturn\n \nmax_so_far\n;\n\n\n}\n\n\n\n\n\n\n\nAppendix: Complete Code Example\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n#include\n \n\"cs1010.h\"\n\n\n\nlong\n \ndays_till_beginning_of\n(\nlong\n \nmonth\n)\n\n\n{\n\n  \nlong\n \ndays_in_month\n[\n12\n]\n \n=\n \n{\n31\n,\n \n28\n,\n \n31\n,\n \n30\n,\n \n31\n,\n \n30\n,\n \n31\n,\n \n31\n,\n \n30\n,\n \n31\n,\n \n30\n,\n \n31\n};\n\n  \nlong\n \nnum_of_days\n \n=\n \n0\n;\n\n  \nfor\n \n(\nlong\n \ni\n \n=\n \n0\n;\n \ni\n \n<\n \nmonth\n \n-\n \n1\n;\n \ni\n \n+=\n \n1\n)\n \n{\n\n    \nnum_of_days\n \n+=\n \ndays_in_month\n[\ni\n];\n\n  \n}\n\n  \nreturn\n \nnum_of_days\n;\n\n\n}\n\n\n\nint\n \nmain\n()\n\n\n{\n\n  \nlong\n \nmonth\n \n=\n \ncs1010_read_long\n();\n\n  \nlong\n \nday\n \n=\n \ncs1010_read_long\n();\n\n  \ncs1010_println_long\n(\nday\n \n+\n \ndays_till_beginning_of\n(\nmonth\n));\n\n\n}\n\n\n\n\n\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\nlong\n \nmax\n(\nlong\n \nlist\n[],\n \nlong\n \nlength\n)\n\n\n{\n\n  \nlong\n \nmax_so_far\n \n=\n \nlist\n[\n0\n];\n\n  \nfor\n \n(\nlong\n \ni\n \n=\n \n1\n;\n \ni\n \n!=\n \nlength\n;\n \ni\n \n+=\n \n1\n)\n \n{\n\n    \nif\n \n(\nlist\n[\ni\n]\n \n>\n \nmax_so_far\n)\n \n{\n\n      \nmax_so_far\n \n=\n \nlist\n[\ni\n];\n\n    \n}\n\n  \n}\n\n  \nreturn\n \nmax_so_far\n;\n\n\n}\n\n\n\nint\n \nmain\n()\n\n\n{\n\n  \nlong\n \na\n[\n10\n]\n \n=\n \n{\n1\n,\n \n2\n,\n \n3\n,\n \n4\n,\n \n1\n,\n \n9\n,\n \n10\n,\n \n44\n,\n \n-\n1\n,\n \n-\n5\n};\n\n  \ncs1010_println_long\n(\nmax\n(\na\n,\n \n10\n));\n\n\n}",
            "title": "15. Arrays"
        },
        {
            "location": "/15-array/index.html#unit-15-array",
            "text": "We now look at the first of the two compound data types in C --  arrays.    A variable can be declared to be of an array, in which case it can hold one or more values.  An array variable can only store values of the  same  type  T T .  We say that the array variable is an array of  T T .  For instance, we can declare a variable  marks  to be an array of  long , in which case,  marks  can hold one or more  long  values.",
            "title": "Unit 15: Array"
        },
        {
            "location": "/15-array/index.html#array-declaration",
            "text": "The declaration syntax for an array in C takes the following form:  1 long   marks [ 10 ];    We use the square bracket  [  and  ]  to indicate that the variable  marks  is an array.  The number  10  indicates that  marks  holds 10  long  values.  Once declared, the variables in the array are uninitialized and will contain whatever value happened to be in the memory at that time.",
            "title": "Array Declaration"
        },
        {
            "location": "/15-array/index.html#accessing-the-array-elements",
            "text": "We can access the array elements using the index of the element, starting from 0.  For instance, to initialize the marks for the first three students to 1, 2, 4, respectively, we can write:  1\n2\n3\n4 long   marks [ 10 ];  marks [ 0 ]   =   1 ;  marks [ 1 ]   =   2 ;  marks [ 2 ]   =   4 ;",
            "title": "Accessing the Array Elements"
        },
        {
            "location": "/15-array/index.html#array-initialization",
            "text": "Initializing a large array using the method above could be tedious.  Alternatively, we can initialize an array using a list of values when we declare the array.    1 long   marks [ 10 ]   =   { 1 ,   2 ,   3 ,   1 ,   5 ,   10 ,   10 ,   4 ,   5 ,   3 ,   };    If we do not specify a value during initialization, it will be set to 0 by default.    1\n2 long   marks [ 10 ]   =   { 1 ,   2 ,   3 ,   1 ,   5 ,   10 ,   10 ,   4 ,   };  // marks[8] and marks[9] are both initialized to 0    Note that, after the declaration, we can no longer using this technique to reinitialized or initialize the array.  1\n2 long   marks [ 10 ];  marks   =   { 1 ,   2 ,   3 ,   1 ,   5 ,   10 ,   10 ,   4 ,   5 ,   3 ,   };    // error",
            "title": "Array Initialization"
        },
        {
            "location": "/15-array/index.html#example-1-array-as-lookup-table",
            "text": "One way the array is useful is that it can be used as a lookup table.  Consider the following function  days() , which, given a month, return the number of days from the 1 st  of January until the 1 st  of the month.  So  days(1)  returns 0,  days(2)  returns 31 (since January has 31 days),  days(3)  returns 31 + 28 = 59 (assuming non-leap year), etc.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28 long   days ( long   month )  { \n   long   days_since   =   0 ; \n   if   ( month   ==   2 )   { \n     days_since   =   31 ; \n   }   else   if   ( month   ==   3 )   { \n     days_since   =   31   +   28 ; \n   }   else   if   ( month   ==   4 )   { \n     days_since   =   31   +   28   +   31 ; \n   }   else   if   ( month   ==   5 )   { \n     days_since   =   31   +   28   +   31   +   30 ; \n   }   else   if   ( month   ==   6 )   { \n     days_since   =   31   +   28   +   31   +   30   +   31 ; \n   }   else   if   ( month   ==   7 )   { \n     days_since   =   31   +   28   +   31   +   30   +   31   +   30 ; \n   }   else   if   ( month   ==   8 )   { \n     days_since   =   31   +   28   +   31   +   30   +   31   +   30   +   31 ; \n   }   else   if   ( month   ==   9 )   { \n     days_since   =   31   +   28   +   31   +   30   +   31   +   30   +   31   +   31 ; \n   }   else   if   ( month   ==   10 )   { \n     days_since   =   31   +   28   +   31   +   30   +   31   +   30   +   31   +   31   +   30 ; \n   }   else   if   ( month   ==   11 )   { \n     days_since   =   31   +   28   +   31   +   30   +   31   +   30   +   31   +   31   +   30   +   31 ; \n   }   else   if   ( month   ==   12 )   { \n     days_since   =   31   +   28   +   31   +   30   +   31   +   30   +   31   +   31   +   30   +   31   +   30 ; \n   } \n   return   days_since ;  }    The code is ugly and bug-prone.  Consider an alternative solution using an array.  1 long   days_in_month [ 12 ]   =   { 31 ,   28 ,   31 ,   30 ,   31 ,   30 ,   31 ,   31 ,   30 ,   31 ,   30 ,   31 };    The array above is initialized with the number of days in a month.   days_in_month[0]  stores the number of days in January,  days_in_month[1]  stores the number of days in February, etc.  The code above can then be written as:  1\n2\n3\n4\n5\n6\n7\n8\n9 long   days ( long   month )  { \n   long   days_in_month [ 12 ]   =   { 31 ,   28 ,   31 ,   30 ,   31 ,   30 ,   31 ,   31 ,   30 ,   31 ,   30 ,   31 }; \n   long   days_since   =   0 ; \n   for   ( long   i   =   0 ;   i   <   month   -   1 ;   i   +=   1 )   { \n     days_since   +=   days_in_month [ i ]; \n   } \n   return   days_since ;  }",
            "title": "Example 1: Array As Lookup Table"
        },
        {
            "location": "/15-array/index.html#example-2-array-as-list",
            "text": "We can now revisit the flowchart for  max max  and write the corresponding code.  The code would look like this:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10 long   max ( long   list [],   long   length )  { \n   long   max_so_far   =   list [ 0 ]; \n   for   ( long   i   =   1 ;   i   !=   length ;   i   +=   1 )   { \n     if   ( list [ i ]   >   max_so_far )   { \n       max_so_far   =   list [ i ]; \n     } \n   } \n   return   max_so_far ;  }    Please see the  Appendix  for the complete code  Note that, in the type of the array passed into the function above, we only need to use  []  without specifying the length.  It is also almost always necessary to pass in the number of elements in the array together with the array so that we know how many elements are there to process.  To understand why, we have to understand something called  array decay .",
            "title": "Example 2: Array As List"
        },
        {
            "location": "/15-array/index.html#array-and-pointers",
            "text": "The relationship between array and pointer can be confusing to beginners.  Some might even think that arrays are pointers due to the way they are passed around and used.  But  arrays are not pointers .  The relationship between the two, boils down to a very simple rule, as follows.  In C, the name of the variable of an array is treated differently from a non-array variable.  If we declare an array  1 type   name [ num_of_elems ];    then any reference to  name  is a synonym to  &name[0]  whenever we need the value of the array.  In other words,  name  is the pointer to the first element in the array.  This is known as the \"array decay\" operation.  There are several implications of this.  First, it is not possible to compare two arrays or assign one array to another.  1\n2\n3\n4\n5\n6\n7\n8 long   a [ 2 ]   =   { 0 ,   1 };  long   b [ 2 ]   =   { 0 ,   1 };  if   ( a   ==   b )   {    // always false \n   :  }  b   =   a ;   // not possible    Line 4 above is equivalent to comparing  &a[0]  to  &b[0] , due to array decay, and therefore is always false (since the array elements do not have the same memory address).  Line 8 above is equivalent to assigning  &a[0]  to  &b[0] , as we seen in (Unit 14)[14-pointers.md], we cannot change the memory address of a variable since this is determined by the OS.  Second, the expression  name[i]  is actually the same as  *(name + i) .  Although we should always write  name[i]  as it is easier to understand, internally, this translates to accessing the value stored at the i-th location after the first element of the array.  (Revisit  Unit 14  if you are unfamiliar with pointer arithmetic).  Third, when we pass an array into a function, we are only passing in the address of the first element.  Consider the example below:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16 long   max ( long   list [],   long   length )  { \n   long   max_so_far   =   list [ 0 ]; \n   for   ( long   i   =   1 ;   i   !=   length ;   i   +=   1 )   { \n     if   ( list [ i ]   >   max_so_far )   { \n       max_so_far   =   list [ i ]; \n     } \n   } \n   return   max_so_far ;  }  int   main ()  { \n   long   a [ 10 ]   =   { 1 ,   2 ,   3 ,   4 ,   1 ,   9 ,   10 ,   44 ,   - 1 ,   - 5 }; \n   cs1010_println_long ( max ( a ,   10 ));  }    On Line 14, we pass  a  into the function  max .  Due to array decay, we are not passing in the whole array, but only the  &a[0] .  Inside  max , we no longer have access to the whole array, but only the address of the first element.  Luckily, due to pointer arithmetic and equivalence of  list[i]  to  *(list + i) , we can still access the elements of the array.    Due to this, the size of  list  in the function parameter does not matter, and we need to pass in the size of the array  length  to  max  so that inside  max  we know the size of the array that we are dealing with.  Array decay also means that, when passing in an array as an argument to a function, we can very well write it as:  1\n2\n3\n4 long   max ( long   * list ,   long   length )  { \n     :  }    For readability, however, we should convey to the reader of the code that  list  is an array and not just a pointer to  long , thus we should still use the  []  notation.  Another implication of array decay when passing an array into a function, is that it is possible to write programs that behave incorrectly, without any compiler error or warning.  Consider the following:  1\n2\n3\n4\n5 int   main ()  { \n   long   a   =   0 ; \n   printf ( \"%ld \\n \" ,   max ( & a ,   10 ));  }    The compiler  clang  would happily compile this and generate an executable.  When executed, it would print a gibberish to the standard output.",
            "title": "Array and Pointers"
        },
        {
            "location": "/15-array/index.html#other-facts-about-arrays",
            "text": "",
            "title": "Other Facts About Arrays"
        },
        {
            "location": "/15-array/index.html#variable-length-array",
            "text": "We can also declare an array where the number of elements depends on the value of a variable.  1\n2 long   num_of_students   =   10 ;  long   marks [ num_of_students ];    Such arrays, where the number of elements (or length) depends on the value of a variable, are sometimes called  variable-length array .  This is a misnomer since once the array is created, the length is fixed.  Changing the value of the variable  num_of_students  above will not change the length of  marks .",
            "title": "Variable Length Array"
        },
        {
            "location": "/15-array/index.html#skipping-elements-during-initialization",
            "text": "If we have a large array, and we want most of it to be initialized to 0, and only some non-zero, we can use  element designators , putting the index of the element we want to initialize to non-zero in square brackets  [  and  ] .  1 long   vector [ 100 ]   =   { 1 ,   [ 5 ]   =   2 ,   3 ,   [ 99 ]   =   - 1 };    An earlier version of this note has a typo, initializing  [100] = -1  instead.  This statement initializes  vector[0]  to 1,  vector[5]  to 2,  vector[6]  to 3, and  vector[99]  to -1.  The rest of the elements will be 0.",
            "title": "Skipping Elements During Initialization"
        },
        {
            "location": "/15-array/index.html#skipping-the-size-in-declaration",
            "text": "If you supply an initialization list, the number of elements already indicates the length to the compiler, so you can skip the length.  1 long   marks []   =   { 1 ,   3 ,   2 ,   8 ,   5 ,}    This makes it easy to add or remove items from the array, without having to remember to keep the array length consistent.",
            "title": "Skipping the Size in Declaration"
        },
        {
            "location": "/15-array/index.html#determining-the-number-of-elements-in-the-array",
            "text": "C provides a  sizeof  operator, which returns the number of bytes allocated to a type.  We can use  sizeof long  for instance, to determine the number of bytes allocated to  long  on a platform.  We can also use  sizeof  on a variable instead of the type.  This becomes useful to determine, programmatically, the length of an array (esp if the array length is skipped in the array declaration).  We can calculate the number of elements in  marks  with   1 long   num_of_elem   =   sizeof   marks / sizeof   marks [ 0 ];    Note that array decay does not apply for only two operators: the  sizeof  operator, and the address-of  &  operator.  So the expression above works as intended.",
            "title": "Determining the Number of Elements in the Array"
        },
        {
            "location": "/15-array/index.html#dynamically-allocated-array",
            "text": "It is often not possible to determine the length of the array beforehand.  So, it is useful to be able to allocate an array with a length that is determined during runtime (not hard-coding the length of the array in the program).  For instance, if I want to keep a  marks  array for a module, it is unclear how big I should set the array to.  How big is big enough?  While I can use a variable-length array for this purpose, it is not ideal -- if the system does not have enough memory to store the array, the program would simply crash with a segfault and there is no way to recover from this.  For this reason, it is useful to request memory from the OS which we will manage ourselves in our program.  Unlike memory space on the call stack which is managed entirely by the OS, there is another region of memory called the  heap , which we can use.  We can request for memory from  heap  using the method  calloc()  and return the memory back to the heap when we are done with  free() .  We will visit these in more details later, but this shallow understanding is enough for now.",
            "title": "Dynamically Allocated Array"
        },
        {
            "location": "/15-array/index.html#cs1010-io-library",
            "text": "To wrap up this unit, we will look at the CS1010 library functions that help us read in an array of either  long  values or  double  values.  These functions,  cs1010_read_long_array  or  cs1010_read_double_array  takes in a parameter, which is the number of elements to read, and it returns a pointer to the array allocated within the function.  For instance, to read in an array of 100 integers, we can write:  1\n2\n3\n4\n5 long   * marks ;  marks   =   cs1010_read_long_array ( 100 );  for   ( long   i   =   0 ;   i   <   100 ;   i   +=   1 )   { \n   cs1010_println_long ( marks [ i ]);  }    This should be straightforward enough.  There are, however, two cases to consider.  What if the OS failed to allocate the memory for our array?  In this case, marks would be  NULL  and access  marks[i]  would cause a segfault. Second, we must return the memory allocated to us back to the OS once we are done.  To let go of this memory, we call the function  free .  The complete code looks like this:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12 long   * marks ;  marks   =   cs1010_read_long_array ( 100 );  if   ( marks   ==   NULL )   { \n   // signal error and return  }  for   ( long   i   =   0 ;   i   <   100 ;   i   +=   1 )   { \n   cs1010_println_long ( marks [ i ]);  }  // do other things to marks  \n   :  free ( marks );",
            "title": "CS1010 I/O Library"
        },
        {
            "location": "/15-array/index.html#problem-set-15",
            "text": "",
            "title": "Problem Set 15"
        },
        {
            "location": "/15-array/index.html#problem-151",
            "text": "Write the function  average  that takes an array of  k k  integers and  k k  and returns the average of the  k k  values in the array.",
            "title": "Problem 15.1"
        },
        {
            "location": "/15-array/index.html#problem-152",
            "text": "Explain why the following would lead to senseless output:  1\n2\n3\n4\n5 int   main ()  { \n   long   a   =   0 ; \n   printf ( \"%ld \\n \" ,   max ( & a ,   10 ));  }    How about the following? Would the output be correct?  1\n2\n3\n4\n5 int   main ()  { \n   long   a   =   0 ; \n   printf ( \"%ld \\n \" ,   max ( & a ,   1 ));   // change 10 to 1  }",
            "title": "Problem 15.2"
        },
        {
            "location": "/15-array/index.html#problem-153",
            "text": "Explain how the following code iterates through every element in the list, when called with an array of length  length  as the first argument.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15 long   max ( long   * list ,   long   length )  { \n   long   max_so_far ; \n   long   * curr ; \n\n   max_so_far   =   * list ; \n   curr   =   list   +   1 ; \n   for   ( long   i   =   1 ;   i   !=   length ;   i   +=   1 )   { \n     if   ( * curr   >   max_so_far )   { \n       max_so_far   =   * curr ; \n     } \n     curr   +=   1 ; \n   } \n   return   max_so_far ;  }",
            "title": "Problem 15.3"
        },
        {
            "location": "/15-array/index.html#appendix-complete-code-example",
            "text": "1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18 #include   \"cs1010.h\"  long   days_till_beginning_of ( long   month )  { \n   long   days_in_month [ 12 ]   =   { 31 ,   28 ,   31 ,   30 ,   31 ,   30 ,   31 ,   31 ,   30 ,   31 ,   30 ,   31 }; \n   long   num_of_days   =   0 ; \n   for   ( long   i   =   0 ;   i   <   month   -   1 ;   i   +=   1 )   { \n     num_of_days   +=   days_in_month [ i ]; \n   } \n   return   num_of_days ;  }  int   main ()  { \n   long   month   =   cs1010_read_long (); \n   long   day   =   cs1010_read_long (); \n   cs1010_println_long ( day   +   days_till_beginning_of ( month ));  }     1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16 long   max ( long   list [],   long   length )  { \n   long   max_so_far   =   list [ 0 ]; \n   for   ( long   i   =   1 ;   i   !=   length ;   i   +=   1 )   { \n     if   ( list [ i ]   >   max_so_far )   { \n       max_so_far   =   list [ i ]; \n     } \n   } \n   return   max_so_far ;  }  int   main ()  { \n   long   a [ 10 ]   =   { 1 ,   2 ,   3 ,   4 ,   1 ,   9 ,   10 ,   44 ,   - 1 ,   - 5 }; \n   cs1010_println_long ( max ( a ,   10 ));  }",
            "title": "Appendix: Complete Code Example"
        },
        {
            "location": "/16-string/index.html",
            "text": "Unit 16: Strings\n\n\nWe have seen strings as a sequence of characters stored in double quotes, e.g., \"hello!\".  In C, a string is nothing more than just an array of \nchar\n values (Recall from \nUnit 5\n that \nsizeof char\n is 1).\n\n\nJust a \nchar\n Array\n\n\nThe only thing special about a string is that it \nalways\n end with a \n0\n value (note: not character '0' which has a value of 48, but the value 0).  Since the character with value 0 is called the null character, written as '\\0', we refer that strings in C as null-terminated strings.\n\n\nIn C, we distinguish between a string and a \nchar\n by the quotes used.  String uses double quotes \n\"\n, while a \nchar\n uses single quote \n'\n.  So we can do the following and they are equivalent:\n\n\n1\n2\nchar\n \nhello1\n[\n7\n]\n \n=\n \n{\n'h'\n,\n \n'e'\n,\n \n'l'\n,\n \n'l'\n,\n \n'o'\n,\n \n'!'\n,\n \n0\n};\n \n\nchar\n \nhello2\n[\n7\n]\n \n=\n \n\"hello!\"\n;\n\n\n\n\n\n\n\nOf course, nobody actually initializes a string in the first way above.\n\n\nWe can also skip the size of the array, as mentioned above, or, more commonly, use a \nchar *\n type for a variable storing a constant string.\n\n1\n2\nchar\n \nhello3\n[]\n \n=\n \n\"hello!\"\n;\n\n\nchar\n \n*\nhello4\n \n=\n \n\"hello!\"\n;\n\n\n\n\n\n\nSpecial Characters\n\n\nThe null character is written as '\\0'.  The use of the backslash \n\\\n creates an escape sequence that can be used to denote characters that would otherwise not visible on screen.  For instance, besides '\\0', we will likely encounter '\\n' (the newline character) '\\t' (the tab character) and '\\a' (the beep character) regularly.  \n\n\nFurthermore, since we already use \n\\\n to indicate the escape sequence, \n'\n to indicate a character, and \n\"\n to indicate a string, in order to use these characters, we need to \"escape\" them -- we use '\\' for the backslash character, '\\'', the single quote character, and the '\\\"' double quote character.\n\n\nString Literals\n\n\nA \nstring literal\n refers to a string written between two \n\"\n characters, such as \n\"Hello world!\"\n.  Such a string are still internally stored as an array of \nchar\n values.  The location these arrays are stored depend on the platform, but usually they are stored in a read only region of the memory called the \ntext\n region.  These strings are not meant to be modified.  Hence, trying something like this:\n\n\n1\n2\nchar\n \n*\nstr1\n \n=\n \n\"Hello!\"\n;\n\n\nstr1\n[\n5\n]\n \n=\n \n'.'\n;\n\n\n\n\n\n\n\nis not allowed and would crash your program.\n\n\nThe following, however, is OK:\n\n1\n2\nchar\n \nstr2\n[\n7\n]\n \n=\n \n\"Hello!\"\n;\n\n\nstr2\n[\n5\n]\n \n=\n \n'.'\n;\n\n\n\n\n\n\nThe differences between the two is that, \nstr1\n points to a read-only region in the memory, while \nstr2\n contains a copy of the string on the stack.\n\n\nEmpty String\n\n\nWe commonly use the empty string \n\"\"\n to indicate a special condition or to initialize a string variable, where appropriate.  The empty string is basically an array where the 0-th element is '\\0'.\n\n\nCS1010 I/O Library\n\n\nThe CS1010 I/O library provides two functions, one to read a word (separated by white-space characters) and the other to read a line (separated by a newline character).  They are \ncs1010_read_word()\n and \ncs1010_read_line()\n respectively.  We can also read multiple words and multiple lines with \ncs1010_read_word_array()\n and \ncs1010_read_line_array()\n.  The results are stored in an array of strings.\n\n\nProblem Set 16\n\n\nProblem 16.1\n\n\nWrite the following functions (without calling the standard C functions declared in \n<string.h>\n such as \nstrlen\n, \nstrcmp\n, \nstrstr\n):\n\n\na) \nlong string_length(char *str)\n return the length (i.e., the number of characters) of the string \nstr\n.\n\n\nb) \nbool string_equal(char *str1, char *str2)\n return \ntrue\n if the two strings \nstr1\n and \nstr2\n contains exactly the same content, \nfalse\n otherwise.  (Note: \nstr1 == str2\n does not compare if two strings have the same content. (Why?))\n\n\nc) \nchar *string_in_string(char *needle, char *haystack)\n return a pointer to the first character of the first occurance of \nneedle\n in \nhaystack\n, if found.  If \nneedle\n does not occur anywhere in \nhaystack\n, return NULL.  If \nneedle\n is an empty string, \nhaystack\n is returned.",
            "title": "16. Strings"
        },
        {
            "location": "/16-string/index.html#unit-16-strings",
            "text": "We have seen strings as a sequence of characters stored in double quotes, e.g., \"hello!\".  In C, a string is nothing more than just an array of  char  values (Recall from  Unit 5  that  sizeof char  is 1).",
            "title": "Unit 16: Strings"
        },
        {
            "location": "/16-string/index.html#just-a-char-array",
            "text": "The only thing special about a string is that it  always  end with a  0  value (note: not character '0' which has a value of 48, but the value 0).  Since the character with value 0 is called the null character, written as '\\0', we refer that strings in C as null-terminated strings.  In C, we distinguish between a string and a  char  by the quotes used.  String uses double quotes  \" , while a  char  uses single quote  ' .  So we can do the following and they are equivalent:  1\n2 char   hello1 [ 7 ]   =   { 'h' ,   'e' ,   'l' ,   'l' ,   'o' ,   '!' ,   0 };   char   hello2 [ 7 ]   =   \"hello!\" ;    Of course, nobody actually initializes a string in the first way above.  We can also skip the size of the array, as mentioned above, or, more commonly, use a  char *  type for a variable storing a constant string. 1\n2 char   hello3 []   =   \"hello!\" ;  char   * hello4   =   \"hello!\" ;",
            "title": "Just a char Array"
        },
        {
            "location": "/16-string/index.html#special-characters",
            "text": "The null character is written as '\\0'.  The use of the backslash  \\  creates an escape sequence that can be used to denote characters that would otherwise not visible on screen.  For instance, besides '\\0', we will likely encounter '\\n' (the newline character) '\\t' (the tab character) and '\\a' (the beep character) regularly.    Furthermore, since we already use  \\  to indicate the escape sequence,  '  to indicate a character, and  \"  to indicate a string, in order to use these characters, we need to \"escape\" them -- we use '\\' for the backslash character, '\\'', the single quote character, and the '\\\"' double quote character.",
            "title": "Special Characters"
        },
        {
            "location": "/16-string/index.html#czjqqkd0string-literalsczjqqkd1",
            "text": "A  string literal  refers to a string written between two  \"  characters, such as  \"Hello world!\" .  Such a string are still internally stored as an array of  char  values.  The location these arrays are stored depend on the platform, but usually they are stored in a read only region of the memory called the  text  region.  These strings are not meant to be modified.  Hence, trying something like this:  1\n2 char   * str1   =   \"Hello!\" ;  str1 [ 5 ]   =   '.' ;    is not allowed and would crash your program.  The following, however, is OK: 1\n2 char   str2 [ 7 ]   =   \"Hello!\" ;  str2 [ 5 ]   =   '.' ;    The differences between the two is that,  str1  points to a read-only region in the memory, while  str2  contains a copy of the string on the stack.",
            "title": "String Literals"
        },
        {
            "location": "/16-string/index.html#empty-string",
            "text": "We commonly use the empty string  \"\"  to indicate a special condition or to initialize a string variable, where appropriate.  The empty string is basically an array where the 0-th element is '\\0'.",
            "title": "Empty String"
        },
        {
            "location": "/16-string/index.html#cs1010-io-library",
            "text": "The CS1010 I/O library provides two functions, one to read a word (separated by white-space characters) and the other to read a line (separated by a newline character).  They are  cs1010_read_word()  and  cs1010_read_line()  respectively.  We can also read multiple words and multiple lines with  cs1010_read_word_array()  and  cs1010_read_line_array() .  The results are stored in an array of strings.",
            "title": "CS1010 I/O Library"
        },
        {
            "location": "/16-string/index.html#problem-set-16",
            "text": "",
            "title": "Problem Set 16"
        },
        {
            "location": "/16-string/index.html#problem-161",
            "text": "Write the following functions (without calling the standard C functions declared in  <string.h>  such as  strlen ,  strcmp ,  strstr ):  a)  long string_length(char *str)  return the length (i.e., the number of characters) of the string  str .  b)  bool string_equal(char *str1, char *str2)  return  true  if the two strings  str1  and  str2  contains exactly the same content,  false  otherwise.  (Note:  str1 == str2  does not compare if two strings have the same content. (Why?))  c)  char *string_in_string(char *needle, char *haystack)  return a pointer to the first character of the first occurance of  needle  in  haystack , if found.  If  needle  does not occur anywhere in  haystack , return NULL.  If  needle  is an empty string,  haystack  is returned.",
            "title": "Problem 16.1"
        },
        {
            "location": "/17-call-by-reference/index.html",
            "text": "Unit 17: Call by Value & Call by Reference\n\n\nSo far, in CS1010, we have considered a very \"clean\" notion of functions -- each function is a black box, it takes in zero or more parameters, and it returns zero or one value.  We also said that within this black box, whatever happens inside the function stays inside, and the function has no effect on the variables outside.  Such \"effect-free\" programming leads to code that is easy to reason about and understandable.  For instance, suppose we have a code like this:\n\n\n1\n2\n3\nlong\n \nx\n \n=\n \n1\n;\n\n\nfoo\n(\nx\n);\n\n\n// { x == 1 }\n\n\n\n\n\n\n\nWe can assert that, after calling \nfoo\n, the value of \nx\n is still 1.\n\n\nSuch functions are called \npure functions\n.  There is a class of programming languages, called functional programming languages, that is built entirely based on such pure functions.  \n\n\nAs much as possible, we should write functions that are pure as it is less bug-prone, is easier to understand, and easier to prove that the code is correct.\n\n\nAll the functions that we have written before are invoked using a mechanism called \ncall by value\n.  This is because the \nvalue\n of the variable is \ncopied\n onto the call stack.\n\n\nFunctions with Side Effects\n\n\nIn \nUnit 15\n, we have seen a mechanism that breaks this rule.  When we pass an array into a function, due to array decay, we are actually passing in the pointer to the first element of the array.  So, what gets copied onto the call stack is the pointer, not the array.  Now, with this pointer, we can modify the elements in the array directly.o\n\n\nFor example, the code below reset all elements in the array to 0.\n\n\n1\n2\n3\n4\n5\n6\nvoid\n \nset_to_zeros\n(\nlong\n \nlength\n,\n \nlong\n \na\n[\nlength\n])\n\n\n{\n\n  \nfor\n \n(\nlong\n \ni\n \n=\n \n0\n;\n \ni\n \n<\n \nlength\n;\n \ni\n \n+=\n \n1\n)\n \n{\n\n    \na\n[\ni\n]\n \n=\n \n0\n;\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\nWhatever happens in the function no longer stays in the function.  When you see code like this:\n\n1\n2\n3\n4\nlong\n \na\n[\n10\n];\n\n\na\n[\n0\n]\n \n=\n \n1\n;\n\n\nfoo\n(\na\n);\n\n\n// { a[0] == ?? }\n\n\n\n\n\n\nWe can no longer be certain that the value of \na[0]\n after calling \nfoo\n remains 1, since \nfoo\n, or functions that it calls, could have modified \na[0]\n.  We have to trace through the code of \nfoo\n and all the function it calls to understand and reason about that changes to \na[0]\n.\n\n\n\n\nThe keyword \nconst\n\n\nSince a function taking in an array parameter can potentially modify the content of the array, as a courtesy, it is useful to add the C keyword \nconst\n in the declaration of the array parameter:\n\n1\n2\n3\nvoid foo(long length, const long a[]) {\n    :\n}\n\n\n\n\nto signal to the readers of the code that this function only reads from the array and does not modify it.  This simplifies the reasoning about the behavior of the code.\n\n\n\n\nCall by Reference\n\n\nThe call-by-value mechanism has its limitation.  Sometimes, it is useful for a function to return more than one results.  You have seen an example before in your \nAssignment 2\n, where, for the \ncollatz\n problem, you are supposed to find both the largest stopping time and the value with the largest stopping time.  \n\n\nC functions, however, can only return at most one value.  One way to get around this limitation is to use call-by-reference, the other is to use \nstruct\n.  We will leave the discussion of \nstruct\n for another day, so let's see how call by reference works in this unit.\n\n\nCalling by reference works by passing the (value of a) pointer to a variable into a function, instead of the (value of) variable.  Here is an example from the \ncollatz\n problem.\n\n\nExample: Collatz\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\nvoid\n \nfind_max_steps\n(\nlong\n \nn\n,\n \nlong\n \n*\nmax_n\n,\n \nlong\n \n*\nmax_num_steps\n)\n \n{\n\n  \n*\nmax_num_steps\n \n=\n \n0\n;\n\n  \n*\nmax_n\n \n=\n \n1\n;\n\n  \nfor\n \n(\nlong\n \ni\n \n=\n \n1\n;\n \ni\n \n<=\n \nn\n;\n \ni\n \n+=\n \n1\n)\n \n{\n\n    \nlong\n \nnum_of_steps\n \n=\n \ncount_num_of_steps\n(\ni\n);\n\n    \nif\n \n(\nnum_of_steps\n \n>=\n \n*\nmax_num_steps\n)\n \n{\n\n      \n*\nmax_n\n \n=\n \ni\n;\n\n      \n*\nmax_num_steps\n \n=\n \nnum_of_steps\n;\n\n    \n}\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\nThe method \nfind_max\n takes in two pointers.  Inside the function, we use the deference operator \n*\n to modify the variable pointed to by the pointers (Lines 2, 3, 7 and 8).\n\n\nTo use this function, we have:\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nint\n \nmain\n()\n\n\n{\n\n  \nlong\n \nn\n \n=\n \ncs1010_read_long\n();\n\n  \nlong\n \nmax_num_steps\n \n=\n \n0\n;\n\n  \nlong\n \nmax_n\n \n=\n \n1\n;\n\n  \nfind_max_steps\n(\nn\n,\n \n&\nmax_n\n,\n \n&\nmax_num_steps\n);\n\n  \ncs1010_println_long\n(\nmax_n\n);\n\n  \ncs1010_println_long\n(\nmax_num_steps\n);\n\n\n}\n\n\n\n\n\n\n\nIn Line 4 above, we pass in the address of \nmax_n\n and \nmax_num_steps\n into \nfind_max_steps\n.  \nfind_max_steps\n updates both variables for us.\n\n\nExample: Swapping Two Variables\n\n\nAnother example for call-by-reference is a function that swaps two variables.  Here is one that swaps two \nlong\n variables.\n\n\n1\n2\n3\n4\n5\nvoid\n \nswap\n(\nlong\n \n*\na\n,\n \nlong\n \n*\nb\n)\n \n{\n\n  \nlong\n \ntemp\n \n=\n \n*\na\n;\n\n  \n*\na\n \n=\n \n*\nb\n;\n\n  \n*\nb\n \n=\n \ntemp\n;\n\n\n}\n\n\n\n\n\n\n\nTo see \nswap\n in action, consider:\n\n1\n2\n3\nlong\n \na\n \n=\n \n10\n;\n\n\nlong\n \nb\n \n=\n \n-\n4\n;\n\n\nswap\n(\n&\na\n,\n \n&\nb\n);\n\n\n\n\n\n\nAfter calling \nswap\n, the value for \na\n becomes -4, \nb\n becomes 10.\n\n\nDocumenting Call-by-Reference Parameters\n\n\nA parameter passed as a pointer could be used in three different ways:\n\n\n\n\nThe parameter could be a read-only input, and the main purpose of passing in the value is so that the function has access to the value of the pointer.  \n\n\nThe parameter could be used as a vessel for the function to pass a value to the caller, similar to the parameters \nmax_n\n and \nmax_num_steps\n in the function \nfind_max_steps\n above.  In this case, the value contained in the variable pointed to by the pointer does not matter.\n\n\nThe parameter could be used as both input and output.  The value contained in the parameter is read inside the function, and the value is updated from inside the function.  For example, the parameters passed to \nswap\n above.\n\n\n\n\nIn CS1010, we will be using \nDoxygen\n format to document our functions.  There are three types of parameters, corresponding to the three situations above: \n@param[in]\n is used to document a read-only parameter (note that this applies to all read-only parameters, not just pointers).  \n@param[out]\n is used to document an output-only parameter, and \n@param[in,out]\n is used to document a parameter that is both input and output.\n\n\nProblem Set\n\n\nProblem 17.1\n\n\nComplete the function \nfind_min_max\n that takes in a \nlength\n  and an array containing \nlong\n values of size \nlength\n, and update the parameter \nmin\n and \nmax\n with the minimum and the maximum value from this array, respectively.  Show how to call this function from \nmain\n.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\nvoid\n \nfind_min_max\n(\nlong\n \nlength\n,\n \nlong\n \narray\n[\nlength\n],\n \nlong\n \n*\nmin\n,\n \nlong\n \n*\nmax\n)\n\n\n{\n\n  \n:\n\n\n}\n\n\n\nint\n \nmain\n()\n\n\n{\n\n  \nlong\n \nlist\n[\n10\n]\n \n=\n \n{\n1\n,\n \n2\n,\n \n3\n,\n \n4\n,\n \n-\n4\n,\n \n5\n,\n \n6\n,\n \n-\n8\n,\n \n3\n,\n \n1\n};\n\n    \n:\n\n\n}\n\n\n\n\n\n\n\nProblem 17.2\n\n\nConsider the program below:\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\nvoid\n \nfoo\n(\ndouble\n \n*\nptr\n,\n \ndouble\n \ntrouble\n)\n \n{\n\n  \nptr\n \n=\n \n&\ntrouble\n;\n\n  \n*\nptr\n \n=\n \n10.0\n;\n\n\n}\n\n\n\nint\n \nmain\n()\n \n{\n\n  \ndouble\n \n*\nptr\n;\n\n  \ndouble\n \nx\n \n=\n \n-\n3.0\n;\n\n  \ndouble\n \ny\n \n=\n \n7.0\n;\n\n  \nptr\n \n=\n \n&\ny\n;\n\n\n  \nfoo\n(\nptr\n,\n \nx\n);\n\n\n  \ncs1010_println_double\n(\nx\n);\n\n  \ncs1010_println_double\n(\ny\n);\n\n\n}\n\n\n\n\n\n\nWhat would be printed?\n\n\nAppendix: Complete Code\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n#include\n \n\"cs1010.h\"\n\n\n\nvoid\n \nset_to_0s\n(\nlong\n \nlen\n,\n \nlong\n \na\n[\nlen\n])\n \n{\n\n  \nfor\n \n(\nlong\n \ni\n \n=\n \n0\n;\n \ni\n \n<\n \nlen\n;\n \ni\n \n+=\n \n1\n)\n \n{\n\n    \na\n[\ni\n]\n \n=\n \n0\n;\n\n  \n}\n\n\n}\n\n\n\nint\n \nmain\n()\n\n\n{\n\n  \nlong\n \na\n[\n5\n]\n \n=\n \n{\n1\n,\n \n2\n,\n \n3\n,\n \n4\n,\n \n5\n};\n\n  \nint\n \nlen\n \n=\n \n5\n;\n\n  \nset_to_0s\n(\nlen\n,\n \na\n);\n\n  \nfor\n \n(\nlong\n \ni\n \n=\n \n0\n;\n \ni\n \n<\n \nlen\n;\n \ni\n \n+=\n \n1\n)\n \n{\n\n    \ncs1010_println_long\n(\na\n[\ni\n]);\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\ninclude\n \n\"cs1010.h\"\n\n\n\nvoid\n \nmax\n(\nconst\n \nlong\n \nlist\n[],\n \nlong\n \nlength\n,\n \nlong\n \n*\nmax_value\n,\n \nlong\n \n*\nmax_pos\n)\n\n\n{\n\n  \n*\nmax_value\n \n=\n \nlist\n[\n0\n];\n\n  \nfor\n \n(\nlong\n \ni\n \n=\n \n1\n;\n \ni\n \n!=\n \nlength\n;\n \ni\n \n+=\n \n1\n)\n \n{\n\n    \nif\n \n(\nlist\n[\ni\n]\n \n>\n \n*\nmax_value\n)\n \n{\n\n      \n*\nmax_value\n \n=\n \nlist\n[\ni\n];\n\n      \n*\nmax_pos\n \n=\n \ni\n;\n\n    \n}\n\n  \n}\n\n\n}\n\n\n\nint\n \nmain\n()\n\n\n{\n\n  \nlong\n \nlist\n[\n6\n]\n \n=\n \n{\n15\n,\n \n8\n,\n \n4\n,\n \n16\n,\n \n42\n,\n \n23\n};\n\n  \nlong\n \nmax_value\n;\n\n  \nlong\n \nmax_pos\n;\n\n  \nmax\n(\nlist\n,\n \n6\n,\n \n&\nmax_value\n,\n \n&\nmax_pos\n);\n\n  \ncs1010_println_long\n(\nmax_value\n);\n\n  \ncs1010_println_long\n(\nmax_pos\n);\n\n\n}",
            "title": "17. Call by Reference"
        },
        {
            "location": "/17-call-by-reference/index.html#unit-17-call-by-value-call-by-reference",
            "text": "So far, in CS1010, we have considered a very \"clean\" notion of functions -- each function is a black box, it takes in zero or more parameters, and it returns zero or one value.  We also said that within this black box, whatever happens inside the function stays inside, and the function has no effect on the variables outside.  Such \"effect-free\" programming leads to code that is easy to reason about and understandable.  For instance, suppose we have a code like this:  1\n2\n3 long   x   =   1 ;  foo ( x );  // { x == 1 }    We can assert that, after calling  foo , the value of  x  is still 1.  Such functions are called  pure functions .  There is a class of programming languages, called functional programming languages, that is built entirely based on such pure functions.    As much as possible, we should write functions that are pure as it is less bug-prone, is easier to understand, and easier to prove that the code is correct.  All the functions that we have written before are invoked using a mechanism called  call by value .  This is because the  value  of the variable is  copied  onto the call stack.",
            "title": "Unit 17: Call by Value &amp; Call by Reference"
        },
        {
            "location": "/17-call-by-reference/index.html#functions-with-side-effects",
            "text": "In  Unit 15 , we have seen a mechanism that breaks this rule.  When we pass an array into a function, due to array decay, we are actually passing in the pointer to the first element of the array.  So, what gets copied onto the call stack is the pointer, not the array.  Now, with this pointer, we can modify the elements in the array directly.o  For example, the code below reset all elements in the array to 0.  1\n2\n3\n4\n5\n6 void   set_to_zeros ( long   length ,   long   a [ length ])  { \n   for   ( long   i   =   0 ;   i   <   length ;   i   +=   1 )   { \n     a [ i ]   =   0 ; \n   }  }    Whatever happens in the function no longer stays in the function.  When you see code like this: 1\n2\n3\n4 long   a [ 10 ];  a [ 0 ]   =   1 ;  foo ( a );  // { a[0] == ?? }    We can no longer be certain that the value of  a[0]  after calling  foo  remains 1, since  foo , or functions that it calls, could have modified  a[0] .  We have to trace through the code of  foo  and all the function it calls to understand and reason about that changes to  a[0] .   The keyword  const  Since a function taking in an array parameter can potentially modify the content of the array, as a courtesy, it is useful to add the C keyword  const  in the declaration of the array parameter: 1\n2\n3 void foo(long length, const long a[]) {\n    :\n}  \nto signal to the readers of the code that this function only reads from the array and does not modify it.  This simplifies the reasoning about the behavior of the code.",
            "title": "Functions with Side Effects"
        },
        {
            "location": "/17-call-by-reference/index.html#call-by-reference",
            "text": "The call-by-value mechanism has its limitation.  Sometimes, it is useful for a function to return more than one results.  You have seen an example before in your  Assignment 2 , where, for the  collatz  problem, you are supposed to find both the largest stopping time and the value with the largest stopping time.    C functions, however, can only return at most one value.  One way to get around this limitation is to use call-by-reference, the other is to use  struct .  We will leave the discussion of  struct  for another day, so let's see how call by reference works in this unit.  Calling by reference works by passing the (value of a) pointer to a variable into a function, instead of the (value of) variable.  Here is an example from the  collatz  problem.",
            "title": "Call by Reference"
        },
        {
            "location": "/17-call-by-reference/index.html#example-collatz",
            "text": "1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11 void   find_max_steps ( long   n ,   long   * max_n ,   long   * max_num_steps )   { \n   * max_num_steps   =   0 ; \n   * max_n   =   1 ; \n   for   ( long   i   =   1 ;   i   <=   n ;   i   +=   1 )   { \n     long   num_of_steps   =   count_num_of_steps ( i ); \n     if   ( num_of_steps   >=   * max_num_steps )   { \n       * max_n   =   i ; \n       * max_num_steps   =   num_of_steps ; \n     } \n   }  }    The method  find_max  takes in two pointers.  Inside the function, we use the deference operator  *  to modify the variable pointed to by the pointers (Lines 2, 3, 7 and 8).  To use this function, we have:  1\n2\n3\n4\n5\n6\n7\n8\n9 int   main ()  { \n   long   n   =   cs1010_read_long (); \n   long   max_num_steps   =   0 ; \n   long   max_n   =   1 ; \n   find_max_steps ( n ,   & max_n ,   & max_num_steps ); \n   cs1010_println_long ( max_n ); \n   cs1010_println_long ( max_num_steps );  }    In Line 4 above, we pass in the address of  max_n  and  max_num_steps  into  find_max_steps .   find_max_steps  updates both variables for us.",
            "title": "Example: Collatz"
        },
        {
            "location": "/17-call-by-reference/index.html#example-swapping-two-variables",
            "text": "Another example for call-by-reference is a function that swaps two variables.  Here is one that swaps two  long  variables.  1\n2\n3\n4\n5 void   swap ( long   * a ,   long   * b )   { \n   long   temp   =   * a ; \n   * a   =   * b ; \n   * b   =   temp ;  }    To see  swap  in action, consider: 1\n2\n3 long   a   =   10 ;  long   b   =   - 4 ;  swap ( & a ,   & b );    After calling  swap , the value for  a  becomes -4,  b  becomes 10.",
            "title": "Example: Swapping Two Variables"
        },
        {
            "location": "/17-call-by-reference/index.html#documenting-call-by-reference-parameters",
            "text": "A parameter passed as a pointer could be used in three different ways:   The parameter could be a read-only input, and the main purpose of passing in the value is so that the function has access to the value of the pointer.    The parameter could be used as a vessel for the function to pass a value to the caller, similar to the parameters  max_n  and  max_num_steps  in the function  find_max_steps  above.  In this case, the value contained in the variable pointed to by the pointer does not matter.  The parameter could be used as both input and output.  The value contained in the parameter is read inside the function, and the value is updated from inside the function.  For example, the parameters passed to  swap  above.   In CS1010, we will be using  Doxygen  format to document our functions.  There are three types of parameters, corresponding to the three situations above:  @param[in]  is used to document a read-only parameter (note that this applies to all read-only parameters, not just pointers).   @param[out]  is used to document an output-only parameter, and  @param[in,out]  is used to document a parameter that is both input and output.",
            "title": "Documenting Call-by-Reference Parameters"
        },
        {
            "location": "/17-call-by-reference/index.html#problem-set",
            "text": "",
            "title": "Problem Set"
        },
        {
            "location": "/17-call-by-reference/index.html#problem-171",
            "text": "Complete the function  find_min_max  that takes in a  length   and an array containing  long  values of size  length , and update the parameter  min  and  max  with the minimum and the maximum value from this array, respectively.  Show how to call this function from  main .   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10 void   find_min_max ( long   length ,   long   array [ length ],   long   * min ,   long   * max )  { \n   :  }  int   main ()  { \n   long   list [ 10 ]   =   { 1 ,   2 ,   3 ,   4 ,   - 4 ,   5 ,   6 ,   - 8 ,   3 ,   1 }; \n     :  }",
            "title": "Problem 17.1"
        },
        {
            "location": "/17-call-by-reference/index.html#problem-172",
            "text": "Consider the program below:  1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16 void   foo ( double   * ptr ,   double   trouble )   { \n   ptr   =   & trouble ; \n   * ptr   =   10.0 ;  }  int   main ()   { \n   double   * ptr ; \n   double   x   =   - 3.0 ; \n   double   y   =   7.0 ; \n   ptr   =   & y ; \n\n   foo ( ptr ,   x ); \n\n   cs1010_println_double ( x ); \n   cs1010_println_double ( y );  }    What would be printed?",
            "title": "Problem 17.2"
        },
        {
            "location": "/17-call-by-reference/index.html#appendix-complete-code",
            "text": "1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17 #include   \"cs1010.h\"  void   set_to_0s ( long   len ,   long   a [ len ])   { \n   for   ( long   i   =   0 ;   i   <   len ;   i   +=   1 )   { \n     a [ i ]   =   0 ; \n   }  }  int   main ()  { \n   long   a [ 5 ]   =   { 1 ,   2 ,   3 ,   4 ,   5 }; \n   int   len   =   5 ; \n   set_to_0s ( len ,   a ); \n   for   ( long   i   =   0 ;   i   <   len ;   i   +=   1 )   { \n     cs1010_println_long ( a [ i ]); \n   }  }     1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22 include   \"cs1010.h\"  void   max ( const   long   list [],   long   length ,   long   * max_value ,   long   * max_pos )  { \n   * max_value   =   list [ 0 ]; \n   for   ( long   i   =   1 ;   i   !=   length ;   i   +=   1 )   { \n     if   ( list [ i ]   >   * max_value )   { \n       * max_value   =   list [ i ]; \n       * max_pos   =   i ; \n     } \n   }  }  int   main ()  { \n   long   list [ 6 ]   =   { 15 ,   8 ,   4 ,   16 ,   42 ,   23 }; \n   long   max_value ; \n   long   max_pos ; \n   max ( list ,   6 ,   & max_value ,   & max_pos ); \n   cs1010_println_long ( max_value ); \n   cs1010_println_long ( max_pos );  }",
            "title": "Appendix: Complete Code"
        },
        {
            "location": "/18-heap/index.html",
            "text": "Unit 18: Heap\n\n\nWe have already seen what a call stack is and how call stack works in \nUnit 13\n.  There is another important area of memory used by our programs, called the \nheap\n.\n\n\nRecall that a variable allocated on the stack has two properties:\n\n\n\n\nIts lifetime is the same as the lifetime of the function the variable is declared in.\n\n\nThe memory allocation and deallocation are automatic.  \n\n\n\n\nFor stack, the memory is allocated automatically when the function is called and deallocated automatically as soon as the function exits.  For this reason, such a variable is sometimes called \nautomatic\n variable, or \nauto\n variable for short.\n\n\nVariables on Heap\n\n\nThe memory allocation on the heap can be done automatically or manually.  For variables allocated on the heap, its lifetime is either the same as the lifetime of the \nwhole\n programme.  Example of such a variable is a \nglobal\n variable -- a variable that is declared \noutside\n of any function and can be read or write anywhere in the program.  We have banned the use of global variables in CS1010.  Using global variable makes your code hard to understand or reason about:\n\n\n1\n2\n3\nx\n \n=\n \n1\n;\n\n\nfoo\n();\n\n\n// { x == ?? }\n\n\n\n\n\n\n\nSuppose \nx\n is a global variable, we cannot assert anything about the property of \nx\n after calling \nfoo\n, since \nx\n can be modified by \nfoo\n or any function it calls, even though we \nnever pass \nx\n into \nfoo\n.  This is worse than passing an array as we have seen in \nUnit 17\n!\n\n\nManual Memory Allocation / Deallocation\n\n\nAllocating memory on the heap, however, is useful if we want to allocate an array dynamically, i.e., not knowing what is the size of the array when we write the program.  Often, we need an array whose size depends on the input from the user, such as reading a string or reading a sequence of numbers.  We cannot use fixed length array unless we know for sure that the input size is limited, and we cannot use variable length array, since we may get a segfault if the array size is too big for the stack.  The only viable solution is to allocate the array on the heap.\n\n\nThe C standard library provides a few functions related to memory allocation on the heap.  The header file for these functions is \nstdlib.h\n.  We are interested in \nmalloc\n and \ncalloc\n.  \nmalloc\n (memory allocation) is declared as:\n\n1\nvoid\n \n*\nmalloc\n(\nsize_t\n \nsize\n);\n\n\n\n\n\n\nIt takes in a parameter, \nsize\n, which is the number of bytes of memory to be allocated and returns a pointer to the memory allocated if successful, or \nNULL\n otherwise.  This is a general function so the type of pointer returned is \nvoid *\n rather than a pointer to a specific type.  The type of \nsize\n is \nsize_t\n, which is a type defined in \nstdlib.h\n to represent the number of bytes in memory.\n\n\nThe function \ncalloc\n (clear allocation) is declared as:\n\n1\nvoid\n \n*\ncalloc\n(\nsize_t\n \ncount\n,\n \nsize_t\n \nsize\n);\n\n\n\n\n\n\ncalloc\n allocates memory for \ncount\n items, each of \nsize\n number of bytes, in a contiguous region in the memory and initialize all bits in this memory region to 0.  Except for the fact that \ncalloc\n initializes the bits to 0, \ncalloc(count, size)\n is the same as \nmalloc(count * size)\n.\n\n\nWe have seen in \nUnit 5\n that the number of bytes needed to represent a type depends on the platform.  Suppose we want to allocate enough memory for, say, 10 \nlong\n values, how do we know how many bytes are needed?  A \nlong\n can be 4 bytes on some platforms, 8 bytes on others.  For this purpose, C provides a \nsizeof\n operator, that returns the number of bytes needed for a type or a variable.  So, to allocate memory for 10 \nlong\n values, we say:\n\n1\nlong\n \n*\narray\n \n=\n \nmalloc\n(\n10\n \n*\n \nsizeof\n(\nlong\n));\n\n\n\n\n\n\nThe CS1010 I/O library, internally, allocates memory on the heap so that we can read in words, lines, or arrays of arbitrary length.\n\n\nThe following shows the example of how \ncs1010_read_long_array\n is implemented with \ncalloc\n.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\nlong\n*\n \ncs1010_read_long_array\n(\nint\n \nhow_many\n)\n\n\n{\n\n  \nlong\n \n*\nbuffer\n \n=\n \ncalloc\n(\nhow_many\n,\n \nsizeof\n(\nlong\n));\n\n  \nif\n \n(\nbuffer\n \n==\n \nNULL\n)\n \n{\n\n    \nreturn\n \nNULL\n;\n\n  \n}\n\n\n  \nfor\n \n(\nint\n \ni\n \n=\n \n0\n;\n \ni\n \n<\n \nhow_many\n;\n \ni\n \n+=\n \n1\n)\n \n{\n\n    \nbuffer\n[\ni\n]\n \n=\n \ncs1010_read_long\n();\n\n  \n}\n\n\n  \nreturn\n \nbuffer\n;\n\n\n}\n\n\n\n\n\n\n\nMemory Deallocation\n\n\nEven though the memory available on the heap is larger than the stack, it is not unlimited, and therefore we should still use the memory judiciously.   In particular, after we are done using the memory allocated to us, we should call the method \nfree\n, passing in the pointer the memory region allocated, to have the memory region deallocated, returned back to the OS to be reused by others.\n\n\nA common bug is for a programmer to access a memory that has been freed.  This would cause strange behaviors, possible crashes in random places since we will be accessing memory that is being used by others.  It is a good practice to set the pointer to NULL after \nfree\n-ing the memory region so that we do not accidentally use it.\n\n\n1\n2\nfree(buffer);\nbuffer = NULL;\n\n\n\n\n\n\nAnother common bug is for programmers to request memory via \nmalloc\n or related functions, but forgot to \nfree\n it back to the OS.  As a result, as the program runs, it starts to hog the memory and the system will become slower and slower.   This bug is known as \nmemory leak\n.  \n\n\nAnother possible bug is for programmers to change the pointer to the region of memory allocated.  For instance,\n\n1\n2\n3\n4\nlong *buffer = calloc(how_many, sizeof(long));\nlong x;\n\nbuffer = &x;\n\n\n\n\n\nAfter we execute the code such as the above, the pointer \nbuffer\n will point to something new, and there is no longer a pointer pointing to allocate memory.  The memory allocated becomes unreachable, and therefore we can no longer free it!\n\n\nIn CS1010, from now on, you are to make sure that memory that is allocated via \nmalloc\n and related functions are \nfree\n after it is used, including those allocated in CS1010 I/O library.  The \nAPI documentation\n tells you what are the values returned by the library that should be deallocated by the caller via \nfree\n.\n\n\nProblem Set\n\n\nProblem Set 18.1\n\n\nDraw the call stack and the heap, showing what happened when we run the following code:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\nvoid\n \nfoo\n(\nlong\n \n*\ny\n,\n \nlong\n \n*\nz\n)\n\n\n{\n\n  \ny\n[\n0\n]\n \n=\n \n-\n7\n;\n\n  \ny\n[\n1\n]\n \n=\n \n-\n8\n;\n\n  \nz\n[\n0\n]\n \n=\n \n4\n;\n\n  \nz\n[\n1\n]\n \n=\n \n5\n;\n\n\n}\n\n\n\n\nint\n \nmain\n()\n\n\n{\n  \n  \nlong\n \ny\n[\n2\n]\n \n=\n \n{\n1\n,\n \n2\n};\n\n  \nlong\n \n*\nz\n \n=\n \ncalloc\n(\n2\n,\n \nsizeof\n(\nlong\n));\n\n\n  \nz\n[\n0\n]\n \n=\n \ny\n[\n0\n];\n\n  \nz\n[\n1\n]\n \n=\n \ny\n[\n1\n];\n\n\n  \nfoo\n(\ny\n,\n \nz\n);\n\n\n}\n\n\n\n\n\n\n\nProblem Set 18.2\n\n\nRead the man page for the function \nrealloc\n and explain what does it do.  Can you come up with a situation where it could be useful?",
            "title": "18. Heap"
        },
        {
            "location": "/18-heap/index.html#unit-18-heap",
            "text": "We have already seen what a call stack is and how call stack works in  Unit 13 .  There is another important area of memory used by our programs, called the  heap .  Recall that a variable allocated on the stack has two properties:   Its lifetime is the same as the lifetime of the function the variable is declared in.  The memory allocation and deallocation are automatic.     For stack, the memory is allocated automatically when the function is called and deallocated automatically as soon as the function exits.  For this reason, such a variable is sometimes called  automatic  variable, or  auto  variable for short.",
            "title": "Unit 18: Heap"
        },
        {
            "location": "/18-heap/index.html#variables-on-heap",
            "text": "The memory allocation on the heap can be done automatically or manually.  For variables allocated on the heap, its lifetime is either the same as the lifetime of the  whole  programme.  Example of such a variable is a  global  variable -- a variable that is declared  outside  of any function and can be read or write anywhere in the program.  We have banned the use of global variables in CS1010.  Using global variable makes your code hard to understand or reason about:  1\n2\n3 x   =   1 ;  foo ();  // { x == ?? }    Suppose  x  is a global variable, we cannot assert anything about the property of  x  after calling  foo , since  x  can be modified by  foo  or any function it calls, even though we  never pass  x  into  foo .  This is worse than passing an array as we have seen in  Unit 17 !",
            "title": "Variables on Heap"
        },
        {
            "location": "/18-heap/index.html#manual-memory-allocation-deallocation",
            "text": "Allocating memory on the heap, however, is useful if we want to allocate an array dynamically, i.e., not knowing what is the size of the array when we write the program.  Often, we need an array whose size depends on the input from the user, such as reading a string or reading a sequence of numbers.  We cannot use fixed length array unless we know for sure that the input size is limited, and we cannot use variable length array, since we may get a segfault if the array size is too big for the stack.  The only viable solution is to allocate the array on the heap.  The C standard library provides a few functions related to memory allocation on the heap.  The header file for these functions is  stdlib.h .  We are interested in  malloc  and  calloc .   malloc  (memory allocation) is declared as: 1 void   * malloc ( size_t   size );    It takes in a parameter,  size , which is the number of bytes of memory to be allocated and returns a pointer to the memory allocated if successful, or  NULL  otherwise.  This is a general function so the type of pointer returned is  void *  rather than a pointer to a specific type.  The type of  size  is  size_t , which is a type defined in  stdlib.h  to represent the number of bytes in memory.  The function  calloc  (clear allocation) is declared as: 1 void   * calloc ( size_t   count ,   size_t   size );    calloc  allocates memory for  count  items, each of  size  number of bytes, in a contiguous region in the memory and initialize all bits in this memory region to 0.  Except for the fact that  calloc  initializes the bits to 0,  calloc(count, size)  is the same as  malloc(count * size) .  We have seen in  Unit 5  that the number of bytes needed to represent a type depends on the platform.  Suppose we want to allocate enough memory for, say, 10  long  values, how do we know how many bytes are needed?  A  long  can be 4 bytes on some platforms, 8 bytes on others.  For this purpose, C provides a  sizeof  operator, that returns the number of bytes needed for a type or a variable.  So, to allocate memory for 10  long  values, we say: 1 long   * array   =   malloc ( 10   *   sizeof ( long ));    The CS1010 I/O library, internally, allocates memory on the heap so that we can read in words, lines, or arrays of arbitrary length.  The following shows the example of how  cs1010_read_long_array  is implemented with  calloc .   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13 long *   cs1010_read_long_array ( int   how_many )  { \n   long   * buffer   =   calloc ( how_many ,   sizeof ( long )); \n   if   ( buffer   ==   NULL )   { \n     return   NULL ; \n   } \n\n   for   ( int   i   =   0 ;   i   <   how_many ;   i   +=   1 )   { \n     buffer [ i ]   =   cs1010_read_long (); \n   } \n\n   return   buffer ;  }",
            "title": "Manual Memory Allocation / Deallocation"
        },
        {
            "location": "/18-heap/index.html#memory-deallocation",
            "text": "Even though the memory available on the heap is larger than the stack, it is not unlimited, and therefore we should still use the memory judiciously.   In particular, after we are done using the memory allocated to us, we should call the method  free , passing in the pointer the memory region allocated, to have the memory region deallocated, returned back to the OS to be reused by others.  A common bug is for a programmer to access a memory that has been freed.  This would cause strange behaviors, possible crashes in random places since we will be accessing memory that is being used by others.  It is a good practice to set the pointer to NULL after  free -ing the memory region so that we do not accidentally use it.  1\n2 free(buffer);\nbuffer = NULL;   Another common bug is for programmers to request memory via  malloc  or related functions, but forgot to  free  it back to the OS.  As a result, as the program runs, it starts to hog the memory and the system will become slower and slower.   This bug is known as  memory leak .    Another possible bug is for programmers to change the pointer to the region of memory allocated.  For instance, 1\n2\n3\n4 long *buffer = calloc(how_many, sizeof(long));\nlong x;\n\nbuffer = &x;   After we execute the code such as the above, the pointer  buffer  will point to something new, and there is no longer a pointer pointing to allocate memory.  The memory allocated becomes unreachable, and therefore we can no longer free it!  In CS1010, from now on, you are to make sure that memory that is allocated via  malloc  and related functions are  free  after it is used, including those allocated in CS1010 I/O library.  The  API documentation  tells you what are the values returned by the library that should be deallocated by the caller via  free .",
            "title": "Memory Deallocation"
        },
        {
            "location": "/18-heap/index.html#problem-set",
            "text": "",
            "title": "Problem Set"
        },
        {
            "location": "/18-heap/index.html#problem-set-181",
            "text": "Draw the call stack and the heap, showing what happened when we run the following code:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19 void   foo ( long   * y ,   long   * z )  { \n   y [ 0 ]   =   - 7 ; \n   y [ 1 ]   =   - 8 ; \n   z [ 0 ]   =   4 ; \n   z [ 1 ]   =   5 ;  }  int   main ()  {   \n   long   y [ 2 ]   =   { 1 ,   2 }; \n   long   * z   =   calloc ( 2 ,   sizeof ( long )); \n\n   z [ 0 ]   =   y [ 0 ]; \n   z [ 1 ]   =   y [ 1 ]; \n\n   foo ( y ,   z );  }",
            "title": "Problem Set 18.1"
        },
        {
            "location": "/18-heap/index.html#problem-set-182",
            "text": "Read the man page for the function  realloc  and explain what does it do.  Can you come up with a situation where it could be useful?",
            "title": "Problem Set 18.2"
        },
        {
            "location": "/19-md-array/index.html",
            "text": "Unit 19: Multi-Dimensional Arrays\n\n\nAt the beginning of this unit, we say that an array can hold one or more values of some type \nT\nT\n.  In fact, \nT\nT\n can also be an array.  So, we can have an array of array of \nlong\n, for instance.  \n\n\n1\nlong matrix[10][20];\n\n\n\n\nHere, we have an array of 10 elements, and each element is an array of 20 \nlong\n values.\n\n\nWhen we access the elements in the array, we can use the notation \nmatrix[i][j]\n (which is actually \n(matrix[i])[j]\n).\n\n\nSuch an array is called a two-dimensional array, or 2D array.  We can have a 3D array, 4D array, and so on.\n\n\nWe have seen three types of arrays.  On the stack, we have fixed length array and variable length array.  On the heap, we have dynamically allocated arrays.  A 2D array can mix different types of array.  Since we discourage the use of variable length array, we will focus on fixed-length arrays and dynamically allocated arrays only.\n\n\nFixed Length 2D Array\n\n\nThe example \nmatrix\n above is a fixed length array.  In the memory, a continuous space of 200 \nlong\n values have been allocated, and we can visualize this is having 10 rows of \nlong\n array, each array contains 20 columns of \nlong\n values.\n\n\nWith array decay, when we use the first level index of the array, \nmatrix[i]\n, this is equivalent to \n&matrix[i][0]\n (the address of the first element in matrix[i]), and it has the type \nlong *\n.  Thus, if we want to pass individulal row of a 2D array into a function, we have two options for parameters declaration:\n\n\n\n\nvoid bar(long num_of_cols, long* matrix_row) { .. }\n\n\nvoid bar(long num_of_cols, long matrix_row[]) { .. }\n\n\n\n\nThis is similar to a 1D array since \nmatrix[i]\n is a 1D array.\n\n\nWe can then invoke the function \nbar\n like:\n\n\n1\nbar\n(\n20\n,\n \nmatrix\n[\ni\n]);\n\n\n\n\n\n\n\nThings get a bit tricky when we want to pass a 2D array into a function.  By array decay, when we use the array name \nmatrix\n, it is equivalent to \n&matrix[0]\n, which is the address of the first element in \nmatrix\n, which is actually the address of an array of 20 \nlong\n.\n\n\nWe can declara the parameter for a function using either one of the following:\n\n\n\n\nvoid qux(long num_of_rows, long num_of_cols, long (* matrix_row)[20]) { .. }\n\n\nvoid qux(long num_of_rows, long num_of_cols, long matrix_row[][20]) { .. }\n\n\n\n\nand call it as:\n\n\n1\nqux\n(\n10\n,\n \n20\n,\n \nmatrix\n);\n\n\n\n\n\n\n\nNote the parenthesis in the declaration of \nlong (* matrix_row)[20]\n.  This declaration is different from \nlong* matrix_row[20]\n (which is actually \nlong *(matrix_row[20])\n  Let's decipher this:\n\n\n\n\nlong *(matrix_row[20])\n actually means \nmatrix_row\n is an array of 20 pointers to \nlong\n values.\n\n\nlong (* matrix_row)[20]\n actually means \nmatrix_row\n is a pointer to an array of 20 \nlong\n values.\n\n\n\n\nIt is also important to note that, we cannot omit the number \n20\n in the \n[]\n since it is part of the type information.  A pointer to an array of 20 \nlong\n values is treated as a different type than a pointer to an array of 19 \nlong\n values in C.\n\n\nFixed Size Array of Dynamically Allocated Array\n\n\nSuppose that we know only one of the dimension of the array in advanced, but not the other dimension.  We can allocate a fixed length array for the known dimension, and allocate the other dimension dynamically using \ncalloc\n.  We can declare an array like this:\n\n\n1\n2\n3\n4\n5\ndouble\n \n*\nbuckets\n[\n10\n];\n\n\nlong\n \nnum_of_cols\n \n=\n \ncs1010_read_long\n();\n\n\nfor\n \n(\nlong\n \ni\n \n=\n \n0\n;\n \ni\n \n<\n \n10\n;\n \ni\n \n+=\n \n1\n)\n \n{\n\n  \nbuckets\n[\ni\n]\n \n=\n \ncalloc\n(\nnum_of_cols\n,\n \nsizeof\n(\ndouble\n));\n\n\n}\n\n\n\n\n\n\n\nHere, \nbucket\n is a 1D array of 10 pointers to \nlong\n.  So, we can easily pass \nbucket\n to a function just like any other 1D array:\n\n\n\n\nvoid baz(long num_of_rows, long num_of_cols, long **bucket)\n\n\nvoid baz(long num_of_rows, long num_of_cols, long *bucket[])\n\n\n\n\nAccess such individual elements in such type of array is no different from accessing a fixed length 2D array: we use \nbucket[i][j]\n.\n\n\nRemember to free the allocated memory after we are done:\n\n\n1\n2\n3\nfor\n \n(\nlong\n \ni\n \n=\n \n0\n;\n \ni\n \n<\n \n10\n;\n \ni\n \n+=\n \n1\n)\n \n{\n\n  \nfree\n(\nbuckets\n[\ni\n]);\n\n\n}\n\n\n\n\n\n\n\nDynamically Size 2D Array\n\n\nSuppose that we do not know both dimensions in advanced, then we can allocate both dimensions of the array dynamically on the heap.\n\n\n1\n2\n3\n4\n5\n6\n7\ndouble\n \n**\ncanvas\n;\n\n\nlong\n \nnum_of_rows\n \n=\n \ncs1010_read_long\n();\n\n\nlong\n \nnum_of_cols\n \n=\n \ncs1010_read_long\n();\n\n\ncanvas\n \n=\n \ncalloc\n(\nnum_of_rows\n,\n \nsizeof\n(\ndouble\n \n*\n));\n\n\nfor\n \n(\nlong\n \ni\n \n=\n \n0\n;\n \ni\n \n<\n \nnum_of_rows\n;\n \ni\n \n+=\n \n1\n)\n \n{\n\n  \ncanvas\n[\ni\n]\n \n=\n \ncalloc\n(\nnum_of_cols\n,\n \nsizeof\n(\ndouble\n));\n\n\n}\n\n\n\n\n\n\n\nPassing such array into a function is no different from a 2D array where only one dimension is dynamically allocated above.\n\n\nRemember to free the allocated memory for both dimension after we are done:\n\n\n1\n2\n3\n4\nfor\n \n(\nlong\n \ni\n \n=\n \n0\n;\n \nlong\n \ni\n \n<\n \nnum_of_rows\n;\n \ni\n \n+=\n \n1\n)\n \n{\n\n  \nfree\n(\ncanvas\n[\ni\n]);\n\n\n}\n\n\nfree\n(\ncanvas\n);\n\n\n\n\n\n\n\nNote that during deallocation of memory, we need to do it in the reverse order of memory allocation.  If we call \nfree(canvas)\n first, we are no longer guaranteed to be able to access \ncanvas[i]\n with the correct pointers inside, so calling \nfree(canvas[i])\n after \nfree(canvas)\n might lead to an error.\n\n\nJagged Array\n\n\nOne advantage of using a dynamically allocated array is that it allows a jagged 2D array, where each row has a different size.  The example below allocate memory for a 2D array that is shaped like a half-square: the first row has one element, second row two elements, third row three, and so on.\n\n\n1\n2\n3\n4\ndouble\n \n*\nhalf_square\n[\n10\n];\n\n\nfor\n \n(\nlong\n \ni\n \n=\n \n0\n;\n \ni\n \n<\n \n10\n;\n \ni\n \n+=\n \n1\n)\n \n{\n\n  \nhalf_square\n[\ni\n]\n \n=\n \ncalloc\n(\ni\n+\n1\n,\n \nsizeof\n(\ndouble\n));\n\n\n}\n\n\n\n\n\n\n\nInitializing a Multidimensional Array\n\n\nJust like a 1D-array, we can initialize a multi-dimensional array with initializers during declaration:\n\n\n1\n2\n3\n4\n5\nlong\n \nmatrix\n[\n3\n][\n3\n]\n \n=\n \n{\n\n    \n{\n1\n,\n \n0\n,\n \n-\n1\n},\n\n    \n{\n-\n1\n,\n \n1\n,\n \n0\n},\n\n    \n{\n0\n,\n \n-\n1\n,\n \n1\n}\n\n\n};\n\n\n\n\n\nNote that we use nested \n{\n and \n}\n here.  There are other variations to the syntax above, which you may read up on your own if you are interested as we do not need to write complex initializers for multi-dimensional arrays that often.\n\n\nProblem Set\n\n\nProblem 19.1\n\n\nWrite two functions described below.  Show how you would declare the parameters to each function and how you would call each function.\n\n\na) Write a function \nadd\n that performs 3x3 matrix addition. The function should operate on 3x3 matrices of \nlong\n, takes in three parameters, the first two are the operands for addition and the third is the result.\n\n\nb) Write a function \nmultiply\n that performs 3x3 matrix multiplication. The function should operate on 3x3 matrices of \nlong\n, takes in three parameters, the first two are the operands for multiplication and the third is the result.\n\n\nProblem 19.2\n\n\nWe need to represent the distance in km between every major cities in the world. Let's label every city with a number, ranging from 0 .. \nn-1\nn-1\n, where \nn\nn\n is the number of cities.  The distance between city \ni\ni\n and \nj\nj\n is the same as the distance between city \nj\nj\n and \ni\ni\n.  The distance can be represented with \nlong\n.\n\n\nExplain how you would represent this information using jagged two-dimensional array in C efficiently.  We have information of a few thousand cities to store.  \n\n\nExplain how you would write a function \nlong dist(long **d, long i, long j)\n to retrieve the distance between any two city \ni\ni\n and \nj\nj\n.\n\n\nAppendix: Complete Code from Lecture\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\ninclude\n \n\"cs1010.h\"\n\n\n\nvoid\n \nprint_row\n(\nlong\n \nncols\n,\n \nlong\n \nrow\n[])\n \n{\n\n  \nfor\n \n(\nlong\n \nj\n \n=\n \n0\n;\n \nj\n \n<\n \nncols\n;\n \nj\n \n+=\n \n1\n)\n \n{\n\n    \ncs1010_print_long\n(\nrow\n[\nj\n]);\n\n    \ncs1010_print_string\n(\n\" \"\n);\n\n  \n}\n\n  \ncs1010_println_string\n(\n\"\"\n);\n\n\n}\n\n\n\nvoid\n \nmatrix_print\n(\nlong\n \nnrows\n,\n \nlong\n \nncols\n,\n \nlong\n \n(\n*\nmatrix\n)[\n20\n])\n \n{\n\n  \nfor\n \n(\nlong\n \ni\n \n=\n \n0\n;\n \ni\n \n<\n \nnrows\n;\n \ni\n \n+=\n \n1\n)\n \n{\n\n    \nprint_row\n(\nncols\n,\n \nmatrix\n[\ni\n]);\n\n  \n}\n\n\n}\n\n\n\nint\n \nmain\n()\n\n\n{\n\n  \nlong\n \nmatrix\n[\n3\n][\n20\n]\n \n=\n \n{\n\n    \n{\n1\n,\n \n0\n,\n \n0\n},\n\n    \n{\n0\n,\n \n1\n,\n \n0\n},\n\n    \n{\n0\n,\n \n0\n,\n \n1\n}\n\n  \n};\n\n\n  \nmatrix_print\n(\n3\n,\n \n3\n,\n \nmatrix\n);\n\n\n}\n\n\n\n\n\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n#include\n \n\"cs1010.h\"\n\n\n\nvoid\n \nprint_row\n(\nlong\n \nncols\n,\n \nlong\n \nrow\n[])\n \n{\n\n  \nfor\n \n(\nlong\n \nj\n \n=\n \n0\n;\n \nj\n \n<\n \nncols\n;\n \nj\n \n+=\n \n1\n)\n \n{\n\n    \ncs1010_print_long\n(\nrow\n[\nj\n]);\n\n    \ncs1010_print_string\n(\n\" \"\n);\n\n  \n}\n\n  \ncs1010_println_string\n(\n\"\"\n);\n\n\n}\n\n\n\nvoid\n \nprint\n(\nlong\n \nnrows\n,\n \nlong\n \nncols\n,\n \nlong\n \n*\nmatrix\n[\n10\n])\n \n{\n\n  \nfor\n \n(\nlong\n \ni\n \n=\n \n0\n;\n \ni\n \n<\n \nnrows\n;\n \ni\n \n+=\n \n1\n)\n \n{\n\n    \nprint_row\n(\nncols\n,\n \nmatrix\n[\ni\n]);\n\n  \n}\n\n\n}\n\n\n\nint\n \nmain\n()\n\n\n{\n\n  \nlong\n \n*\nbuckets\n[\n10\n];\n\n  \nlong\n \nnum_of_cols\n \n=\n \ncs1010_read_long\n();\n\n  \nfor\n \n(\nlong\n \ni\n \n=\n \n0\n;\n \ni\n \n<\n \n10\n;\n \ni\n \n+=\n \n1\n)\n \n{\n\n      \nbuckets\n[\ni\n]\n \n=\n \ncalloc\n(\nnum_of_cols\n,\n \nsizeof\n(\nlong\n));\n\n  \n}\n\n  \nprint\n(\n10\n,\n \nnum_of_cols\n,\n \nbuckets\n);\n\n  \nfor\n \n(\nlong\n \ni\n \n=\n \n0\n;\n \ni\n \n<\n \n10\n;\n \ni\n \n+=\n \n1\n)\n \n{\n\n      \nfree\n(\nbuckets\n[\ni\n]);\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n#include\n \n\"cs1010.h\"\n\n\n\nvoid\n \nprint_row\n(\nlong\n \nncols\n,\n \nlong\n \nrow\n[])\n \n{\n\n  \nfor\n \n(\nlong\n \nj\n \n=\n \n0\n;\n \nj\n \n<\n \nncols\n;\n \nj\n \n+=\n \n1\n)\n \n{\n\n    \ncs1010_print_long\n(\nrow\n[\nj\n]);\n\n    \ncs1010_print_string\n(\n\" \"\n);\n\n  \n}\n\n  \ncs1010_println_string\n(\n\"\"\n);\n\n\n}\n\n\n\nvoid\n \nprint\n(\nlong\n \nnrows\n,\n \nlong\n \nncols\n,\n \nlong\n \n*\nmatrix\n[\n10\n])\n \n{\n\n  \nfor\n \n(\nlong\n \ni\n \n=\n \n0\n;\n \ni\n \n<\n \nnrows\n;\n \ni\n \n+=\n \n1\n)\n \n{\n\n    \nprint_row\n(\nncols\n,\n \nmatrix\n[\ni\n]);\n\n  \n}\n\n\n}\n\n\n\nint\n \nmain\n()\n\n\n{\n\n  \nlong\n \n**\ncanvas\n;\n\n  \nlong\n \nnum_of_rows\n \n=\n \ncs1010_read_long\n();\n\n  \nlong\n \nnum_of_cols\n \n=\n \ncs1010_read_long\n();\n\n  \ncanvas\n \n=\n \ncalloc\n(\nnum_of_rows\n,\n \nsizeof\n(\nlong\n \n*\n));\n\n  \nfor\n \n(\nlong\n \ni\n \n=\n \n0\n;\n \ni\n \n<\n \nnum_of_rows\n;\n \ni\n \n+=\n \n1\n)\n \n{\n\n      \ncanvas\n[\ni\n]\n \n=\n \ncalloc\n(\ni\n \n+\n \n1\n,\n \nsizeof\n(\nlong\n));\n\n  \n}\n\n\n  \n// print(num_of_rows, num_of_cols, canvas);\n\n\n  \nfor\n \n(\nlong\n \ni\n \n=\n \n0\n;\n \ni\n \n<\n \nnum_of_rows\n;\n \ni\n \n+=\n \n1\n)\n \n{\n\n      \nfree\n(\ncanvas\n[\ni\n]);\n\n  \n}\n\n  \nfree\n(\ncanvas\n);\n\n\n}",
            "title": "19. Multidimensional Array"
        },
        {
            "location": "/19-md-array/index.html#unit-19-multi-dimensional-arrays",
            "text": "At the beginning of this unit, we say that an array can hold one or more values of some type  T T .  In fact,  T T  can also be an array.  So, we can have an array of array of  long , for instance.    1 long matrix[10][20];  \nHere, we have an array of 10 elements, and each element is an array of 20  long  values.  When we access the elements in the array, we can use the notation  matrix[i][j]  (which is actually  (matrix[i])[j] ).  Such an array is called a two-dimensional array, or 2D array.  We can have a 3D array, 4D array, and so on.  We have seen three types of arrays.  On the stack, we have fixed length array and variable length array.  On the heap, we have dynamically allocated arrays.  A 2D array can mix different types of array.  Since we discourage the use of variable length array, we will focus on fixed-length arrays and dynamically allocated arrays only.",
            "title": "Unit 19: Multi-Dimensional Arrays"
        },
        {
            "location": "/19-md-array/index.html#fixed-length-2d-array",
            "text": "The example  matrix  above is a fixed length array.  In the memory, a continuous space of 200  long  values have been allocated, and we can visualize this is having 10 rows of  long  array, each array contains 20 columns of  long  values.  With array decay, when we use the first level index of the array,  matrix[i] , this is equivalent to  &matrix[i][0]  (the address of the first element in matrix[i]), and it has the type  long * .  Thus, if we want to pass individulal row of a 2D array into a function, we have two options for parameters declaration:   void bar(long num_of_cols, long* matrix_row) { .. }  void bar(long num_of_cols, long matrix_row[]) { .. }   This is similar to a 1D array since  matrix[i]  is a 1D array.  We can then invoke the function  bar  like:  1 bar ( 20 ,   matrix [ i ]);    Things get a bit tricky when we want to pass a 2D array into a function.  By array decay, when we use the array name  matrix , it is equivalent to  &matrix[0] , which is the address of the first element in  matrix , which is actually the address of an array of 20  long .  We can declara the parameter for a function using either one of the following:   void qux(long num_of_rows, long num_of_cols, long (* matrix_row)[20]) { .. }  void qux(long num_of_rows, long num_of_cols, long matrix_row[][20]) { .. }   and call it as:  1 qux ( 10 ,   20 ,   matrix );    Note the parenthesis in the declaration of  long (* matrix_row)[20] .  This declaration is different from  long* matrix_row[20]  (which is actually  long *(matrix_row[20])   Let's decipher this:   long *(matrix_row[20])  actually means  matrix_row  is an array of 20 pointers to  long  values.  long (* matrix_row)[20]  actually means  matrix_row  is a pointer to an array of 20  long  values.   It is also important to note that, we cannot omit the number  20  in the  []  since it is part of the type information.  A pointer to an array of 20  long  values is treated as a different type than a pointer to an array of 19  long  values in C.",
            "title": "Fixed Length 2D Array"
        },
        {
            "location": "/19-md-array/index.html#fixed-size-array-of-dynamically-allocated-array",
            "text": "Suppose that we know only one of the dimension of the array in advanced, but not the other dimension.  We can allocate a fixed length array for the known dimension, and allocate the other dimension dynamically using  calloc .  We can declare an array like this:  1\n2\n3\n4\n5 double   * buckets [ 10 ];  long   num_of_cols   =   cs1010_read_long ();  for   ( long   i   =   0 ;   i   <   10 ;   i   +=   1 )   { \n   buckets [ i ]   =   calloc ( num_of_cols ,   sizeof ( double ));  }    Here,  bucket  is a 1D array of 10 pointers to  long .  So, we can easily pass  bucket  to a function just like any other 1D array:   void baz(long num_of_rows, long num_of_cols, long **bucket)  void baz(long num_of_rows, long num_of_cols, long *bucket[])   Access such individual elements in such type of array is no different from accessing a fixed length 2D array: we use  bucket[i][j] .  Remember to free the allocated memory after we are done:  1\n2\n3 for   ( long   i   =   0 ;   i   <   10 ;   i   +=   1 )   { \n   free ( buckets [ i ]);  }",
            "title": "Fixed Size Array of Dynamically Allocated Array"
        },
        {
            "location": "/19-md-array/index.html#dynamically-size-2d-array",
            "text": "Suppose that we do not know both dimensions in advanced, then we can allocate both dimensions of the array dynamically on the heap.  1\n2\n3\n4\n5\n6\n7 double   ** canvas ;  long   num_of_rows   =   cs1010_read_long ();  long   num_of_cols   =   cs1010_read_long ();  canvas   =   calloc ( num_of_rows ,   sizeof ( double   * ));  for   ( long   i   =   0 ;   i   <   num_of_rows ;   i   +=   1 )   { \n   canvas [ i ]   =   calloc ( num_of_cols ,   sizeof ( double ));  }    Passing such array into a function is no different from a 2D array where only one dimension is dynamically allocated above.  Remember to free the allocated memory for both dimension after we are done:  1\n2\n3\n4 for   ( long   i   =   0 ;   long   i   <   num_of_rows ;   i   +=   1 )   { \n   free ( canvas [ i ]);  }  free ( canvas );    Note that during deallocation of memory, we need to do it in the reverse order of memory allocation.  If we call  free(canvas)  first, we are no longer guaranteed to be able to access  canvas[i]  with the correct pointers inside, so calling  free(canvas[i])  after  free(canvas)  might lead to an error.",
            "title": "Dynamically Size 2D Array"
        },
        {
            "location": "/19-md-array/index.html#jagged-array",
            "text": "One advantage of using a dynamically allocated array is that it allows a jagged 2D array, where each row has a different size.  The example below allocate memory for a 2D array that is shaped like a half-square: the first row has one element, second row two elements, third row three, and so on.  1\n2\n3\n4 double   * half_square [ 10 ];  for   ( long   i   =   0 ;   i   <   10 ;   i   +=   1 )   { \n   half_square [ i ]   =   calloc ( i + 1 ,   sizeof ( double ));  }",
            "title": "Jagged Array"
        },
        {
            "location": "/19-md-array/index.html#initializing-a-multidimensional-array",
            "text": "Just like a 1D-array, we can initialize a multi-dimensional array with initializers during declaration:  1\n2\n3\n4\n5 long   matrix [ 3 ][ 3 ]   =   { \n     { 1 ,   0 ,   - 1 }, \n     { - 1 ,   1 ,   0 }, \n     { 0 ,   - 1 ,   1 }  };   \nNote that we use nested  {  and  }  here.  There are other variations to the syntax above, which you may read up on your own if you are interested as we do not need to write complex initializers for multi-dimensional arrays that often.",
            "title": "Initializing a Multidimensional Array"
        },
        {
            "location": "/19-md-array/index.html#problem-set",
            "text": "",
            "title": "Problem Set"
        },
        {
            "location": "/19-md-array/index.html#problem-191",
            "text": "Write two functions described below.  Show how you would declare the parameters to each function and how you would call each function.  a) Write a function  add  that performs 3x3 matrix addition. The function should operate on 3x3 matrices of  long , takes in three parameters, the first two are the operands for addition and the third is the result.  b) Write a function  multiply  that performs 3x3 matrix multiplication. The function should operate on 3x3 matrices of  long , takes in three parameters, the first two are the operands for multiplication and the third is the result.",
            "title": "Problem 19.1"
        },
        {
            "location": "/19-md-array/index.html#problem-192",
            "text": "We need to represent the distance in km between every major cities in the world. Let's label every city with a number, ranging from 0 ..  n-1 n-1 , where  n n  is the number of cities.  The distance between city  i i  and  j j  is the same as the distance between city  j j  and  i i .  The distance can be represented with  long .  Explain how you would represent this information using jagged two-dimensional array in C efficiently.  We have information of a few thousand cities to store.    Explain how you would write a function  long dist(long **d, long i, long j)  to retrieve the distance between any two city  i i  and  j j .",
            "title": "Problem 19.2"
        },
        {
            "location": "/19-md-array/index.html#appendix-complete-code-from-lecture",
            "text": "1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26 include   \"cs1010.h\"  void   print_row ( long   ncols ,   long   row [])   { \n   for   ( long   j   =   0 ;   j   <   ncols ;   j   +=   1 )   { \n     cs1010_print_long ( row [ j ]); \n     cs1010_print_string ( \" \" ); \n   } \n   cs1010_println_string ( \"\" );  }  void   matrix_print ( long   nrows ,   long   ncols ,   long   ( * matrix )[ 20 ])   { \n   for   ( long   i   =   0 ;   i   <   nrows ;   i   +=   1 )   { \n     print_row ( ncols ,   matrix [ i ]); \n   }  }  int   main ()  { \n   long   matrix [ 3 ][ 20 ]   =   { \n     { 1 ,   0 ,   0 }, \n     { 0 ,   1 ,   0 }, \n     { 0 ,   0 ,   1 } \n   }; \n\n   matrix_print ( 3 ,   3 ,   matrix );  }     1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28 #include   \"cs1010.h\"  void   print_row ( long   ncols ,   long   row [])   { \n   for   ( long   j   =   0 ;   j   <   ncols ;   j   +=   1 )   { \n     cs1010_print_long ( row [ j ]); \n     cs1010_print_string ( \" \" ); \n   } \n   cs1010_println_string ( \"\" );  }  void   print ( long   nrows ,   long   ncols ,   long   * matrix [ 10 ])   { \n   for   ( long   i   =   0 ;   i   <   nrows ;   i   +=   1 )   { \n     print_row ( ncols ,   matrix [ i ]); \n   }  }  int   main ()  { \n   long   * buckets [ 10 ]; \n   long   num_of_cols   =   cs1010_read_long (); \n   for   ( long   i   =   0 ;   i   <   10 ;   i   +=   1 )   { \n       buckets [ i ]   =   calloc ( num_of_cols ,   sizeof ( long )); \n   } \n   print ( 10 ,   num_of_cols ,   buckets ); \n   for   ( long   i   =   0 ;   i   <   10 ;   i   +=   1 )   { \n       free ( buckets [ i ]); \n   }  }     1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33 #include   \"cs1010.h\"  void   print_row ( long   ncols ,   long   row [])   { \n   for   ( long   j   =   0 ;   j   <   ncols ;   j   +=   1 )   { \n     cs1010_print_long ( row [ j ]); \n     cs1010_print_string ( \" \" ); \n   } \n   cs1010_println_string ( \"\" );  }  void   print ( long   nrows ,   long   ncols ,   long   * matrix [ 10 ])   { \n   for   ( long   i   =   0 ;   i   <   nrows ;   i   +=   1 )   { \n     print_row ( ncols ,   matrix [ i ]); \n   }  }  int   main ()  { \n   long   ** canvas ; \n   long   num_of_rows   =   cs1010_read_long (); \n   long   num_of_cols   =   cs1010_read_long (); \n   canvas   =   calloc ( num_of_rows ,   sizeof ( long   * )); \n   for   ( long   i   =   0 ;   i   <   num_of_rows ;   i   +=   1 )   { \n       canvas [ i ]   =   calloc ( i   +   1 ,   sizeof ( long )); \n   } \n\n   // print(num_of_rows, num_of_cols, canvas); \n\n   for   ( long   i   =   0 ;   i   <   num_of_rows ;   i   +=   1 )   { \n       free ( canvas [ i ]); \n   } \n   free ( canvas );  }",
            "title": "Appendix: Complete Code from Lecture"
        },
        {
            "location": "/20-macro/index.html",
            "text": "Unit 20: C Preprocessor: Constants and Macros\n\n\nIn this unit, we are going to delve deeper into the C compilation process, focusing on a step called \npreprocessing\n.\n\nThis step is usually the first step in the compilation process.\n\n\nPreprocessing is, in essence, a text processing and substitution process, and so it is not C specific.  This process is used by C to implement, among other things: (i) file inclusion, (ii) macro, and (iii) conditional compilation. \n\n\nA C preprocessor processes all the lines in the input file that starts with a \npreprocessor directive\n.  A directive starts with the letter \n#\n.  You have seen two of such directives, \n#include\n to include a file, and \n#define\n to define a constant.\n\n\n#include\n\n\nThe \n#include\n directive has the format\n\n\n1\n#include\n \n<filename>\n\n\n\n\n\nor\n\n\n1\n#include\n \n\"filename\"\n\n\n\n\n\n\n\nWhen the C preprocessor sees this directive, it reads the file specified by the given filename, and inserts the text, line-by-line, from this file, into the current file, in the location where the line \n#include\n occurs.   Any C preprocessor directive in the included file is recursively processed.\n\n\n#define Constant\n\n\nWe have seen how we can use \n#define\n to define constant values in our code in our exercises and assignments.  \n\n\nWe should avoid hardcoding constant values (also called \nmagic numbers\n) in our code so that our code can be easily changed when the requirement of our program has changed.\n\n\nTake this code, for instance, from Taxi:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\ndouble\n \nmetered_fare\n(\nlong\n \ndistance\n)\n\n\n{\n\n  \ndouble\n \nfare\n \n=\n \n3.40\n;\n\n\n  \ndistance\n \n-=\n \n1000\n;\n\n  \nif\n \n(\ndistance\n \n<=\n \n0\n)\n \n{\n\n    \nreturn\n \nfare\n;\n\n  \n}\n\n\n  \nif\n \n(\ndistance\n \n<=\n \n9200\n)\n \n{\n\n    \nfare\n \n+=\n \n0.22\n \n*\n \n(\ndistance\n \n/\n \n400\n);\n\n    \nif\n \n(\ndistance\n \n%\n \n400\n \n>\n \n0\n)\n \n{\n\n      \nfare\n \n+=\n \n0.22\n;\n\n    \n}\n\n  \n}\n \nelse\n \n{\n\n    \nfare\n \n+=\n \n0.22\n \n*\n \n(\n9200\n \n/\n \n400\n);\n\n  \n}\n\n\n  \ndistance\n \n-=\n \n9200\n;\n\n  \nif\n \n(\ndistance\n \n<=\n \n0\n)\n \n{\n\n    \nreturn\n \nfare\n;\n\n  \n}\n\n\n  \nfare\n \n+=\n \n0.22\n \n*\n \n(\ndistance\n \n/\n \n350\n);\n\n  \nif\n \n(\ndistance\n \n%\n \n350\n \n>\n \n0\n)\n \n{\n\n    \nfare\n \n+=\n \n0.22\n;\n\n  \n}\n\n\n  \nreturn\n \nfare\n;\n\n\n}\n\n\n\n\n\n\n\nIn my answer posted, I have used many hardcoded values.  Suppose one day, the taxi fare changes (and that day will come).  Perhaps the base fare is more, perhaps the distance threshold is shorter.  We will have to change the code above to calculate the new fare.  By littering the code above with hardcoded values, the code is difficult and error-prone to change.  Suppose we rewrite the code as:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n#define BASE_FARE 3.40\n\n\n#define BASE_DISTANCE 1000\n\n\n#define TIER_ONE_FARE 0.22\n\n\n#define TIER_ONE_DISTANCE 400\n\n\n#define TIER_ONE_LIMIT 9200\n\n\n#define TIER_TWO_FARE 0.22\n\n\n#define TIER_TWO_DISTANCE 350\n\n\n\ndouble\n \nmetered_fare\n(\nlong\n \ndistance\n)\n\n\n{\n\n  \ndouble\n \nfare\n \n=\n \nBASE_FARE\n;\n\n\n  \ndistance\n \n-=\n \nBASE_DISTANCE\n;\n\n  \nif\n \n(\ndistance\n \n<=\n \n0\n)\n \n{\n\n    \nreturn\n \nfare\n;\n\n  \n}\n\n\n  \nif\n \n(\ndistance\n \n<=\n \nTIER_ONE_LIMIT\n)\n \n{\n\n    \nfare\n \n+=\n \nTIER_ONE_FARE\n \n*\n \n(\ndistance\n \n/\n \nTIER_ONE_DISTANCE\n);\n\n    \nif\n \n(\ndistance\n \n%\n \nTIER_ONE_DISTANCE\n \n>\n \n0\n)\n \n{\n\n      \nfare\n \n+=\n \nTIER_ONE_FARE\n;\n\n    \n}\n\n  \n}\n \nelse\n \n{\n\n    \nfare\n \n+=\n \nTIER_ONE_FARE\n \n*\n \n(\nTIER_ONE_LIMIT\n \n/\n \nTIER_ONE_DISTANCE\n);\n\n  \n}\n\n\n  \ndistance\n \n-=\n \nTIER_ONE_LIMIT\n;\n\n  \nif\n \n(\ndistance\n \n<=\n \n0\n)\n \n{\n\n    \nreturn\n \nfare\n;\n\n  \n}\n\n\n  \nfare\n \n+=\n \nTIER_TWO_FARE\n \n*\n \n(\ndistance\n \n/\n \nTIER_TWO_DISTANCE\n);\n\n  \nif\n \n(\ndistance\n \n%\n \nTIER_TWO_DISTANCE\n \n>\n \n0\n)\n \n{\n\n    \nfare\n \n+=\n \nTIER_TWO_FARE\n;\n\n  \n}\n\n\n  \nreturn\n \nfare\n;\n\n\n}\n\n\n\n\n\n\n\nWe have factored out all the hardcoded values into constants we defined.  It does make the code a bit harder to read, but now, it is super easy to change.  Suppose, one day, the base taxi fare is decreased to $3.20, and then $0.20 per 500m subsequently up to 10km, and $0.15 per 600m thereafter, we only need to change:\n\n\n1\n2\n3\n4\n5\n6\n7\n#define BASE_FARE 3.20\n\n\n#define BASE_DISTANCE 1000\n\n\n#define TIER_ONE_FARE 0.20\n\n\n#define TIER_ONE_DISTANCE 500\n\n\n#define TIER_ONE_LIMIT 10000\n\n\n#define TIER_TWO_FARE 0.15\n\n\n#define TIER_TWO_DISTANCE 600\n\n\n\n\n\n\n\nThe logic of the code remains the same.   \n\n\nThe \n#define\n directive should be followed an \nidentifier\n and a \ntoken\n.  The token may contain space but must be terminated by a newline.  In the example above, \nBASE_FARE\n is the identifier, and \n3.20\n is the token.\n\n\nWhen the C preprocessor sees the \n#define\n directive, it replaces all instances of the identifier in the file with the token.  This is merely a text substitution operation.\n\n\nExample:\n\n\nConsider the example below.  Suppose we have three files:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n/**\n\n\n * @file: a.c\n\n\n */\n\n\n\n#include\n \n\"b.h\"\n\n\n\nint\n \nmain\n()\n\n\n{\n\n  \nfoo\n(\nPI\n);\n\n\n}\n\n\n\n\n\n\n\n1\n2\n3\n4\n5\n6\n/**\n\n\n * @file: b.h\n\n\n */\n\n\n\n#include\n \n\"c.h\"\n\n\n#define PI 3.1415926\n\n\n\n\n\n\n\n1\n2\n3\n4\n5\n/**\n\n\n * @file: c.h\n\n\n */\n\n\n\nvoid\n \nfoo\n(\ndouble\n \nx\n);\n\n\n\n\n\n\n\nLet's see what happen when we run C pre-processor on the file \na.c\n.  We can ask \nclang\n to stop the compilation process after the pre-processing phase, using the flag \n-E\n.\n\n\n1\nclang -E a.c\n\n\n\n\n\n\nThe command will produce the output after C pre-processing:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n# 1 \"a.c\"\n\n\n# 1 \"<built-in>\" 1\n\n\n# 1 \"<built-in>\" 3\n\n\n# 360 \"<built-in>\" 3\n\n\n# 1 \"<command line>\" 1\n\n\n# 1 \"<built-in>\" 2\n\n\n# 1 \"a.c\" 2\n\n\n# 1 \"./b.h\" 1\n\n\n# 1 \"./c.h\" 1\n\n\nvoid\n \nfoo\n(\ndouble\n \nx\n);\n\n\n# 6 \"./b.h\" 2\n\n\n# 5 \"a.c\" 2\n\n\nint\n \nmain\n()\n\n\n{\n\n  \nfoo\n(\n3.1415926\n);\n\n\n}\n\n\n\n\n\n\n\nThe lines start with \n#\n are metadata meant for the compiler.  If we ignore those, we can see that the file \na.c\n has been expanded into\n\n1\n2\n3\n4\n5\nvoid\n \nfoo\n(\ndouble\n \nx\n);\n\n\nint\n \nmain\n()\n\n\n{\n\n  \nfoo\n(\n3.1415926\n);\n\n\n}\n\n\n\n\n\n\nLine 1 above is included from file \nc.h\n, which in turn is included from file \nb.h\n.  The C pre-processor also substitutes the text \nPI\n with the text \n3.1415926\n, as the identifier \nPI\n is defined in \nb.h\n.\n\n\n#define\n Macro\n\n\nThe \n#define\n directive can be used for a more flexible and powerful text substitution feature called \nmacro\n.  \nA macro is a block of code that is given an identifying name and is substituted and expanded during pre-processing.\n\n\nFor instance, we can write the following:\n\n\n1\n#define SQUARE(x) x*x\n\n\n\n\n\n\nThis macro is named \nSQUARE\n, just like a function we defined in Lecture 3 and it takes in a parameter \nx\n as well.  But that's where the similarity ends.  There are a few important differences between macros and functions in C:\n\n\n\n\nMacros are not called.  They are only substituted during preprocessing phase which performs text processing on the source code.\n\n\nMacros have no information about types. It has no return type and the parameters have no type.\n\n\n\n\nTake the example below.  The file:\n\n\n1\n2\n3\n4\n5\n6\n7\n#define SQUARE(x) x*x\n\n\n#define PI 3.1415926\n\n\nint\n \nmain\n()\n\n\n{\n\n  \ndouble\n \nradius\n \n=\n \n4.0\n;\n\n  \ncs1010_print_double\n(\nPI\n*\nSQUARE\n(\nradius\n));\n\n\n}\n\n\n\n\n\n\n\nGet expanded into:\n\n\n1\n2\n3\n4\n5\nint\n \nmain\n()\n\n\n{\n\n  \ndouble\n \nradius\n \n=\n \n4.0\n;\n\n  \ncs1010_print_double\n(\n3.1415926\n*\nradius\n*\nradius\n);\n\n\n}\n\n\n\n\n\n\n\nLet's look at another example.  We have seen how to write a function that swaps two the value of variables.  The one we wrote swaps two \ndouble\n.  If we want to swap two \nlong\n, or two \nchar *\n, etc, we will need to write a new function for each one.  \n\n\nLet's write a generic macro that does swapping for any type.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n#define SWAP(T, x, y) {\\\n\n\n  T temp;\\\n\n\n  temp = x;\\\n\n\n  x = y;\\\n\n\n  y = temp;\\\n\n\n}\n\n\n\nint\n \nmain\n(){\n\n  \nlong\n \nx\n \n=\n \n3.0\n;\n\n  \nlong\n \ny\n \n=\n \n-\n1.0\n;\n\n  \nSWAP\n(\nlong\n,\n \nx\n,\n \ny\n);\n\n\n}\n\n\n\n\n\n\n\nThe macro \nSWAP\n takes in three parameters, the first is the type T, the second and the third are the variables to be swapped.  This macro definition spans multiple lines.  Since C preprocessor ends the definition of a macro with the end of the line, we add a backslash character to \"escape\" the newline, telling the preprocessor not to treat the newline as the end of the macro definition.\n\n\nThe code above gets expanded to:\n\n\n1\n2\n3\n4\n5\nint\n \nmain\n(){\n\n  \nlong\n \nx\n \n=\n \n3.0\n;\n\n  \nlong\n \ny\n \n=\n \n-\n1.0\n;\n\n  \n{\n \nlong\n \ntemp\n;\n \ntemp\n \n=\n \nx\n;\n \nx\n \n=\n \ny\n;\n \ny\n \n=\n \ntemp\n;};\n\n\n}\n\n\n\n\n\n\n\nPitfalls and Best Practices\n\n\nIt is easy to forget that macro is doing simple text substitution without an understanding of C syntax.  When we write macros, we should always guard against improper usage of macros.  Let's consider this:\n\n\n1\n#define SQUARE(x) x*x\n\n\n\n\n\n\n1\nSQUARE\n(\nradius\n \n+\n \n2\n)\n\n\n\n\n\n\nWhen the preprocessor substitutes the macro \nSQUARE\n, it replaces all instances of the text \nx\n with the text \nradius + 2\n.  After substitution, we get \nradius + 2*radius + 2\n!  This is not what we expected.\n\n\nTo prevent such unexpected expansion, we should always add parenthesis to our macro expression:\n\n\n1\n#define SQUARE(x) ((x)*(x))\n\n\n\n\n\n\n\nSo now, \n\n1\nSQUARE(radius + 2)\n\n\n\n\n\ngets expanded into \n((radius + 2)*(radius + 2))\n, which is what we would expect when we call \nSQUARE\n.\n\n\nTo help the readers of your code know that you are referencing a macro rather than a function, all macros should be written with uppercase letters.\n\n\nProblem Set 20\n\n\nProblem 20.1\n\n\na) Consider the macro below:\n\n\n1\n2\n3\n4\n#define MIN(a,b)  a < b ? a : b\n\n\n\nlong\n \ni\n \n=\n \nMIN\n(\n10\n,\n \n20\n);\n\n\nlong\n \nj\n \n=\n \nMIN\n(\n10\n,\n \n20\n)\n \n+\n \n1\n;\n\n\n\n\n\n\n\nWhat are the values for \ni\n and \nj\n after executing the above?  \n\n\nb) \n\n\n1\n2\n3\n4\n5\n#define MIN(a,b)  a < b ? a : b\n\n\n\nlong\n \ni\n \n=\n \n10\n;\n\n\nlong\n \nj\n \n=\n \n20\n;\n\n\nlong\n \nk\n \n=\n \nMIN\n(\nj\n,\n \ni\n++\n);\n\n\n\n\n\n\n\nWhat are the values of \ni\n and \nk\n after executing the above?\n\n\nProblem 20.2\n\n\nSuppose we write our \nSWAP\n macro without the opening and closing brackets:\n\n\n1\n2\n3\n#define SWAP(T, x, y) T temp = x;\\\n\n\n  x = y;\\\n\n\n  y = temp;\n\n\n\n\n\n\n\nWhat could go wrong?",
            "title": "20. C Pre-processing"
        },
        {
            "location": "/20-macro/index.html#unit-20-c-preprocessor-constants-and-macros",
            "text": "In this unit, we are going to delve deeper into the C compilation process, focusing on a step called  preprocessing . \nThis step is usually the first step in the compilation process.  Preprocessing is, in essence, a text processing and substitution process, and so it is not C specific.  This process is used by C to implement, among other things: (i) file inclusion, (ii) macro, and (iii) conditional compilation.   A C preprocessor processes all the lines in the input file that starts with a  preprocessor directive .  A directive starts with the letter  # .  You have seen two of such directives,  #include  to include a file, and  #define  to define a constant.",
            "title": "Unit 20: C Preprocessor: Constants and Macros"
        },
        {
            "location": "/20-macro/index.html#include",
            "text": "The  #include  directive has the format  1 #include   <filename>   \nor  1 #include   \"filename\"    When the C preprocessor sees this directive, it reads the file specified by the given filename, and inserts the text, line-by-line, from this file, into the current file, in the location where the line  #include  occurs.   Any C preprocessor directive in the included file is recursively processed.",
            "title": "#include"
        },
        {
            "location": "/20-macro/index.html#define-constant",
            "text": "We have seen how we can use  #define  to define constant values in our code in our exercises and assignments.    We should avoid hardcoding constant values (also called  magic numbers ) in our code so that our code can be easily changed when the requirement of our program has changed.  Take this code, for instance, from Taxi:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30 double   metered_fare ( long   distance )  { \n   double   fare   =   3.40 ; \n\n   distance   -=   1000 ; \n   if   ( distance   <=   0 )   { \n     return   fare ; \n   } \n\n   if   ( distance   <=   9200 )   { \n     fare   +=   0.22   *   ( distance   /   400 ); \n     if   ( distance   %   400   >   0 )   { \n       fare   +=   0.22 ; \n     } \n   }   else   { \n     fare   +=   0.22   *   ( 9200   /   400 ); \n   } \n\n   distance   -=   9200 ; \n   if   ( distance   <=   0 )   { \n     return   fare ; \n   } \n\n   fare   +=   0.22   *   ( distance   /   350 ); \n   if   ( distance   %   350   >   0 )   { \n     fare   +=   0.22 ; \n   } \n\n   return   fare ;  }    In my answer posted, I have used many hardcoded values.  Suppose one day, the taxi fare changes (and that day will come).  Perhaps the base fare is more, perhaps the distance threshold is shorter.  We will have to change the code above to calculate the new fare.  By littering the code above with hardcoded values, the code is difficult and error-prone to change.  Suppose we rewrite the code as:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38 #define BASE_FARE 3.40  #define BASE_DISTANCE 1000  #define TIER_ONE_FARE 0.22  #define TIER_ONE_DISTANCE 400  #define TIER_ONE_LIMIT 9200  #define TIER_TWO_FARE 0.22  #define TIER_TWO_DISTANCE 350  double   metered_fare ( long   distance )  { \n   double   fare   =   BASE_FARE ; \n\n   distance   -=   BASE_DISTANCE ; \n   if   ( distance   <=   0 )   { \n     return   fare ; \n   } \n\n   if   ( distance   <=   TIER_ONE_LIMIT )   { \n     fare   +=   TIER_ONE_FARE   *   ( distance   /   TIER_ONE_DISTANCE ); \n     if   ( distance   %   TIER_ONE_DISTANCE   >   0 )   { \n       fare   +=   TIER_ONE_FARE ; \n     } \n   }   else   { \n     fare   +=   TIER_ONE_FARE   *   ( TIER_ONE_LIMIT   /   TIER_ONE_DISTANCE ); \n   } \n\n   distance   -=   TIER_ONE_LIMIT ; \n   if   ( distance   <=   0 )   { \n     return   fare ; \n   } \n\n   fare   +=   TIER_TWO_FARE   *   ( distance   /   TIER_TWO_DISTANCE ); \n   if   ( distance   %   TIER_TWO_DISTANCE   >   0 )   { \n     fare   +=   TIER_TWO_FARE ; \n   } \n\n   return   fare ;  }    We have factored out all the hardcoded values into constants we defined.  It does make the code a bit harder to read, but now, it is super easy to change.  Suppose, one day, the base taxi fare is decreased to $3.20, and then $0.20 per 500m subsequently up to 10km, and $0.15 per 600m thereafter, we only need to change:  1\n2\n3\n4\n5\n6\n7 #define BASE_FARE 3.20  #define BASE_DISTANCE 1000  #define TIER_ONE_FARE 0.20  #define TIER_ONE_DISTANCE 500  #define TIER_ONE_LIMIT 10000  #define TIER_TWO_FARE 0.15  #define TIER_TWO_DISTANCE 600    The logic of the code remains the same.     The  #define  directive should be followed an  identifier  and a  token .  The token may contain space but must be terminated by a newline.  In the example above,  BASE_FARE  is the identifier, and  3.20  is the token.  When the C preprocessor sees the  #define  directive, it replaces all instances of the identifier in the file with the token.  This is merely a text substitution operation.",
            "title": "#define Constant"
        },
        {
            "location": "/20-macro/index.html#example",
            "text": "Consider the example below.  Suppose we have three files:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10 /**   * @file: a.c   */  #include   \"b.h\"  int   main ()  { \n   foo ( PI );  }    1\n2\n3\n4\n5\n6 /**   * @file: b.h   */  #include   \"c.h\"  #define PI 3.1415926    1\n2\n3\n4\n5 /**   * @file: c.h   */  void   foo ( double   x );    Let's see what happen when we run C pre-processor on the file  a.c .  We can ask  clang  to stop the compilation process after the pre-processing phase, using the flag  -E .  1 clang -E a.c   The command will produce the output after C pre-processing:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16 # 1 \"a.c\"  # 1 \"<built-in>\" 1  # 1 \"<built-in>\" 3  # 360 \"<built-in>\" 3  # 1 \"<command line>\" 1  # 1 \"<built-in>\" 2  # 1 \"a.c\" 2  # 1 \"./b.h\" 1  # 1 \"./c.h\" 1  void   foo ( double   x );  # 6 \"./b.h\" 2  # 5 \"a.c\" 2  int   main ()  { \n   foo ( 3.1415926 );  }    The lines start with  #  are metadata meant for the compiler.  If we ignore those, we can see that the file  a.c  has been expanded into 1\n2\n3\n4\n5 void   foo ( double   x );  int   main ()  { \n   foo ( 3.1415926 );  }    Line 1 above is included from file  c.h , which in turn is included from file  b.h .  The C pre-processor also substitutes the text  PI  with the text  3.1415926 , as the identifier  PI  is defined in  b.h .",
            "title": "Example:"
        },
        {
            "location": "/20-macro/index.html#define-macro",
            "text": "The  #define  directive can be used for a more flexible and powerful text substitution feature called  macro .   A macro is a block of code that is given an identifying name and is substituted and expanded during pre-processing.  For instance, we can write the following:  1 #define SQUARE(x) x*x   This macro is named  SQUARE , just like a function we defined in Lecture 3 and it takes in a parameter  x  as well.  But that's where the similarity ends.  There are a few important differences between macros and functions in C:   Macros are not called.  They are only substituted during preprocessing phase which performs text processing on the source code.  Macros have no information about types. It has no return type and the parameters have no type.   Take the example below.  The file:  1\n2\n3\n4\n5\n6\n7 #define SQUARE(x) x*x  #define PI 3.1415926  int   main ()  { \n   double   radius   =   4.0 ; \n   cs1010_print_double ( PI * SQUARE ( radius ));  }    Get expanded into:  1\n2\n3\n4\n5 int   main ()  { \n   double   radius   =   4.0 ; \n   cs1010_print_double ( 3.1415926 * radius * radius );  }    Let's look at another example.  We have seen how to write a function that swaps two the value of variables.  The one we wrote swaps two  double .  If we want to swap two  long , or two  char * , etc, we will need to write a new function for each one.    Let's write a generic macro that does swapping for any type.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12 #define SWAP(T, x, y) {\\    T temp;\\    temp = x;\\    x = y;\\    y = temp;\\  }  int   main (){ \n   long   x   =   3.0 ; \n   long   y   =   - 1.0 ; \n   SWAP ( long ,   x ,   y );  }    The macro  SWAP  takes in three parameters, the first is the type T, the second and the third are the variables to be swapped.  This macro definition spans multiple lines.  Since C preprocessor ends the definition of a macro with the end of the line, we add a backslash character to \"escape\" the newline, telling the preprocessor not to treat the newline as the end of the macro definition.  The code above gets expanded to:  1\n2\n3\n4\n5 int   main (){ \n   long   x   =   3.0 ; \n   long   y   =   - 1.0 ; \n   {   long   temp ;   temp   =   x ;   x   =   y ;   y   =   temp ;};  }",
            "title": "#define Macro"
        },
        {
            "location": "/20-macro/index.html#pitfalls-and-best-practices",
            "text": "It is easy to forget that macro is doing simple text substitution without an understanding of C syntax.  When we write macros, we should always guard against improper usage of macros.  Let's consider this:  1 #define SQUARE(x) x*x    1 SQUARE ( radius   +   2 )    When the preprocessor substitutes the macro  SQUARE , it replaces all instances of the text  x  with the text  radius + 2 .  After substitution, we get  radius + 2*radius + 2 !  This is not what we expected.  To prevent such unexpected expansion, we should always add parenthesis to our macro expression:  1 #define SQUARE(x) ((x)*(x))    So now,  1 SQUARE(radius + 2)   gets expanded into  ((radius + 2)*(radius + 2)) , which is what we would expect when we call  SQUARE .  To help the readers of your code know that you are referencing a macro rather than a function, all macros should be written with uppercase letters.",
            "title": "Pitfalls and Best Practices"
        },
        {
            "location": "/20-macro/index.html#problem-set-20",
            "text": "",
            "title": "Problem Set 20"
        },
        {
            "location": "/20-macro/index.html#problem-201",
            "text": "a) Consider the macro below:  1\n2\n3\n4 #define MIN(a,b)  a < b ? a : b  long   i   =   MIN ( 10 ,   20 );  long   j   =   MIN ( 10 ,   20 )   +   1 ;    What are the values for  i  and  j  after executing the above?    b)   1\n2\n3\n4\n5 #define MIN(a,b)  a < b ? a : b  long   i   =   10 ;  long   j   =   20 ;  long   k   =   MIN ( j ,   i ++ );    What are the values of  i  and  k  after executing the above?",
            "title": "Problem 20.1"
        },
        {
            "location": "/20-macro/index.html#problem-202",
            "text": "Suppose we write our  SWAP  macro without the opening and closing brackets:  1\n2\n3 #define SWAP(T, x, y) T temp = x;\\    x = y;\\    y = temp;    What could go wrong?",
            "title": "Problem 20.2"
        },
        {
            "location": "/21-assert/index.html",
            "text": "Unit 21: The \nassert\n Macro\n\n\nYou have learned what is an assertion and how it can help you to reason about your programs.  Previously we have only seen assertion as a commenting tool, to comment on certain properties that are guaranteed to be true at a certain point of a program.\n\n\nNow, we will make the concept of assertion even more powerful -- we can cause our program to throw an error if an assertion is ever violated.  This way, we can tell immediately if certain assumptions or properties that we made in our code are violated.\n\n\nC provides a macro called \nassert()\n (in the header file \nassert.h\n)  which takes in a logical expression.  This logical expression must always evaluate to true when \nassert\n is used.  Otherwise, assert will throw an error, giving the file and the line number where the error occurred.\n\n\nUsing assertions and the \nassert\n macro can help us pinpoint exactly where our code goes wrong, quickly.\n\n\nTake the following code, for instance:\n\n\n1\n2\n3\n4\n5\n6\n7\nlong\n \nnrows\n \n=\n \n20\n;\n\n\nlong\n \nncols\n \n=\n \n10\n;\n\n\nlong\n \nmatrix\n[\nnrows\n][\nncols\n];\n\n\n  \n:\n\n    \nmatrix\n[\ni\n][\nj\n]\n \n=\n \n-\n1\n;\n\n  \n:\n\n\n\n\n\n\n\nRemember our rule: we can only access memory that has been allocated to us.  So we need to make sure that \ni\n and \nj\n must be within the correct range.  We can add an assert statement to check that \ni\n and \nj\n are correct.\n\n\n1\n2\n    \nassert\n(\ni\n \n>=\n \n0\n \n&&\n \ni\n \n<\n \nnrows\n \n&&\n \nj\n \n>=\n \n0\n \n&&\n \nj\n \n<\n \nncols\n);\n\n    \nmatrix\n[\ni\n][\nj\n]\n \n=\n \n-\n1\n;\n\n\n\n\n\n\n\nIf the assertion fails, the program will exit and print something like this:\n\n\n1\n2\nassert\n:\n \nassert\n.\nc\n:\n12\n:\n \nint\n \nmain\n()\n:\n \nAssertion\n \n`\ni\n \n>=\n \n0\n \n&&\n \ni\n \n<\n \nnrows\n \n&&\n \nj\n \n>=\n \n0\n \n&&\n \nj\n \n<\n \nncols\n'\n \nfailed\n.\n\n\nAborted\n\n\n\n\n\n\n\nSo that we know on which line in our code the assertion has failed -- in this case, which is the line in our code we have tried to access memory that does not belong to us.\n\n\nAs you reason about your code, sprinkle \nassert\n liberally in your code so that, if you are wrong about your reasoning or you make a careless mistake in your code, \nassert\n will spot that for you.\n\n\nProblem Set 21\n\n\nProblem 21.1\n\n\nConsider the code:\n\n1\n2\n3\n4\n5\n6\n7\nvoid\n \nfoo\n(\nlong\n \nx\n)\n \n{\n\n    \nif\n \n(\nx\n \n%\n \n2\n \n==\n \n0\n)\n \n{\n\n        \n// do something\n\n    \n}\n \nelse\n \n{\n\n        \nassert\n(\nx\n \n%\n \n2\n \n==\n \n1\n);\n\n    \n}\n\n\n}\n\n\n\n\n\n\nWould the assert in Line 5 above ever fail?\n\n\nProblem 21.2\n\n\nTake your \nadd.c\n from Assignment 3 and add as many \nassert\n as you code to your code.",
            "title": "21. Assert"
        },
        {
            "location": "/21-assert/index.html#unit-21-the-assert-macro",
            "text": "You have learned what is an assertion and how it can help you to reason about your programs.  Previously we have only seen assertion as a commenting tool, to comment on certain properties that are guaranteed to be true at a certain point of a program.  Now, we will make the concept of assertion even more powerful -- we can cause our program to throw an error if an assertion is ever violated.  This way, we can tell immediately if certain assumptions or properties that we made in our code are violated.  C provides a macro called  assert()  (in the header file  assert.h )  which takes in a logical expression.  This logical expression must always evaluate to true when  assert  is used.  Otherwise, assert will throw an error, giving the file and the line number where the error occurred.  Using assertions and the  assert  macro can help us pinpoint exactly where our code goes wrong, quickly.  Take the following code, for instance:  1\n2\n3\n4\n5\n6\n7 long   nrows   =   20 ;  long   ncols   =   10 ;  long   matrix [ nrows ][ ncols ]; \n\n   : \n     matrix [ i ][ j ]   =   - 1 ; \n   :    Remember our rule: we can only access memory that has been allocated to us.  So we need to make sure that  i  and  j  must be within the correct range.  We can add an assert statement to check that  i  and  j  are correct.  1\n2      assert ( i   >=   0   &&   i   <   nrows   &&   j   >=   0   &&   j   <   ncols ); \n     matrix [ i ][ j ]   =   - 1 ;    If the assertion fails, the program will exit and print something like this:  1\n2 assert :   assert . c : 12 :   int   main () :   Assertion   ` i   >=   0   &&   i   <   nrows   &&   j   >=   0   &&   j   <   ncols '   failed .  Aborted    So that we know on which line in our code the assertion has failed -- in this case, which is the line in our code we have tried to access memory that does not belong to us.  As you reason about your code, sprinkle  assert  liberally in your code so that, if you are wrong about your reasoning or you make a careless mistake in your code,  assert  will spot that for you.",
            "title": "Unit 21: The assert Macro"
        },
        {
            "location": "/21-assert/index.html#problem-set-21",
            "text": "",
            "title": "Problem Set 21"
        },
        {
            "location": "/21-assert/index.html#problem-211",
            "text": "Consider the code: 1\n2\n3\n4\n5\n6\n7 void   foo ( long   x )   { \n     if   ( x   %   2   ==   0 )   { \n         // do something \n     }   else   { \n         assert ( x   %   2   ==   1 ); \n     }  }    Would the assert in Line 5 above ever fail?",
            "title": "Problem 21.1"
        },
        {
            "location": "/21-assert/index.html#problem-212",
            "text": "Take your  add.c  from Assignment 3 and add as many  assert  as you code to your code.",
            "title": "Problem 21.2"
        },
        {
            "location": "/22-efficiency/index.html",
            "text": "Unit 22: Efficiency\n\n\nWe have been writing code and solving problems, focusing on producing the correct output and using the various construct of C language appropriately.  Now, we will introduce a new criterion on writing code: \nefficiency\n.\n\n\nNo Redundant Work\n\n\nWriting efficient code basically means that we should not write code that runs unnecessarily.  In my comments on your \nAssignment 2\n, I gave you an example where the same function \nis_prime\n has different implementations -- some runs very slowly, while some runs quickly.   I reproduce them here:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\nbool\n \nis_prime\n(\nlong\n \nn\n)\n\n\n{\n\n  \nbool\n \nis_prime\n \n=\n \ntrue\n;\n\n  \nfor\n \n(\nlong\n \ni\n \n=\n \n2\n;\n \ni\n \n<=\n \nn\n \n-\n \n1\n;\n \ni\n++\n)\n \n{\n\n    \nif\n \n(\nn\n \n%\n \ni\n \n==\n \n0\n)\n \n{\n\n      \nis_prime\n \n=\n \nfalse\n;\n\n    \n}\n\n  \n}\n\n  \nreturn\n \nis_prime\n;\n\n\n}\n\n\n\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nbool\n \nis_prime\n(\nlong\n \nn\n)\n\n\n{\n\n  \nfor\n \n(\nlong\n \ni\n \n=\n \n2\n;\n \ni\n \n<=\n \nsqrt\n(\nn\n);\n \ni\n++\n)\n \n{\n\n    \nif\n \n(\nn\n \n%\n \ni\n \n==\n \n0\n)\n \n{\n\n      \nreturn\n \nfalse\n;\n\n    \n}\n\n  \n}\n\n  \nreturn\n \ntrue\n;\n\n\n}\n\n\n\n\n\n\n\nIn fact, on my machine, the slowest version of \nis_prime\n took ~100s, while the fast one runs ~3ms when invoked with \nis_prime(10000000001)\n.  The time taken is five orders of magnitude difference!  But there is no magic here, as we merely apply the following principle:\n\n\n\"No redundant work\"\n\n\nIf you recall, we improve the efficiency of \nis_prime\n by (i) returning \nfalse\n as soon as we found a proof that the input is not a prime, and (ii) not checking for divisor that is redundant.\n\n\nWorst Case Performance\n\n\nThe two techniques we employed above behave slightly differently.  For (i), we \nopportunistically\n stop our computation once we know the answer when the input is not a prime.  However, in the \nworst case\n, when the input is a prime, we still have to check through all \nn-2\nn-2\n divisor, from 2 up to \nn-1\nn-1\n, before we can conclude that the input is a prime.  Thus, for (i), we make our program faster for certain inputs but in the worst case, we are not able to speed up the program.\n\n\nThe second technique is more interesting and more fruitful.  With a little math, we can show that we only need to check for the divisor up to \n\\sqrt{n}\n\\sqrt{n}\n.  Here, we are improving the \nworst case\n performance of \nis_prime\n, so whether the input is a prime or not, we always have a speed up.  \n\n\nHow much is the speed up in the worst case?  In the input above, with the original slow code, in the worst case I need to check through ~10,000,000,001 divisors.  With the faster version, I only need to check \n\\sqrt{10,000,000,001}\n\\sqrt{10,000,000,001}\n = \n10,000 divisors.  That's where the five orders of magnitude speed up comes from.\n\n\nNo Repetition\n\n\nThe second principle to improving the efficiency of the program is that \n\"No repetition\"\n -- we should not repeat work that has been done before.\n\n\nLet's look at the example from earlier this semester, where you are asked to compute the range of a list.  Recall that the range of a list is the absolute difference between the largest element and the smallest element.  We use this problem to motivate the use of function, where we denote \nrange(L, k) = |max(L, k) - min(L, k)|\nrange(L, k) = |max(L, k) - min(L, k)|\n.  If we are to implement this solution in C, however, we would end up scanning through the list twice: first to find the max, then to find the min.  \n\n\nThe example code from Lecture 7 has shown that we could easily just go through the list once, use call-by-reference to output both the max and the min if we are willing to forgo the notion of pure functions and function-as-a-black-box.\n\n\nIn your midterm, you see another example where we can go through the list once to find the second largest element, instead of twice: first to find the max, then to find the next largest.\n\n\nThe performance improvement for not scanning through a list (or an array) twice is modest at most.  Let's look at another example where, by not repeating ourselves, we can gain significant performance improvement.\n\n\nFinding Fibonacci Numbers\n\n\nRecall from your Exercise 3, the Fibonacci sequence of numbers are numbers formed by adding the previous two numbers to form the next numbers. In other words, the \ni\ni\n-th Fibonacci number is computed as the sum of the previous two Fibonacci numbers, the \n(i-2)\n(i-2)\n-th, and the \n(i-1)\n(i-1)\n-th.\n\n\nHere is one way we can find the Fibonacci numbers with a loop:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\nlong\n \nfib\n(\nlong\n \nn\n)\n\n\n{\n\n  \nif\n \n(\nn\n \n==\n \n1\n \n||\n \nn\n \n==\n \n2\n)\n \n{\n\n    \nreturn\n \n1\n;\n\n  \n}\n\n  \nlong\n \nfirst\n \n=\n \n1\n;\n\n  \nlong\n \nsecond\n \n=\n \n1\n;\n\n  \nlong\n \nthird\n \n=\n \n1\n;\n\n  \nfor\n \n(\nlong\n \ni\n \n=\n \n2\n;\n \ni\n \n!=\n \nn\n;\n \ni\n \n+=\n \n1\n)\n \n{\n\n    \nfirst\n \n=\n \nsecond\n;\n\n    \nsecond\n \n=\n \nthird\n;\n\n    \nthird\n \n=\n \nfirst\n \n+\n \nsecond\n;\n\n  \n}\n\n  \nreturn\n \nthird\n;\n\n\n}\n\n\n\n\n\n\n\nTo find the \nn\nn\n-th Fibonacci number, we take \nn\nn\n steps in a loop.\n\n\nNow, let's see the following elegant recursive solution:\n\n1\n2\n3\n4\n5\n6\n7\nlong\n \nfib\n(\nlong\n \nn\n)\n\n\n{\n\n  \nif\n \n(\nn\n \n==\n \n1\n \n||\n \nn\n \n==\n \n2\n)\n \n{\n\n    \nreturn\n \n1\n;\n\n  \n}\n\n  \nreturn\n \nfib\n(\nn\n-\n1\n)\n \n+\n \nfib\n(\nn\n-\n2\n);\n\n\n}\n\n\n\n\n\n\nThis solution is short and follows directly from the definition of Fibonacci numbers.  Running this, however, reveals something very disturbing.  Let's say we call \nfib(n)\n.  This invocation in turns calls \nfib(n-1)\n and \nfib(n-2)\n.  \nfib(n-1)\n then calls \nfib(n-2)\n and \nfib(n-3)\n.   So, \nfib(n-2)\n will be called twice -- so we are repeating ourselves, violating the no repetition principles.  In fact, we will invoke \nfib()\n a large number of times.  \n\n\nBig-O Notation\n\n\nHow do we characterize the number of times \nfib()\n is called?  To answer this, we will introduce to you the Big-O notation.\n\n\nThe Big-O function is a mathematical function that computer scientists use to characterize the time and space efficiency of an algorithm.  There is a formal definition to Big-O, which interested students can find out by Googling, or you can wait until you take CS2040C and CS3230.  In CS1010, we will introduce Big-O using the intuition that it is the \"rate of growth\" of a function.\n\n\nTo motivate Big-O, let's consider how we can count the number of \"steps\" taken by an algorithm.  Let's consider this again:\n\n\n1\n2\n3\n4\n5\n  \nfor\n \n(\nlong\n \ni\n \n=\n \n2\n;\n \ni\n \n!=\n \nn\n;\n \ni\n \n+=\n \n1\n)\n \n{\n\n    \nfirst\n \n=\n \nsecond\n;\n\n    \nsecond\n \n=\n \nthird\n;\n\n    \nthird\n \n=\n \nfirst\n \n+\n \nsecond\n;\n\n  \n}\n\n\n\n\n\n\n\nIf we consider each of the fundamental operations: comparison, addition, and assignment, as a step, then we can see that, in each loop, there is one comparison (\ni != n\n), two additions (\ni + 1\n, \nthird = first + second\n), four assignments.  So we have seven operations per loop, with a total of \nn-1\nn-1\n loops.  So we have \n7n - 7\n7n - 7\n operations.  In addition, we also need to count for the assignment \ni = 2\n and the additional comparison before we exit the loop (\ni != n\n).  So, in total, we have \n7n - 5\n7n - 5\n operations.\n\n\nAs you can see, such detailed counting of the steps in tedious, and in fact, not very meaningful.  For instance, we did not account for reading values from the memory and writing of values into the memory, the performance of which becomes dependant on the architecture underneath.  \n\n\nTo free us from such low-level accounting of the number of steps, let's focus on the big picture.  No matter how we count the number of steps, in the end, it is a linear function of \nn\nn\n.  In order words, the number of steps taken by the algorithm to compute Fibonacci in a loop grows linearly with \nn\nn\n.  Using the Big-O notation, we say that it takes \nO(n)\nO(n)\n steps.\n\n\nGiven a mathematical function with multiple terms, the Big-O of this function is obtained by dropping any multiplicative constants and all terms, except for the one with the \nhighest rate of growth\n.  For instance, \nO(\\frac{n^4}{10} + 10000n^2 - n) = O(n^4)\nO(\\frac{n^4}{10} + 10000n^2 - n) = O(n^4)\n.\n\n\nDue to this focus on the term with highest rate of growth, and not bothering about other terms or multiplicative constants, it becomes very convenient for us to expression the time efficiency of an algorithm with \nO()\nO()\n -- we no longer need to count the steps precisely but just focus on the number of times it takes to run the algorithm in terms of \nn\nn\n.  \n\n\nTake the example of \nis_prime\n.  The slow algorithm takes \nO(n)\nO(n)\n, the fast algorithm takes \nO(\\sqrt{n})\nO(\\sqrt{n})\n.  \n\n\nTake another example: to find the range of a list, both algorithms, regardless of whether we are taking two passes or one pass, take \nO(n)\nO(n)\n time.\n\n\nRate of Growth\n\n\nGiven two functions \nf(n)\nf(n)\n and \ng(n)\ng(n)\n, how do we determine which one has a higher rate of growth?  We say that \nf(n)\nf(n)\n grows faster than \ng(n)\ng(n)\n if we can find a \nn_0\nn_0\n, such that \nf(n) > cg(n)\nf(n) > cg(n)\n for all \nn \\ge n_0\nn \\ge n_0\n and for some constant \nc\nc\n.  \n\n\nFor instance, which one grows faster?  \nf(n) = n^n\nf(n) = n^n\n or \ng(n) = 2^n\ng(n) = 2^n\n?  Pick \nn = 1\nn = 1\n, we have \nf(1) < g(1)\nf(1) < g(1)\n1\n.  Pick \nn = 2\nn = 2\n, we have \nf(2)\nf(2)\n equals \ng(2)\ng(2)\n.  Pick \nn = 3\nn = 3\n, we have $f(3) > \ng(3)\ng(3)\n now, and we can see that for any \nn > 3\nn > 3\n, \nn^n > 2^n\nn^n > 2^n\n, so we can conclude that \nf(n)\nf(n)\n grows faster than \ng(n)\ng(n)\n.\n\n\nExample: Kendall\n\n\nNow, consider the algorithm to compute the Kendall-Tau distance.  The code is given below.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\nlong\n \ncount_inversion\n(\nlong\n \ni\n,\n \nlong\n \nn\n,\n \nconst\n \nlong\n \nrank\n[\nn\n])\n\n\n{\n\n  \nlong\n \ncount\n \n=\n \n0\n;\n\n  \nfor\n \n(\nlong\n \nj\n \n=\n \ni\n \n+\n \n1\n;\n \nj\n \n<\n \nn\n;\n \nj\n \n+=\n \n1\n)\n \n{\n\n    \nif\n \n(\nrank\n[\ni\n]\n \n>\n \nrank\n[\nj\n])\n \n{\n\n      \ncount\n \n++\n;\n\n    \n}\n\n  \n}\n\n  \nreturn\n \ncount\n;\n\n\n}\n\n\n\ndouble\n \nkendall_tau\n(\nlong\n \nn\n,\n \nconst\n \nlong\n \nrank\n[\nn\n])\n\n\n{\n\n  \nlong\n \ncount\n \n=\n \n0\n;\n\n  \nfor\n \n(\nlong\n \ni\n \n=\n \n0\n;\n \ni\n \n<\n \nn\n \n-\n \n1\n;\n \ni\n \n+=\n \n1\n)\n \n{\n\n    \ncount\n \n+=\n \ncount_inversion\n(\ni\n,\n \nn\n,\n \nrank\n);\n\n  \n}\n\n  \nreturn\n \n2.0\n*\ncount\n/\n(\nn\n*\n(\nn\n \n-\n \n1\n));\n\n\n}\n\n\n\n\n\n\n\nWhat is the running time of the function \nkendall_tau\n, expressed in Big-O notation in terms of \nn\nn\n, the length of the input array?\n\n\nTo analyze the running time, we focus on the big picture, the part of the code that takes the most time, and we ignore all the other operations that take negligible time.  In the function \nkendall_tau\n above, Line 16 is repeated many times, so let's focus on that.  Looking at the looping conditions, we can conclude that Line 16 repeats \nO(n)\nO(n)\n times.  \n\n\nIt is tempting to conclude that \nkentall_tau\n takes \nO(n)\nO(n)\n steps here, but it would be wrong.  \n\n\nNotice that Line 16 calls another function \ncount_inversion\n.  What is the running time of \ncount_inversion\n?  Inside \ncount_inversion\n, there is another loop that repeats \nn - i\nn - i\n times.  Each time we call \ncount_inversion\n, \ni\n increases, so the loop in \ncount_inversion\n takes fewer steps each time the function is called.\n\n\nTo calculate the total number of steps, we can compute the following sum\n\nsum_{i = 0}^{n} (n - i)\nsum_{i = 0}^{n} (n - i)\n, which is just \nn + (n-1) + (n-2) + .. + 2 + 1\nn + (n-1) + (n-2) + .. + 2 + 1\n.\nThis sum is the sum of an arithmetic series and equals to \nn(n+1)/2\nn(n+1)/2\n.   Since we use the Big-O notation, we can focus on the term with the highest rate of growth, \nn^2\nn^2\n, and ignore everything else.  We have obtained the running time for \nkentall_tau\n function above as \nO(n^2)\nO(n^2)\n.\n\n\nEfficiency in CS1010\n\n\nIn CS1010, we will focus on the efficiency of your code in two senses: First, your code should not perform redundant work and it should not repeat itself unnecessarily.  This criterion is independent of Big-O notation -- i.e., even though by optimizing the performance of your code, you do not change the worst-case Big-O performance, you should still optimize your code that makes it run faster.  Second, your algorithm should run within a given Big-O running time.  We will start to impose time limitations on the running time of your code, such that if you choose the wrong algorithm with the higher rate of growth, your code would not pass the test.\n\n\nProblem Set 22\n\n\nProblem 22.1\n\n\nOrder the following functions in the increasing order of rate of growth:\n\n\n\n\nn!\nn!\n,\n\n\n2^n\n2^n\n,\n\n\n\\log_{10} n\n\\log_{10} n\n,\n\n\n\\ln n\n\\ln n\n,\n\n\nn^4\nn^4\n,\n\n\nn\\ln n\nn\\ln n\n,\n\n\nn\nn\n,\n\n\nn^2\nn^2\n,\n\n\ne^n\ne^n\n,\n\n\n\\sqrt{n}\n\\sqrt{n}\n\n\n\n\nProblem 22.2\n\n\nWhat is the Big-O running time of the following code, in terms of \nn\nn\n?\n\n\na)\n\n\n1\n2\n3\n4\n5\nfor\n \n(\nlong\n \ni\n \n=\n \n0\n;\n \ni\n \n<\n \nn\n;\n \ni\n \n+=\n \n1\n)\n \n{\n\n  \nfor\n \n(\nlong\n \nj\n \n=\n \n0\n;\n \nj\n \n<\n \nn\n;\n \nj\n \n+=\n \n2\n)\n \n{\n\n    \ncs1010_println_long\n(\ni\n \n+\n \nj\n);\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\nb)\n\n1\n2\n3\n4\n5\nfor\n \n(\nlong\n \ni\n \n=\n \n1\n;\n \ni\n \n<\n \nn\n;\n \ni\n \n*=\n \n2\n)\n \n{\n\n  \nfor\n \n(\nlong\n \nj\n \n=\n \n1\n;\n \nj\n \n<\n \nn\n;\n \nj\n \n*=\n \n2\n)\n \n{\n\n    \ncs1010_println_long\n(\ni\n \n+\n \nj\n);\n\n  \n}\n\n\n}\n\n\n\n\n\n\nc)\n\n1\n2\n3\n4\n5\n6\n7\nlong\n \nk\n \n=\n \n1\n;\n\n\nfor\n \n(\nlong\n \nj\n \n=\n \n0\n;\n \nj\n \n<\n \nn\n;\n \nj\n \n+=\n \n1\n)\n \n{\n\n  \nk\n \n*=\n \n2\n;\n\n  \nfor\n \n(\nlong\n \ni\n \n=\n \n0\n;\n \ni\n \n<\n \nk\n;\n \ni\n \n+=\n \n1\n)\n \n{\n\n    \ncs1010_println_long\n(\ni\n \n+\n \nj\n);\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote that we cannot conclude that \ng(n)\ng(n)\n grows faster than \nf(n)\nf(n)\n because of this.\u00a0\n\u21a9",
            "title": "22. Efficiency"
        },
        {
            "location": "/22-efficiency/index.html#unit-22-efficiency",
            "text": "We have been writing code and solving problems, focusing on producing the correct output and using the various construct of C language appropriately.  Now, we will introduce a new criterion on writing code:  efficiency .",
            "title": "Unit 22: Efficiency"
        },
        {
            "location": "/22-efficiency/index.html#no-redundant-work",
            "text": "Writing efficient code basically means that we should not write code that runs unnecessarily.  In my comments on your  Assignment 2 , I gave you an example where the same function  is_prime  has different implementations -- some runs very slowly, while some runs quickly.   I reproduce them here:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10 bool   is_prime ( long   n )  { \n   bool   is_prime   =   true ; \n   for   ( long   i   =   2 ;   i   <=   n   -   1 ;   i ++ )   { \n     if   ( n   %   i   ==   0 )   { \n       is_prime   =   false ; \n     } \n   } \n   return   is_prime ;  }    1\n2\n3\n4\n5\n6\n7\n8\n9 bool   is_prime ( long   n )  { \n   for   ( long   i   =   2 ;   i   <=   sqrt ( n );   i ++ )   { \n     if   ( n   %   i   ==   0 )   { \n       return   false ; \n     } \n   } \n   return   true ;  }    In fact, on my machine, the slowest version of  is_prime  took ~100s, while the fast one runs ~3ms when invoked with  is_prime(10000000001) .  The time taken is five orders of magnitude difference!  But there is no magic here, as we merely apply the following principle:  \"No redundant work\"  If you recall, we improve the efficiency of  is_prime  by (i) returning  false  as soon as we found a proof that the input is not a prime, and (ii) not checking for divisor that is redundant.",
            "title": "No Redundant Work"
        },
        {
            "location": "/22-efficiency/index.html#worst-case-performance",
            "text": "The two techniques we employed above behave slightly differently.  For (i), we  opportunistically  stop our computation once we know the answer when the input is not a prime.  However, in the  worst case , when the input is a prime, we still have to check through all  n-2 n-2  divisor, from 2 up to  n-1 n-1 , before we can conclude that the input is a prime.  Thus, for (i), we make our program faster for certain inputs but in the worst case, we are not able to speed up the program.  The second technique is more interesting and more fruitful.  With a little math, we can show that we only need to check for the divisor up to  \\sqrt{n} \\sqrt{n} .  Here, we are improving the  worst case  performance of  is_prime , so whether the input is a prime or not, we always have a speed up.    How much is the speed up in the worst case?  In the input above, with the original slow code, in the worst case I need to check through ~10,000,000,001 divisors.  With the faster version, I only need to check  \\sqrt{10,000,000,001} \\sqrt{10,000,000,001}  =  10,000 divisors.  That's where the five orders of magnitude speed up comes from.",
            "title": "Worst Case Performance"
        },
        {
            "location": "/22-efficiency/index.html#no-repetition",
            "text": "The second principle to improving the efficiency of the program is that  \"No repetition\"  -- we should not repeat work that has been done before.  Let's look at the example from earlier this semester, where you are asked to compute the range of a list.  Recall that the range of a list is the absolute difference between the largest element and the smallest element.  We use this problem to motivate the use of function, where we denote  range(L, k) = |max(L, k) - min(L, k)| range(L, k) = |max(L, k) - min(L, k)| .  If we are to implement this solution in C, however, we would end up scanning through the list twice: first to find the max, then to find the min.    The example code from Lecture 7 has shown that we could easily just go through the list once, use call-by-reference to output both the max and the min if we are willing to forgo the notion of pure functions and function-as-a-black-box.  In your midterm, you see another example where we can go through the list once to find the second largest element, instead of twice: first to find the max, then to find the next largest.  The performance improvement for not scanning through a list (or an array) twice is modest at most.  Let's look at another example where, by not repeating ourselves, we can gain significant performance improvement.",
            "title": "No Repetition"
        },
        {
            "location": "/22-efficiency/index.html#finding-fibonacci-numbers",
            "text": "Recall from your Exercise 3, the Fibonacci sequence of numbers are numbers formed by adding the previous two numbers to form the next numbers. In other words, the  i i -th Fibonacci number is computed as the sum of the previous two Fibonacci numbers, the  (i-2) (i-2) -th, and the  (i-1) (i-1) -th.  Here is one way we can find the Fibonacci numbers with a loop:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15 long   fib ( long   n )  { \n   if   ( n   ==   1   ||   n   ==   2 )   { \n     return   1 ; \n   } \n   long   first   =   1 ; \n   long   second   =   1 ; \n   long   third   =   1 ; \n   for   ( long   i   =   2 ;   i   !=   n ;   i   +=   1 )   { \n     first   =   second ; \n     second   =   third ; \n     third   =   first   +   second ; \n   } \n   return   third ;  }    To find the  n n -th Fibonacci number, we take  n n  steps in a loop.  Now, let's see the following elegant recursive solution: 1\n2\n3\n4\n5\n6\n7 long   fib ( long   n )  { \n   if   ( n   ==   1   ||   n   ==   2 )   { \n     return   1 ; \n   } \n   return   fib ( n - 1 )   +   fib ( n - 2 );  }    This solution is short and follows directly from the definition of Fibonacci numbers.  Running this, however, reveals something very disturbing.  Let's say we call  fib(n) .  This invocation in turns calls  fib(n-1)  and  fib(n-2) .   fib(n-1)  then calls  fib(n-2)  and  fib(n-3) .   So,  fib(n-2)  will be called twice -- so we are repeating ourselves, violating the no repetition principles.  In fact, we will invoke  fib()  a large number of times.",
            "title": "Finding Fibonacci Numbers"
        },
        {
            "location": "/22-efficiency/index.html#big-o-notation",
            "text": "How do we characterize the number of times  fib()  is called?  To answer this, we will introduce to you the Big-O notation.  The Big-O function is a mathematical function that computer scientists use to characterize the time and space efficiency of an algorithm.  There is a formal definition to Big-O, which interested students can find out by Googling, or you can wait until you take CS2040C and CS3230.  In CS1010, we will introduce Big-O using the intuition that it is the \"rate of growth\" of a function.  To motivate Big-O, let's consider how we can count the number of \"steps\" taken by an algorithm.  Let's consider this again:  1\n2\n3\n4\n5    for   ( long   i   =   2 ;   i   !=   n ;   i   +=   1 )   { \n     first   =   second ; \n     second   =   third ; \n     third   =   first   +   second ; \n   }    If we consider each of the fundamental operations: comparison, addition, and assignment, as a step, then we can see that, in each loop, there is one comparison ( i != n ), two additions ( i + 1 ,  third = first + second ), four assignments.  So we have seven operations per loop, with a total of  n-1 n-1  loops.  So we have  7n - 7 7n - 7  operations.  In addition, we also need to count for the assignment  i = 2  and the additional comparison before we exit the loop ( i != n ).  So, in total, we have  7n - 5 7n - 5  operations.  As you can see, such detailed counting of the steps in tedious, and in fact, not very meaningful.  For instance, we did not account for reading values from the memory and writing of values into the memory, the performance of which becomes dependant on the architecture underneath.    To free us from such low-level accounting of the number of steps, let's focus on the big picture.  No matter how we count the number of steps, in the end, it is a linear function of  n n .  In order words, the number of steps taken by the algorithm to compute Fibonacci in a loop grows linearly with  n n .  Using the Big-O notation, we say that it takes  O(n) O(n)  steps.  Given a mathematical function with multiple terms, the Big-O of this function is obtained by dropping any multiplicative constants and all terms, except for the one with the  highest rate of growth .  For instance,  O(\\frac{n^4}{10} + 10000n^2 - n) = O(n^4) O(\\frac{n^4}{10} + 10000n^2 - n) = O(n^4) .  Due to this focus on the term with highest rate of growth, and not bothering about other terms or multiplicative constants, it becomes very convenient for us to expression the time efficiency of an algorithm with  O() O()  -- we no longer need to count the steps precisely but just focus on the number of times it takes to run the algorithm in terms of  n n .    Take the example of  is_prime .  The slow algorithm takes  O(n) O(n) , the fast algorithm takes  O(\\sqrt{n}) O(\\sqrt{n}) .    Take another example: to find the range of a list, both algorithms, regardless of whether we are taking two passes or one pass, take  O(n) O(n)  time.",
            "title": "Big-O Notation"
        },
        {
            "location": "/22-efficiency/index.html#rate-of-growth",
            "text": "Given two functions  f(n) f(n)  and  g(n) g(n) , how do we determine which one has a higher rate of growth?  We say that  f(n) f(n)  grows faster than  g(n) g(n)  if we can find a  n_0 n_0 , such that  f(n) > cg(n) f(n) > cg(n)  for all  n \\ge n_0 n \\ge n_0  and for some constant  c c .    For instance, which one grows faster?   f(n) = n^n f(n) = n^n  or  g(n) = 2^n g(n) = 2^n ?  Pick  n = 1 n = 1 , we have  f(1) < g(1) f(1) < g(1) 1 .  Pick  n = 2 n = 2 , we have  f(2) f(2)  equals  g(2) g(2) .  Pick  n = 3 n = 3 , we have $f(3) >  g(3) g(3)  now, and we can see that for any  n > 3 n > 3 ,  n^n > 2^n n^n > 2^n , so we can conclude that  f(n) f(n)  grows faster than  g(n) g(n) .",
            "title": "Rate of Growth"
        },
        {
            "location": "/22-efficiency/index.html#example-kendall",
            "text": "Now, consider the algorithm to compute the Kendall-Tau distance.  The code is given below.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19 long   count_inversion ( long   i ,   long   n ,   const   long   rank [ n ])  { \n   long   count   =   0 ; \n   for   ( long   j   =   i   +   1 ;   j   <   n ;   j   +=   1 )   { \n     if   ( rank [ i ]   >   rank [ j ])   { \n       count   ++ ; \n     } \n   } \n   return   count ;  }  double   kendall_tau ( long   n ,   const   long   rank [ n ])  { \n   long   count   =   0 ; \n   for   ( long   i   =   0 ;   i   <   n   -   1 ;   i   +=   1 )   { \n     count   +=   count_inversion ( i ,   n ,   rank ); \n   } \n   return   2.0 * count / ( n * ( n   -   1 ));  }    What is the running time of the function  kendall_tau , expressed in Big-O notation in terms of  n n , the length of the input array?  To analyze the running time, we focus on the big picture, the part of the code that takes the most time, and we ignore all the other operations that take negligible time.  In the function  kendall_tau  above, Line 16 is repeated many times, so let's focus on that.  Looking at the looping conditions, we can conclude that Line 16 repeats  O(n) O(n)  times.    It is tempting to conclude that  kentall_tau  takes  O(n) O(n)  steps here, but it would be wrong.    Notice that Line 16 calls another function  count_inversion .  What is the running time of  count_inversion ?  Inside  count_inversion , there is another loop that repeats  n - i n - i  times.  Each time we call  count_inversion ,  i  increases, so the loop in  count_inversion  takes fewer steps each time the function is called.  To calculate the total number of steps, we can compute the following sum sum_{i = 0}^{n} (n - i) sum_{i = 0}^{n} (n - i) , which is just  n + (n-1) + (n-2) + .. + 2 + 1 n + (n-1) + (n-2) + .. + 2 + 1 .\nThis sum is the sum of an arithmetic series and equals to  n(n+1)/2 n(n+1)/2 .   Since we use the Big-O notation, we can focus on the term with the highest rate of growth,  n^2 n^2 , and ignore everything else.  We have obtained the running time for  kentall_tau  function above as  O(n^2) O(n^2) .",
            "title": "Example: Kendall"
        },
        {
            "location": "/22-efficiency/index.html#efficiency-in-cs1010",
            "text": "In CS1010, we will focus on the efficiency of your code in two senses: First, your code should not perform redundant work and it should not repeat itself unnecessarily.  This criterion is independent of Big-O notation -- i.e., even though by optimizing the performance of your code, you do not change the worst-case Big-O performance, you should still optimize your code that makes it run faster.  Second, your algorithm should run within a given Big-O running time.  We will start to impose time limitations on the running time of your code, such that if you choose the wrong algorithm with the higher rate of growth, your code would not pass the test.",
            "title": "Efficiency in CS1010"
        },
        {
            "location": "/22-efficiency/index.html#problem-set-22",
            "text": "",
            "title": "Problem Set 22"
        },
        {
            "location": "/22-efficiency/index.html#problem-221",
            "text": "Order the following functions in the increasing order of rate of growth:   n! n! ,  2^n 2^n ,  \\log_{10} n \\log_{10} n ,  \\ln n \\ln n ,  n^4 n^4 ,  n\\ln n n\\ln n ,  n n ,  n^2 n^2 ,  e^n e^n ,  \\sqrt{n} \\sqrt{n}",
            "title": "Problem 22.1"
        },
        {
            "location": "/22-efficiency/index.html#problem-222",
            "text": "What is the Big-O running time of the following code, in terms of  n n ?  a)  1\n2\n3\n4\n5 for   ( long   i   =   0 ;   i   <   n ;   i   +=   1 )   { \n   for   ( long   j   =   0 ;   j   <   n ;   j   +=   2 )   { \n     cs1010_println_long ( i   +   j ); \n   }  }    b) 1\n2\n3\n4\n5 for   ( long   i   =   1 ;   i   <   n ;   i   *=   2 )   { \n   for   ( long   j   =   1 ;   j   <   n ;   j   *=   2 )   { \n     cs1010_println_long ( i   +   j ); \n   }  }    c) 1\n2\n3\n4\n5\n6\n7 long   k   =   1 ;  for   ( long   j   =   0 ;   j   <   n ;   j   +=   1 )   { \n   k   *=   2 ; \n   for   ( long   i   =   0 ;   i   <   k ;   i   +=   1 )   { \n     cs1010_println_long ( i   +   j ); \n   }  }        Note that we cannot conclude that  g(n) g(n)  grows faster than  f(n) f(n)  because of this.\u00a0 \u21a9",
            "title": "Problem 22.2"
        },
        {
            "location": "/23-search/index.html",
            "text": "Unit 23: Searching\n\n\nLet's continue the discussion on efficiency on one of the fundamental problems in computing: how to look for something.\n\n\nYou have seen a similar problem in the problem Index in Exercise 3: Given a list of items \nL\nL\n and query item \nq\nq\n, find if \nq\nq\n is in \nL\nL\n.  \n\n\nLet's write a function to solve this.  Our function returns -1 if \nq\nq\n is not in the list.  It returns the position of \nq\nq\n in the list otherwise.\n\n\n1\n2\n3\n4\n5\n6\n7\nlong\n \nsearch\n(\nlong\n \nn\n,\n \nconst\n \nlong\n \nlist\n[\nn\n],\n \nlong\n \nq\n)\n \n{\n\n  \nfor\n \n(\nlong\n \ni\n \n=\n \n0\n;\n \ni\n \n<\n \nn\n;\n \ni\n \n+=\n \n1\n)\n \n{\n\n    \nif\n \n(\nlist\n[\ni\n]\n \n==\n \nq\n)\n \n{\n\n      \nreturn\n \ni\n;\n\n  \n}\n\n  \nreturn\n \n-\n1\n;\n\n\n}\n\n\n\n\n\n\n\nWhat is the worst-case running time, expressed in Big-O notation, of the function above?  Suppose the query \nq\nq\n is not in the list, we will have to scan the whole list, once.  The worst case running time is, therefore, \nO(n)\nO(n)\n.\n\n\nCan we do better?  It turns out that this running time \nO(n)\nO(n)\n is also the best that we can do because we cannot be sure that \nq\nq\n does not exist until we check every single element in the list.  So there is no shortcut.\n\n\nBinary Search\n\n\nBut, do we always have to check every element in the list?  It turns out that, like many real-life situations, \nif the input list is sorted\n, we do not have to scan through every element.  We can eliminate a huge chunk of the elements based on whether a chosen element is bigger or smaller than \nq\nq\n.\n\n\nSuppose that the input list is sorted in increasing order.  Pick a random element \nx\nx\n from the list.  Any element to the left of \nx\nx\n must be less than or equal to \nx\nx\n, and any element to the right of \nx\nx\n must be greater or equal to \nx\nx\n. \n\n\nSuppose that \nq > x\nq > x\n, then we know that \nq\nq\n must be to the right of \nx\nx\n, there is no need to search to the left of \nx\nx\n.  Otherwise, \nq < x\nq < x\n, and \nq\nq\n must be to the left of \nx\nx\n, and there is no need to search to the right of \nx\nx\n.\n\n\nWe can code this out using a recursive function below:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n/**\n\n\n * Look for q in list[i]..list[j].\n\n\n *\n\n\n * @pre list is sorted\n\n\n * @return -1 if not found, the position of q in list otherwise.\n\n\n */\n\n\nlong\n \nsearch\n(\nconst\n \nlong\n \nlist\n[],\n \nlong\n \ni\n,\n \nlong\n \nj\n,\n \nlong\n \nq\n)\n \n{\n\n  \nif\n \n(\ni\n \n>\n \nj\n)\n \n{\n\n    \nreturn\n \n-\n1\n;\n\n  \n}\n\n  \nlong\n \nmid\n \n=\n \n(\ni\n+\nj\n)\n/\n2\n;\n\n  \nif\n \n(\nlist\n[\nmid\n]\n \n==\n \nq\n)\n \n{\n\n    \nreturn\n \nmid\n;\n\n  \n}\n \nelse\n \nif\n \n(\nlist\n[\nmid\n]\n \n>\n \nq\n)\n \n{\n\n    \nreturn\n \nsearch\n(\nlist\n,\n \ni\n,\n \nmid\n-\n1\n,\n \nq\n);\n\n  \n}\n \n  \nreturn\n \nsearch\n(\nlist\n,\n \nmid\n+\n1\n,\n \nj\n,\n \nq\n);\n\n\n}\n\n\n\n\n\n\n\nWe call this function with:\n\n\n1\nsearch\n(\nlist\n,\n \n0\n,\n \nn\n-\n1\n,\n \nq\n);\n\n\n\n\n\n\n\nThe search algorithm above is called \nbinary search\n since it repeatedly cut the range of values to search by half.\n\n\nWhy is it correct?\n\n\nIt is not obvious at first glance that the code above correctly searches for \nq\nq\n in \nL\nL\n. \n\n\nLet's analyze this function more systematically by writing an assertion for this function.  What we want to do here is to eliminate elements in the array that cannot possibly contain \nq\nq\n -- these are elements outside of the \nlist[i]\n .. \nlist[j]\n range.  In other words, we want to assert that \n\n\n1\n// { q is not in list[0]..list[i-1] and list[j+1]..list[n-1] }\n\n\n\n\n\n\n\nat the beginning of the function.  In other words, this is a precondition for the function.\n\n\nLet's see if this precondition is true at the beginning.  Since \ni\ni\n is \n0\n0\n and \nj\nj\n is \nn-1\nn-1\n, the ranges \nlist[0]..list[i-1]\n and \nlist[j+1]..list[n-1]\n are empty, so the assertion is true.\n\n\nWhat happen if \ni > j\ni > j\n?  This implies that \ni - 1 > j - 1\ni - 1 > j - 1\n, so the range \nlist[0]\n..\nlist[i-1]\n and the range \nlist[j+1]\n..\nlist[n-1]\n overlap.  We can be sure that \nq\nq\n is not anywhere in \nlist\n. \n\n\nLet's see how we ensure this assertion is true in the recursive call.\n\n\n1\n2\n3\n4\n5\n       \n:\n\n  \n}\n \nelse\n \nif\n \n(\nlist\n[\nmid\n]\n \n>\n \nq\n)\n \n{\n\n    \nreturn\n \nsearch\n(\nlist\n,\n \ni\n,\n \nmid\n-\n1\n,\n \nq\n);\n\n  \n}\n \n       \n:\n\n\n\n\n\n\n\nLine 3 of the snippet above is invoked only if \nlist[mid] > q\n.  Since the array \nlist\n is sorted, we know for sure that any element in \nlist[mid+1]\n..\nlist[j]\n is larger than \nq\nq\n.  So, \nq\nq\n cannot be anywhere in that range.  We can assert, between Line 3 and Line 4 above:\n\n\n1\n// { q is not in list[0]..list[i-1] and list[mid]..list[n-1] }\n\n\n\n\n\n\n\nThus, when Line 4 is invoked, the same assertion holds true.  You can apply the same argument to the call:\n\n\n1\n  \nreturn\n \nsearch\n(\nlist\n,\n \nmid\n+\n1\n,\n \nj\n,\n \nq\n);\n\n\n\n\n\n\n\nTo summarize, we annotate the code above with the assertions:\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n/**\n\n\n * Look for q in list[i]..list[j].\n\n\n *\n\n\n * @pre list is sorted\n\n\n * @pre q is not in list[0]..list[i-1] and list[j+1]..list[n-1]\n\n\n * @return -1 if not found, the position of q in list otherwise.\n\n\n */\n\n\nlong\n \nsearch\n(\nconst\n \nlong\n \nlist\n[],\n \nlong\n \ni\n,\n \nlong\n \nj\n,\n \nlong\n \nq\n)\n \n{\n\n  \nif\n \n(\ni\n \n>\n \nj\n)\n \n{\n\n    \n// { q is not in list[0]..list[n-1] }\n\n    \nreturn\n \n-\n1\n;\n\n  \n}\n\n  \nlong\n \nmid\n \n=\n \n(\ni\n+\nj\n)\n/\n2\n;\n\n  \nif\n \n(\nlist\n[\nmid\n]\n \n==\n \nq\n)\n \n{\n\n    \nreturn\n \nmid\n;\n\n  \n}\n \nelse\n \nif\n \n(\nlist\n[\nmid\n]\n \n>\n \nq\n)\n \n{\n\n    \n// { q is not in list[0]..list[i-1] and list[mid]..list[n-1] }\n\n    \nreturn\n \nsearch\n(\nlist\n,\n \ni\n,\n \nmid\n-\n1\n,\n \nq\n);\n\n  \n}\n \n  \n// { q is not in list[0]..list[mid] and list[j]..list[n-1] }\n\n  \nreturn\n \nsearch\n(\nlist\n,\n \nmid\n+\n1\n,\n \nj\n,\n \nq\n);\n\n\n}\n\n\n\n\n\n\nHow Efficient is Binary Search\n\n\nWe have seen that if the input list is not sorted, then we minimally have to check every element in the list, leading to an \nO(n)\nO(n)\n algorithm.\n\n\nWith a sorted input and using binary search, however, we can do a better.  Let's consider the worst case, where \nq\nq\n is not in the list.  Note that every comparison we make, we reduce the range of elements to search by half, until we reach one element.  We start with \nn\nn\n elements that could possibly contain \nq\nq\n.  After one comparison, we are left with \nn/2\nn/2\n.  After another comparison, we are left with \nn/4\nn/4\n, etc.  It takes only \nO(\\log_2 n)\nO(\\log_2 n)\n steps until we reach one element in the list.  This is a big improvement over \nO(n)\nO(n)\n time!\n\n\nAppendix: Complete Code\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n#include\n \n\"cs1010.h\"\n\n\n\n/* Look for q in list[i]..list[j].\n\n\n *\n\n\n * @pre list is sorted in increasing order\n\n\n * @pre q is not in list[0]..list[i-1], list[j+1]..list[n-1]\n\n\n * @return -1 if not found, the position of q in list otherwise.\n\n\n */\n\n\nlong\n \nsearch\n(\nconst\n \nlong\n \nlist\n[],\n \nlong\n \ni\n,\n \nlong\n \nj\n,\n \nlong\n \nq\n)\n \n{\n\n  \nif\n \n(\nj\n \n<\n \ni\n)\n \n{\n\n    \nreturn\n \n-\n1\n;\n\n  \n}\n\n  \nlong\n \nmid\n \n=\n \n(\ni\n+\nj\n)\n/\n2\n;\n\n  \nif\n \n(\nlist\n[\nmid\n]\n \n==\n \nq\n)\n \n{\n\n    \nreturn\n \nmid\n;\n\n  \n}\n\n  \nif\n \n(\nlist\n[\nmid\n]\n \n>\n \nq\n)\n \n{\n\n    \nreturn\n \nsearch\n(\nlist\n,\n \ni\n,\n \nmid\n-\n1\n,\n \nq\n);\n\n  \n}\n \n  \n// { list[mid] < q }\n\n  \nreturn\n \nsearch\n(\nlist\n,\n \nmid\n+\n1\n,\n \nj\n,\n \nq\n);\n\n\n}\n\n\n\nint\n \nmain\n()\n\n\n{\n\n  \nlong\n \na\n[]\n \n=\n \n{\n1\n,\n \n3\n,\n \n5\n,\n \n9\n,\n \n11\n,\n \n13\n,\n \n14\n,\n \n19\n};\n\n  \nlong\n \nq\n \n=\n \ncs1010_read_long\n();\n\n  \ncs1010_println_long\n(\nsearch\n(\na\n,\n \n0\n,\n \n7\n,\n \nq\n));\n \n\n}",
            "title": "23. Binary Search"
        },
        {
            "location": "/23-search/index.html#unit-23-searching",
            "text": "Let's continue the discussion on efficiency on one of the fundamental problems in computing: how to look for something.  You have seen a similar problem in the problem Index in Exercise 3: Given a list of items  L L  and query item  q q , find if  q q  is in  L L .    Let's write a function to solve this.  Our function returns -1 if  q q  is not in the list.  It returns the position of  q q  in the list otherwise.  1\n2\n3\n4\n5\n6\n7 long   search ( long   n ,   const   long   list [ n ],   long   q )   { \n   for   ( long   i   =   0 ;   i   <   n ;   i   +=   1 )   { \n     if   ( list [ i ]   ==   q )   { \n       return   i ; \n   } \n   return   - 1 ;  }    What is the worst-case running time, expressed in Big-O notation, of the function above?  Suppose the query  q q  is not in the list, we will have to scan the whole list, once.  The worst case running time is, therefore,  O(n) O(n) .  Can we do better?  It turns out that this running time  O(n) O(n)  is also the best that we can do because we cannot be sure that  q q  does not exist until we check every single element in the list.  So there is no shortcut.",
            "title": "Unit 23: Searching"
        },
        {
            "location": "/23-search/index.html#binary-search",
            "text": "But, do we always have to check every element in the list?  It turns out that, like many real-life situations,  if the input list is sorted , we do not have to scan through every element.  We can eliminate a huge chunk of the elements based on whether a chosen element is bigger or smaller than  q q .  Suppose that the input list is sorted in increasing order.  Pick a random element  x x  from the list.  Any element to the left of  x x  must be less than or equal to  x x , and any element to the right of  x x  must be greater or equal to  x x .   Suppose that  q > x q > x , then we know that  q q  must be to the right of  x x , there is no need to search to the left of  x x .  Otherwise,  q < x q < x , and  q q  must be to the left of  x x , and there is no need to search to the right of  x x .  We can code this out using a recursive function below:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18 /**   * Look for q in list[i]..list[j].   *   * @pre list is sorted   * @return -1 if not found, the position of q in list otherwise.   */  long   search ( const   long   list [],   long   i ,   long   j ,   long   q )   { \n   if   ( i   >   j )   { \n     return   - 1 ; \n   } \n   long   mid   =   ( i + j ) / 2 ; \n   if   ( list [ mid ]   ==   q )   { \n     return   mid ; \n   }   else   if   ( list [ mid ]   >   q )   { \n     return   search ( list ,   i ,   mid - 1 ,   q ); \n   }  \n   return   search ( list ,   mid + 1 ,   j ,   q );  }    We call this function with:  1 search ( list ,   0 ,   n - 1 ,   q );    The search algorithm above is called  binary search  since it repeatedly cut the range of values to search by half.",
            "title": "Binary Search"
        },
        {
            "location": "/23-search/index.html#why-is-it-correct",
            "text": "It is not obvious at first glance that the code above correctly searches for  q q  in  L L .   Let's analyze this function more systematically by writing an assertion for this function.  What we want to do here is to eliminate elements in the array that cannot possibly contain  q q  -- these are elements outside of the  list[i]  ..  list[j]  range.  In other words, we want to assert that   1 // { q is not in list[0]..list[i-1] and list[j+1]..list[n-1] }    at the beginning of the function.  In other words, this is a precondition for the function.  Let's see if this precondition is true at the beginning.  Since  i i  is  0 0  and  j j  is  n-1 n-1 , the ranges  list[0]..list[i-1]  and  list[j+1]..list[n-1]  are empty, so the assertion is true.  What happen if  i > j i > j ?  This implies that  i - 1 > j - 1 i - 1 > j - 1 , so the range  list[0] .. list[i-1]  and the range  list[j+1] .. list[n-1]  overlap.  We can be sure that  q q  is not anywhere in  list .   Let's see how we ensure this assertion is true in the recursive call.  1\n2\n3\n4\n5         : \n   }   else   if   ( list [ mid ]   >   q )   { \n     return   search ( list ,   i ,   mid - 1 ,   q ); \n   }  \n        :    Line 3 of the snippet above is invoked only if  list[mid] > q .  Since the array  list  is sorted, we know for sure that any element in  list[mid+1] .. list[j]  is larger than  q q .  So,  q q  cannot be anywhere in that range.  We can assert, between Line 3 and Line 4 above:  1 // { q is not in list[0]..list[i-1] and list[mid]..list[n-1] }    Thus, when Line 4 is invoked, the same assertion holds true.  You can apply the same argument to the call:  1    return   search ( list ,   mid + 1 ,   j ,   q );    To summarize, we annotate the code above with the assertions:  1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22 /**   * Look for q in list[i]..list[j].   *   * @pre list is sorted   * @pre q is not in list[0]..list[i-1] and list[j+1]..list[n-1]   * @return -1 if not found, the position of q in list otherwise.   */  long   search ( const   long   list [],   long   i ,   long   j ,   long   q )   { \n   if   ( i   >   j )   { \n     // { q is not in list[0]..list[n-1] } \n     return   - 1 ; \n   } \n   long   mid   =   ( i + j ) / 2 ; \n   if   ( list [ mid ]   ==   q )   { \n     return   mid ; \n   }   else   if   ( list [ mid ]   >   q )   { \n     // { q is not in list[0]..list[i-1] and list[mid]..list[n-1] } \n     return   search ( list ,   i ,   mid - 1 ,   q ); \n   }  \n   // { q is not in list[0]..list[mid] and list[j]..list[n-1] } \n   return   search ( list ,   mid + 1 ,   j ,   q );  }",
            "title": "Why is it correct?"
        },
        {
            "location": "/23-search/index.html#how-efficient-is-binary-search",
            "text": "We have seen that if the input list is not sorted, then we minimally have to check every element in the list, leading to an  O(n) O(n)  algorithm.  With a sorted input and using binary search, however, we can do a better.  Let's consider the worst case, where  q q  is not in the list.  Note that every comparison we make, we reduce the range of elements to search by half, until we reach one element.  We start with  n n  elements that could possibly contain  q q .  After one comparison, we are left with  n/2 n/2 .  After another comparison, we are left with  n/4 n/4 , etc.  It takes only  O(\\log_2 n) O(\\log_2 n)  steps until we reach one element in the list.  This is a big improvement over  O(n) O(n)  time!",
            "title": "How Efficient is Binary Search"
        },
        {
            "location": "/23-search/index.html#appendix-complete-code",
            "text": "1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29 #include   \"cs1010.h\"  /* Look for q in list[i]..list[j].   *   * @pre list is sorted in increasing order   * @pre q is not in list[0]..list[i-1], list[j+1]..list[n-1]   * @return -1 if not found, the position of q in list otherwise.   */  long   search ( const   long   list [],   long   i ,   long   j ,   long   q )   { \n   if   ( j   <   i )   { \n     return   - 1 ; \n   } \n   long   mid   =   ( i + j ) / 2 ; \n   if   ( list [ mid ]   ==   q )   { \n     return   mid ; \n   } \n   if   ( list [ mid ]   >   q )   { \n     return   search ( list ,   i ,   mid - 1 ,   q ); \n   }  \n   // { list[mid] < q } \n   return   search ( list ,   mid + 1 ,   j ,   q );  }  int   main ()  { \n   long   a []   =   { 1 ,   3 ,   5 ,   9 ,   11 ,   13 ,   14 ,   19 }; \n   long   q   =   cs1010_read_long (); \n   cs1010_println_long ( search ( a ,   0 ,   7 ,   q ));   }",
            "title": "Appendix: Complete Code"
        },
        {
            "location": "/24-sort/index.html",
            "text": "Unit 24: Sorting\n\n\nSorting is one of the most fundamental computational problem.  Given a list of items, we want to rearrange the items in some order.\n\n\nWe have actually seen two algorithms to sort in this module: counting sort and selection sort.  We are going to see two more today.\n\n\nBubble Sort\n\n\nBubble sort is probably the most well known, under-performed sorting algorithm\n1\n, but is taught in most CS classes because of its simplicity.  The idea of bubble sort is to make multiple passes through the list.  In each pass, we look for all possible adjacent pair of items.  Any adjacent pair that is out of order are swapped so that they are in order.  This process repeats until everything is in order.\n\n\nLet's look at an example.  Suppose we have, as an input, the numbers \n8 4 23 42 16 15\n.  In the first pass, we starts from the first item and check from left to right.  The pair \n8 4\n is out of order, so we swap them, and we get \n4 8 23 42 16 15\n.  The pair \n8 23\n and \n23 42\n are in order, so we do not need to swap them.  The pair \n42 16\n is out of order.  We swap them and get \n4 8 23 16 42 15\n.  The pair \n42 15\n is again out of order, so we swap them and get \n4 8 23 16 15 42\n.\n\n\nThe following sequence show the first pass through the array:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n \n8\n  \n4\n \n23\n \n42\n \n16\n \n15\n   \n<-\n swap\n\n--\n \n--\n\n \n4\n  \n8\n \n23\n \n42\n \n16\n \n15\n  \n   \n--\n \n--\n \n \n4\n  \n8\n \n23\n \n42\n \n16\n \n15\n  \n      \n--\n \n--\n\n \n4\n  \n8\n \n23\n \n42\n \n16\n \n15\n   \n<-\n swap\n         \n--\n \n--\n\n \n4\n  \n8\n \n23\n \n16\n \n42\n \n15\n   \n<-\n swap\n            \n--\n \n--\n\n \n4\n  \n8\n \n23\n \n16\n \n15\n \n42\n  \n\n\n\n\n\n\nAfter the first pass, notice that the largest element, 42, \"bubbles\" up through the list until it reaches the maximum position.  We can now make the second pass, but we can exclude the last item, since it is already in place.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n \n4\n  \n8\n \n23\n \n16\n \n15\n \n42\n  \n\n--\n \n--\n\n \n4\n  \n8\n \n23\n \n16\n \n15\n \n42\n  \n   \n--\n \n--\n \n \n4\n  \n8\n \n23\n \n16\n \n15\n \n42\n   \n<-\n swap\n      \n--\n \n--\n\n \n4\n  \n8\n \n16\n \n23\n \n15\n \n42\n   \n<-\n swap\n         \n--\n \n--\n\n \n4\n  \n8\n \n16\n \n15\n \n23\n \n42\n   \n         \n--\n \n--\n\n\n\n\n\n\n\nAfter the second pass, the second largest element, 23, is in its position.  So we can exclude this item in the subsequent pass.\n\n\nThe rest of the passes operates similarly.  In the \ni\ni\n-th pass, we scan through array item 0 to \nn-i\nn-i\n, swapping any adjacent element that is out of order, until \ni = n - 1\ni = n - 1\n, in which case we only have two elements, we swap them if we are out of order, and we are done!\n\n\nThe code for bubble sort can be written as follows:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\nvoid\n \nbubble_pass\n(\nlong\n \nlast\n,\n \nlong\n \na\n[])\n \n\n{\n\n  \nfor\n \n(\nlong\n \ni\n \n=\n \n0\n;\n \ni\n \n<\n \nlast\n;\n \ni\n \n+=\n \n1\n)\n \n{\n\n    \nif\n \n(\na\n[\ni\n]\n \n>\n \na\n[\ni\n+\n1\n])\n \n{\n\n      \nswap\n(\na\n,\n \ni\n,\n \ni\n+\n1\n);\n\n    \n}\n\n  \n}\n\n\n}\n\n\n\nvoid\n \nbubble_sort\n(\nlong\n \nn\n,\n \nlong\n \na\n[\nn\n])\n \n{\n\n  \nfor\n \n(\nlong\n \nlast\n \n=\n \nn\n \n-\n \n1\n;\n \nlast\n \n>\n \n0\n;\n \nlast\n \n-=\n \n1\n)\n \n{\n\n    \nbubble_pass\n(\nlast\n,\n \na\n);\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\nHow many steps does it take to bubble-sort an array of \nn\nn\n elements?   Since the \ni\ni\n-th pass scans through \nn-i\nn-i\n elements, and there are a \nn\nn\n passes in total, the analysis is similar to the one we did for the algorithm to compute the Kendall-tau distance -- bubble sort takes \nO(n^2)\nO(n^2)\n steps.\n\n\nInsertion Sort\n\n\nThe next sorting algorithm we are going to discuss is insertion sort.  This is another classic algorithm, that could perform better than bubble sort in some scenario.  The idea of insertion sort is simple: we partition the input list into two, a sorted partition, and an unsorted partition.  Then we repeatedly take the first element from the unsorted partition, find its rightful place in the sorted partition, and \ninsert\n it into place.  We start with a sorted partition of one element, and we end if the sorted partition contains all the elements.\n\n\nTake \n8 4 23 42 16 15\n as an example.  I will use \n|\n to partition the array into a left sorted partition, and a right, unsorted, partition.  \n\n\n1\n8 | 4 23 42 16 15 \n\n\n\n\n\n\nWe pick the first element on the unsorted partition, 4, and insert it into the sorted partition.  This involves shifting the elements in the sorted partition to the right until we find the rightful place for \n4\n.   After this step, the sorted partition grows by 1 and the unsorted partition shrinks by 1.\n\n\n1\n4 8 | 23 42 16 15 \n\n\n\n\n\n\nIn the next round, we take \n23\n, and finds its rightful place.  It turns out \n23\n is already in its correct place.\n\n\n1\n4 8 23 | 42 16 15 \n\n\n\n\n\nIn the next step, \n42\n is also in its correct place.\n\n1\n4 8 23 42 | 16 15 \n\n\n\n\n\n16\n is next element, and we insert it between 8 and 23.\n\n1\n4 8 16 23 42 | 15 \n\n\n\n\n\nFinally we insert \n15\n and we are done, as there is no more element in the unsorted partition.\n\n1\n4 8 15 16 23 42\n\n\n\n\n\nThe code for insertion sort can be written as follows:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\nvoid\n \ninsert\n(\nlong\n \na\n[],\n \nlong\n \ncurr\n)\n\n\n{\n\n  \nlong\n \ni\n \n=\n \ncurr\n \n-\n \n1\n;\n\n  \nlong\n \ntemp\n \n=\n \na\n[\ncurr\n];\n\n  \nwhile\n \n(\ntemp\n \n<\n \na\n[\ni\n]\n \n&&\n \ni\n \n>=\n \n0\n)\n \n{\n\n    \na\n[\ni\n+\n1\n]\n \n=\n \na\n[\ni\n];\n\n    \ni\n \n-=\n \n1\n;\n\n  \n}\n\n  \na\n[\ni\n+\n1\n]\n \n=\n \ntemp\n;\n\n\n}\n\n\n\nvoid\n \ninsertion_sort\n(\nlong\n \nn\n,\n \nlong\n \na\n[\nn\n])\n \n{\n\n  \nfor\n \n(\nlong\n \ncurr\n \n=\n \n1\n;\n \ncurr\n \n<\n \nn\n;\n \ncurr\n \n+=\n \n1\n)\n \n{\n\n    \ninsert\n(\na\n,\n \ncurr\n);\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\nAnimation\n\n\nAnimations for various sorting algorithms, including some which you will learn in CS2040C, are available online on \nVisuAlgo\n\n\nProblem Set 24\n\n\nProblem 24.1\n\n\nIn the implementation of bubble sort above, we always make \nn-1\nn-1\n passes through the array.  It is, however, possible to stop the whole sorting procedure, when a pass through the array does not lead to any swapping.  Modify the code above to achieve this optimization.\n\n\nProblem 24.2\n\n\na) Suppose the input list to insertion sort is already sorted.  What is the running time of insertion sort?\nb) Suppose the input list to insertion sort is inversely sorted.  What is the running time of insertion sort?\n\n\nProblem 24.3\n\n\nWhat is the loop invariant for the loop in the function \ninsert\n? \n\n\nAppendix: Complete Code From Lecture\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n#include\n \n<assert.h>\n\n\n#include\n \n\"cs1010.h\"\n\n\n\nvoid\n \nswap\n(\nlong\n \na\n[],\n \nint\n \ni\n,\n \nint\n \nj\n)\n \n{\n\n  \nlong\n \ntemp\n \n=\n \na\n[\ni\n];\n\n  \na\n[\ni\n]\n \n=\n \na\n[\nj\n];\n\n  \na\n[\nj\n]\n \n=\n \ntemp\n;\n\n\n}\n\n\n\nvoid\n \nprint\n(\nlong\n \nlen\n,\n \nlong\n \na\n[\nlen\n])\n \n{\n\n  \nfor\n \n(\nlong\n \ni\n \n=\n \n0\n;\n \ni\n \n<\n \nlen\n;\n \ni\n \n+=\n \n1\n)\n \n{\n\n    \ncs1010_print_long\n(\na\n[\ni\n]);\n\n    \ncs1010_print_string\n(\n\" \"\n);\n\n  \n}\n\n  \ncs1010_println_string\n(\n\"\"\n);\n\n\n}\n\n\n\nvoid\n \nbubble_pass\n(\nlong\n \nlast\n,\n \nlong\n \na\n[])\n \n{\n\n  \nfor\n \n(\nlong\n \ni\n \n=\n \n0\n;\n \ni\n \n<\n \nlast\n \n-\n \n1\n;\n \ni\n \n+=\n \n1\n)\n \n{\n\n    \nif\n \n(\na\n[\ni\n]\n \n>\n \na\n[\ni\n+\n1\n])\n \n{\n\n      \nswap\n(\na\n,\n \ni\n,\n \ni\n+\n1\n);\n\n    \n}\n\n  \n}\n\n  \nprint\n(\n6\n,\n \na\n);\n\n\n}\n\n\n\nvoid\n \nbubble_sort\n(\nlong\n \nlen\n,\n \nlong\n \na\n[\nlen\n])\n \n{\n\n  \nfor\n \n(\nlong\n \nlast\n \n=\n \nlen\n \n-\n \n1\n;\n \nlast\n \n>\n \n0\n;\n \nlast\n \n-=\n \n1\n)\n \n{\n\n    \nbubble_pass\n(\nlast\n,\n \na\n);\n\n  \n}\n\n\n}\n\n\n\nint\n \nmain\n()\n\n\n{\n\n  \nlong\n \na\n[]\n \n=\n \n{\n44\n,\n \n4\n,\n \n23\n,\n \n42\n,\n \n16\n,\n \n15\n};\n\n  \nbubble_sort\n(\n6\n,\n \na\n);\n\n  \nprint\n(\n6\n,\n \na\n);\n\n\n}\n\n\n\n\n\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n#include\n \n\"cs1010.h\"\n\n\n\nvoid\n \nprint\n(\nlong\n \nlen\n,\n \nlong\n \na\n[\nlen\n])\n \n{\n\n  \nfor\n \n(\nlong\n \ni\n \n=\n \n0\n;\n \ni\n \n<\n \nlen\n;\n \ni\n \n+=\n \n1\n)\n \n{\n\n    \ncs1010_print_long\n(\na\n[\ni\n]);\n\n    \ncs1010_print_string\n(\n\" \"\n);\n\n  \n}\n\n  \ncs1010_println_string\n(\n\"\"\n);\n\n\n}\n\n\n\nvoid\n \ninsert\n(\nlong\n \na\n[],\n \nlong\n \ncurr\n)\n \n{\n\n  \n// insert a[curr] into a[0]..a[curr-1] in the right position\n\n  \nlong\n \ntemp\n \n=\n \na\n[\ncurr\n];\n\n  \nlong\n \ni\n \n=\n \ncurr\n \n-\n \n1\n;\n\n  \nwhile\n \n(\ntemp\n \n<\n \na\n[\ni\n]\n \n&&\n \ni\n \n>=\n \n0\n)\n \n{\n\n    \na\n[\ni\n+\n1\n]\n \n=\n \na\n[\ni\n];\n\n    \ni\n \n-=\n \n1\n;\n\n  \n}\n\n  \n// { temp >= a[i] || i < 0 }\n\n  \na\n[\ni\n+\n1\n]\n \n=\n \ntemp\n;\n\n\n}\n\n\n\nvoid\n \ninsertion_sort\n(\nlong\n \nn\n,\n \nlong\n \na\n[\nn\n])\n \n{\n\n  \nfor\n \n(\nlong\n \ncurr\n \n=\n \n1\n;\n \ncurr\n \n<\n \nn\n;\n \ncurr\n \n+=\n \n1\n)\n \n{\n\n    \ninsert\n(\na\n,\n \ncurr\n);\n\n    \nprint\n(\nn\n,\n \na\n);\n\n  \n}\n\n\n}\n\n\n\nint\n \nmain\n()\n\n\n{\n\n  \nlong\n \na\n[]\n \n=\n \n{\n44\n,\n \n4\n,\n \n23\n,\n \n42\n,\n \n16\n,\n \n15\n};\n\n  \ninsertion_sort\n(\n6\n,\n \na\n);\n\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nhttps://www.youtube.com/watch?v=k4RRi_ntQc8\n\u00a0\n\u21a9",
            "title": "24. Sorting"
        },
        {
            "location": "/24-sort/index.html#unit-24-sorting",
            "text": "Sorting is one of the most fundamental computational problem.  Given a list of items, we want to rearrange the items in some order.  We have actually seen two algorithms to sort in this module: counting sort and selection sort.  We are going to see two more today.",
            "title": "Unit 24: Sorting"
        },
        {
            "location": "/24-sort/index.html#bubble-sort",
            "text": "Bubble sort is probably the most well known, under-performed sorting algorithm 1 , but is taught in most CS classes because of its simplicity.  The idea of bubble sort is to make multiple passes through the list.  In each pass, we look for all possible adjacent pair of items.  Any adjacent pair that is out of order are swapped so that they are in order.  This process repeats until everything is in order.  Let's look at an example.  Suppose we have, as an input, the numbers  8 4 23 42 16 15 .  In the first pass, we starts from the first item and check from left to right.  The pair  8 4  is out of order, so we swap them, and we get  4 8 23 42 16 15 .  The pair  8 23  and  23 42  are in order, so we do not need to swap them.  The pair  42 16  is out of order.  We swap them and get  4 8 23 16 42 15 .  The pair  42 15  is again out of order, so we swap them and get  4 8 23 16 15 42 .  The following sequence show the first pass through the array:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11   8    4   23   42   16   15     <-  swap --   -- \n  4    8   23   42   16   15   \n    --   --  \n  4    8   23   42   16   15   \n       --   -- \n  4    8   23   42   16   15     <-  swap\n          --   -- \n  4    8   23   16   42   15     <-  swap\n             --   -- \n  4    8   23   16   15   42      After the first pass, notice that the largest element, 42, \"bubbles\" up through the list until it reaches the maximum position.  We can now make the second pass, but we can exclude the last item, since it is already in place.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10   4    8   23   16   15   42    --   -- \n  4    8   23   16   15   42   \n    --   --  \n  4    8   23   16   15   42     <-  swap\n       --   -- \n  4    8   16   23   15   42     <-  swap\n          --   -- \n  4    8   16   15   23   42    \n          --   --    After the second pass, the second largest element, 23, is in its position.  So we can exclude this item in the subsequent pass.  The rest of the passes operates similarly.  In the  i i -th pass, we scan through array item 0 to  n-i n-i , swapping any adjacent element that is out of order, until  i = n - 1 i = n - 1 , in which case we only have two elements, we swap them if we are out of order, and we are done!  The code for bubble sort can be written as follows:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14 void   bubble_pass ( long   last ,   long   a [])   { \n   for   ( long   i   =   0 ;   i   <   last ;   i   +=   1 )   { \n     if   ( a [ i ]   >   a [ i + 1 ])   { \n       swap ( a ,   i ,   i + 1 ); \n     } \n   }  }  void   bubble_sort ( long   n ,   long   a [ n ])   { \n   for   ( long   last   =   n   -   1 ;   last   >   0 ;   last   -=   1 )   { \n     bubble_pass ( last ,   a ); \n   }  }    How many steps does it take to bubble-sort an array of  n n  elements?   Since the  i i -th pass scans through  n-i n-i  elements, and there are a  n n  passes in total, the analysis is similar to the one we did for the algorithm to compute the Kendall-tau distance -- bubble sort takes  O(n^2) O(n^2)  steps.",
            "title": "Bubble Sort"
        },
        {
            "location": "/24-sort/index.html#insertion-sort",
            "text": "The next sorting algorithm we are going to discuss is insertion sort.  This is another classic algorithm, that could perform better than bubble sort in some scenario.  The idea of insertion sort is simple: we partition the input list into two, a sorted partition, and an unsorted partition.  Then we repeatedly take the first element from the unsorted partition, find its rightful place in the sorted partition, and  insert  it into place.  We start with a sorted partition of one element, and we end if the sorted partition contains all the elements.  Take  8 4 23 42 16 15  as an example.  I will use  |  to partition the array into a left sorted partition, and a right, unsorted, partition.    1 8 | 4 23 42 16 15    We pick the first element on the unsorted partition, 4, and insert it into the sorted partition.  This involves shifting the elements in the sorted partition to the right until we find the rightful place for  4 .   After this step, the sorted partition grows by 1 and the unsorted partition shrinks by 1.  1 4 8 | 23 42 16 15    In the next round, we take  23 , and finds its rightful place.  It turns out  23  is already in its correct place.  1 4 8 23 | 42 16 15    In the next step,  42  is also in its correct place. 1 4 8 23 42 | 16 15    16  is next element, and we insert it between 8 and 23. 1 4 8 16 23 42 | 15    Finally we insert  15  and we are done, as there is no more element in the unsorted partition. 1 4 8 15 16 23 42   The code for insertion sort can be written as follows:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16 void   insert ( long   a [],   long   curr )  { \n   long   i   =   curr   -   1 ; \n   long   temp   =   a [ curr ]; \n   while   ( temp   <   a [ i ]   &&   i   >=   0 )   { \n     a [ i + 1 ]   =   a [ i ]; \n     i   -=   1 ; \n   } \n   a [ i + 1 ]   =   temp ;  }  void   insertion_sort ( long   n ,   long   a [ n ])   { \n   for   ( long   curr   =   1 ;   curr   <   n ;   curr   +=   1 )   { \n     insert ( a ,   curr ); \n   }  }",
            "title": "Insertion Sort"
        },
        {
            "location": "/24-sort/index.html#animation",
            "text": "Animations for various sorting algorithms, including some which you will learn in CS2040C, are available online on  VisuAlgo",
            "title": "Animation"
        },
        {
            "location": "/24-sort/index.html#problem-set-24",
            "text": "",
            "title": "Problem Set 24"
        },
        {
            "location": "/24-sort/index.html#problem-241",
            "text": "In the implementation of bubble sort above, we always make  n-1 n-1  passes through the array.  It is, however, possible to stop the whole sorting procedure, when a pass through the array does not lead to any swapping.  Modify the code above to achieve this optimization.",
            "title": "Problem 24.1"
        },
        {
            "location": "/24-sort/index.html#problem-242",
            "text": "a) Suppose the input list to insertion sort is already sorted.  What is the running time of insertion sort?\nb) Suppose the input list to insertion sort is inversely sorted.  What is the running time of insertion sort?",
            "title": "Problem 24.2"
        },
        {
            "location": "/24-sort/index.html#problem-243",
            "text": "What is the loop invariant for the loop in the function  insert ?",
            "title": "Problem 24.3"
        },
        {
            "location": "/24-sort/index.html#appendix-complete-code-from-lecture",
            "text": "1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38 #include   <assert.h>  #include   \"cs1010.h\"  void   swap ( long   a [],   int   i ,   int   j )   { \n   long   temp   =   a [ i ]; \n   a [ i ]   =   a [ j ]; \n   a [ j ]   =   temp ;  }  void   print ( long   len ,   long   a [ len ])   { \n   for   ( long   i   =   0 ;   i   <   len ;   i   +=   1 )   { \n     cs1010_print_long ( a [ i ]); \n     cs1010_print_string ( \" \" ); \n   } \n   cs1010_println_string ( \"\" );  }  void   bubble_pass ( long   last ,   long   a [])   { \n   for   ( long   i   =   0 ;   i   <   last   -   1 ;   i   +=   1 )   { \n     if   ( a [ i ]   >   a [ i + 1 ])   { \n       swap ( a ,   i ,   i + 1 ); \n     } \n   } \n   print ( 6 ,   a );  }  void   bubble_sort ( long   len ,   long   a [ len ])   { \n   for   ( long   last   =   len   -   1 ;   last   >   0 ;   last   -=   1 )   { \n     bubble_pass ( last ,   a ); \n   }  }  int   main ()  { \n   long   a []   =   { 44 ,   4 ,   23 ,   42 ,   16 ,   15 }; \n   bubble_sort ( 6 ,   a ); \n   print ( 6 ,   a );  }     1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34 #include   \"cs1010.h\"  void   print ( long   len ,   long   a [ len ])   { \n   for   ( long   i   =   0 ;   i   <   len ;   i   +=   1 )   { \n     cs1010_print_long ( a [ i ]); \n     cs1010_print_string ( \" \" ); \n   } \n   cs1010_println_string ( \"\" );  }  void   insert ( long   a [],   long   curr )   { \n   // insert a[curr] into a[0]..a[curr-1] in the right position \n   long   temp   =   a [ curr ]; \n   long   i   =   curr   -   1 ; \n   while   ( temp   <   a [ i ]   &&   i   >=   0 )   { \n     a [ i + 1 ]   =   a [ i ]; \n     i   -=   1 ; \n   } \n   // { temp >= a[i] || i < 0 } \n   a [ i + 1 ]   =   temp ;  }  void   insertion_sort ( long   n ,   long   a [ n ])   { \n   for   ( long   curr   =   1 ;   curr   <   n ;   curr   +=   1 )   { \n     insert ( a ,   curr ); \n     print ( n ,   a ); \n   }  }  int   main ()  { \n   long   a []   =   { 44 ,   4 ,   23 ,   42 ,   16 ,   15 }; \n   insertion_sort ( 6 ,   a );  }        https://www.youtube.com/watch?v=k4RRi_ntQc8 \u00a0 \u21a9",
            "title": "Appendix: Complete Code From Lecture"
        },
        {
            "location": "/25-tower/index.html",
            "text": "Unit 25: Tower of Hanoi\n\n\nIn this unit and the next, we will see how we can use recursion to solve more complex problems.  We will start with the Tower of Hanoi problem in this unit.\n\n\nThe Tower of Hanoi problem is a famous mathematical puzzle invented by French mathematician \u00c9douard Lucas in 1883.  It goes like this: There are three pegs and \nn\nn\n disks of various size that we can slide into any of the pegs.  There are a few rules that we have to obey: \n\n\n\n\nwe can only move one disk at a time;\n\n\nwe can only move the topmost disk from one peg and place the disk on another peg;\n\n\nno disk can be placed on top of a smaller disk.\n\n\n\n\nIn the beginning, we have all the disks in one peg.  The goal is to move all the disks onto another peg.  \n\n\nWikipedia has the following animation showing how to solve the puzzle with 4 disks in 15 steps.  \n\n\n\n\n\nby Andr\u00e9 Karwath aka \nAka\n - \nOwn work\n, \nCC BY-SA 2.5\n, \nLink\n\n\n\n\nYou can play a \nversion online here\n\n\nUsing Recursion\n\n\nRecall the two steps in recursive problem solving: (i) reduce the problem to the simplest version where we can solve it trivially; and (ii) assuming that we can solve the simpler version of the problem, we combine the solution to solve the more complex version.\n\n\nWhat is the simplest version of the Tower of Hanoi puzzle?  It is the version with only a single disk.  In this version, the solution is trivial -- we just move the disk from the source peg to the destination peg\n\n\nLet's label the pegs A, B, and C, with A being the source and C being the destination.  We will use peg B as the temporary placeholder.  \n\n\nNow, let's assume that we can solve the Tower of Hanoi puzzle for \nk-1\nk-1\n disks.  How can we solve the puzzle for \nk\nk\n disks?  It turns out the solution is equally trivial.  First, move the top \nk-1\nk-1\n disk from A to B.  This would free up the largest disk, which we move from A to C.  Then, we move the \nk-1\nk-1\n disk from B to C.\n\n\n\n\n\n\nThe figures above illustrate the recursion steps.  The first figure shows the original configuration.  The second figure shows the recursive step -- by wishful thinking, we believe that we can solve the puzzle for \nk-1\nk-1\n disks and move \nk-1\nk-1\n disks from A to B, using C as the placeholder.  The third figure shows the move after moving the largest disk from A to C.  The last figure shows the move of \nk-1\nk-1\n disks from B to C.  Now that A is empty, the last move uses A as the placeholder.\n\n\nRepresenting the Tower of Hanoi in Code\n\n\nTo write a solution for the Tower of Hanoi, we need to decide how to represent the disks and the pegs in our code.  We are going to \nabstract\n out only the necessary details.  Such an abstraction process is similar to what we have done so far, representing elevations data as integers, student ids as integers, etc.  Here, we are representing physical objects, but note that the actual size of the disks, the location of the pegs, etc, do not matter in our code.  As such, we will represent the disks with integers 1 to \nk\nk\n (1 being smallest, \nk\nk\n being the largest) and pegs with integers 1 to 3.\n\n\nThe Solution\n\n\nLet's write the code for a function \nvoid solve_tower_of_hanoi(long k, long source, long dest)\n, which will print out the solution for moving \nk\nk\n disks from the peg \nsource\n to the peg \ndest\n.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\nvoid\n \nsolve_tower_of_hanoi\n(\nlong\n \nk\n,\n \nlong\n \nsource\n,\n \nlong\n \ndest\n,\n \nlong\n \nplaceholder\n)\n \n{\n\n  \nif\n \n(\nk\n \n==\n \n1\n)\n \n{\n\n    \nprint\n(\nk\n,\n \nsource\n,\n \ndest\n);\n\n  \n}\n\n  \nelse\n \n{\n\n    \nsolve_tower_of_hanoi\n(\nk\n \n-\n \n1\n,\n \nsource\n,\n \nplaceholder\n,\n \ndest\n);\n\n    \nprint\n(\nk\n,\n \nsource\n,\n \ndest\n);\n\n    \nsolve_tower_of_hanoi\n(\nk\n \n-\n \n1\n,\n \nplaceholder\n,\n \ndest\n,\n \nsource\n);\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\nwhere \nprint\n is a helper function to display the move to standard output.\n\n1\n2\n3\n4\n5\n6\n7\n8\nvoid\n \nprint\n(\nlong\n \nk\n,\n \nlong\n \nsource\n,\n \nlong\n \ndest\n)\n \n{\n\n  \ncs1010_print_string\n(\n\"Disk \"\n);\n\n  \ncs1010_print_long\n(\nk\n);\n\n  \ncs1010_print_string\n(\n\": Peg \"\n);\n\n  \ncs1010_print_long\n(\nsource\n);\n\n  \ncs1010_print_string\n(\n\" -> Peg \"\n);\n\n  \ncs1010_print_long\n(\ndest\n);\n\n\n}\n\n\n\n\n\n\nRunning Time\n\n\nHow many moves does it take to solve the Tower of Hanoi puzzle with \nk\nk\n disks?  \n\n\nIf \nk\nk\n is 1, then it takes one move.  Otherwise, let us denote the number of moves taken as \nT(k)\nT(k)\n.  From the code, we can see that it takes \nT(k) = 2T(k-1) + 1\nT(k) = 2T(k-1) + 1\n.\n\n\nAn equation of this form is called a \nrecurrance equation\n.  You can learn how to solve such equations generally in later modules (e.g., CS3230), but, for now, we will expand the equation to derive the solution for \nT(k)\nT(k)\n.\n\n\nYou can see that:\n\n\n\n\nT(k) = 2T(k-1) + 1 = 4T(k-2) + 2 + 1 = 8T(k-3) + 4 + 2 + 1 = ...\n\n\nT(k) = 2T(k-1) + 1 = 4T(k-2) + 2 + 1 = 8T(k-3) + 4 + 2 + 1 = ...\n\n\n\n\nSo,\n\n\n\n\nT(k) = 2^{k-1}T(1) + 2^{k-2} + ... + 4 + 2 + 1\n\n\nT(k) = 2^{k-1}T(1) + 2^{k-2} + ... + 4 + 2 + 1\n\n\n\n\nSince \nT(1) = 1\nT(1) = 1\n, we have\n\n\n\n\nT(k) = 2^{k-1} + 2^{k-2} + ... + 4 + 2 + 1 = 2^k - 1\n\n\nT(k) = 2^{k-1} + 2^{k-2} + ... + 4 + 2 + 1 = 2^k - 1\n\n\n\n\nThus, solving the Tower of Hanoi with \nk\nk\n disks takes \n2^k-1\n2^k-1\n steps.   \n\n\nProblem Set\n\n\nProblem 25.1\n\n\nSuppose that we add a new restriction to the Tower of Hanoi puzzle.  Let's say that the disks are on Peg A (or Peg 1) to begin with, and \n we want to move the disk to Peg C (or Peg 3). \n We are only allowed to move a disk either to \n Peg A \n Peg B from another peg or from \n Peg A \n Peg B to another peg.  In other words, we cannot move the disks between \n Peg B or Peg C. \n Peg A and Peg C directly.\n\n\nChange the recursive algorithm above to solve the Tower of Hanoi with this new restriction.  How many steps (use big O notation) are needed now?\n\n\nAppendix: Complete Code\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n#include\n \n\"cs1010.h\"\n\n\n\n/**\n\n\n * Move Disk k from Peg source to Peg dest.\n\n\n *\n\n\n * @param[in] k The disk to move\n\n\n * @param[in] source The peg Disk k is currently at.\n\n\n * @param[in] dest The peg Disk k is moved to.\n\n\n */\n\n\nvoid\n \nmove\n(\nlong\n \nk\n,\n \nlong\n \nsource\n,\n \nlong\n \ndest\n)\n \n{\n\n  \ncs1010_print_string\n(\n\"Disk \"\n);\n\n  \ncs1010_print_long\n(\nk\n);\n\n  \ncs1010_print_string\n(\n\": Peg \"\n);\n\n  \ncs1010_print_long\n(\nsource\n);\n\n  \ncs1010_print_string\n(\n\" -> Peg \"\n);\n\n  \ncs1010_println_long\n(\ndest\n);\n\n\n}\n\n\n\nvoid\n \nsolve\n(\nlong\n \nk\n,\n \nlong\n \nsource\n,\n \nlong\n \ndest\n,\n \nlong\n \nplaceholder\n)\n \n{\n\n  \nif\n \n(\nk\n \n==\n \n1\n)\n \n{\n\n    \nmove\n(\nk\n,\n \nsource\n,\n \ndest\n);\n\n    \nreturn\n;\n\n  \n}\n\n\n  \nsolve\n(\nk\n \n-\n \n1\n,\n \nsource\n,\n \nplaceholder\n,\n \ndest\n);\n\n  \nmove\n(\nk\n,\n \nsource\n,\n \ndest\n);\n\n  \nsolve\n(\nk\n \n-\n \n1\n,\n \nplaceholder\n,\n \ndest\n,\n \nsource\n);\n\n\n}\n\n\n\nint\n \nmain\n()\n \n{\n\n  \nlong\n \nk\n \n=\n \ncs1010_read_long\n();\n\n  \nsolve\n(\nk\n,\n \n1\n,\n \n3\n,\n \n2\n);\n\n\n}",
            "title": "25. Tower of Hanoi"
        },
        {
            "location": "/25-tower/index.html#unit-25-tower-of-hanoi",
            "text": "In this unit and the next, we will see how we can use recursion to solve more complex problems.  We will start with the Tower of Hanoi problem in this unit.  The Tower of Hanoi problem is a famous mathematical puzzle invented by French mathematician \u00c9douard Lucas in 1883.  It goes like this: There are three pegs and  n n  disks of various size that we can slide into any of the pegs.  There are a few rules that we have to obey:    we can only move one disk at a time;  we can only move the topmost disk from one peg and place the disk on another peg;  no disk can be placed on top of a smaller disk.   In the beginning, we have all the disks in one peg.  The goal is to move all the disks onto another peg.    Wikipedia has the following animation showing how to solve the puzzle with 4 disks in 15 steps.     \nby Andr\u00e9 Karwath aka  Aka  -  Own work ,  CC BY-SA 2.5 ,  Link   You can play a  version online here",
            "title": "Unit 25: Tower of Hanoi"
        },
        {
            "location": "/25-tower/index.html#using-recursion",
            "text": "Recall the two steps in recursive problem solving: (i) reduce the problem to the simplest version where we can solve it trivially; and (ii) assuming that we can solve the simpler version of the problem, we combine the solution to solve the more complex version.  What is the simplest version of the Tower of Hanoi puzzle?  It is the version with only a single disk.  In this version, the solution is trivial -- we just move the disk from the source peg to the destination peg  Let's label the pegs A, B, and C, with A being the source and C being the destination.  We will use peg B as the temporary placeholder.    Now, let's assume that we can solve the Tower of Hanoi puzzle for  k-1 k-1  disks.  How can we solve the puzzle for  k k  disks?  It turns out the solution is equally trivial.  First, move the top  k-1 k-1  disk from A to B.  This would free up the largest disk, which we move from A to C.  Then, we move the  k-1 k-1  disk from B to C.    The figures above illustrate the recursion steps.  The first figure shows the original configuration.  The second figure shows the recursive step -- by wishful thinking, we believe that we can solve the puzzle for  k-1 k-1  disks and move  k-1 k-1  disks from A to B, using C as the placeholder.  The third figure shows the move after moving the largest disk from A to C.  The last figure shows the move of  k-1 k-1  disks from B to C.  Now that A is empty, the last move uses A as the placeholder.",
            "title": "Using Recursion"
        },
        {
            "location": "/25-tower/index.html#representing-the-tower-of-hanoi-in-code",
            "text": "To write a solution for the Tower of Hanoi, we need to decide how to represent the disks and the pegs in our code.  We are going to  abstract  out only the necessary details.  Such an abstraction process is similar to what we have done so far, representing elevations data as integers, student ids as integers, etc.  Here, we are representing physical objects, but note that the actual size of the disks, the location of the pegs, etc, do not matter in our code.  As such, we will represent the disks with integers 1 to  k k  (1 being smallest,  k k  being the largest) and pegs with integers 1 to 3.",
            "title": "Representing the Tower of Hanoi in Code"
        },
        {
            "location": "/25-tower/index.html#the-solution",
            "text": "Let's write the code for a function  void solve_tower_of_hanoi(long k, long source, long dest) , which will print out the solution for moving  k k  disks from the peg  source  to the peg  dest .   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10 void   solve_tower_of_hanoi ( long   k ,   long   source ,   long   dest ,   long   placeholder )   { \n   if   ( k   ==   1 )   { \n     print ( k ,   source ,   dest ); \n   } \n   else   { \n     solve_tower_of_hanoi ( k   -   1 ,   source ,   placeholder ,   dest ); \n     print ( k ,   source ,   dest ); \n     solve_tower_of_hanoi ( k   -   1 ,   placeholder ,   dest ,   source ); \n   }  }    where  print  is a helper function to display the move to standard output. 1\n2\n3\n4\n5\n6\n7\n8 void   print ( long   k ,   long   source ,   long   dest )   { \n   cs1010_print_string ( \"Disk \" ); \n   cs1010_print_long ( k ); \n   cs1010_print_string ( \": Peg \" ); \n   cs1010_print_long ( source ); \n   cs1010_print_string ( \" -> Peg \" ); \n   cs1010_print_long ( dest );  }",
            "title": "The Solution"
        },
        {
            "location": "/25-tower/index.html#running-time",
            "text": "How many moves does it take to solve the Tower of Hanoi puzzle with  k k  disks?    If  k k  is 1, then it takes one move.  Otherwise, let us denote the number of moves taken as  T(k) T(k) .  From the code, we can see that it takes  T(k) = 2T(k-1) + 1 T(k) = 2T(k-1) + 1 .  An equation of this form is called a  recurrance equation .  You can learn how to solve such equations generally in later modules (e.g., CS3230), but, for now, we will expand the equation to derive the solution for  T(k) T(k) .  You can see that:   T(k) = 2T(k-1) + 1 = 4T(k-2) + 2 + 1 = 8T(k-3) + 4 + 2 + 1 = ...  T(k) = 2T(k-1) + 1 = 4T(k-2) + 2 + 1 = 8T(k-3) + 4 + 2 + 1 = ...   So,   T(k) = 2^{k-1}T(1) + 2^{k-2} + ... + 4 + 2 + 1  T(k) = 2^{k-1}T(1) + 2^{k-2} + ... + 4 + 2 + 1   Since  T(1) = 1 T(1) = 1 , we have   T(k) = 2^{k-1} + 2^{k-2} + ... + 4 + 2 + 1 = 2^k - 1  T(k) = 2^{k-1} + 2^{k-2} + ... + 4 + 2 + 1 = 2^k - 1   Thus, solving the Tower of Hanoi with  k k  disks takes  2^k-1 2^k-1  steps.",
            "title": "Running Time"
        },
        {
            "location": "/25-tower/index.html#problem-set",
            "text": "",
            "title": "Problem Set"
        },
        {
            "location": "/25-tower/index.html#problem-251",
            "text": "Suppose that we add a new restriction to the Tower of Hanoi puzzle.  Let's say that the disks are on Peg A (or Peg 1) to begin with, and   we want to move the disk to Peg C (or Peg 3).   We are only allowed to move a disk either to   Peg A   Peg B from another peg or from   Peg A   Peg B to another peg.  In other words, we cannot move the disks between   Peg B or Peg C.   Peg A and Peg C directly.  Change the recursive algorithm above to solve the Tower of Hanoi with this new restriction.  How many steps (use big O notation) are needed now?",
            "title": "Problem 25.1"
        },
        {
            "location": "/25-tower/index.html#appendix-complete-code",
            "text": "1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33 #include   \"cs1010.h\"  /**   * Move Disk k from Peg source to Peg dest.   *   * @param[in] k The disk to move   * @param[in] source The peg Disk k is currently at.   * @param[in] dest The peg Disk k is moved to.   */  void   move ( long   k ,   long   source ,   long   dest )   { \n   cs1010_print_string ( \"Disk \" ); \n   cs1010_print_long ( k ); \n   cs1010_print_string ( \": Peg \" ); \n   cs1010_print_long ( source ); \n   cs1010_print_string ( \" -> Peg \" ); \n   cs1010_println_long ( dest );  }  void   solve ( long   k ,   long   source ,   long   dest ,   long   placeholder )   { \n   if   ( k   ==   1 )   { \n     move ( k ,   source ,   dest ); \n     return ; \n   } \n\n   solve ( k   -   1 ,   source ,   placeholder ,   dest ); \n   move ( k ,   source ,   dest ); \n   solve ( k   -   1 ,   placeholder ,   dest ,   source );  }  int   main ()   { \n   long   k   =   cs1010_read_long (); \n   solve ( k ,   1 ,   3 ,   2 );  }",
            "title": "Appendix: Complete Code"
        },
        {
            "location": "/26-permutation/index.html",
            "text": "Unit 26: Permutations\n\n\nWe have been using recursions to either compute or find a solution to a problem.  In this unit, let's look at another useful application of recursion: to generate all possible permutations or combinations of items.\n\n\nLet's see a simple example of this: generate all permutations of the characters in a string of length \nn\nn\n.  For simplicity, we assume that there is no repetition in the string.\n\n\nRecursive Formulation\n\n\nTo formulate a recursive solution, as usual, let's simplify the problem.  A simpler version of the problem is to permute a string of length \nn-1\nn-1\n.\n\n\nThe trivial case is when we generate the permutation of a string with one character.  There is only one possible permutation!  Now, by wishful thinking, we assume that we know how to generate all permutations of a string of length \nn-1\nn-1\n.  Here is what we do to generate all permutations of a string of length \nn\nn\n.\n\n\nFor each character \ni\ni\n in the string, we move \ni\ni\n to the first position in the string.  We have \nn-1\nn-1\n characters left, which we solve recursively, generating all possible permutations with \ni\ni\n as the first character.  \n\n\nFor example, consider a string length 3, \nabc\n.  We start with \na\n as the first character, and generate all the permutations of the string \nbc\n.  We get two permutations \nabc\n and \nacb\n.  The next character is \nb\n.  We generate all permutations of the string \nac\n.  We get \nbac\n and \nbca\n.  Similarly, we get the permutations \ncab\n and \ncba\n by considering \nc\n as the first character and permutating \nba\n.\n\n\nThe Code\n\n\nThe idea above is implemented as the following:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\nvoid\n \npermute\n(\nchar\n \na\n[],\n \nlong\n \nlen\n,\n \nlong\n \ncurr\n)\n \n{\n\n  \n// permute characters a[curr]..a[len-1] and print out a for each permutation.\n\n  \nif\n \n(\ncurr\n \n==\n \nlen\n-\n1\n)\n \n{\n\n    \ncs1010_println_string\n(\na\n);\n\n    \nreturn\n;\n\n  \n}\n\n\n  \npermute\n(\na\n,\n \nlen\n,\n \ncurr\n \n+\n \n1\n);\n\n  \nfor\n \n(\nlong\n \ni\n \n=\n \ncurr\n \n+\n \n1\n;\n \ni\n \n<\n \nlen\n;\n \ni\n \n+=\n \n1\n)\n \n{\n\n    \nswap\n(\na\n,\n \ncurr\n,\n \ni\n);\n\n    \npermute\n(\na\n,\n \nlen\n,\n \ncurr\n \n+\n \n1\n);\n\n    \nswap\n(\na\n,\n \ni\n,\n \ncurr\n);\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\nLines 3-6 above corresponds to the base case, where we have reached the end of the string, there is only one character left to permutate.  Since there is only one possible permutation, we do not need to do anything except to print out the permutated string.\n\n\nLine 8 permutes the remaining string, \na[curr + 1]\n to \na[len - 1]\n, with character \na[curr]\n intact.  Lines 9-13 is a for loop which loops through all characters \na[curr + 1]\n to \na[len - 1]\n, and swaps each one to the position of \na[curr]\n, and recursively permutes the string \na[curr + 1]\n..\na[len - 1]\n.   When we are done, we swap back the original \na[curr]\n, this is to ensure that the string remains unchanged after \npermute\n is called.\n\n\nRunning Time\n\n\nHow efficient is the function \npermute\n?  We know that for a string of length \nn\nn\n, there are \nn!\nn!\n permutations, so the function \npermute\n should be at least \nn!\nn!\n.  If it runs in \nO(n!)\nO(n!)\n steps, then our function above is as efficient as it can get.\n\n\nLet the number of times \npermute\n is called when we pass in a string of length \nn\nn\n be \nT(n)\nT(n)\n.  Each invocation of \npermute(a, n, k)\n calls \npermute(a, n, k+1)\n recursively \nn-k\nn-k\n times.  The first call to \npermute\n is \npermute(a, n, 0)\n.  We stop when we call \npermute(a, n, n-1)\n.  So \nT(1) = 1\nT(1) = 1\n.\n\n\nSo, we have:\n\n\n\n\nT(n) = nT(n-1) = n(n-1)T(n-2) = n(n-1)(n-2)T(n-3) = .. = n(n-1)(n-2)..T(1) = n!\n\n\nT(n) = nT(n-1) = n(n-1)T(n-2) = n(n-1)(n-2)T(n-3) = .. = n(n-1)(n-2)..T(1) = n!\n\n\n\n\nWe made \nn!\nn!\n calls to \npermute\n, so the function \npermute\n is as efficient as it gets.  \n\n\nProblem Set\n\n\nProblem Set 26.1\n\n\nIn the code above, we assume that the string contains distinct characters.  If there are duplicate characters in the string, duplicate permutations will be generated.  For instance, if the input is \naaa\n, the code above would print \naaa\n six times.\n\n\nWe can fix this by making a small change to the function \npermute\n above so that it does not generate duplicate permutations.  This can be done by adding a condition (Line A).  Write a boolean function that we can call in Line A to check if we should continue to permute the rest of the string, and therefore avoid generating duplicate permutations when the input string contains duplicate characters.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\nvoid\n \npermute\n(\nchar\n \na\n[],\n \nlong\n \nlen\n,\n \nlong\n \ncurr\n)\n \n{\n\n  \n// permute characters a[curr]..a[len-1] and print out a for each permutation.\n\n  \nif\n \n(\ncurr\n \n==\n \nlen\n-\n1\n)\n \n{\n\n    \ncs1010_println_string\n(\na\n);\n\n    \nreturn\n;\n\n  \n}\n\n\n  \npermute\n(\na\n,\n \nlen\n,\n \ncurr\n \n+\n \n1\n);\n\n  \nfor\n \n(\nlong\n \ni\n \n=\n \ncurr\n \n+\n \n1\n;\n \ni\n \n<\n \nlen\n;\n \ni\n \n+=\n \n1\n)\n \n{\n\n    \nif\n \n(...)\n \n{\n \n// Line A\n\n      \nswap\n(\na\n,\n \ncurr\n,\n \ni\n);\n\n      \npermute\n(\na\n,\n \nlen\n,\n \ncurr\n \n+\n \n1\n);\n\n      \nswap\n(\na\n,\n \ni\n,\n \ncurr\n);\n\n    \n}\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\nAppendix: Complete Code Written in Lecture\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n#include\n \n\"cs1010.h\"\n\n\n#include\n \n<stdbool.h>\n\n\n#include\n \n<stdio.h>\n\n\n#include\n \n<string.h>\n\n\n\nvoid\n \nswap\n(\nchar\n \na\n[],\n \nlong\n \ni\n,\n \nlong\n \nj\n)\n \n{\n\n  \nchar\n \ntemp\n \n=\n \na\n[\ni\n];\n\n  \na\n[\ni\n]\n \n=\n \na\n[\nj\n];\n\n  \na\n[\nj\n]\n \n=\n \ntemp\n;\n\n\n}\n\n\n\nvoid\n \npermute\n(\nchar\n \nstr\n[],\n \nlong\n \nn\n,\n \nlong\n \nk\n)\n \n{\n\n  \nif\n \n(\nk\n \n==\n \nn\n-\n1\n)\n \n{\n\n    \ncs1010_println_string\n(\nstr\n);\n\n    \nreturn\n;\n\n  \n}\n\n  \npermute\n(\nstr\n,\n \nn\n,\n \nk\n+\n1\n);\n\n  \nfor\n \n(\nlong\n \ni\n \n=\n \nk\n+\n1\n;\n \ni\n \n<\n \nn\n;\n \ni\n+=\n \n1\n)\n \n{\n\n    \nswap\n(\nstr\n,\n \nk\n,\n \ni\n);\n\n    \npermute\n(\nstr\n,\n \nn\n,\n \nk\n+\n1\n);\n\n    \nswap\n(\nstr\n,\n \ni\n,\n \nk\n);\n\n  \n}\n\n\n}\n\n\n\nint\n \nmain\n()\n \n{\n\n  \nchar\n \n*\nstr\n \n=\n \ncs1010_read_word\n();\n\n  \npermute\n(\nstr\n,\n \nstrlen\n(\nstr\n),\n \n0\n);\n\n  \nfree\n(\nstr\n);\n\n\n}",
            "title": "26. Permutation"
        },
        {
            "location": "/26-permutation/index.html#unit-26-permutations",
            "text": "We have been using recursions to either compute or find a solution to a problem.  In this unit, let's look at another useful application of recursion: to generate all possible permutations or combinations of items.  Let's see a simple example of this: generate all permutations of the characters in a string of length  n n .  For simplicity, we assume that there is no repetition in the string.",
            "title": "Unit 26: Permutations"
        },
        {
            "location": "/26-permutation/index.html#recursive-formulation",
            "text": "To formulate a recursive solution, as usual, let's simplify the problem.  A simpler version of the problem is to permute a string of length  n-1 n-1 .  The trivial case is when we generate the permutation of a string with one character.  There is only one possible permutation!  Now, by wishful thinking, we assume that we know how to generate all permutations of a string of length  n-1 n-1 .  Here is what we do to generate all permutations of a string of length  n n .  For each character  i i  in the string, we move  i i  to the first position in the string.  We have  n-1 n-1  characters left, which we solve recursively, generating all possible permutations with  i i  as the first character.    For example, consider a string length 3,  abc .  We start with  a  as the first character, and generate all the permutations of the string  bc .  We get two permutations  abc  and  acb .  The next character is  b .  We generate all permutations of the string  ac .  We get  bac  and  bca .  Similarly, we get the permutations  cab  and  cba  by considering  c  as the first character and permutating  ba .",
            "title": "Recursive Formulation"
        },
        {
            "location": "/26-permutation/index.html#the-code",
            "text": "The idea above is implemented as the following:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14 void   permute ( char   a [],   long   len ,   long   curr )   { \n   // permute characters a[curr]..a[len-1] and print out a for each permutation. \n   if   ( curr   ==   len - 1 )   { \n     cs1010_println_string ( a ); \n     return ; \n   } \n\n   permute ( a ,   len ,   curr   +   1 ); \n   for   ( long   i   =   curr   +   1 ;   i   <   len ;   i   +=   1 )   { \n     swap ( a ,   curr ,   i ); \n     permute ( a ,   len ,   curr   +   1 ); \n     swap ( a ,   i ,   curr ); \n   }  }    Lines 3-6 above corresponds to the base case, where we have reached the end of the string, there is only one character left to permutate.  Since there is only one possible permutation, we do not need to do anything except to print out the permutated string.  Line 8 permutes the remaining string,  a[curr + 1]  to  a[len - 1] , with character  a[curr]  intact.  Lines 9-13 is a for loop which loops through all characters  a[curr + 1]  to  a[len - 1] , and swaps each one to the position of  a[curr] , and recursively permutes the string  a[curr + 1] .. a[len - 1] .   When we are done, we swap back the original  a[curr] , this is to ensure that the string remains unchanged after  permute  is called.",
            "title": "The Code"
        },
        {
            "location": "/26-permutation/index.html#running-time",
            "text": "How efficient is the function  permute ?  We know that for a string of length  n n , there are  n! n!  permutations, so the function  permute  should be at least  n! n! .  If it runs in  O(n!) O(n!)  steps, then our function above is as efficient as it can get.  Let the number of times  permute  is called when we pass in a string of length  n n  be  T(n) T(n) .  Each invocation of  permute(a, n, k)  calls  permute(a, n, k+1)  recursively  n-k n-k  times.  The first call to  permute  is  permute(a, n, 0) .  We stop when we call  permute(a, n, n-1) .  So  T(1) = 1 T(1) = 1 .  So, we have:   T(n) = nT(n-1) = n(n-1)T(n-2) = n(n-1)(n-2)T(n-3) = .. = n(n-1)(n-2)..T(1) = n!  T(n) = nT(n-1) = n(n-1)T(n-2) = n(n-1)(n-2)T(n-3) = .. = n(n-1)(n-2)..T(1) = n!   We made  n! n!  calls to  permute , so the function  permute  is as efficient as it gets.",
            "title": "Running Time"
        },
        {
            "location": "/26-permutation/index.html#problem-set",
            "text": "",
            "title": "Problem Set"
        },
        {
            "location": "/26-permutation/index.html#problem-set-261",
            "text": "In the code above, we assume that the string contains distinct characters.  If there are duplicate characters in the string, duplicate permutations will be generated.  For instance, if the input is  aaa , the code above would print  aaa  six times.  We can fix this by making a small change to the function  permute  above so that it does not generate duplicate permutations.  This can be done by adding a condition (Line A).  Write a boolean function that we can call in Line A to check if we should continue to permute the rest of the string, and therefore avoid generating duplicate permutations when the input string contains duplicate characters.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16 void   permute ( char   a [],   long   len ,   long   curr )   { \n   // permute characters a[curr]..a[len-1] and print out a for each permutation. \n   if   ( curr   ==   len - 1 )   { \n     cs1010_println_string ( a ); \n     return ; \n   } \n\n   permute ( a ,   len ,   curr   +   1 ); \n   for   ( long   i   =   curr   +   1 ;   i   <   len ;   i   +=   1 )   { \n     if   (...)   {   // Line A \n       swap ( a ,   curr ,   i ); \n       permute ( a ,   len ,   curr   +   1 ); \n       swap ( a ,   i ,   curr ); \n     } \n   }  }",
            "title": "Problem Set 26.1"
        },
        {
            "location": "/26-permutation/index.html#appendix-complete-code-written-in-lecture",
            "text": "1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29 #include   \"cs1010.h\"  #include   <stdbool.h>  #include   <stdio.h>  #include   <string.h>  void   swap ( char   a [],   long   i ,   long   j )   { \n   char   temp   =   a [ i ]; \n   a [ i ]   =   a [ j ]; \n   a [ j ]   =   temp ;  }  void   permute ( char   str [],   long   n ,   long   k )   { \n   if   ( k   ==   n - 1 )   { \n     cs1010_println_string ( str ); \n     return ; \n   } \n   permute ( str ,   n ,   k + 1 ); \n   for   ( long   i   =   k + 1 ;   i   <   n ;   i +=   1 )   { \n     swap ( str ,   k ,   i ); \n     permute ( str ,   n ,   k + 1 ); \n     swap ( str ,   i ,   k ); \n   }  }  int   main ()   { \n   char   * str   =   cs1010_read_word (); \n   permute ( str ,   strlen ( str ),   0 ); \n   free ( str );  }",
            "title": "Appendix: Complete Code Written in Lecture"
        },
        {
            "location": "/27-queens/index.html",
            "text": "Unit 27: N Queens\n\n\nWe now look at how recursion can help with solving problems that require \nsearching and backtracking\n.  A classical example for this is the \nn\nn\n-queens problem, which can be stated as given a \nn \\times n\nn \\times n\n chessboard, find a possible placement of \nn\nn\n queens on the chessboard, such that the queens do not threaten each other.    In other words, there is exactly one queen in each row, in each column, and in each diagonal.  The 8-queens puzzle was first published by Max Bezzel in 1848, with the first solution published Franz Nauck in 1850.\nThe generalized \nn\nn\n-queens problems were introduced later.  It is known that there is no solution for \nn = 2\nn = 2\n and \nn = 3\nn = 3\n, but a solution exists for \nn > 3\nn > 3\n.\n\n\nIf we visualize the chessboard as a 2D array, with \n#\n as the position of a queen, and \n.\n as an empty position on the board, then a solution to the 4-queens problem looks like this:\n\n\n1\n2\n3\n4\n.#..\n...#\n#...\n..#.\n\n\n\n\n\n\nRecursive Formulation\n\n\nLet's see how we can formulate the problem recursively.  The first step is to simplify the problem to the most trivial case where we can solve it.  It is tempting to say that a simpler version of the problem is an \nn-1\nn-1\n-queens problem, and so the most trivial case is 1-queen.  While the solution to 1-queen is trivial, there is no solution to both 2-queen and 3-queen problems.  Further, if we have found a solution to the \nn-1\nn-1\n-queens problem, extending it to a solution of \nn\nn\n-queens problem is not trivial.  \n\n\nApproach 1: Generate All Permutations\n\n\nAs a start, let's borrow the idea from \nUnit 26\n and generate all permutations of the queens' positions.  Let's label the columns \na\n, \nb\n, \nc\n, .. etc.  Since we know that there must be exactly one queen in each row, and one queen in each column, the positions of the queens can be represented as a string that is a permutation of \nabcde..\n.  For instance, the solution of the 4-queen problem depicted above can be represented by \nbdac\n.\n\n\nA simple algorithm is thus to generate all possible \nn!\nn!\n permutations, and for each one, check if it is a valid placement.  We already ensure that there is exactly one queen per row and one queen per column.  It remains to check that the queens do not threaten each other diagonally.\n\n\nLet's write a function that checks, given a string representation of the queen positions, whether there is any queen that threaten another or not:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\nbool\n \nhas_a_queen_in_diagonal\n(\nchar\n \nqueens\n[],\n \nlong\n \nlen\n,\n \nlong\n \ni\n)\n \n{\n\n  \nchar\n \ncurr_col\n \n=\n \nqueens\n[\ni\n];\n\n  \nchar\n \nleft_col\n \n=\n \ncurr_col\n \n-\n \n1\n;\n\n  \nchar\n \nright_col\n \n=\n \ncurr_col\n \n+\n \n1\n;\n\n  \nfor\n \n(\nlong\n \nrow\n \n=\n \ni\n+\n1\n;\n \nrow\n \n<\n \nlen\n;\n \nrow\n \n+=\n \n1\n)\n \n{\n\n    \nif\n \n(\nqueens\n[\nrow\n]\n \n==\n \nleft_col\n \n||\n \nqueens\n[\nrow\n]\n \n==\n \nright_col\n)\n \n{\n\n      \nreturn\n \ntrue\n;\n\n    \n}\n\n    \nleft_col\n \n-=\n \n1\n;\n\n    \nright_col\n \n+=\n \n1\n;\n\n  \n}\n\n  \nreturn\n \nfalse\n;\n\n\n}\n\n\n\nbool\n \nthreaten_each_other_diagonally\n(\nchar\n \nqueens\n[],\n \nlong\n \nlen\n)\n \n{\n\n  \nfor\n \n(\nlong\n \ni\n \n=\n \n0\n;\n \ni\n \n<\n \nlen\n;\n \ni\n \n+=\n \n1\n)\n \n{\n\n    \n// for each queen in row i, check rows i+1 onwards, \n\n    \n// on both left (-=1) and right (+=1) side, if there \n\n    \n// is a queen in that column.\n\n    \nif\n \n(\nhas_a_queen_in_diagonal\n(\nqueens\n,\n \nlen\n,\n \ni\n))\n \n{\n\n      \nreturn\n \ntrue\n;\n\n    \n}\n\n  \n}\n\n  \nreturn\n \nfalse\n;\n\n\n}\n\n\n\n\n\n\n\nSolving the \nn\nn\n queens problem is then easy.  The code below prints out all possible solutions to the \nn\nn\n queens problem.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\nvoid\n \nnqueens\n(\nchar\n \nqueens\n[],\n \nlong\n \nn\n,\n \nlong\n \nrow\n)\n \n{\n\n  \nif\n \n(\nrow\n \n==\n \nn\n-\n1\n)\n \n{\n\n    \nif\n \n(\n!\nthreaten_each_other_diagonally\n(\nqueens\n,\n \nn\n))\n \n{\n\n      \ncs1010_println_string\n(\nqueens\n);\n\n    \n}\n\n    \nreturn\n;\n\n  \n}\n\n\n  \nnqueens\n(\nqueens\n,\n \nn\n,\n \nrow\n \n+\n \n1\n);\n\n  \nfor\n \n(\nlong\n \ni\n \n=\n \nrow\n \n+\n \n1\n;\n \ni\n \n<\n \nn\n;\n \ni\n++\n)\n \n{\n\n    \nswap\n(\nqueens\n,\n \nrow\n,\n \ni\n);\n\n    \nnqueens\n(\nqueens\n,\n \nn\n,\n \nrow\n \n+\n \n1\n);\n\n    \nswap\n(\nqueens\n,\n \nrow\n,\n \ni\n);\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\nApproach 2: Pruning Impossible Solutions\n\n\nOne of the principles to writing efficient code is to avoid doing useless work.  The code above, which tests all permutations, actually generates much work that is useless.  Suppose the queens in the first two rows already threaten each other, then, there is no need to continue to generate all possible placements of queens for the remaining rows.\n\n\nThis concept is called \npruning\n and is a key to speeding up many searching-based solutions.  We want to prune away bad solutions as early as possible.  This can be achieved easily, by checking if the queens already placed on the first \nk\nk\n rows threaten each other.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\nvoid\n \nnqueens\n(\nchar\n \nqueens\n[],\n \nlong\n \nn\n,\n \nlong\n \nrow\n)\n \n{\n\n  \nif\n \n(\nrow\n \n==\n \nn\n-\n1\n)\n \n{\n\n    \nif\n \n(\n!\nthreaten_each_other_diagonally\n(\nqueens\n,\n \nn\n))\n \n{\n\n      \ncs1010_println_string\n(\nqueens\n);\n\n    \n}\n\n    \nreturn\n;\n\n  \n}\n\n\n  \nif\n \n(\n!\nthreaten_each_other_diagonally\n(\nqueens\n,\n \nrow\n))\n \n{\n\n    \nnqueens\n(\nqueens\n,\n \nn\n,\n \nrow\n \n+\n \n1\n);\n\n  \n}\n\n  \nfor\n \n(\nlong\n \ni\n \n=\n \nrow\n \n+\n \n1\n;\n \ni\n \n<\n \nn\n;\n \ni\n++\n)\n \n{\n\n    \nswap\n(\nqueens\n,\n \nrow\n,\n \ni\n);\n\n    \nif\n \n(\n!\nthreaten_each_other_diagonally\n(\nqueens\n,\n \nrow\n))\n \n{\n\n      \nnqueens\n(\nqueens\n,\n \nn\n,\n \nrow\n \n+\n \n1\n);\n\n    \n}\n\n    \nswap\n(\nqueens\n,\n \nrow\n,\n \ni\n);\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\nAdding these two conditionals can speed up the code significantly.\n\n\nProblem Set 27\n\n\nProblem 27.1\n\n\nIn the code for Approach 2 above, we check if the queens placed on Rows 0 to \nrow\n threaten each other, and call \nnqueens\n recursively only if these queens do not threaten each other.  Identify the repetitive work being done in the calls \nthreaten_each_other_diagonally\n, and suggest a way to remove the repetitive work.\n\n\nProblem 27.2\n\n\nConsider the code to generate all possible permutations of a string from Problem 26.1.  Suppose that we restrict the permutations to those where the same character does not appear next to each other.  Modify the solution to Problem 26.1 to prune away permutations where the same character appears more than once consecutively.\n\n\nAppendix: Complete Code Written in Lecture\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n#include\n \n\"cs1010.h\"\n\n\n#include\n \n<stdbool.h>\n\n\n#include\n \n<unistd.h>\n\n\n\nvoid\n \ndraw\n(\nchar\n \nqueens\n[],\n \nlong\n \nn\n,\n \nlong\n \nrow\n)\n \n{\n\n  \nstatic\n \nchar\n \nclear_screen\n[]\n \n=\n \n{\n \n27\n,\n \n'['\n,\n \n'2'\n,\n \n'J'\n,\n27\n,\n \n'['\n,\n \n';'\n,\n \n'H'\n,\n \n0\n};\n\n  \ncs1010_print_string\n(\nclear_screen\n);\n\n  \nfor\n \n(\nlong\n \ni\n \n=\n \n0\n;\n \ni\n \n<=\n \nrow\n;\n \ni\n \n+=\n \n1\n)\n \n{\n\n    \nfor\n \n(\nchar\n \ncol\n \n=\n \n'a'\n;\n \ncol\n \n<\n \n'a'\n \n+\n \nn\n;\n \ncol\n \n+=\n \n1\n)\n \n{\n\n      \nif\n \n(\nqueens\n[\ni\n]\n \n==\n \ncol\n)\n \n{\n\n        \nputchar\n(\n'#'\n);\n\n      \n}\n \nelse\n \n{\n\n        \nputchar\n(\n'.'\n);\n\n      \n}\n\n    \n}\n\n    \nputchar\n(\n'\\n'\n);\n\n  \n}\n\n  \nfor\n \n(\nlong\n \ni\n \n=\n \nrow\n+\n1\n;\n \ni\n \n<\n \nn\n;\n \ni\n \n+=\n \n1\n)\n \n{\n\n    \nfor\n \n(\nlong\n \ncol\n \n=\n \n0\n;\n \ncol\n \n<\n \nn\n;\n \ncol\n \n+=\n \n1\n)\n \n{\n\n      \nputchar\n(\n'.'\n);\n\n    \n}\n\n    \nputchar\n(\n'\\n'\n);\n\n  \n}\n\n  \nusleep\n(\n10000\n);\n\n\n}\n\n\n\nvoid\n \nswap\n(\nchar\n \na\n[],\n \nlong\n \ni\n,\n \nlong\n \nj\n)\n \n{\n\n  \nchar\n \ntemp\n \n=\n \na\n[\ni\n];\n\n  \na\n[\ni\n]\n \n=\n \na\n[\nj\n];\n\n  \na\n[\nj\n]\n \n=\n \ntemp\n;\n\n\n}\n\n\n\nbool\n \nhas_a_queen_in_diagonal\n(\nconst\n \nchar\n \nqueens\n[],\n \nlong\n \nlen\n,\n \nlong\n \ni\n)\n \n{\n\n  \nchar\n \ncurr_col\n \n=\n \nqueens\n[\ni\n];\n\n  \nchar\n \nleft_col\n \n=\n \ncurr_col\n \n-\n \n1\n;\n\n  \nchar\n \nright_col\n \n=\n \ncurr_col\n \n+\n \n1\n;\n\n  \nfor\n \n(\nlong\n \nrow\n \n=\n \ni\n+\n1\n;\n \nrow\n \n<\n \nlen\n;\n \nrow\n \n+=\n \n1\n)\n \n{\n\n    \nif\n \n(\nqueens\n[\nrow\n]\n \n==\n \nleft_col\n \n||\n \nqueens\n[\nrow\n]\n \n==\n \nright_col\n)\n \n{\n\n      \nreturn\n \ntrue\n;\n\n    \n}\n\n    \nleft_col\n \n-=\n \n1\n;\n\n    \nright_col\n \n+=\n \n1\n;\n\n  \n}\n\n  \nreturn\n \nfalse\n;\n\n\n}\n\n\n\nbool\n \nthreaten_each_other_diagonally\n(\nchar\n \nqueens\n[],\n \nlong\n \nlen\n)\n \n{\n\n  \nfor\n \n(\nlong\n \ni\n \n=\n \n0\n;\n \ni\n \n<\n \nlen\n;\n \ni\n \n+=\n \n1\n)\n \n{\n\n    \n// for each queen in row i, check rows i+1 onwards, \n\n    \n// on both left (-=1) and right (+=1) side, if there \n\n    \n// is a queen in that column.\n\n    \nif\n \n(\nhas_a_queen_in_diagonal\n(\nqueens\n,\n \nlen\n,\n \ni\n))\n \n{\n\n      \nreturn\n \ntrue\n;\n\n    \n}\n\n  \n}\n\n  \nreturn\n \nfalse\n;\n\n\n}\n\n\n\nbool\n \nnqueens\n(\nchar\n \nqueens\n[],\n \nlong\n \nn\n,\n \nlong\n \nrow\n)\n \n{\n\n  \nif\n \n(\nrow\n \n==\n \nn\n-\n1\n)\n \n{\n\n    \ndraw\n(\nqueens\n,\n \nn\n,\n \nrow\n);\n\n    \nif\n \n(\n!\nthreaten_each_other_diagonally\n(\nqueens\n,\n \nn\n))\n \n{\n\n      \ncs1010_println_string\n(\nqueens\n);\n\n      \nreturn\n \ntrue\n;\n\n    \n}\n\n    \nreturn\n \nfalse\n;\n\n  \n}\n\n  \nif\n \n(\n!\nthreaten_each_other_diagonally\n(\nqueens\n,\n \nrow\n))\n \n{\n\n    \nbool\n \nresult\n \n=\n \nnqueens\n(\nqueens\n,\n \nn\n,\n \nrow\n+\n1\n);\n\n    \nif\n \n(\nresult\n)\n \n{\n\n      \nreturn\n \ntrue\n;\n\n    \n}\n\n  \n}\n\n  \nfor\n \n(\nlong\n \ni\n \n=\n \nrow\n+\n1\n;\n \ni\n \n<\n \nn\n;\n \ni\n+=\n \n1\n)\n \n{\n\n    \nswap\n(\nqueens\n,\n \nrow\n,\n \ni\n);\n\n    \nif\n \n(\n!\nthreaten_each_other_diagonally\n(\nqueens\n,\n \nrow\n))\n \n{\n\n      \nbool\n \nresult\n \n=\n \nnqueens\n(\nqueens\n,\n \nn\n,\n \nrow\n+\n1\n);\n\n      \nif\n \n(\nresult\n)\n \n{\n\n        \nreturn\n \ntrue\n;\n\n      \n}\n\n    \n}\n\n    \nswap\n(\nqueens\n,\n \ni\n,\n \nrow\n);\n\n  \n}\n\n  \nreturn\n \nfalse\n;\n\n\n}\n\n\n\nint\n \nmain\n()\n \n\n{\n\n  \nlong\n \nn\n \n=\n \ncs1010_read_long\n();\n\n  \nchar\n \nqueens\n[\nn\n+\n1\n];\n\n  \nchar\n \ncurr\n \n=\n \n'a'\n;\n\n  \nfor\n \n(\nlong\n \ni\n \n=\n \n0\n;\n \ni\n \n<\n \nn\n;\n \ni\n++\n)\n \n{\n\n    \nqueens\n[\ni\n]\n \n=\n \ncurr\n;\n\n    \ncurr\n \n+=\n \n1\n;\n\n  \n}\n\n  \nqueens\n[\nn\n]\n \n=\n \n'\\0'\n;\n\n\n  \nnqueens\n(\nqueens\n,\n \nn\n,\n \n0\n);\n\n\n}",
            "title": "27. N Queens"
        },
        {
            "location": "/27-queens/index.html#unit-27-n-queens",
            "text": "We now look at how recursion can help with solving problems that require  searching and backtracking .  A classical example for this is the  n n -queens problem, which can be stated as given a  n \\times n n \\times n  chessboard, find a possible placement of  n n  queens on the chessboard, such that the queens do not threaten each other.    In other words, there is exactly one queen in each row, in each column, and in each diagonal.  The 8-queens puzzle was first published by Max Bezzel in 1848, with the first solution published Franz Nauck in 1850.\nThe generalized  n n -queens problems were introduced later.  It is known that there is no solution for  n = 2 n = 2  and  n = 3 n = 3 , but a solution exists for  n > 3 n > 3 .  If we visualize the chessboard as a 2D array, with  #  as the position of a queen, and  .  as an empty position on the board, then a solution to the 4-queens problem looks like this:  1\n2\n3\n4 .#..\n...#\n#...\n..#.",
            "title": "Unit 27: N Queens"
        },
        {
            "location": "/27-queens/index.html#recursive-formulation",
            "text": "Let's see how we can formulate the problem recursively.  The first step is to simplify the problem to the most trivial case where we can solve it.  It is tempting to say that a simpler version of the problem is an  n-1 n-1 -queens problem, and so the most trivial case is 1-queen.  While the solution to 1-queen is trivial, there is no solution to both 2-queen and 3-queen problems.  Further, if we have found a solution to the  n-1 n-1 -queens problem, extending it to a solution of  n n -queens problem is not trivial.",
            "title": "Recursive Formulation"
        },
        {
            "location": "/27-queens/index.html#approach-1-generate-all-permutations",
            "text": "As a start, let's borrow the idea from  Unit 26  and generate all permutations of the queens' positions.  Let's label the columns  a ,  b ,  c , .. etc.  Since we know that there must be exactly one queen in each row, and one queen in each column, the positions of the queens can be represented as a string that is a permutation of  abcde.. .  For instance, the solution of the 4-queen problem depicted above can be represented by  bdac .  A simple algorithm is thus to generate all possible  n! n!  permutations, and for each one, check if it is a valid placement.  We already ensure that there is exactly one queen per row and one queen per column.  It remains to check that the queens do not threaten each other diagonally.  Let's write a function that checks, given a string representation of the queen positions, whether there is any queen that threaten another or not:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25 bool   has_a_queen_in_diagonal ( char   queens [],   long   len ,   long   i )   { \n   char   curr_col   =   queens [ i ]; \n   char   left_col   =   curr_col   -   1 ; \n   char   right_col   =   curr_col   +   1 ; \n   for   ( long   row   =   i + 1 ;   row   <   len ;   row   +=   1 )   { \n     if   ( queens [ row ]   ==   left_col   ||   queens [ row ]   ==   right_col )   { \n       return   true ; \n     } \n     left_col   -=   1 ; \n     right_col   +=   1 ; \n   } \n   return   false ;  }  bool   threaten_each_other_diagonally ( char   queens [],   long   len )   { \n   for   ( long   i   =   0 ;   i   <   len ;   i   +=   1 )   { \n     // for each queen in row i, check rows i+1 onwards,  \n     // on both left (-=1) and right (+=1) side, if there  \n     // is a queen in that column. \n     if   ( has_a_queen_in_diagonal ( queens ,   len ,   i ))   { \n       return   true ; \n     } \n   } \n   return   false ;  }    Solving the  n n  queens problem is then easy.  The code below prints out all possible solutions to the  n n  queens problem.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15 void   nqueens ( char   queens [],   long   n ,   long   row )   { \n   if   ( row   ==   n - 1 )   { \n     if   ( ! threaten_each_other_diagonally ( queens ,   n ))   { \n       cs1010_println_string ( queens ); \n     } \n     return ; \n   } \n\n   nqueens ( queens ,   n ,   row   +   1 ); \n   for   ( long   i   =   row   +   1 ;   i   <   n ;   i ++ )   { \n     swap ( queens ,   row ,   i ); \n     nqueens ( queens ,   n ,   row   +   1 ); \n     swap ( queens ,   row ,   i ); \n   }  }",
            "title": "Approach 1: Generate All Permutations"
        },
        {
            "location": "/27-queens/index.html#approach-2-pruning-impossible-solutions",
            "text": "One of the principles to writing efficient code is to avoid doing useless work.  The code above, which tests all permutations, actually generates much work that is useless.  Suppose the queens in the first two rows already threaten each other, then, there is no need to continue to generate all possible placements of queens for the remaining rows.  This concept is called  pruning  and is a key to speeding up many searching-based solutions.  We want to prune away bad solutions as early as possible.  This can be achieved easily, by checking if the queens already placed on the first  k k  rows threaten each other.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19 void   nqueens ( char   queens [],   long   n ,   long   row )   { \n   if   ( row   ==   n - 1 )   { \n     if   ( ! threaten_each_other_diagonally ( queens ,   n ))   { \n       cs1010_println_string ( queens ); \n     } \n     return ; \n   } \n\n   if   ( ! threaten_each_other_diagonally ( queens ,   row ))   { \n     nqueens ( queens ,   n ,   row   +   1 ); \n   } \n   for   ( long   i   =   row   +   1 ;   i   <   n ;   i ++ )   { \n     swap ( queens ,   row ,   i ); \n     if   ( ! threaten_each_other_diagonally ( queens ,   row ))   { \n       nqueens ( queens ,   n ,   row   +   1 ); \n     } \n     swap ( queens ,   row ,   i ); \n   }  }    Adding these two conditionals can speed up the code significantly.",
            "title": "Approach 2: Pruning Impossible Solutions"
        },
        {
            "location": "/27-queens/index.html#problem-set-27",
            "text": "",
            "title": "Problem Set 27"
        },
        {
            "location": "/27-queens/index.html#problem-271",
            "text": "In the code for Approach 2 above, we check if the queens placed on Rows 0 to  row  threaten each other, and call  nqueens  recursively only if these queens do not threaten each other.  Identify the repetitive work being done in the calls  threaten_each_other_diagonally , and suggest a way to remove the repetitive work.",
            "title": "Problem 27.1"
        },
        {
            "location": "/27-queens/index.html#problem-272",
            "text": "Consider the code to generate all possible permutations of a string from Problem 26.1.  Suppose that we restrict the permutations to those where the same character does not appear next to each other.  Modify the solution to Problem 26.1 to prune away permutations where the same character appears more than once consecutively.",
            "title": "Problem 27.2"
        },
        {
            "location": "/27-queens/index.html#appendix-complete-code-written-in-lecture",
            "text": "1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99 #include   \"cs1010.h\"  #include   <stdbool.h>  #include   <unistd.h>  void   draw ( char   queens [],   long   n ,   long   row )   { \n   static   char   clear_screen []   =   {   27 ,   '[' ,   '2' ,   'J' , 27 ,   '[' ,   ';' ,   'H' ,   0 }; \n   cs1010_print_string ( clear_screen ); \n   for   ( long   i   =   0 ;   i   <=   row ;   i   +=   1 )   { \n     for   ( char   col   =   'a' ;   col   <   'a'   +   n ;   col   +=   1 )   { \n       if   ( queens [ i ]   ==   col )   { \n         putchar ( '#' ); \n       }   else   { \n         putchar ( '.' ); \n       } \n     } \n     putchar ( '\\n' ); \n   } \n   for   ( long   i   =   row + 1 ;   i   <   n ;   i   +=   1 )   { \n     for   ( long   col   =   0 ;   col   <   n ;   col   +=   1 )   { \n       putchar ( '.' ); \n     } \n     putchar ( '\\n' ); \n   } \n   usleep ( 10000 );  }  void   swap ( char   a [],   long   i ,   long   j )   { \n   char   temp   =   a [ i ]; \n   a [ i ]   =   a [ j ]; \n   a [ j ]   =   temp ;  }  bool   has_a_queen_in_diagonal ( const   char   queens [],   long   len ,   long   i )   { \n   char   curr_col   =   queens [ i ]; \n   char   left_col   =   curr_col   -   1 ; \n   char   right_col   =   curr_col   +   1 ; \n   for   ( long   row   =   i + 1 ;   row   <   len ;   row   +=   1 )   { \n     if   ( queens [ row ]   ==   left_col   ||   queens [ row ]   ==   right_col )   { \n       return   true ; \n     } \n     left_col   -=   1 ; \n     right_col   +=   1 ; \n   } \n   return   false ;  }  bool   threaten_each_other_diagonally ( char   queens [],   long   len )   { \n   for   ( long   i   =   0 ;   i   <   len ;   i   +=   1 )   { \n     // for each queen in row i, check rows i+1 onwards,  \n     // on both left (-=1) and right (+=1) side, if there  \n     // is a queen in that column. \n     if   ( has_a_queen_in_diagonal ( queens ,   len ,   i ))   { \n       return   true ; \n     } \n   } \n   return   false ;  }  bool   nqueens ( char   queens [],   long   n ,   long   row )   { \n   if   ( row   ==   n - 1 )   { \n     draw ( queens ,   n ,   row ); \n     if   ( ! threaten_each_other_diagonally ( queens ,   n ))   { \n       cs1010_println_string ( queens ); \n       return   true ; \n     } \n     return   false ; \n   } \n   if   ( ! threaten_each_other_diagonally ( queens ,   row ))   { \n     bool   result   =   nqueens ( queens ,   n ,   row + 1 ); \n     if   ( result )   { \n       return   true ; \n     } \n   } \n   for   ( long   i   =   row + 1 ;   i   <   n ;   i +=   1 )   { \n     swap ( queens ,   row ,   i ); \n     if   ( ! threaten_each_other_diagonally ( queens ,   row ))   { \n       bool   result   =   nqueens ( queens ,   n ,   row + 1 ); \n       if   ( result )   { \n         return   true ; \n       } \n     } \n     swap ( queens ,   i ,   row ); \n   } \n   return   false ;  }  int   main ()   { \n   long   n   =   cs1010_read_long (); \n   char   queens [ n + 1 ]; \n   char   curr   =   'a' ; \n   for   ( long   i   =   0 ;   i   <   n ;   i ++ )   { \n     queens [ i ]   =   curr ; \n     curr   +=   1 ; \n   } \n   queens [ n ]   =   '\\0' ; \n\n   nqueens ( queens ,   n ,   0 );  }",
            "title": "Appendix: Complete Code Written in Lecture"
        },
        {
            "location": "/28-struct/index.html",
            "text": "Unit 28: Structures\n\n\nWe have so far been working with numbers, characters, and strings.  Not all real-world objects can be easily abstracted and represented with numbers and characters.  It is useful to create our own \ncompound data type\n that represent real worlds objects.  Each object typically has one or more attributes, which can be of different types: A module has a code, a title, and the number of MCs; A person has a name, height, weight, and age; A phone has a model, price, and brand.\n\n\nIf you look back at the code that we have written, often there are multiple variables that are related to each other and \"belongs together.\"  When we pass one as an argument into a function, often we need to pass another.  It is useful to group them into a compound data type as well.  For instance: A 1D array and its length; A 2D array, its width, and its height; A pixel, its row, its column, and its color.\n\n\nStructure in C\n\n\nIn C, we can define a compound data type using a structure, through the C keyword \nstruct\n.  The syntax looks like this:\n\n\n1\n2\n3\n4\n5\nstruct\n \nmatrix\n \n{\n\n  \ndouble\n**\n \narray\n;\n\n  \nlong\n \nnum_of_rows\n;\n\n  \nlong\n \nnum_of_columns\n;\n\n\n};\n\n\n\n\n\n\n\nIn the definition above, the structure is given a name, \nmatrix\n.  The structure contains three \nmembers\n.  The first is a pointer to a 2D array, the other two is the number of rows and number of columns of that array.\n\n\nNote\n that we need a semicolon \n;\n after the definition of a \nstruct\n.\n\n\nHere are a few more examples:\n\n\n1\n2\n3\n4\n5\nstruct\n \ncircle\n \n{\n\n  \ndouble\n \nx_of_center\n;\n\n  \ndouble\n \ny_of_center\n;\n\n  \ndouble\n \nradius\n;\n\n\n}\n\n\n\n\n\n\n\n1\n2\n3\n4\n5\nstruct\n \nmodule\n \n{\n\n  \nchar\n \n*\ncode\n;\n\n  \nchar\n \n*\ntitle\n\n  \nlong\n \nmc\n;\n\n\n}\n\n\n\n\n\n\n\nDeclaring and Initializing a Structure Variable\n\n\nLet's see an example of how we can declare and initialize a structure variable:\n\n\n1\n2\n3\n4\nstruct\n \nmodule\n \ncs1010\n;\n\n\ncs1010\n.\ncode\n \n=\n \n\"CS1010\"\n;\n\n\ncs1010\n.\ntitle\n \n=\n \n\"Programming Methodology\"\n;\n\n\ncs1010\n.\nmc\n \n=\n \n4\n;\n\n\n\n\n\n\n\nLine 1 above declares a variable called \ncs1010\n.  Lines 2-4 initialize each member of the structure.  Note that we use \n.\n to access each member.\n\n\nAn alternative is to use a \ncompound literal\n:\n\n\n1\n2\n3\n4\n5\nstruct\n \nmodule\n \ncs1010\n \n=\n \n{\n\n  \n.\ncode\n \n=\n \n\"CS1010\"\n,\n\n  \n.\ntitle\n \n=\n \n\"Programming Methodology\"\n,\n\n  \n.\nmc\n \n=\n \n4\n\n\n};\n\n\n\n\n\n\n\nUsing compound literal is convenient in certain cases, as uninitialized members are set to 0 (similar to initializers of arrays).\n\n\nYou can read and write to individual members of a structure variable just like any other variables. \n\n\n1\n2\ncs1010.mc = hours_spent_per_week/2.5;\ncs1010_println_long(cs1010.mc);\n\n\n\n\n\n\nStructure as Parameters\n\n\nWe can pass a structure variable into a function just like a non-array variable.  Unlike an array, a \nstruct\n is called by value, i.e., it is copied onto the call stack of the function.\n\n\nHence, the code below does not actually update the MCs of CS1010:\n\n\n1\n2\n3\nvoid update_mc(struct module cs1010, long hours_spent_per_week) {\n  cs1010.mc = hours_spent_per_week/2.5;\n}\n\n\n\n\n\n\nTo call a structure by reference, we can pass in its pointer.\n\n\n1\n2\n3\nvoid update_mc(struct module *cs1010, long hours_spent_per_week) {\n  (*cs1010).mc = hours_spent_per_week/2.5;\n}\n\n\n\n\n\n\nThe latter example is a more common idiom.  Since a structure can contain multiple fields and usually occupies more bytes than a pointer, it is less efficient to copy a structure onto the call stack compared to copying its pointer.  \n\n\nSince this is common, C provides another syntax for accessing the member of a structure through its pointer, using the \"arrow\" notation\"\n\n\n1\n2\n3\nvoid update_mc(struct module *cs1010, long hours_spent_per_week) {\n  cs1010->mc = hours_spent_per_week/2.5;\n}\n\n\n\n\n\n\nReturning a Structure\n\n\nA function can return structure.  Remember in \nUnit 17\n we said that C functions can return only one value and one way to get around this limitation is to use call by reference and the other is to use \nstruct\n?  Here is how we use \nstruct\n to return more than one values:\n\n\n1\n2\n3\n4\nstruct answer {\n  long max_n;\n  long max_num_steps\n}\n\n\n\n\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\nstruct\n \nanswer\n \nfind_max_steps\n(\nlong\n \nn\n)\n \n{\n\n  \nstruct\n \nanswer\n \nans\n \n=\n \n{\n\n    \n.\nmax_n\n \n=\n \n1\n,\n\n    \n.\nmax_num_steps\n \n=\n \n0\n,\n\n  \n};\n\n  \nfor\n \n(\nlong\n \ni\n \n=\n \n1\n;\n \ni\n \n<=\n \nn\n;\n \ni\n \n+=\n \n1\n)\n \n{\n\n    \nlong\n \nnum_of_steps\n \n=\n \ncount_num_of_steps\n(\ni\n);\n\n    \nif\n \n(\nnum_of_steps\n \n>=\n \nans\n.\nmax_num_steps\n)\n \n{\n\n      \nans\n.\nmax_n\n \n=\n \ni\n;\n\n      \nans\n.\nmax_num_steps\n \n=\n \nnum_of_steps\n;\n\n    \n}\n\n  \n}\n\n  \nreturn\n \nans\n;\n\n\n}\n\n\n\n\n\n\n\nWhen a function returns a \nstruct\n, the structure gets \ncopied\n back to the caller.\n\n\nDefining a Structure as a Type\n\n\nTo avoid writing the keyword 'struct\nevery time we declare a variable or parameter, let's introduce another keyword in C:\ntypedef`.  \n\n\nC allows programmers to define their own type based on the existing types.  Suppose that I want a type that represents a color component (red, green, or blue) of a pixel.  Each pixel can have a value between 0 to 255.  So we can represent it with an \nunsigned char\n.  I can define:\n\n\n1\ntypedef\n \nunsigned\n \nchar\n \ncolor_t\n;\n\n\n\n\n\n\n\nRecall that we use the suffix \n_t\n convention to denote user-defined type.  You have probably seen these two types elsewhere \nsize_t\n and \ntime_t\n in the past.\n\n\nNow that we have defined \ncolor_t\n as a new type that is equivalent to \nunsigned char\n, we can use it just like another type:\n\n\n1\n2\n3\ncolor_t r;\n\nvoid paint(color_t r, color_t g, color_t b);\n\n\n\n\n\n\nUsing \ntypedef\n on \nstruct\n frees us from typing the word \nstruct\n every time.  We can do so with either:\n\n\n1\n2\n3\n4\n5\ntypedef\n \nstruct\n \nmodule\n \n{\n\n  \nchar\n \n*\ncode\n;\n\n  \nchar\n \n*\ntitle\n\n  \nlong\n \nmc\n;\n\n\n}\n \nmodule\n;\n\n\n\n\n\n\n\nor\n\n\n1\n2\n3\n4\n5\ntypedef\n \nstruct\n \n{\n\n  \nchar\n \n*\ncode\n;\n\n  \nchar\n \n*\ntitle\n\n  \nlong\n \nmc\n;\n\n\n}\n \nmodule\n;\n\n\n\n\n\n\n\nIn either case, we can just use \nmodule\n like any other type:\n\n\n1\n2\n3\nvoid update_mc(module cs1010, long hours_spent_per_week) {\n  cs1010.mc = hours_spent_per_week/2.5;\n}\n\n\n\n\n\n\nIf you use third-party libraries or C libraries, chances are you will come across such type.  Use of \ntypedef\n on \nstruct\n is controversial.  There is a school of thoughts that think it makes the code harder to read as it obscured the fact that a variable is a struct.  Hidden costs in copying the variable onto the call stack as a parameter or returned value become non-obvious.  Interested students can read \nLinux's Kernel Coding Style\n for the pros and cons of this approach.",
            "title": "28. Structure"
        },
        {
            "location": "/28-struct/index.html#unit-28-structures",
            "text": "We have so far been working with numbers, characters, and strings.  Not all real-world objects can be easily abstracted and represented with numbers and characters.  It is useful to create our own  compound data type  that represent real worlds objects.  Each object typically has one or more attributes, which can be of different types: A module has a code, a title, and the number of MCs; A person has a name, height, weight, and age; A phone has a model, price, and brand.  If you look back at the code that we have written, often there are multiple variables that are related to each other and \"belongs together.\"  When we pass one as an argument into a function, often we need to pass another.  It is useful to group them into a compound data type as well.  For instance: A 1D array and its length; A 2D array, its width, and its height; A pixel, its row, its column, and its color.",
            "title": "Unit 28: Structures"
        },
        {
            "location": "/28-struct/index.html#structure-in-c",
            "text": "In C, we can define a compound data type using a structure, through the C keyword  struct .  The syntax looks like this:  1\n2\n3\n4\n5 struct   matrix   { \n   double **   array ; \n   long   num_of_rows ; \n   long   num_of_columns ;  };    In the definition above, the structure is given a name,  matrix .  The structure contains three  members .  The first is a pointer to a 2D array, the other two is the number of rows and number of columns of that array.  Note  that we need a semicolon  ;  after the definition of a  struct .  Here are a few more examples:  1\n2\n3\n4\n5 struct   circle   { \n   double   x_of_center ; \n   double   y_of_center ; \n   double   radius ;  }    1\n2\n3\n4\n5 struct   module   { \n   char   * code ; \n   char   * title \n   long   mc ;  }",
            "title": "Structure in C"
        },
        {
            "location": "/28-struct/index.html#declaring-and-initializing-a-structure-variable",
            "text": "Let's see an example of how we can declare and initialize a structure variable:  1\n2\n3\n4 struct   module   cs1010 ;  cs1010 . code   =   \"CS1010\" ;  cs1010 . title   =   \"Programming Methodology\" ;  cs1010 . mc   =   4 ;    Line 1 above declares a variable called  cs1010 .  Lines 2-4 initialize each member of the structure.  Note that we use  .  to access each member.  An alternative is to use a  compound literal :  1\n2\n3\n4\n5 struct   module   cs1010   =   { \n   . code   =   \"CS1010\" , \n   . title   =   \"Programming Methodology\" , \n   . mc   =   4  };    Using compound literal is convenient in certain cases, as uninitialized members are set to 0 (similar to initializers of arrays).  You can read and write to individual members of a structure variable just like any other variables.   1\n2 cs1010.mc = hours_spent_per_week/2.5;\ncs1010_println_long(cs1010.mc);",
            "title": "Declaring and Initializing a Structure Variable"
        },
        {
            "location": "/28-struct/index.html#structure-as-parameters",
            "text": "We can pass a structure variable into a function just like a non-array variable.  Unlike an array, a  struct  is called by value, i.e., it is copied onto the call stack of the function.  Hence, the code below does not actually update the MCs of CS1010:  1\n2\n3 void update_mc(struct module cs1010, long hours_spent_per_week) {\n  cs1010.mc = hours_spent_per_week/2.5;\n}   To call a structure by reference, we can pass in its pointer.  1\n2\n3 void update_mc(struct module *cs1010, long hours_spent_per_week) {\n  (*cs1010).mc = hours_spent_per_week/2.5;\n}   The latter example is a more common idiom.  Since a structure can contain multiple fields and usually occupies more bytes than a pointer, it is less efficient to copy a structure onto the call stack compared to copying its pointer.    Since this is common, C provides another syntax for accessing the member of a structure through its pointer, using the \"arrow\" notation\"  1\n2\n3 void update_mc(struct module *cs1010, long hours_spent_per_week) {\n  cs1010->mc = hours_spent_per_week/2.5;\n}",
            "title": "Structure as Parameters"
        },
        {
            "location": "/28-struct/index.html#returning-a-structure",
            "text": "A function can return structure.  Remember in  Unit 17  we said that C functions can return only one value and one way to get around this limitation is to use call by reference and the other is to use  struct ?  Here is how we use  struct  to return more than one values:  1\n2\n3\n4 struct answer {\n  long max_n;\n  long max_num_steps\n}    1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14 struct   answer   find_max_steps ( long   n )   { \n   struct   answer   ans   =   { \n     . max_n   =   1 , \n     . max_num_steps   =   0 , \n   }; \n   for   ( long   i   =   1 ;   i   <=   n ;   i   +=   1 )   { \n     long   num_of_steps   =   count_num_of_steps ( i ); \n     if   ( num_of_steps   >=   ans . max_num_steps )   { \n       ans . max_n   =   i ; \n       ans . max_num_steps   =   num_of_steps ; \n     } \n   } \n   return   ans ;  }    When a function returns a  struct , the structure gets  copied  back to the caller.",
            "title": "Returning a Structure"
        },
        {
            "location": "/28-struct/index.html#defining-a-structure-as-a-type",
            "text": "To avoid writing the keyword 'struct every time we declare a variable or parameter, let's introduce another keyword in C: typedef`.    C allows programmers to define their own type based on the existing types.  Suppose that I want a type that represents a color component (red, green, or blue) of a pixel.  Each pixel can have a value between 0 to 255.  So we can represent it with an  unsigned char .  I can define:  1 typedef   unsigned   char   color_t ;    Recall that we use the suffix  _t  convention to denote user-defined type.  You have probably seen these two types elsewhere  size_t  and  time_t  in the past.  Now that we have defined  color_t  as a new type that is equivalent to  unsigned char , we can use it just like another type:  1\n2\n3 color_t r;\n\nvoid paint(color_t r, color_t g, color_t b);   Using  typedef  on  struct  frees us from typing the word  struct  every time.  We can do so with either:  1\n2\n3\n4\n5 typedef   struct   module   { \n   char   * code ; \n   char   * title \n   long   mc ;  }   module ;    or  1\n2\n3\n4\n5 typedef   struct   { \n   char   * code ; \n   char   * title \n   long   mc ;  }   module ;    In either case, we can just use  module  like any other type:  1\n2\n3 void update_mc(module cs1010, long hours_spent_per_week) {\n  cs1010.mc = hours_spent_per_week/2.5;\n}   If you use third-party libraries or C libraries, chances are you will come across such type.  Use of  typedef  on  struct  is controversial.  There is a school of thoughts that think it makes the code harder to read as it obscured the fact that a variable is a struct.  Hidden costs in copying the variable onto the call stack as a parameter or returned value become non-obvious.  Interested students can read  Linux's Kernel Coding Style  for the pros and cons of this approach.",
            "title": "Defining a Structure as a Type"
        },
        {
            "location": "/29-stdio/index.html",
            "text": "Unit 29: Standard I/O Functions\n\n\nWe have been shielding you from the pain and pitfalls of using C I/O functions.  Since you are close to \"graduate\" from CS1010, this is a good time to show you what the real world is like.\n\n\nprintf\n\n\nThe function \nprintf\n is used to print a formatted string to the standard output.  Unlike functions that we have seen so far, \nprintf\n can take in a variable number of arguments, but it must have at least one argument -- a string written in a certain format.  The rest of the arguments can be of different types.  Let's look at an example:\n\n\n1\n2\nchar\n \n*\nname\n \n=\n \n\"Siri\"\n;\n\n\nprintf\n(\n\"Hello! My name is %s.\n\\n\n\"\n,\n \nname\n);\n\n\n\n\n\n\n\nThe code above prints \nHello! My name is Siri.\n.\n\n\nThere are two arguments to \nprintf\n, both are strings.  The first is the string to print.  There is a placeholder \n%s\n in the string, which will be replaced by the second argument \nname\n.  The string to print ends with \n\\n\n, which is the new line character.\n\n\nThe placeholder \n%s\n is called a \nformat modifier\n.  It controls how to interpret the arguments (i.e., what type) and how to format the output.   The general format is:\n\n\n1\n%[flags][field_width][.precision][length_modifier]specifier\n\n\n\n\n\n\n\nThe letter after \n%\n controls the interpretation of the argument.  \ns\n for string, \nc\n for character, \nd\n for integer (base 10), \nf\n for floating point number, \np\n for pointer (base 16).  We can additionally prepend this with \nlength modifier\n.  \nld\n for \nlong\n integer, \nlld\n for \nlong long\n, and \nlf\n for \ndouble\n.\n\n\nTo format the output, we can prepend it with a number to indicate its \nfield width\n, or minimum space used when printing.  E.g., \n%3d\n will pad the number printed with space if the number printed is less than 3 digits.  Adding a \nflag\n 0 in front, \n%03d\n, will pad the number with 0s if the number printed is less than 3 digits.  Other flags include \n+\n, which tells \nprintf\n to print a sign (\n+\n or \n-\n) for the number.  For floating point numbers, we can additionally control the \nprecision\n, or the number of digits printed after the decimal point.  \n%3.4lf\n will print a double to four decimal points.\n\n\nNote: \ncs1010_println_double\n uses \n%.4lf\n as the format modifier.\n\n\nPitfalls when using \nprintf\n\n\nMismatch Types\n\n\nprintf\n does not check for the type of arguments we pass to it.  The compiler does, but it only politely warns us instead of throwing an error like other type mismatches.\n\n\nIf you ignore such warnings, you might print strange things like:\n\n\n1\n  \nprintf\n(\n\"%d %f\n\\n\n\"\n,\n \n100000000000\n,\n \n100000000000\n);\n\n\n\n\n\n\n\nor worse, crash your program:\n\n\n1\n  \nprintf\n(\n\"%s %s\n\\n\n\"\n,\n \n100000000000\n,\n \n100000000000\n);\n\n\n\n\n\n\n\nMismatch Number of Arguments\n\n\nSince \nprintf\n expects a variable number of arguments, you can pass it fewer arguments than expected and the code would still compile (with warnings).  If you push ahead and run it anyway, \nprintf\n will start to fetch arguments from the stack, pretending that it is there, causing weird things to happen.\n\n\nConsider:\n\n\n1\nprintf\n(\n\"%d %s %s\n\\n\n\"\n,\n \n10\n);\n\n\n\n\n\n\n\nIt would cause \nprintf\n to access memory content of the stack as strings. \n\n\nPrinting User Input\n\n\nWe should also never do this:\n\n\n1\n2\nchar\n \n*\nstr\n \n=\n \ncs1010_read_word\n();\n\n\nprintf\n(\nstr\n);\n\n\n\n\n\n\n\nThe reason is that we have no control over what the user would type as input: the user may type \"%s\" into the standard input, so the variable \nstr\n now points to \n%s\n, which \nprintf\n treats as a format modifier, and output the content of the stack!  This is a huge security risk.\n\n\nWe should always print a string using:\n\n\n1\nprintf\n(\n\"%s\"\n,\n \nstr\n);\n\n\n\n\n\n\n\nscanf\n\n\nThe function \nscanf\n is used to read inputs from the standard input.  It requires us to pass in pointers to variables where we want to store the input value is.  Like \nprintf\n, it takes in one or more arguments, with the first argument being a format string containing one or more format specifier.  The format specifier for \nscanf\n is simpler and has the following pattern:\n\n\n1\n%[*][field_width][length_modifier]specifier\n\n\n\n\n\n\n\nFor instance, to read an integer, a floating point number, and a string of at most 10 characters, \n\n\n1\n2\n3\n4\nlong\n \nl\n;\n\n\ndouble\n \nd\n;\n\n\nchar\n \ns\n[\n11\n];\n \n\nscanf\n(\n\"%ld %lf %10s\"\n,\n \n&\nl\n,\n \n&\nd\n,\n \ns\n);\n\n\n\n\n\n\n\nscanf\n scans the standard input, try to match it to the format specified.\nThe space in between the format specifier matches zero or more white spaces (space, tab, newline).  Scanning stops when an input character does not match such a format character or when an input conversion fails.\n\n\nAdding a \n*\n to the format modifier means that scanf should consume the inputs but not store it in any variables.  This, combined with \n%[``]\n is useful to clear any remaining data from the standard input.\n\n\nPitfalls When Using \nscanf\n\n\nChecking for Error\n\n\nThe function \nscanf\n fails silently when the input character does not match a format or when the input conversion fails.  It might return a totally unexpected input.  We should always check the return value of \nscanf\n to make sure that it is reading properly.\n\n\n1\n2\n3\nlong\n \na\n;\n\n\nscanf\n(\n\"%ld\"\n,\n \n&\na\n);\n\n\nprintf\n(\n\"%ld\"\n,\n \na\n);\n\n\n\n\n\n\n\nThe code above might print uninitialized value if the input is not an integer.\n\n\nWe should check\n\n\n1\n2\n3\n4\n5\nlong\n \na\n;\n\n\nlong\n \nresult\n \n=\n \nscanf\n(\n\"%ld\"\n,\n \n&\na\n);\n\n\nif\n \n(\nresult\n \n!=\n \n1\n)\n \n{\n\n  \nprintf\n(\n\"%ld\"\n,\n \na\n);\n\n\n}\n\n\n\n\n\n\n\nThe above, however, does not properly \"clear\" the standard input of the incorrect input.  So the next \nscanf\n calls would still try to read it again!\n\n\nTo clear the input, we can use the \n%*[^\\n]\n modifier, which read in any characters expect (\n^\n) the newline (\n\\n\n).  \n\n\n1\n2\n3\n4\n5\n6\n7\nlong\n \na\n;\n\n\nlong\n \nresult\n \n=\n \nscanf\n(\n\"%ld\"\n,\n \n&\na\n);\n\n\nif\n \n(\nresult\n \n!=\n \n1\n)\n \n{\n\n  \nprintf\n(\n\"%ld\"\n,\n \na\n);\n\n\n}\n \nelse\n \n{\n\n  \nscanf\n(\n\"*[^\n\\n\n]\"\n);\n\n\n}\n\n\n\n\n\n\n\nAs a side note, the \n%[]\n modifier is useful to read in strings containing a certain range of characters only.  E.g., you can read \n%[a-zA-Z0-9]\n to match any sequence of alphanumeric characters.\n\n\nInvalid Pointers\n\n\nSince \nscanf\n expects the caller to pass in pointers to variables for it to store the results, we need to be careful about what we pass in.  It is easy to pass in something like this:\n\n\n1\n2\nlong\n \n*\na\n;\n\n\nscanf\n(\n\"%ld\"\n,\n \na\n);\n\n\n\n\n\n\n\nThe compiler would not warn us since the type matches perfectly.  The program may crash since the pointer is not pointing to a valid memory location accessible by the program.\n\n\nBuffer Overflow\n\n\nWhen we use \nscanf\n to read a string, it keeps reading until it reaches an empty space, and stores everything that it reads into an array.  The problem here is that we do not know when it will stop reading, and therefore how big is the array that we need to allocate for the input!\n\n\nLet's say we do:\n\n\n1\n2\n3\n4\nchar\n \nname\n[\n10\n];\n\n\nprintf\n(\n\"What's your name?\"\n,\n \nname\n);\n\n\nscanf\n(\n\"%s\"\n,\n \nname\n);\n\n\nprintf\n(\n\"Hello %s!\n\\n\n\"\n,\n \nname\n);\n\n\n\n\n\n\n\nThe program would crash if we enter a very long string in the standard input.\n\n\nYou can read \na beginners' guide away from scanf()\n for more information.\n\n\nfgets\n\n\nfgets\n is a better alternative to \nscanf\n for reading inputs (Note: this is what CS1010 library use internally).  \nfgets\n takes three parameters, a pointer to a string (or buffer), the size of the buffer, and the input to read from (which can be a file, a network socket, or in our case, most of the time \nstdin\n).\n\n\nThe advantage of \nfgets\n is that it never overflows the buffer (it knows the size).  Once we read the input, we can use functions such as \nstrtol\n or \nstrtod\n to convert the strings to \nlong\n or \ndouble\n.\n\n\nAvoid atol or atof\n\n\nInstead of \nstrtol\n or \nstrtof\n, some old school textbooks might show you that you can convert a string to a \nlong\n or a \ndouble\n using \natol\n or \natof\n.  You should avoid these two functions (even the man pages of \natof\n says so!).  They do not provide any mechanism for error checking if the string is not a valid integer or if the input is out of range of the type.\n\n\nYou can read \nthe source code for the CS1010 library\n to see how it uses \nfgets\n, \nstrtol\n and related functions to parse numbers and strings from the standard inputs.",
            "title": "29. stdio"
        },
        {
            "location": "/29-stdio/index.html#unit-29-standard-io-functions",
            "text": "We have been shielding you from the pain and pitfalls of using C I/O functions.  Since you are close to \"graduate\" from CS1010, this is a good time to show you what the real world is like.",
            "title": "Unit 29: Standard I/O Functions"
        },
        {
            "location": "/29-stdio/index.html#printf",
            "text": "The function  printf  is used to print a formatted string to the standard output.  Unlike functions that we have seen so far,  printf  can take in a variable number of arguments, but it must have at least one argument -- a string written in a certain format.  The rest of the arguments can be of different types.  Let's look at an example:  1\n2 char   * name   =   \"Siri\" ;  printf ( \"Hello! My name is %s. \\n \" ,   name );    The code above prints  Hello! My name is Siri. .  There are two arguments to  printf , both are strings.  The first is the string to print.  There is a placeholder  %s  in the string, which will be replaced by the second argument  name .  The string to print ends with  \\n , which is the new line character.  The placeholder  %s  is called a  format modifier .  It controls how to interpret the arguments (i.e., what type) and how to format the output.   The general format is:  1 %[flags][field_width][.precision][length_modifier]specifier    The letter after  %  controls the interpretation of the argument.   s  for string,  c  for character,  d  for integer (base 10),  f  for floating point number,  p  for pointer (base 16).  We can additionally prepend this with  length modifier .   ld  for  long  integer,  lld  for  long long , and  lf  for  double .  To format the output, we can prepend it with a number to indicate its  field width , or minimum space used when printing.  E.g.,  %3d  will pad the number printed with space if the number printed is less than 3 digits.  Adding a  flag  0 in front,  %03d , will pad the number with 0s if the number printed is less than 3 digits.  Other flags include  + , which tells  printf  to print a sign ( +  or  - ) for the number.  For floating point numbers, we can additionally control the  precision , or the number of digits printed after the decimal point.   %3.4lf  will print a double to four decimal points.  Note:  cs1010_println_double  uses  %.4lf  as the format modifier.",
            "title": "printf"
        },
        {
            "location": "/29-stdio/index.html#pitfalls-when-using-printf",
            "text": "",
            "title": "Pitfalls when using printf"
        },
        {
            "location": "/29-stdio/index.html#mismatch-types",
            "text": "printf  does not check for the type of arguments we pass to it.  The compiler does, but it only politely warns us instead of throwing an error like other type mismatches.  If you ignore such warnings, you might print strange things like:  1    printf ( \"%d %f \\n \" ,   100000000000 ,   100000000000 );    or worse, crash your program:  1    printf ( \"%s %s \\n \" ,   100000000000 ,   100000000000 );",
            "title": "Mismatch Types"
        },
        {
            "location": "/29-stdio/index.html#mismatch-number-of-arguments",
            "text": "Since  printf  expects a variable number of arguments, you can pass it fewer arguments than expected and the code would still compile (with warnings).  If you push ahead and run it anyway,  printf  will start to fetch arguments from the stack, pretending that it is there, causing weird things to happen.  Consider:  1 printf ( \"%d %s %s \\n \" ,   10 );    It would cause  printf  to access memory content of the stack as strings.",
            "title": "Mismatch Number of Arguments"
        },
        {
            "location": "/29-stdio/index.html#printing-user-input",
            "text": "We should also never do this:  1\n2 char   * str   =   cs1010_read_word ();  printf ( str );    The reason is that we have no control over what the user would type as input: the user may type \"%s\" into the standard input, so the variable  str  now points to  %s , which  printf  treats as a format modifier, and output the content of the stack!  This is a huge security risk.  We should always print a string using:  1 printf ( \"%s\" ,   str );",
            "title": "Printing User Input"
        },
        {
            "location": "/29-stdio/index.html#scanf",
            "text": "The function  scanf  is used to read inputs from the standard input.  It requires us to pass in pointers to variables where we want to store the input value is.  Like  printf , it takes in one or more arguments, with the first argument being a format string containing one or more format specifier.  The format specifier for  scanf  is simpler and has the following pattern:  1 %[*][field_width][length_modifier]specifier    For instance, to read an integer, a floating point number, and a string of at most 10 characters,   1\n2\n3\n4 long   l ;  double   d ;  char   s [ 11 ];   scanf ( \"%ld %lf %10s\" ,   & l ,   & d ,   s );    scanf  scans the standard input, try to match it to the format specified.\nThe space in between the format specifier matches zero or more white spaces (space, tab, newline).  Scanning stops when an input character does not match such a format character or when an input conversion fails.  Adding a  *  to the format modifier means that scanf should consume the inputs but not store it in any variables.  This, combined with  %[``]  is useful to clear any remaining data from the standard input.",
            "title": "scanf"
        },
        {
            "location": "/29-stdio/index.html#pitfalls-when-using-scanf",
            "text": "",
            "title": "Pitfalls When Using scanf"
        },
        {
            "location": "/29-stdio/index.html#checking-for-error",
            "text": "The function  scanf  fails silently when the input character does not match a format or when the input conversion fails.  It might return a totally unexpected input.  We should always check the return value of  scanf  to make sure that it is reading properly.  1\n2\n3 long   a ;  scanf ( \"%ld\" ,   & a );  printf ( \"%ld\" ,   a );    The code above might print uninitialized value if the input is not an integer.  We should check  1\n2\n3\n4\n5 long   a ;  long   result   =   scanf ( \"%ld\" ,   & a );  if   ( result   !=   1 )   { \n   printf ( \"%ld\" ,   a );  }    The above, however, does not properly \"clear\" the standard input of the incorrect input.  So the next  scanf  calls would still try to read it again!  To clear the input, we can use the  %*[^\\n]  modifier, which read in any characters expect ( ^ ) the newline ( \\n ).    1\n2\n3\n4\n5\n6\n7 long   a ;  long   result   =   scanf ( \"%ld\" ,   & a );  if   ( result   !=   1 )   { \n   printf ( \"%ld\" ,   a );  }   else   { \n   scanf ( \"*[^ \\n ]\" );  }    As a side note, the  %[]  modifier is useful to read in strings containing a certain range of characters only.  E.g., you can read  %[a-zA-Z0-9]  to match any sequence of alphanumeric characters.",
            "title": "Checking for Error"
        },
        {
            "location": "/29-stdio/index.html#invalid-pointers",
            "text": "Since  scanf  expects the caller to pass in pointers to variables for it to store the results, we need to be careful about what we pass in.  It is easy to pass in something like this:  1\n2 long   * a ;  scanf ( \"%ld\" ,   a );    The compiler would not warn us since the type matches perfectly.  The program may crash since the pointer is not pointing to a valid memory location accessible by the program.",
            "title": "Invalid Pointers"
        },
        {
            "location": "/29-stdio/index.html#buffer-overflow",
            "text": "When we use  scanf  to read a string, it keeps reading until it reaches an empty space, and stores everything that it reads into an array.  The problem here is that we do not know when it will stop reading, and therefore how big is the array that we need to allocate for the input!  Let's say we do:  1\n2\n3\n4 char   name [ 10 ];  printf ( \"What's your name?\" ,   name );  scanf ( \"%s\" ,   name );  printf ( \"Hello %s! \\n \" ,   name );    The program would crash if we enter a very long string in the standard input.  You can read  a beginners' guide away from scanf()  for more information.",
            "title": "Buffer Overflow"
        },
        {
            "location": "/29-stdio/index.html#fgets",
            "text": "fgets  is a better alternative to  scanf  for reading inputs (Note: this is what CS1010 library use internally).   fgets  takes three parameters, a pointer to a string (or buffer), the size of the buffer, and the input to read from (which can be a file, a network socket, or in our case, most of the time  stdin ).  The advantage of  fgets  is that it never overflows the buffer (it knows the size).  Once we read the input, we can use functions such as  strtol  or  strtod  to convert the strings to  long  or  double .",
            "title": "fgets"
        },
        {
            "location": "/29-stdio/index.html#avoid-atol-or-atof",
            "text": "Instead of  strtol  or  strtof , some old school textbooks might show you that you can convert a string to a  long  or a  double  using  atol  or  atof .  You should avoid these two functions (even the man pages of  atof  says so!).  They do not provide any mechanism for error checking if the string is not a valid integer or if the input is out of range of the type.  You can read  the source code for the CS1010 library  to see how it uses  fgets ,  strtol  and related functions to parse numbers and strings from the standard inputs.",
            "title": "Avoid atol or atof"
        },
        {
            "location": "/ex01/index.html",
            "text": "Exercise 1: Freezer\n\n\nThis is your first programming exercise.  An exercise is something that you do on your own.  You can submit them but it will not be graded.   Test cases are provided for the exercises so that you can test and check on your own if your code is correct.  This is in contrast to an assignment, where you need to submit for grading and for credits.\n\n\nPrerequisite\n\n\n\n\nYou are able to access the \nCS1010 programming environment\n.\n\n\nYou are familiar with \nbasic UNIX CLI\n and using terminal-based editor \nvim\n.\n\n\n\n\nLearning Outcomes\n\n\n\n\nBe comfortable writing simple C programs that involves arithmetic operations, \nlong\n and \ndouble\n types.\n\n\n\n\nOne-Time Setup\n\n\nBefore going into their first programming exercise, you need to do a one time setup of your account on PE. You need to create a file called \n.gitconfig\n in your home directory and with the following content:\n\n\n1\n2\n3\n4\n5\n[user]\n  name = Your Name\n  email = Your Email\n[github]  \n  user = Your GitHub ID\n\n\n\n\n\n\nYour email should be whatever you used to sign up Github.\n\n\nFor example, a sample \n.gitconfig\n looks like this:\n\n\n1\n2\n3\n4\n5\n[user]\n  name = Jon Snow\n  email = king@north.gov\n[github]  \n  user = jonsnow\n\n\n\n\n\n\nAfter saving this file, run:\n\n\n1\ngit config --get github.user\n\n\n\n\n\n\nIt should return your GitHub user id.\n\n\nIt should print your GitHub user id as set.  If there is a typo, you need to edit \n.gitconfig\n again and reload it by repeating the command above.\n\n\nSetup\n\n\n\n\nClick on \nthis link\n to accept the exercise.\n\n\nLogin to one of the hosts of \nCS1010 programming environment (PE)\n\n\nRun the following on the command line on one of the PE hosts:\n\n\n\n\n1\n~cs1010/get-ex01\n\n\n\n\n\n\n\n\nYou should see a new subdirectory \nex01-<githubid>\n in your current working directory, where \ngithubid\n is your GitHub ID.\n\n\n\n\nWe will call this directory your \nexercise directory\n or \nassignment directory\n.\n\n\n\n\n\n\nInside that directory, you should see a bunch of files:\n\n\n\n\nfreezer1.c\n and \nfreezer2.c\n are the most important files.  They are the skeleton C code that you should edit to solve the exercise.\n\n\ninputs\n and \noutputs\n are sub directories that contain test inputs and test outputs.  We use the convention \nproblem-name\n.\ntest-id\n.in for input test data, and \nproblem-name\n.\ntest-id\n.out for output test data.  So, you will see \nfreezer1.1.in\n, \nfreezer1.1.out\n, etc.  The expected output for \nfreezer1.1.in\n is in \nfreezer1.1.out\n.  You can look at the content of these files if you wish (which \nUNIX\n command should you use to do this?).  You can edit these files to change the test input and output.\n\n\nMakefile\n: This is the configuration for the tool \nmake\n that we use to automate the compilation and testing of the programs.  You do not have to understand how to write a \nMakefile\n for CS1010.  If you are interested to learn how to write a \nMakefile\n, talk to either Wei Tsang or Google.\n\n\ntest.sh\n: This is a bash script for testing your code.  You do not have to edit this file nor call it directly.  It is called by \nmake\n.  If you are interested to learn how to write bash script, talk to either Wei Tsang or Google.\n\n\n\n\n\n\n\n\nIdentifying Yourself\n\n\nIn every C file that you submit to CS1010, you need to identify yourself by writing your name and tutorial group.  Marks will be deducted if you fail to do so.  You need to edit the line:\n\n\n1\n@author XXXX (Group YYYY)\n\n\n\n\n\n\nand change it to something like:\n\n\n1\n@author Jon Snow (Group 10)\n\n\n\n\n\n\nSolving The Assignments\n\n\n\n\nEdit the files \nfreezer1.c\n and \nfreezer2.c\n to solve the corresponding question as described below.\n\n\nTo compile and run the given tests with the sample inputs and outputs, run on the command line,\n\n\n\n\n1\nmake\n\n\n\n\n\n\nThis will compile both C files and if there is no error, run the test scripts.\n\n\nSubmission\n\n\nWhen you are ready, run the following command while you are in the exercise directory:\n\n\n1\n~cs1010/submit-ex01\n\n\n\n\n\n\nThe files \nfreezer1.c\n and \nfreezer2.c\n will be uploaded to GitHub.  You can submit multiple times.\n\n\nGrading\n\n\nThis assignment is not graded.\n\n\n\n\nQuestion 1: Freezer\n\n\n(a)\n\n\nWrite a program \nfreezer1\n (source file \nfreezer1.c\n) that estimates the temperature (in degree Celsius) in a freezer given the elapsed time (in hours) since a power failure.\n\n\nAssume this temperature \nT\nT\n is given by\n1\n:\n\n\n\n\n\nT = \\frac{4t^2}{t + 2} - 20;\n\n\n\n\nT = \\frac{4t^2}{t + 2} - 20;\n\n\n\n\n\nwhere \nt\nt\n is the time (in hours) since the power failure.\n\n\nYour program reads in an integer: the number of hours since the start of the power failure.\n\n\nSample run:\n\n\n1\n2\n3\n4\n5\n6\nooiwt@pe111:~/ex01-ooiwt$ ./freezer1\n0\n-20.0000\nooiwt@pe111:~/ex01-ooiwt$ ./freezer1\n1\n-18.6667\n\n\n\n\n\n\nThe text \nooiwt@pe111:~/ex01-ooiwt$\n is the command prompt.  Yours will look different, of course.  \nfreezer1\n is the executable you created.  The next line, \n0\n, is the input you provide.  Press enter after the input.  \n-20.0000\n is the output printed by \nfreezer1\n.\n\n\n(b)\n\n\nfreezer1\n is rather restrictive, as we can only calculate the temperature after one hour, two hours, etc.  The equation given above works for fractional hours as well.  Modify your program, call it \nfreezer2\n (source file \nfreezer2.c\n), so that it now reads in two integers: the number of hours and the number of additional minutes since the start of the power failure.  For example, to calculate the temperature after 2 hours and 45 minutes of power failure:\n\n\n1\n2\n3\nooiwt@pe111:~/ex01-ooiwt$ ./freezer2\n2 45\n-13.6316\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nI do not know where this formula comes from or if it is correct.  Please ignore the fact that, according to this formula, 32 hours after the power is turned off, the freezer will reach the boiling point of 100 Celsius!\u00a0\n\u21a9",
            "title": "1. Freezer"
        },
        {
            "location": "/ex01/index.html#exercise-1-freezer",
            "text": "This is your first programming exercise.  An exercise is something that you do on your own.  You can submit them but it will not be graded.   Test cases are provided for the exercises so that you can test and check on your own if your code is correct.  This is in contrast to an assignment, where you need to submit for grading and for credits.",
            "title": "Exercise 1: Freezer"
        },
        {
            "location": "/ex01/index.html#prerequisite",
            "text": "You are able to access the  CS1010 programming environment .  You are familiar with  basic UNIX CLI  and using terminal-based editor  vim .",
            "title": "Prerequisite"
        },
        {
            "location": "/ex01/index.html#learning-outcomes",
            "text": "Be comfortable writing simple C programs that involves arithmetic operations,  long  and  double  types.",
            "title": "Learning Outcomes"
        },
        {
            "location": "/ex01/index.html#one-time-setup",
            "text": "Before going into their first programming exercise, you need to do a one time setup of your account on PE. You need to create a file called  .gitconfig  in your home directory and with the following content:  1\n2\n3\n4\n5 [user]\n  name = Your Name\n  email = Your Email\n[github]  \n  user = Your GitHub ID   Your email should be whatever you used to sign up Github.  For example, a sample  .gitconfig  looks like this:  1\n2\n3\n4\n5 [user]\n  name = Jon Snow\n  email = king@north.gov\n[github]  \n  user = jonsnow   After saving this file, run:  1 git config --get github.user   It should return your GitHub user id.  It should print your GitHub user id as set.  If there is a typo, you need to edit  .gitconfig  again and reload it by repeating the command above.",
            "title": "One-Time Setup"
        },
        {
            "location": "/ex01/index.html#setup",
            "text": "Click on  this link  to accept the exercise.  Login to one of the hosts of  CS1010 programming environment (PE)  Run the following on the command line on one of the PE hosts:   1 ~cs1010/get-ex01    You should see a new subdirectory  ex01-<githubid>  in your current working directory, where  githubid  is your GitHub ID.   We will call this directory your  exercise directory  or  assignment directory .    Inside that directory, you should see a bunch of files:   freezer1.c  and  freezer2.c  are the most important files.  They are the skeleton C code that you should edit to solve the exercise.  inputs  and  outputs  are sub directories that contain test inputs and test outputs.  We use the convention  problem-name . test-id .in for input test data, and  problem-name . test-id .out for output test data.  So, you will see  freezer1.1.in ,  freezer1.1.out , etc.  The expected output for  freezer1.1.in  is in  freezer1.1.out .  You can look at the content of these files if you wish (which  UNIX  command should you use to do this?).  You can edit these files to change the test input and output.  Makefile : This is the configuration for the tool  make  that we use to automate the compilation and testing of the programs.  You do not have to understand how to write a  Makefile  for CS1010.  If you are interested to learn how to write a  Makefile , talk to either Wei Tsang or Google.  test.sh : This is a bash script for testing your code.  You do not have to edit this file nor call it directly.  It is called by  make .  If you are interested to learn how to write bash script, talk to either Wei Tsang or Google.",
            "title": "Setup"
        },
        {
            "location": "/ex01/index.html#identifying-yourself",
            "text": "In every C file that you submit to CS1010, you need to identify yourself by writing your name and tutorial group.  Marks will be deducted if you fail to do so.  You need to edit the line:  1 @author XXXX (Group YYYY)   and change it to something like:  1 @author Jon Snow (Group 10)",
            "title": "Identifying Yourself"
        },
        {
            "location": "/ex01/index.html#solving-the-assignments",
            "text": "Edit the files  freezer1.c  and  freezer2.c  to solve the corresponding question as described below.  To compile and run the given tests with the sample inputs and outputs, run on the command line,   1 make   This will compile both C files and if there is no error, run the test scripts.",
            "title": "Solving The Assignments"
        },
        {
            "location": "/ex01/index.html#submission",
            "text": "When you are ready, run the following command while you are in the exercise directory:  1 ~cs1010/submit-ex01   The files  freezer1.c  and  freezer2.c  will be uploaded to GitHub.  You can submit multiple times.",
            "title": "Submission"
        },
        {
            "location": "/ex01/index.html#grading",
            "text": "This assignment is not graded.",
            "title": "Grading"
        },
        {
            "location": "/ex01/index.html#question-1-freezer",
            "text": "",
            "title": "Question 1: Freezer"
        },
        {
            "location": "/ex01/index.html#a",
            "text": "Write a program  freezer1  (source file  freezer1.c ) that estimates the temperature (in degree Celsius) in a freezer given the elapsed time (in hours) since a power failure.  Assume this temperature  T T  is given by 1 :   \nT = \\frac{4t^2}{t + 2} - 20;  \nT = \\frac{4t^2}{t + 2} - 20;   where  t t  is the time (in hours) since the power failure.  Your program reads in an integer: the number of hours since the start of the power failure.",
            "title": "(a)"
        },
        {
            "location": "/ex01/index.html#sample-run",
            "text": "1\n2\n3\n4\n5\n6 ooiwt@pe111:~/ex01-ooiwt$ ./freezer1\n0\n-20.0000\nooiwt@pe111:~/ex01-ooiwt$ ./freezer1\n1\n-18.6667   The text  ooiwt@pe111:~/ex01-ooiwt$  is the command prompt.  Yours will look different, of course.   freezer1  is the executable you created.  The next line,  0 , is the input you provide.  Press enter after the input.   -20.0000  is the output printed by  freezer1 .",
            "title": "Sample run:"
        },
        {
            "location": "/ex01/index.html#b",
            "text": "freezer1  is rather restrictive, as we can only calculate the temperature after one hour, two hours, etc.  The equation given above works for fractional hours as well.  Modify your program, call it  freezer2  (source file  freezer2.c ), so that it now reads in two integers: the number of hours and the number of additional minutes since the start of the power failure.  For example, to calculate the temperature after 2 hours and 45 minutes of power failure:  1\n2\n3 ooiwt@pe111:~/ex01-ooiwt$ ./freezer2\n2 45\n-13.6316       I do not know where this formula comes from or if it is correct.  Please ignore the fact that, according to this formula, 32 hours after the power is turned off, the freezer will reach the boiling point of 100 Celsius!\u00a0 \u21a9",
            "title": "(b)"
        },
        {
            "location": "/ex02/index.html",
            "text": "Exercise 2: Leap, Suffix, Days\n\n\nThis is a programming exercise for you to solve on your own.  You can submit but it will not be graded.  Test cases are provided for the exercises so that you can test and check on your own if your code is correct.  Feel free to discuss your solution with your peers or your TAs.\n\n\nPrerequisite\n\n\n\n\nYou are able to access the \nCS1010 programming environment\n.\n\n\nYou are familiar with \nbasic UNIX CLI\n and using terminal-based editor \nvim\n.\n\n\nYou have a GitHub account and have setup \n.gitconfig\n (see \nExercise 1\n).\n\n\n\n\nLearning Outcomes\n\n\n\n\nBe comfortable writing correct C programs that involve \nif\n, \nelse\n, and logical statements.\n\n\n\n\nSetup\n\n\n\n\nClick on \nthis link\n to accept the exercise.\n\n\nLog in to one of the hosts of \nCS1010 programming environment (PE)\n\n\nRun the following on the command line on one of the PE hosts:\n\n\n\n\n1\n~cs1010/get-ex02\n\n\n\n\n\n\n\n\nYou should see a new subdirectory \nex02-<githubid>\n in your current working directory, where \ngithubid\n is your GitHub ID.\n\n\nInside that directory, you should see a bunch of files:\n\n\nleap.c\n, \nsuffix.c\n, and \ndays.c\n are the most important files.  They are the skeleton C code that you should edit to solve the exercise.\n\n\ninputs\n and \noutputs\n are subdirectories that contain test inputs and test outputs.  We use the same convention as Exercise 1 so you should be familiar with them.\n\n\nMakefile\n: This is the configuration for the tool \nmake\n that we use to automate the compilation and testing of the programs.  \n\n\ntest.sh\n: This is a bash script for testing your code.\n\n\n\n\n\n\n\n\nSolving The Assignments\n\n\n\n\nEdit the .c files to solve the corresponding question as described below\n\n\nYou can assume that all test inputs are valid inputs.\n\n\nTo compile and run the given tests with the sample inputs and outputs, run on the command line,\n\n\n\n\n1\nmake\n\n\n\n\n\n\nThis will compile all your C files and if there is no error, run the test scripts.\n\n\nSubmission\n\n\nWhen you are ready, run the following command while you are in the exercise directory:\n\n\n1\n~cs1010/submit-ex02\n\n\n\n\n\n\nThe .c files will be uploaded to GitHub.  You can submit multiple times.  As an exercise is not graded, submitting your code only serves the purpose of archiving your work for backup purposes.\n\n\n\n\nQuestion 1: Leap Year\n\n\nA \nleap year\n is a calendar year containing an extra day to synchronize the calendar to seasons and astronomical events.  In the Gregorian calendar, years that are multiples of four (with the exception of years divisible by 100 but not by 400) are leap years.\n\n\nWrite a program that reads in an integer representing a year from the standard input and prints out \"\n is a leap year\" if the input is a leap year.  Otherwise, print \"\n is not a leap year\" to the standard output.\n\n\nYour program should include a \nbool\n function \nis_leap_year\n that takes in the input year and returns \ntrue\n if the input is a leap year and returns \nfalse\n otherwise.\n\n\nSample run:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\nooiwt@pe112:~/ex02-ooiwt$ ./leap\n1995\n1995 is not a leap year\nooiwt@pe112:~/ex02-ooiwt$ ./leap\n1996\n1996 is a leap year\nooiwt@pe112:~/ex02-ooiwt$ ./leap\n1900\n1900 is not a leap year\nooiwt@pe112:~/ex02-ooiwt$ ./leap\n2000\n2000 is a leap year\n\n\n\n\n\n\nQuestion 2: Ordinal Suffix\n\n\nIn English, an ordinal number is written with numerals, followed by its letter suffixes.  For instance: 1\nst\n, 2\nnd\n, 3\nrd\n, 4\nth\n, 11\nth\n, 31\nst\n, etc.  The rule is that, a number that ends with digit 1 should have a suffix \"st\" (except if it ends with 11), a number that ends with 2 should have a suffix \"nd\" (except if it ends with 12), and a number that ends with 3 should have a suffix \"rd\" (except if it ends with 13).  All other numbers should end with \"th\".\n\n\nWrite a program \nsuffix\n that reads in an integer number from the standard input and prints out the number with its ordinal suffix.\n\n\nYour program should include a \nvoid\n function \nprint_with_suffix(long n)\n that takes in the input and prints out the number followed by its suffix.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\nooiwt@pe112:~/ex02-ooiwt$ ./suffix\n2\n2nd\nooiwt@pe112:~/ex02-ooiwt$ ./suffix\n13\n13th\nooiwt@pe112:~/ex02-ooiwt$ ./suffix\n412\n412th\nooiwt@pe112:~/ex02-ooiwt$ ./suffix\n3\n3rd\n\n\n\n\n\n\nQuestion 3: Days Since 1 January\n\n\nWrite a program called \ndays\n that reads in two integers from the standard input, the first is the month (ranged 1 to 12, inclusive) and the second is the day (ranged 1 to 31, inclusive).  The program should print to the standard output which day of the year it is.  \nAssume that the year is not a leap year\n.  You can reuse the method \nprint_suffix\n from the previous question.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nooiwt@pe112:~/ex02-ooiwt$ ./days\n1 1\n1st\nooiwt@pe112:~/ex02-ooiwt$ ./days\n8 15\n227th\nooiwt@pe112:~/ex02-ooiwt$ ./days\n12 31\n365th",
            "title": "2. Leap, Suffix, Days"
        },
        {
            "location": "/ex02/index.html#exercise-2-leap-suffix-days",
            "text": "This is a programming exercise for you to solve on your own.  You can submit but it will not be graded.  Test cases are provided for the exercises so that you can test and check on your own if your code is correct.  Feel free to discuss your solution with your peers or your TAs.",
            "title": "Exercise 2: Leap, Suffix, Days"
        },
        {
            "location": "/ex02/index.html#prerequisite",
            "text": "You are able to access the  CS1010 programming environment .  You are familiar with  basic UNIX CLI  and using terminal-based editor  vim .  You have a GitHub account and have setup  .gitconfig  (see  Exercise 1 ).",
            "title": "Prerequisite"
        },
        {
            "location": "/ex02/index.html#learning-outcomes",
            "text": "Be comfortable writing correct C programs that involve  if ,  else , and logical statements.",
            "title": "Learning Outcomes"
        },
        {
            "location": "/ex02/index.html#setup",
            "text": "Click on  this link  to accept the exercise.  Log in to one of the hosts of  CS1010 programming environment (PE)  Run the following on the command line on one of the PE hosts:   1 ~cs1010/get-ex02    You should see a new subdirectory  ex02-<githubid>  in your current working directory, where  githubid  is your GitHub ID.  Inside that directory, you should see a bunch of files:  leap.c ,  suffix.c , and  days.c  are the most important files.  They are the skeleton C code that you should edit to solve the exercise.  inputs  and  outputs  are subdirectories that contain test inputs and test outputs.  We use the same convention as Exercise 1 so you should be familiar with them.  Makefile : This is the configuration for the tool  make  that we use to automate the compilation and testing of the programs.    test.sh : This is a bash script for testing your code.",
            "title": "Setup"
        },
        {
            "location": "/ex02/index.html#solving-the-assignments",
            "text": "Edit the .c files to solve the corresponding question as described below  You can assume that all test inputs are valid inputs.  To compile and run the given tests with the sample inputs and outputs, run on the command line,   1 make   This will compile all your C files and if there is no error, run the test scripts.",
            "title": "Solving The Assignments"
        },
        {
            "location": "/ex02/index.html#submission",
            "text": "When you are ready, run the following command while you are in the exercise directory:  1 ~cs1010/submit-ex02   The .c files will be uploaded to GitHub.  You can submit multiple times.  As an exercise is not graded, submitting your code only serves the purpose of archiving your work for backup purposes.",
            "title": "Submission"
        },
        {
            "location": "/ex02/index.html#question-1-leap-year",
            "text": "A  leap year  is a calendar year containing an extra day to synchronize the calendar to seasons and astronomical events.  In the Gregorian calendar, years that are multiples of four (with the exception of years divisible by 100 but not by 400) are leap years.  Write a program that reads in an integer representing a year from the standard input and prints out \"  is a leap year\" if the input is a leap year.  Otherwise, print \"  is not a leap year\" to the standard output.  Your program should include a  bool  function  is_leap_year  that takes in the input year and returns  true  if the input is a leap year and returns  false  otherwise.",
            "title": "Question 1: Leap Year"
        },
        {
            "location": "/ex02/index.html#sample-run",
            "text": "1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12 ooiwt@pe112:~/ex02-ooiwt$ ./leap\n1995\n1995 is not a leap year\nooiwt@pe112:~/ex02-ooiwt$ ./leap\n1996\n1996 is a leap year\nooiwt@pe112:~/ex02-ooiwt$ ./leap\n1900\n1900 is not a leap year\nooiwt@pe112:~/ex02-ooiwt$ ./leap\n2000\n2000 is a leap year",
            "title": "Sample run:"
        },
        {
            "location": "/ex02/index.html#question-2-ordinal-suffix",
            "text": "In English, an ordinal number is written with numerals, followed by its letter suffixes.  For instance: 1 st , 2 nd , 3 rd , 4 th , 11 th , 31 st , etc.  The rule is that, a number that ends with digit 1 should have a suffix \"st\" (except if it ends with 11), a number that ends with 2 should have a suffix \"nd\" (except if it ends with 12), and a number that ends with 3 should have a suffix \"rd\" (except if it ends with 13).  All other numbers should end with \"th\".  Write a program  suffix  that reads in an integer number from the standard input and prints out the number with its ordinal suffix.  Your program should include a  void  function  print_with_suffix(long n)  that takes in the input and prints out the number followed by its suffix.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12 ooiwt@pe112:~/ex02-ooiwt$ ./suffix\n2\n2nd\nooiwt@pe112:~/ex02-ooiwt$ ./suffix\n13\n13th\nooiwt@pe112:~/ex02-ooiwt$ ./suffix\n412\n412th\nooiwt@pe112:~/ex02-ooiwt$ ./suffix\n3\n3rd",
            "title": "Question 2: Ordinal Suffix"
        },
        {
            "location": "/ex02/index.html#question-3-days-since-1-january",
            "text": "Write a program called  days  that reads in two integers from the standard input, the first is the month (ranged 1 to 12, inclusive) and the second is the day (ranged 1 to 31, inclusive).  The program should print to the standard output which day of the year it is.   Assume that the year is not a leap year .  You can reuse the method  print_suffix  from the previous question.  1\n2\n3\n4\n5\n6\n7\n8\n9 ooiwt@pe112:~/ex02-ooiwt$ ./days\n1 1\n1st\nooiwt@pe112:~/ex02-ooiwt$ ./days\n8 15\n227th\nooiwt@pe112:~/ex02-ooiwt$ ./days\n12 31\n365th",
            "title": "Question 3: Days Since 1 January"
        },
        {
            "location": "/ex03/index.html",
            "text": "Exercise 3: Binary, Rectangle, Fibonacci, Prime\n\n\nThis is a programming exercise for you to solve on your own.  You can submit but it will not be graded.  Test cases are provided for the exercises so that you can test and check on your own if your code is correct.  Feel free to discuss your solution with your peers or your TAs.\n\n\nPrerequisite\n\n\n\n\nYou are able to access the \nCS1010 programming environment\n.\n\n\nYou are familiar with \nbasic UNIX CLI\n and using terminal-based editor \nvim\n.\n\n\nYou have a GitHub account and have setup \n.gitconfig\n (see \nExercise 1\n).\n\n\n\n\nLearning Outcomes\n\n\n\n\nBe comfortable writing correct C programs that involve \nif\n, \nelse\n, loops, and logical statements.\n\n\nBe able to decompose a more complex problem into smaller subproblems and write functions to solve the sub-problems.\n\n\n\n\nSetup\n\n\n\n\nClick on \nthis link\n to accept the exercise.\n\n\nLog in to one of the hosts of \nCS1010 programming environment (PE)\n\n\nRun the following on the command line on one of the PE hosts:\n\n\n\n\n1\n~cs1010/get-ex03\n\n\n\n\n\n\n\n\nYou should see a new subdirectory \nex03-<githubid>\n in your current working directory, where \ngithubid\n is your GitHub ID.\n\n\nInside that directory, you should see a bunch of files:\n\n\nbinary.c\n, \nrectangle.c\n, \nprime.c\n and \nfibonacci.c\n are the most important files.  They are the skeleton C code that you should edit to solve the exercise.\n\n\ninputs\n and \noutputs\n are subdirectories that contain test inputs and test outputs.  We use the same convention as Exercise 1 so you should be familiar with them.\n\n\nMakefile\n: This is the configuration for the tool \nmake\n that we use to automate the compilation and testing of the programs.  \n\n\ntest.sh\n: This is a bash script for testing your code.\n\n\n\n\n\n\n\n\nSolving The Assignments\n\n\n\n\nEdit the .c files on the PE hosts to solve the corresponding question as described below.\n\n\nYou can assume that all test inputs are valid inputs.\n\n\nTo compile and run the given tests with the sample inputs and outputs, run on the command line,\n\n\n\n\n1\nmake\n\n\n\n\n\n\nThis will compile all your C files and if there is no error, run the test scripts.\n\n\nSubmission\n\n\nWhen you are ready, run the following command while you are in the exercise directory:\n\n\n1\n~cs1010/submit-ex03\n\n\n\n\n\n\nThe .c files will be uploaded to GitHub.  You can submit multiple times.  As an exercise is not graded, submitting your code only serves the purpose of archiving your work for backup purposes.\n\n\n\n\nQuestion 1: Binary\n\n\nIn this question, you are asked to convert a number represented in binary format (using digits 0 and 1) into the decimal format (using digits 0 and 9).  A number in decimal format is represented with based 10.  The last digit (rightmost) corresponds to the unit of \n10^0 = 1\n10^0 = 1\n, the next digit (second last) corresponds to the unit of \n10^1 = 10\n10^1 = 10\n, and so on.  So, one can write the decimal number, for instance, 7146 as \n\n7 \\times 10^3 + 1 \\times 10^2 + 4 \\times 10^1 + 6 \\times 10^0\n7 \\times 10^3 + 1 \\times 10^2 + 4 \\times 10^1 + 6 \\times 10^0\n.\n\n\nA number represented in binary uses base 2 instead of base 10.  The last digit corresponds to \n2^0 = 1\n2^0 = 1\n.  The second last digit correponds to \n2^1 = 2\n2^1 = 2\n, the third last digit corresponds to \n2^2 = 4\n2^2 = 4\n, and so on.  So, the binary number 1101, for instance, corresponds to \n1 \\times 2^3 + 1 \\times 2^2 + 1 \\times 2^0 = 13\n1 \\times 2^3 + 1 \\times 2^2 + 1 \\times 2^0 = 13\n.\n\n\nWrite a program called \nbinary\n that reads in a positive integer consists of only 0s and 1s from the standard input, treats it as a binary number, and prints the corresponding decimal number to the standard output.\n\n\nSample run:\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nooiwt@pe113:~/ex03-ooiwt$ ./binary\n1101\n13\nooiwt@pe113:~/ex03-ooiwt$ ./binary\n111\n7\nooiwt@pe113:~/ex03-ooiwt$ ./binary\n10110100\n180\n\n\n\n\n\n\nQuestion 2: Rectangle\n\n\nWrite a program called \nrectangle\n that reads two positive integers from the standard input, corresponding to the width and the height of the rectangle.  The width and height must be at least 2.  Draw a rectangle on the screen using the special ASCII characters #define \"\u2554\" \"\u2557\" \"\u255d\" \"\u255a\" \"\u2550\" \"\u2551\", which corresponds to the top left, top right, bottom right, bottom left, top/bottom edge, and left/right edge of the rectangle respectively.   Strings consisting of these special characters have been given to you in \nrectangle.c\n and we have defined them as constants.   For instance, \"\u2554\" is called \nTOP_LEFT\n, and to print this out, you can write\n\n1\ncs1010_print_string\n(\nTOP_LEFT\n);\n\n\n\n\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\nooiwt@pe113:~/ex03-ooiwt$ ./rectangle\n2 2\n\u2554\u2557\n\u255a\u255d\nooiwt@pe113:~/ex03-ooiwt$ ./rectangle\n2 10\n\u2554\u2557\n\u2551\u2551\n\u2551\u2551\n\u2551\u2551\n\u2551\u2551\n\u2551\u2551\n\u2551\u2551\n\u2551\u2551\n\u2551\u2551\n\u255a\u255d\nooiwt@pe113:~/ex03-ooiwt$ ./rectangle\n10 10\n\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n\u2551        \u2551\n\u2551        \u2551\n\u2551        \u2551\n\u2551        \u2551\n\u2551        \u2551\n\u2551        \u2551\n\u2551        \u2551\n\u2551        \u2551\n\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n\n\n\n\n\n\nQuestion 3: Fibonacci\n\n\nThe Fibonacci sequence is a sequence of numbers 1, 1, 2, 3, 5, 8, 13, ... Fibonacci numbers often appear in mathematics as well as in nature and have \nmany fascinating properties\n. \n\n\nThe Fibonacci sequence can be constructed as follows.  The first Fibonacci number is 1.  The second Fibonacci number is also 1.  Subsequently, the i-th Fibonacci number is computed as the sum of the previous two Fibonacci numbers, the (i-2)-th, and the (i-1)-th.\n\n\nWrite a program called \nfibonacci\n that reads a positive integer number \nn\n from the standard input, and print the \nn\n-th Fibonacci number to the standard output.  Your program must not use recursion.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nooiwt@pe113:~/ex03-ooiwt$ ./fibonacci\n1\n1\nooiwt@pe113:~/ex03-ooiwt$ ./fibonacci\n10\n55\nooiwt@pe113:~/ex03-ooiwt$ ./fibonacci\n83\n99194853094755497\n\n\n\n\n\n\nQuestion 4: Prime\n\n\nWrite a program called \nprime\n that reads a positive integer \nn\n from the standard input and either prints \nprime\n if \nn\n is a prime number, or prints \nnot prime\n if \nn\n is not a prime number.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nooiwt@pe113:~/ex03-ooiwt$ ./prime\n2\nprime\nooiwt@pe113:~/ex03-ooiwt$ ./prime\n14000605\nnot prime\nooiwt@pe113:~/ex03-ooiwt$ ./prime\n99194853094755497\nprime\n\n\n\n\n\n\nBonus: UNIX Pipe\n\n\nIf you look at the output from the last \nfibonacci\n example and the input to the last \nprime\n example, you will see that they are the same number.  This means that the 83\nrd\n Fibonacci number is prime!  \n\n\nSuppose now you want to ask, is the 13\nth\n Fibonacci number a prime?  How can we use the programs that we have wrote to do this?  There are several ways\n\n\n\n\nYou can merge the two C files to create a new program that, given \nn\n, calculate the \nn\n-th Fibonacci number, then check if it is prime.\n\n\nYou can reuse the two programs you have already written.  First, run \nfibonacci\n with input 13, then cut-and-paste the output as input to \nprime\n.\n\n\n\n\nA better alternative is to use a \n|\n in a UNIX-based system.  A \n|\n, called a \npipe\n, basically interconnects the standard output of one command to the standard input of the second command.  Consider the following:\n\n\n1\nooiwt@pe113:~/ex03-ooiwt$ a | b\n\n\n\n\n\n\nWhatever the program \na\n prints to the standard output, will be read by the program \nb\n when it reads from the standard input.  You have seen how the standard input can refer to a keyboard or a file, now you have seen how the standard input can also be another program!\n\n\nBack to the original problem: how to check if the 83\nrd\n Fibonnacci number is prime?  You can run:\n\n1\n2\n3\nooiwt@pe113:~/ex03-ooiwt$ ./fibonacci | ./prime\n83\nprime",
            "title": "3. Binary, Rectangle, Fibonacci, Prime"
        },
        {
            "location": "/ex03/index.html#exercise-3-binary-rectangle-fibonacci-prime",
            "text": "This is a programming exercise for you to solve on your own.  You can submit but it will not be graded.  Test cases are provided for the exercises so that you can test and check on your own if your code is correct.  Feel free to discuss your solution with your peers or your TAs.",
            "title": "Exercise 3: Binary, Rectangle, Fibonacci, Prime"
        },
        {
            "location": "/ex03/index.html#prerequisite",
            "text": "You are able to access the  CS1010 programming environment .  You are familiar with  basic UNIX CLI  and using terminal-based editor  vim .  You have a GitHub account and have setup  .gitconfig  (see  Exercise 1 ).",
            "title": "Prerequisite"
        },
        {
            "location": "/ex03/index.html#learning-outcomes",
            "text": "Be comfortable writing correct C programs that involve  if ,  else , loops, and logical statements.  Be able to decompose a more complex problem into smaller subproblems and write functions to solve the sub-problems.",
            "title": "Learning Outcomes"
        },
        {
            "location": "/ex03/index.html#setup",
            "text": "Click on  this link  to accept the exercise.  Log in to one of the hosts of  CS1010 programming environment (PE)  Run the following on the command line on one of the PE hosts:   1 ~cs1010/get-ex03    You should see a new subdirectory  ex03-<githubid>  in your current working directory, where  githubid  is your GitHub ID.  Inside that directory, you should see a bunch of files:  binary.c ,  rectangle.c ,  prime.c  and  fibonacci.c  are the most important files.  They are the skeleton C code that you should edit to solve the exercise.  inputs  and  outputs  are subdirectories that contain test inputs and test outputs.  We use the same convention as Exercise 1 so you should be familiar with them.  Makefile : This is the configuration for the tool  make  that we use to automate the compilation and testing of the programs.    test.sh : This is a bash script for testing your code.",
            "title": "Setup"
        },
        {
            "location": "/ex03/index.html#solving-the-assignments",
            "text": "Edit the .c files on the PE hosts to solve the corresponding question as described below.  You can assume that all test inputs are valid inputs.  To compile and run the given tests with the sample inputs and outputs, run on the command line,   1 make   This will compile all your C files and if there is no error, run the test scripts.",
            "title": "Solving The Assignments"
        },
        {
            "location": "/ex03/index.html#submission",
            "text": "When you are ready, run the following command while you are in the exercise directory:  1 ~cs1010/submit-ex03   The .c files will be uploaded to GitHub.  You can submit multiple times.  As an exercise is not graded, submitting your code only serves the purpose of archiving your work for backup purposes.",
            "title": "Submission"
        },
        {
            "location": "/ex03/index.html#question-1-binary",
            "text": "In this question, you are asked to convert a number represented in binary format (using digits 0 and 1) into the decimal format (using digits 0 and 9).  A number in decimal format is represented with based 10.  The last digit (rightmost) corresponds to the unit of  10^0 = 1 10^0 = 1 , the next digit (second last) corresponds to the unit of  10^1 = 10 10^1 = 10 , and so on.  So, one can write the decimal number, for instance, 7146 as  7 \\times 10^3 + 1 \\times 10^2 + 4 \\times 10^1 + 6 \\times 10^0 7 \\times 10^3 + 1 \\times 10^2 + 4 \\times 10^1 + 6 \\times 10^0 .  A number represented in binary uses base 2 instead of base 10.  The last digit corresponds to  2^0 = 1 2^0 = 1 .  The second last digit correponds to  2^1 = 2 2^1 = 2 , the third last digit corresponds to  2^2 = 4 2^2 = 4 , and so on.  So, the binary number 1101, for instance, corresponds to  1 \\times 2^3 + 1 \\times 2^2 + 1 \\times 2^0 = 13 1 \\times 2^3 + 1 \\times 2^2 + 1 \\times 2^0 = 13 .  Write a program called  binary  that reads in a positive integer consists of only 0s and 1s from the standard input, treats it as a binary number, and prints the corresponding decimal number to the standard output.",
            "title": "Question 1: Binary"
        },
        {
            "location": "/ex03/index.html#sample-run",
            "text": "1\n2\n3\n4\n5\n6\n7\n8\n9 ooiwt@pe113:~/ex03-ooiwt$ ./binary\n1101\n13\nooiwt@pe113:~/ex03-ooiwt$ ./binary\n111\n7\nooiwt@pe113:~/ex03-ooiwt$ ./binary\n10110100\n180",
            "title": "Sample run:"
        },
        {
            "location": "/ex03/index.html#question-2-rectangle",
            "text": "Write a program called  rectangle  that reads two positive integers from the standard input, corresponding to the width and the height of the rectangle.  The width and height must be at least 2.  Draw a rectangle on the screen using the special ASCII characters #define \"\u2554\" \"\u2557\" \"\u255d\" \"\u255a\" \"\u2550\" \"\u2551\", which corresponds to the top left, top right, bottom right, bottom left, top/bottom edge, and left/right edge of the rectangle respectively.   Strings consisting of these special characters have been given to you in  rectangle.c  and we have defined them as constants.   For instance, \"\u2554\" is called  TOP_LEFT , and to print this out, you can write 1 cs1010_print_string ( TOP_LEFT );     1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28 ooiwt@pe113:~/ex03-ooiwt$ ./rectangle\n2 2\n\u2554\u2557\n\u255a\u255d\nooiwt@pe113:~/ex03-ooiwt$ ./rectangle\n2 10\n\u2554\u2557\n\u2551\u2551\n\u2551\u2551\n\u2551\u2551\n\u2551\u2551\n\u2551\u2551\n\u2551\u2551\n\u2551\u2551\n\u2551\u2551\n\u255a\u255d\nooiwt@pe113:~/ex03-ooiwt$ ./rectangle\n10 10\n\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n\u2551        \u2551\n\u2551        \u2551\n\u2551        \u2551\n\u2551        \u2551\n\u2551        \u2551\n\u2551        \u2551\n\u2551        \u2551\n\u2551        \u2551\n\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d",
            "title": "Question 2: Rectangle"
        },
        {
            "location": "/ex03/index.html#question-3-fibonacci",
            "text": "The Fibonacci sequence is a sequence of numbers 1, 1, 2, 3, 5, 8, 13, ... Fibonacci numbers often appear in mathematics as well as in nature and have  many fascinating properties .   The Fibonacci sequence can be constructed as follows.  The first Fibonacci number is 1.  The second Fibonacci number is also 1.  Subsequently, the i-th Fibonacci number is computed as the sum of the previous two Fibonacci numbers, the (i-2)-th, and the (i-1)-th.  Write a program called  fibonacci  that reads a positive integer number  n  from the standard input, and print the  n -th Fibonacci number to the standard output.  Your program must not use recursion.  1\n2\n3\n4\n5\n6\n7\n8\n9 ooiwt@pe113:~/ex03-ooiwt$ ./fibonacci\n1\n1\nooiwt@pe113:~/ex03-ooiwt$ ./fibonacci\n10\n55\nooiwt@pe113:~/ex03-ooiwt$ ./fibonacci\n83\n99194853094755497",
            "title": "Question 3: Fibonacci"
        },
        {
            "location": "/ex03/index.html#question-4-prime",
            "text": "Write a program called  prime  that reads a positive integer  n  from the standard input and either prints  prime  if  n  is a prime number, or prints  not prime  if  n  is not a prime number.  1\n2\n3\n4\n5\n6\n7\n8\n9 ooiwt@pe113:~/ex03-ooiwt$ ./prime\n2\nprime\nooiwt@pe113:~/ex03-ooiwt$ ./prime\n14000605\nnot prime\nooiwt@pe113:~/ex03-ooiwt$ ./prime\n99194853094755497\nprime",
            "title": "Question 4: Prime"
        },
        {
            "location": "/ex03/index.html#bonus-unix-pipe",
            "text": "If you look at the output from the last  fibonacci  example and the input to the last  prime  example, you will see that they are the same number.  This means that the 83 rd  Fibonacci number is prime!    Suppose now you want to ask, is the 13 th  Fibonacci number a prime?  How can we use the programs that we have wrote to do this?  There are several ways   You can merge the two C files to create a new program that, given  n , calculate the  n -th Fibonacci number, then check if it is prime.  You can reuse the two programs you have already written.  First, run  fibonacci  with input 13, then cut-and-paste the output as input to  prime .   A better alternative is to use a  |  in a UNIX-based system.  A  | , called a  pipe , basically interconnects the standard output of one command to the standard input of the second command.  Consider the following:  1 ooiwt@pe113:~/ex03-ooiwt$ a | b   Whatever the program  a  prints to the standard output, will be read by the program  b  when it reads from the standard input.  You have seen how the standard input can refer to a keyboard or a file, now you have seen how the standard input can also be another program!  Back to the original problem: how to check if the 83 rd  Fibonnacci number is prime?  You can run: 1\n2\n3 ooiwt@pe113:~/ex03-ooiwt$ ./fibonacci | ./prime\n83\nprime",
            "title": "Bonus: UNIX Pipe"
        },
        {
            "location": "/ex04/index.html",
            "text": "Exercise 4: ID, Grade, Index, Max\n\n\nThis is a programming exercise for you to solve on your own.  You can submit but it will not be graded.  Test cases are provided for the exercises so that you can test and check on your own if your code is correct.  Feel free to discuss your solution with your peers or your TAs.\n\n\nPrerequisite\n\n\n\n\nYou are able to access the \nCS1010 programming environment\n.\n\n\nYou are familiar with \nbasic UNIX CLI\n and using terminal-based editor \nvim\n.\n\n\nYou have a GitHub account and have setup \n.gitconfig\n (see \nExercise 1\n).\n\n\n\n\nLearning Outcomes\n\n\n\n\nBe comfortable writing correct C programs that involve \nif\n, \nelse\n, loops, logical statements, and arrays.\n\n\nBe able to decompose a more complex problem into smaller subproblems and write functions to solve the sub-problems.\n\n\n\n\nSetup\n\n\n\n\nClick on \nthis link\n to accept the exercise.\n\n\nLog in to one of the hosts of \nCS1010 programming environment (PE)\n\n\nRun the following on the command line on one of the PE hosts:\n\n\n\n\n1\n~cs1010/get-ex04\n\n\n\n\n\n\n\n\nYou should see a new subdirectory \nex04-<githubid>\n in your current working directory, where \ngithubid\n is your GitHub ID.\n\n\nInside that directory, you should see a bunch of files:\n\n\nid.c\n, \ngrade.c\n, \nindex.c\n and \nmax.c\n are the most important files.  They are the skeleton C code that you should edit to solve the exercise.\n\n\ninputs\n and \noutputs\n are subdirectories that contain test inputs and test outputs.  We use the same convention as Exercise 1 so you should be familiar with them.\n\n\nMakefile\n: This is the configuration for the tool \nmake\n that we use to automate the compilation and testing of the programs.  \n\n\ntest.sh\n: This is a bash script for testing your code.\n\n\n\n\n\n\n\n\nSolving The Assignments\n\n\n\n\nEdit the .c files on the PE hosts to solve the corresponding question as described below.\n\n\nYou can assume that all test inputs are valid inputs.\n\n\nTo compile and run the given tests with the sample inputs and outputs, run on the command line,\n\n\n\n\n1\nmake\n\n\n\n\n\n\nThis will compile all your C files and if there is no error, run the test scripts.\n\n\nSubmission\n\n\nWhen you are ready, run the following command while you are in the exercise directory:\n\n\n1\n~cs1010/submit-ex04\n\n\n\n\n\n\nThe .c files will be uploaded to GitHub.  You can submit multiple times.  As an exercise is not graded, submitting your code only serves the purpose of archiving your work for backup purposes.\n\n\n\n\nQuestion 1: ID\n\n\nYour NUS student id has a letter at the end.  This letter is called a \ncheck code\n and is a form of redundancy check used for detecting errors, especially when your student id is manually entered into a software application.\n\n\nYour check code is calculated by:\n\n\n\n\nSum up the digits in your student id.  Let the sum be \nN\nN\n.\n\n\nDivide \nN\nN\n by 13, and take the remainder.  Let the remainder be \nR\nR\n\n\nLook up the table below:\n\n\n\n\n\n\n\n\n\n\nRemainder\n\n\nCheck Code\n\n\n\n\n\n\n\n\n\n\n0\n\n\nY\n\n\n\n\n\n\n1\n\n\nX\n\n\n\n\n\n\n2\n\n\nW\n\n\n\n\n\n\n3\n\n\nU\n\n\n\n\n\n\n4\n\n\nR\n\n\n\n\n\n\n5\n\n\nN\n\n\n\n\n\n\n6\n\n\nM\n\n\n\n\n\n\n7\n\n\nL\n\n\n\n\n\n\n8\n\n\nJ\n\n\n\n\n\n\n9\n\n\nH\n\n\n\n\n\n\n10\n\n\nE\n\n\n\n\n\n\n11\n\n\nA\n\n\n\n\n\n\n12\n\n\nB\n\n\n\n\n\n\n\n\nWrite a program that reads in an integer containing the digits of a student's id from the standard input.  Print out the check code to the standard output.\n\n\nYou should practice using an array to solve this problem instead of using a long if-else statement.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nooiwt@pe116:~/ex04-ooiwt$ ./studentid\n1933091\nY\nooiwt@pe116:~/ex04-ooiwt$ ./studentid\n3364497\nE\nooiwt@pe116:~/ex04-ooiwt$ ./studentid\n0123456\nJ\n\n\n\n\n\n\nAddendum:\n\nSome students choose to store the check code in an array of \nchar\n values instead of an array of strings.  Storing the check code as \nchar\n is indeed more appropriate, but I have not mentioned how to print a \nchar\n to the standard output.  There is no \ncs1010_print_char\n in the CS1010 I/O library.  One way to print a \nchar\n variable is to use \nputchar()\n function.  The example below print \nA\n.\n\n1\n2\n3\n4\n5\n6\n#include\n \n<stdio.h>\n\n\n\nint\n \nmain\n()\n \n{\n\n  \nchar\n \nc\n \n=\n \n'A'\n;\n\n  \nputchar\n(\nc\n);\n\n\n}\n\n\n\n\n\n\nQuestion 2: Grade\n\n\nIn a mirror universe, there is an evil version of your professor who is especially tough on his CS1010 students.  He uses the following grading scheme to decide the letter grade to give out.\n\n\n\n\n\n\n\n\nMarks\n\n\nLetter Grade\n\n\n\n\n\n\n\n\n\n\n100\n\n\nA+\n\n\n\n\n\n\n99\n\n\nA\n\n\n\n\n\n\n98\n\n\nA-\n\n\n\n\n\n\n96-97\n\n\nB+\n\n\n\n\n\n\n91-95\n\n\nB\n\n\n\n\n\n\n86-90\n\n\nB-\n\n\n\n\n\n\n81-85\n\n\nC+\n\n\n\n\n\n\n71-80\n\n\nC\n\n\n\n\n\n\n61-70\n\n\nD+\n\n\n\n\n\n\n51-60\n\n\nD\n\n\n\n\n\n\n0 -50\n\n\nF\n\n\n\n\n\n\n\n\nWrite a program called \ngrade\n that reads in an integer corresponding to the marks given to a student. Print out the letter grade given by the evil professor.\n\n\nYou should practice using an array to solve this problem instead of using a long if-else statement as done in \nUnit 8\n.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\nooiwt@pe116:~/ex04-ooiwt$ ./grade\n100\nA+\nooiwt@pe116:~/ex04-ooiwt$ ./grade\n99\nA\nooiwt@pe116:~/ex04-ooiwt$ ./grade\n50\nF\nooiwt@pe116:~/ex04-ooiwt$ ./grade\n87\nB-\n\n\n\n\n\n\nQuestion 3: Index\n\n\nWrite a program \nindex\n that finds a given number from a list of \nn\nn\n integers \nL\nL\n.\n\n\nThe program should read the following from the standard inputs in order:\n\n\n\n\nThe first number is a positive integer \nn\nn\n\n\nThe next \nn\nn\n numbers corresponds to the list of integers \nl_0, l_1, ... l_{n-1}\nl_0, l_1, ... l_{n-1}\n in \nL\nL\n.\n\n\nThe next number is a positive integer \nk\nk\n\n\nThe next \nk\nk\n numbers are integers corresponds to a list of queries \nq_0, q_1, .. q_k\nq_0, q_1, .. q_k\n\n\n\n\nFor each query, the program should print (on a new line) the position of the integer in the list, or \"not found\" if the query cannot be found.  To be more precise, for each \ni\ni\n, if \nq_i == l_j\nq_i == l_j\n for some \nj\nj\n, print \nj\nj\n.  If \nq_i\nq_i\n appears multiple times in \nL\nL\n, print the smallest \nj\nj\n.  If \nq_i\nq_i\n is not in \nL\nL\n, then print \"not found\".\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nooiwt@pe116:~/ex04-ooiwt$ cat input\n5\n-5 3 1 8 -5\n3\n1 4 -5\nooiwt@pe116:~/ex04-ooiwt$ ./index < input\n2\nnot found\n0\n\n\n\n\n\n\nLine 1 of the input file \ninput\n tells the program that there are five integers to read.  The next five integers should be read in as the list.  The next integer (Line 3) is 3.  The next three integers should be read in as queries.  The first query is 1, which can be found at position 2 (we start counting from 0).  The next query is 4, which is not found in the list.  Finally, the last query is -5, which can be found at position 0 and 4, but we return only the one at position 0.\n\n\nQuestion 4: Max\n\n\nWrite a program \nmax\n that finds the maximum value from a list of \nn\nn\n integers \nL\nL\n.\n\n\nInstead of doing this with a loop, you should solve this question with recursion.  Write a function\n\n\n1\n2\n3\nlong max(const long list[], long start, long end)\n{\n}\n\n\n\n\n\n\nthat calls itself and return the maximum value among the array elements \nlist[start]\n .. \nlist[end - 1]\n.  It should split the input list into two halves (roughly), find the maximum of the left half, find the maximum of the right half, and return the larger of these two maximums.\n\n\nIn the function definition above, the keyword \nconst\n (short for constant) is used to annotate that the array \nlist\n is meant to remain unchanged.\n\n\nThe program should read the following from the standard inputs:\n\n\n\n\nThe first number is a positive integer \nn\nn\n\n\nThe next \nn\nn\n numbers correspond to the list of integers \nL\nL\n.\n\n\n\n\nand print to the largest value among the inputs to the standard output.\n\n\n1\n2\n3\n4\n5\nooiwt@pe116:~/ex04-ooiwt$ cat input\n5\n-5 3 1 8 2\nooiwt@pe116:~/ex04-ooiwt$ ./max < input\n8",
            "title": "4. ID, Grade, Index, Max"
        },
        {
            "location": "/ex04/index.html#exercise-4-id-grade-index-max",
            "text": "This is a programming exercise for you to solve on your own.  You can submit but it will not be graded.  Test cases are provided for the exercises so that you can test and check on your own if your code is correct.  Feel free to discuss your solution with your peers or your TAs.",
            "title": "Exercise 4: ID, Grade, Index, Max"
        },
        {
            "location": "/ex04/index.html#prerequisite",
            "text": "You are able to access the  CS1010 programming environment .  You are familiar with  basic UNIX CLI  and using terminal-based editor  vim .  You have a GitHub account and have setup  .gitconfig  (see  Exercise 1 ).",
            "title": "Prerequisite"
        },
        {
            "location": "/ex04/index.html#learning-outcomes",
            "text": "Be comfortable writing correct C programs that involve  if ,  else , loops, logical statements, and arrays.  Be able to decompose a more complex problem into smaller subproblems and write functions to solve the sub-problems.",
            "title": "Learning Outcomes"
        },
        {
            "location": "/ex04/index.html#setup",
            "text": "Click on  this link  to accept the exercise.  Log in to one of the hosts of  CS1010 programming environment (PE)  Run the following on the command line on one of the PE hosts:   1 ~cs1010/get-ex04    You should see a new subdirectory  ex04-<githubid>  in your current working directory, where  githubid  is your GitHub ID.  Inside that directory, you should see a bunch of files:  id.c ,  grade.c ,  index.c  and  max.c  are the most important files.  They are the skeleton C code that you should edit to solve the exercise.  inputs  and  outputs  are subdirectories that contain test inputs and test outputs.  We use the same convention as Exercise 1 so you should be familiar with them.  Makefile : This is the configuration for the tool  make  that we use to automate the compilation and testing of the programs.    test.sh : This is a bash script for testing your code.",
            "title": "Setup"
        },
        {
            "location": "/ex04/index.html#solving-the-assignments",
            "text": "Edit the .c files on the PE hosts to solve the corresponding question as described below.  You can assume that all test inputs are valid inputs.  To compile and run the given tests with the sample inputs and outputs, run on the command line,   1 make   This will compile all your C files and if there is no error, run the test scripts.",
            "title": "Solving The Assignments"
        },
        {
            "location": "/ex04/index.html#submission",
            "text": "When you are ready, run the following command while you are in the exercise directory:  1 ~cs1010/submit-ex04   The .c files will be uploaded to GitHub.  You can submit multiple times.  As an exercise is not graded, submitting your code only serves the purpose of archiving your work for backup purposes.",
            "title": "Submission"
        },
        {
            "location": "/ex04/index.html#question-1-id",
            "text": "Your NUS student id has a letter at the end.  This letter is called a  check code  and is a form of redundancy check used for detecting errors, especially when your student id is manually entered into a software application.  Your check code is calculated by:   Sum up the digits in your student id.  Let the sum be  N N .  Divide  N N  by 13, and take the remainder.  Let the remainder be  R R  Look up the table below:      Remainder  Check Code      0  Y    1  X    2  W    3  U    4  R    5  N    6  M    7  L    8  J    9  H    10  E    11  A    12  B     Write a program that reads in an integer containing the digits of a student's id from the standard input.  Print out the check code to the standard output.  You should practice using an array to solve this problem instead of using a long if-else statement.  1\n2\n3\n4\n5\n6\n7\n8\n9 ooiwt@pe116:~/ex04-ooiwt$ ./studentid\n1933091\nY\nooiwt@pe116:~/ex04-ooiwt$ ./studentid\n3364497\nE\nooiwt@pe116:~/ex04-ooiwt$ ./studentid\n0123456\nJ   Addendum: \nSome students choose to store the check code in an array of  char  values instead of an array of strings.  Storing the check code as  char  is indeed more appropriate, but I have not mentioned how to print a  char  to the standard output.  There is no  cs1010_print_char  in the CS1010 I/O library.  One way to print a  char  variable is to use  putchar()  function.  The example below print  A . 1\n2\n3\n4\n5\n6 #include   <stdio.h>  int   main ()   { \n   char   c   =   'A' ; \n   putchar ( c );  }",
            "title": "Question 1: ID"
        },
        {
            "location": "/ex04/index.html#question-2-grade",
            "text": "In a mirror universe, there is an evil version of your professor who is especially tough on his CS1010 students.  He uses the following grading scheme to decide the letter grade to give out.     Marks  Letter Grade      100  A+    99  A    98  A-    96-97  B+    91-95  B    86-90  B-    81-85  C+    71-80  C    61-70  D+    51-60  D    0 -50  F     Write a program called  grade  that reads in an integer corresponding to the marks given to a student. Print out the letter grade given by the evil professor.  You should practice using an array to solve this problem instead of using a long if-else statement as done in  Unit 8 .   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12 ooiwt@pe116:~/ex04-ooiwt$ ./grade\n100\nA+\nooiwt@pe116:~/ex04-ooiwt$ ./grade\n99\nA\nooiwt@pe116:~/ex04-ooiwt$ ./grade\n50\nF\nooiwt@pe116:~/ex04-ooiwt$ ./grade\n87\nB-",
            "title": "Question 2: Grade"
        },
        {
            "location": "/ex04/index.html#question-3-index",
            "text": "Write a program  index  that finds a given number from a list of  n n  integers  L L .  The program should read the following from the standard inputs in order:   The first number is a positive integer  n n  The next  n n  numbers corresponds to the list of integers  l_0, l_1, ... l_{n-1} l_0, l_1, ... l_{n-1}  in  L L .  The next number is a positive integer  k k  The next  k k  numbers are integers corresponds to a list of queries  q_0, q_1, .. q_k q_0, q_1, .. q_k   For each query, the program should print (on a new line) the position of the integer in the list, or \"not found\" if the query cannot be found.  To be more precise, for each  i i , if  q_i == l_j q_i == l_j  for some  j j , print  j j .  If  q_i q_i  appears multiple times in  L L , print the smallest  j j .  If  q_i q_i  is not in  L L , then print \"not found\".  1\n2\n3\n4\n5\n6\n7\n8\n9 ooiwt@pe116:~/ex04-ooiwt$ cat input\n5\n-5 3 1 8 -5\n3\n1 4 -5\nooiwt@pe116:~/ex04-ooiwt$ ./index < input\n2\nnot found\n0   Line 1 of the input file  input  tells the program that there are five integers to read.  The next five integers should be read in as the list.  The next integer (Line 3) is 3.  The next three integers should be read in as queries.  The first query is 1, which can be found at position 2 (we start counting from 0).  The next query is 4, which is not found in the list.  Finally, the last query is -5, which can be found at position 0 and 4, but we return only the one at position 0.",
            "title": "Question 3: Index"
        },
        {
            "location": "/ex04/index.html#question-4-max",
            "text": "Write a program  max  that finds the maximum value from a list of  n n  integers  L L .  Instead of doing this with a loop, you should solve this question with recursion.  Write a function  1\n2\n3 long max(const long list[], long start, long end)\n{\n}   that calls itself and return the maximum value among the array elements  list[start]  ..  list[end - 1] .  It should split the input list into two halves (roughly), find the maximum of the left half, find the maximum of the right half, and return the larger of these two maximums.  In the function definition above, the keyword  const  (short for constant) is used to annotate that the array  list  is meant to remain unchanged.  The program should read the following from the standard inputs:   The first number is a positive integer  n n  The next  n n  numbers correspond to the list of integers  L L .   and print to the largest value among the inputs to the standard output.  1\n2\n3\n4\n5 ooiwt@pe116:~/ex04-ooiwt$ cat input\n5\n-5 3 1 8 2\nooiwt@pe116:~/ex04-ooiwt$ ./max < input\n8",
            "title": "Question 4: Max"
        },
        {
            "location": "/ex05/index.html",
            "text": "Exercise 5: Square, Escape, MagicSquare\n\n\nThis is a programming exercise for you to solve on your own.  You can submit but it will not be graded.  Test cases are provided for the exercises so that you can test and check on your own if your code is correct.  Feel free to discuss your solution with your peers or your TAs.\n\n\nPrerequisite\n\n\n\n\nYou are able to access the \nCS1010 programming environment\n.\n\n\nYou are familiar with \nbasic UNIX CLI\n and using terminal-based editor \nvim\n.\n\n\nYou have a GitHub account and have setup \n.gitconfig\n (see \nExercise 1\n).\n\n\n\n\nLearning Outcomes\n\n\n\n\nBe comfortable writing correct C programs that involve \nif\n, \nelse\n, loops, logical statements, memory management, and arrays. \n\n\nBe able to decompose a more complex problem into smaller subproblems and write functions to solve the sub-problems.\n\n\nBe able to use nD arrays to solve problems\n\n\n\n\nSetup\n\n\n\n\nClick on \nthis link\n to accept the exercise.\n\n\nLog in to one of the hosts of \nCS1010 programming environment (PE)\n\n\nRun the following on the command line on one of the PE hosts:\n\n\n\n\n1\n~cs1010/get-ex05\n\n\n\n\n\n\n\n\nYou should see a new subdirectory \nex05-<githubid>\n in your current working directory, where \ngithubid\n is your GitHub ID.\n\n\nInside that directory, you should see a bunch of files:\n\n\nsquare.c\n, \nescape.c\n, and \nmagicsquare.c\n are the most important files.  They are the C code that you should edit to solve the exercise.\n\n\ninputs\n and \noutputs\n are subdirectories that contain test inputs and test outputs.  We use the same convention as Exercise 1 so you should be familiar with them.\n\n\nMakefile\n: This is the configuration for the tool \nmake\n that we use to automate the compilation and testing of the programs.  \n\n\ntest.sh\n: This is a bash script for testing your code.\n\n\n\n\n\n\n\n\nSolving The Assignments\n\n\n\n\nEdit the .c files on the PE hosts to solve the corresponding question as described below.\n\n\nYou can assume that all test inputs are valid inputs.\n\n\nTo compile and run the given tests with the sample inputs and outputs, run on the command line,\n\n\n\n\n1\nmake\n\n\n\n\n\n\nThis will compile all your C files and if there is no error, run the test scripts.\n\n\nSubmission\n\n\nWhen you are ready, run the following command while you are in the exercise directory:\n\n\n1\n~cs1010/submit-ex05\n\n\n\n\n\n\nThe .c files will be uploaded to GitHub.  You can submit multiple times.  As an exercise is not graded, submitting your code only serves the purpose of archiving your work for backup purposes.\n\n\n\n\nQuestion 1: Square\n\n\nRecall Question 5 from PE1, where you are asked to draw patterns of squares using recursion.  In this problem, you are to solve the same problem using loops and arrays, instead of recursion.\n\n\nWrite a program \nsquare\n that reads, from the standard input, an integer \nn\nn\n and prints, to the standard output, a set of squares with width \nn\nn\n, \nn - 4\nn - 4\n, \nn - 8\nn - 8\n, .. until we reach either the width of 3, 2, 1, or 0. The smaller square is contained in the larger squares. The squares do not touch each other. A square has exactly one space between itself and the next larger square (if exists), in each direction.\n\n\nHere is how we can use loops and a 2D array to solve this problem.  Suppose we have a 2D \nchar\n array of size $n \\times $n.  We can \"draw\" in this array by filling it with \n' '\n or \n'#'\n.  We can then print this array to the standard output to display the pattern on the screen.\n\n\nWrite a program \nsquare\n, that reads from standard inputs, an integer \nn\n, and prints to standard output the expected pattern of squares.\n\n\nSample Run 1\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\nooiwt@pe119:~ex05-weitsang$ ./square\n1\n#\nooiwt@pe119:~ex05-weitsang$ ./square\n2\n##\n##\nooiwt@pe119:~ex05-weitsang$ ./square\n3\n###\n# #\n###\nooiwt@pe119:~ex05-weitsang$ ./square\n4\n####\n#  #\n#  #\n####\nooiwt@pe119:~ex05-weitsang$ ./square\n5\n#####\n#   #\n# # #\n#   #\n#####\nooiwt@pe119:~ex05-weitsang$ ./square\n6\n######\n#    #\n# ## #\n# ## #\n#    #\n######\nooiwt@pe119:~ex05-weitsang$ ./square\n7\n#######\n#     #\n# ### #\n# # # #\n# ### #\n#     #\n#######\nooiwt@pe119:~ex05-weitsang$ ./square\n10\n##########\n#        #\n# ###### #\n# #    # #\n# # ## # #\n# # ## # #\n# #    # #\n# ###### #\n#        #\n##########\n\n\n\n\n\n\nQuestion 2: Escape\n\n\nAckbar is lost in a maze that contains traps.  You are his only hope!  Send him instructions remotely to help him escape.\n\n\nThe maze is represented as a \nm \\times n\nm \\times n\n grid of cells, where each cell can be of the following:\n\n\n\n\nA wall, denoted by character \n'#'\n\n\nAn empty space, denoted by character \n'.'\n\n\nA trap, denoted by character \n'*'\n\n\n\n\nTo help Ackbar, you give Ackbar a series of instructions denoted by \nU\n,\nD\n,\nL\n, or \nR\n. \nU\n instructs Ackbar to move to the cell one row above. \nD\n instructors Ackbar to go to the cell one row below.  \nL\n instructs Ackbar to move to the cell one column to the left, and \nR\n instructs Ackbar to move to the cell one column to the right.  Ackbar follows the instructions in the order they are given, and it only moves one cell adjacent by following each instruction, with the following exceptions:\n\n\n\n\n\n\nIf an instruction leads Ackbar to a wall, Ackbar's path is blocked and he stays in position.  He continues with the next instruction if there is one.\n\n\n\n\n\n\nif an instruction leads Ackbar to a trap, he is trapped and is unable to move anymore.  All subsequent instructions have no effect on Ackbar.  Poor Ackbar!\n\n\n\n\n\n\nIf the instruction leads Ackbar to anywhere outside the maze, Ackbar escapes happily and any instruction after that is ignored.\n\n\n\n\n\n\nFor convenience, we index the row as 0 to \nm\nm\n-1 from top to bottom, and column as 0 to \nn\nn\n-1 from left to right.\n\n\nWrite a program \nescape\n, that reads (from the standard input) two positive integers \nm\nm\n and \nn\nn\n, followed by \nm\nm\n rows with \nn\nn\n characters in each row. These characters denote the maze of size \nm \\times n\nm \\times n\n. Each character can only be \n#\n, \n.\n, \n*\n or \nA\n, where \nA\n denotes the initial position of Ackbar on an empty space.  It is guaranteed only one \nA\n exists in the input.  Your program then reads a string denoting the order you give to Ackbar.  Each character can only be \nU\n, \nD\n, \nL\n, or \nR\n.  Finally, your program prints, to the standard output, one of the following:\n\n\n\n\nIf Ackbar escaped from the maze after following some instructions, print \"ESCAPED!\"\n\n\nIf Ackbar is trapped due to your unwise instruction, print \"IT'S A TRAP!\"\n\n\nIf Ackbar is still stuck in the maze but not trapped after following all the instructions, print the position of Ackbar as \nx y\n where \nx\n and \ny\n denotes the row and column of Ackbar's position after following all your instructions.\n\n\n\n\nSample Run\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\nooiwt@pe119:~/ex05-weitsang$ ./escape\n5 5\n#.###\n#...#\n#.A##\n#.*.#\n#####\nRLU\n1 1\nooiwt@pe119:~/ex05-weitsang$ ./escape\n5 5\n#.###\n#...#\n#.A##\n#.*.#\n#####\nRLUUU\nESCAPED!\nooiwt@pe119:~/ex05-weitsang$ ./escape\n5 5\n#.###\n#...#\n#.A##\n#.*.#\n#####\nLURLUUUDLR\nESCAPED!\nooiwt@pe119:~/ex05-weitsang$ ./escape\n5 5\n#.###\n#...#\n#.A##\n#.*.#\n#####\nUDDLUUUUU\nIT'S A TRAP!\n\n\n\n\n\n\nQuestion 3: Magic\n\n\nA magic square is a grid of \nn \\times n\nn \\times n\n with each cell filled with a distinct number from 1 to \nn^2\nn^2\n, such that, the sum of each row, column, or diagonal are the same. \n\n\nWrite a program, \nmagicsquare\n, that constructs a magic square of size \nn \\times n\nn \\times n\n, where \nn\nn\n is odd.\n\n\nThere are multiple ways we can construct such as magic square.  For this question, you shall follow the following algorithm:\n\n\n\n\nPut 1 at center column of the top row\n\n\n\n\nEach of the remaining numbers is placed one row up and one column to the right of the previous number.  This may not always work when we reach the edge of the square or when the cell one row up and one column to the right is occupied.  In such a case, you should follow the rules below:\n\n\n\n\nA. If a number's cell is already taken, put it one row below the position of the previous number;\n\n\nB. If a number's cell is above the top row, stay in that column and put it in the bottom row;\n\n\nC. If a number's cell is outside of the rightmost column, stay in that row and put it in the leftmost column;\n\n\nD. If a number's cell is outside both the topmost row and the rightmost column put it one row below the previous number.\n\n\n\n\n\n\n\n\nThe following example shows how we fill up a \n5\\times 5\n5\\times 5\n magic square.\n\n\n\n\nThe number 2 is filled above the top row, so we apply Rule B.  The number 4 is filled outside the rightmost column, so we apply Rule C.\n\n\n\n\nThe cell for number 6 is already taken (by 1), so we apply Rule A.\n\n\n\n\nThe number 16 goes outside both the topmost row and the rightmost column, so we apply Rule D.\n\n\n\n\nWrite a program \nmagicsquare\n, that reads (from the standard input) an odd integer \nn\nn\n and prints (to the standard output) \nn\nn\n rows with \nn\nn\n numbers in each row, denoting the constructed magic square using above described method.\n\n\nSample Run\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\nooiwt@pe119:~/ex05-weitsang$ ./magicsquare\n3\n8 1 6\n3 5 7\n4 9 2\nooiwt@pe119:~/ex05-weitsang$ ./magicsquare\n7\n30 39 48 1 10 19 28\n38 47 7 9 18 27 29\n46 6 8 17 26 35 37\n5 14 16 25 34 36 45\n13 15 24 33 42 44 4\n21 23 32 41 43 3 12\n22 31 40 49 2 11 20",
            "title": "5. Square, Escape, Magic"
        },
        {
            "location": "/ex05/index.html#exercise-5-square-escape-magicsquare",
            "text": "This is a programming exercise for you to solve on your own.  You can submit but it will not be graded.  Test cases are provided for the exercises so that you can test and check on your own if your code is correct.  Feel free to discuss your solution with your peers or your TAs.",
            "title": "Exercise 5: Square, Escape, MagicSquare"
        },
        {
            "location": "/ex05/index.html#prerequisite",
            "text": "You are able to access the  CS1010 programming environment .  You are familiar with  basic UNIX CLI  and using terminal-based editor  vim .  You have a GitHub account and have setup  .gitconfig  (see  Exercise 1 ).",
            "title": "Prerequisite"
        },
        {
            "location": "/ex05/index.html#learning-outcomes",
            "text": "Be comfortable writing correct C programs that involve  if ,  else , loops, logical statements, memory management, and arrays.   Be able to decompose a more complex problem into smaller subproblems and write functions to solve the sub-problems.  Be able to use nD arrays to solve problems",
            "title": "Learning Outcomes"
        },
        {
            "location": "/ex05/index.html#setup",
            "text": "Click on  this link  to accept the exercise.  Log in to one of the hosts of  CS1010 programming environment (PE)  Run the following on the command line on one of the PE hosts:   1 ~cs1010/get-ex05    You should see a new subdirectory  ex05-<githubid>  in your current working directory, where  githubid  is your GitHub ID.  Inside that directory, you should see a bunch of files:  square.c ,  escape.c , and  magicsquare.c  are the most important files.  They are the C code that you should edit to solve the exercise.  inputs  and  outputs  are subdirectories that contain test inputs and test outputs.  We use the same convention as Exercise 1 so you should be familiar with them.  Makefile : This is the configuration for the tool  make  that we use to automate the compilation and testing of the programs.    test.sh : This is a bash script for testing your code.",
            "title": "Setup"
        },
        {
            "location": "/ex05/index.html#solving-the-assignments",
            "text": "Edit the .c files on the PE hosts to solve the corresponding question as described below.  You can assume that all test inputs are valid inputs.  To compile and run the given tests with the sample inputs and outputs, run on the command line,   1 make   This will compile all your C files and if there is no error, run the test scripts.",
            "title": "Solving The Assignments"
        },
        {
            "location": "/ex05/index.html#submission",
            "text": "When you are ready, run the following command while you are in the exercise directory:  1 ~cs1010/submit-ex05   The .c files will be uploaded to GitHub.  You can submit multiple times.  As an exercise is not graded, submitting your code only serves the purpose of archiving your work for backup purposes.",
            "title": "Submission"
        },
        {
            "location": "/ex05/index.html#question-1-square",
            "text": "Recall Question 5 from PE1, where you are asked to draw patterns of squares using recursion.  In this problem, you are to solve the same problem using loops and arrays, instead of recursion.  Write a program  square  that reads, from the standard input, an integer  n n  and prints, to the standard output, a set of squares with width  n n ,  n - 4 n - 4 ,  n - 8 n - 8 , .. until we reach either the width of 3, 2, 1, or 0. The smaller square is contained in the larger squares. The squares do not touch each other. A square has exactly one space between itself and the next larger square (if exists), in each direction.  Here is how we can use loops and a 2D array to solve this problem.  Suppose we have a 2D  char  array of size $n \\times $n.  We can \"draw\" in this array by filling it with  ' '  or  '#' .  We can then print this array to the standard output to display the pattern on the screen.  Write a program  square , that reads from standard inputs, an integer  n , and prints to standard output the expected pattern of squares.",
            "title": "Question 1: Square"
        },
        {
            "location": "/ex05/index.html#sample-run-1",
            "text": "1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54 ooiwt@pe119:~ex05-weitsang$ ./square\n1\n#\nooiwt@pe119:~ex05-weitsang$ ./square\n2\n##\n##\nooiwt@pe119:~ex05-weitsang$ ./square\n3\n###\n# #\n###\nooiwt@pe119:~ex05-weitsang$ ./square\n4\n####\n#  #\n#  #\n####\nooiwt@pe119:~ex05-weitsang$ ./square\n5\n#####\n#   #\n# # #\n#   #\n#####\nooiwt@pe119:~ex05-weitsang$ ./square\n6\n######\n#    #\n# ## #\n# ## #\n#    #\n######\nooiwt@pe119:~ex05-weitsang$ ./square\n7\n#######\n#     #\n# ### #\n# # # #\n# ### #\n#     #\n#######\nooiwt@pe119:~ex05-weitsang$ ./square\n10\n##########\n#        #\n# ###### #\n# #    # #\n# # ## # #\n# # ## # #\n# #    # #\n# ###### #\n#        #\n##########",
            "title": "Sample Run 1"
        },
        {
            "location": "/ex05/index.html#question-2-escape",
            "text": "Ackbar is lost in a maze that contains traps.  You are his only hope!  Send him instructions remotely to help him escape.  The maze is represented as a  m \\times n m \\times n  grid of cells, where each cell can be of the following:   A wall, denoted by character  '#'  An empty space, denoted by character  '.'  A trap, denoted by character  '*'   To help Ackbar, you give Ackbar a series of instructions denoted by  U , D , L , or  R .  U  instructs Ackbar to move to the cell one row above.  D  instructors Ackbar to go to the cell one row below.   L  instructs Ackbar to move to the cell one column to the left, and  R  instructs Ackbar to move to the cell one column to the right.  Ackbar follows the instructions in the order they are given, and it only moves one cell adjacent by following each instruction, with the following exceptions:    If an instruction leads Ackbar to a wall, Ackbar's path is blocked and he stays in position.  He continues with the next instruction if there is one.    if an instruction leads Ackbar to a trap, he is trapped and is unable to move anymore.  All subsequent instructions have no effect on Ackbar.  Poor Ackbar!    If the instruction leads Ackbar to anywhere outside the maze, Ackbar escapes happily and any instruction after that is ignored.    For convenience, we index the row as 0 to  m m -1 from top to bottom, and column as 0 to  n n -1 from left to right.  Write a program  escape , that reads (from the standard input) two positive integers  m m  and  n n , followed by  m m  rows with  n n  characters in each row. These characters denote the maze of size  m \\times n m \\times n . Each character can only be  # ,  . ,  *  or  A , where  A  denotes the initial position of Ackbar on an empty space.  It is guaranteed only one  A  exists in the input.  Your program then reads a string denoting the order you give to Ackbar.  Each character can only be  U ,  D ,  L , or  R .  Finally, your program prints, to the standard output, one of the following:   If Ackbar escaped from the maze after following some instructions, print \"ESCAPED!\"  If Ackbar is trapped due to your unwise instruction, print \"IT'S A TRAP!\"  If Ackbar is still stuck in the maze but not trapped after following all the instructions, print the position of Ackbar as  x y  where  x  and  y  denotes the row and column of Ackbar's position after following all your instructions.",
            "title": "Question 2: Escape"
        },
        {
            "location": "/ex05/index.html#sample-run",
            "text": "1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36 ooiwt@pe119:~/ex05-weitsang$ ./escape\n5 5\n#.###\n#...#\n#.A##\n#.*.#\n#####\nRLU\n1 1\nooiwt@pe119:~/ex05-weitsang$ ./escape\n5 5\n#.###\n#...#\n#.A##\n#.*.#\n#####\nRLUUU\nESCAPED!\nooiwt@pe119:~/ex05-weitsang$ ./escape\n5 5\n#.###\n#...#\n#.A##\n#.*.#\n#####\nLURLUUUDLR\nESCAPED!\nooiwt@pe119:~/ex05-weitsang$ ./escape\n5 5\n#.###\n#...#\n#.A##\n#.*.#\n#####\nUDDLUUUUU\nIT'S A TRAP!",
            "title": "Sample Run"
        },
        {
            "location": "/ex05/index.html#question-3-magic",
            "text": "A magic square is a grid of  n \\times n n \\times n  with each cell filled with a distinct number from 1 to  n^2 n^2 , such that, the sum of each row, column, or diagonal are the same.   Write a program,  magicsquare , that constructs a magic square of size  n \\times n n \\times n , where  n n  is odd.  There are multiple ways we can construct such as magic square.  For this question, you shall follow the following algorithm:   Put 1 at center column of the top row   Each of the remaining numbers is placed one row up and one column to the right of the previous number.  This may not always work when we reach the edge of the square or when the cell one row up and one column to the right is occupied.  In such a case, you should follow the rules below:   A. If a number's cell is already taken, put it one row below the position of the previous number;  B. If a number's cell is above the top row, stay in that column and put it in the bottom row;  C. If a number's cell is outside of the rightmost column, stay in that row and put it in the leftmost column;  D. If a number's cell is outside both the topmost row and the rightmost column put it one row below the previous number.     The following example shows how we fill up a  5\\times 5 5\\times 5  magic square.   The number 2 is filled above the top row, so we apply Rule B.  The number 4 is filled outside the rightmost column, so we apply Rule C.   The cell for number 6 is already taken (by 1), so we apply Rule A.   The number 16 goes outside both the topmost row and the rightmost column, so we apply Rule D.   Write a program  magicsquare , that reads (from the standard input) an odd integer  n n  and prints (to the standard output)  n n  rows with  n n  numbers in each row, denoting the constructed magic square using above described method.",
            "title": "Question 3: Magic"
        },
        {
            "location": "/ex05/index.html#sample-run_1",
            "text": "1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14 ooiwt@pe119:~/ex05-weitsang$ ./magicsquare\n3\n8 1 6\n3 5 7\n4 9 2\nooiwt@pe119:~/ex05-weitsang$ ./magicsquare\n7\n30 39 48 1 10 19 28\n38 47 7 9 18 27 29\n46 6 8 17 26 35 37\n5 14 16 25 34 36 45\n13 15 24 33 42 44 4\n21 23 32 41 43 3 12\n22 31 40 49 2 11 20",
            "title": "Sample Run"
        },
        {
            "location": "/assignment/index.html",
            "text": "Guide to Programming Assignments\n\n\nTimeline\n\n\nThere will be weekly take-home programming assignments, each consisting of 2 to 4 questions. \nThese programming assignments collectively contribute to 30% of your final grade.\n\n\nThe programming assignment is released on the CS1010 website every Friday, with a deadline given.  You must submit all questions for each particular programming assignment before the deadline.\n\n\nGeneral Advice\n\n\nYou are advised to (i) spend some time thinking before you begin coding, (ii) practice incremental coding and (iii) test your programs thoroughly.\n\n\nRemember to spend some time thinking about the algorithm for each question.  Write out the pseudo-code or draw out the flowchart on your own before you start typing in your program. \n\n\nIncremental coding means do NOT type in the whole long program in a single session and then compile it. Instead, type your program in bits and pieces and compile it incrementally. Try to maintain a compilable program even while you are working on it. Submitting a compilable program that partially works is better than submitting an un-compilable one; this is especially important for your practical exams. \n\n\nYou should test your program thoroughly with your own test data before submission.  \n\n\nPlease note that:\n\n\n\n\n\n\nYou may assume that all input data are correct unless otherwise stated. Hence you do NOT need to do input data validation. This is to allow you to focus on getting the program right, instead of worrying about making your program fool-proof which involves a lot more work. \n\n\n\n\n\n\nCopying others' programs or relying on others to help you with these assignments will only offer a short-term reprieve. When Practical Exam (PE) time comes, your inadequacy will be exposed and the consequence would be dire.\n\n\n\n\n\n\nLate Submission\n\n\nAll programming assignments must be submitted on time.  If you need an extension, please ask for one and provide a justification for approval.  Only academic reasons and compassionate reasons can be considered (e.g., representing NUS for a sports event is OK; Attending a wedding is not.)\n\n\nFor late submission, there is a 1% penalty (of the total awarded marks for that particular assignment) for every 5-minute after the deadline, capped at 80%.  For example, if an assignment is awarded 40 marks, and it is submitted 100 minutes after the deadline, the student will get 32 marks instead (20% penalty).  If it is submitted 10 hours after the deadline, the student will get 8 marks (as it has hit the cap of 80% penalty).\n\n\nMethod of Submission\n\n\nPlease follow the instructions provided in each programming assignment to submit the programs to GitHub.  Programs submitted through other means, such as emails, will NOT be accepted.\n\n\nIdentifying Yourself\n\n\nIn every C file that you submit to CS1010, you need to identify yourself by writing your name and tutorial group. Marks will be deducted if you fail to do so. You need to edit the line:\n\n\n1\n@author XXXX (Group YYYY)\n\n\n\n\n\n\nand change it to something like:\n\n\n1\n@author Gamora (Group 10)\n\n\n\n\n\n\nPlease follow the instructions provided in each programming assignment to submit the programs to GitHub.  Programs submitted through other means, such as emails, will NOT be accepted.\n\n\nGrading\n\n\nOnly the final submission of each exercise will be graded.  For each exercise, we will provide you will a limited set of test data.  During grading, we may grade your program with additional test data.\n\n\nEach programming assignment will be graded differently.  Generally, marks are given for attempt, correctness, design, and style, and documentation.  The weight of each one will be adjusted over the semester.  \n\n\nA program that cannot compile will receive 0 marks for correctness.\n\n\nFeedback will be provided by the graders on GitHub.\n\n\nUse of Piazza\n\n\nIf you have doubts about the problem statements of an assignment, you may raise them on Piazza.  But before that, please read through the problem statements carefully first, and check if the same questions have been asked and answered on the forum.\n\n\nPlease exercise discretion when posting to Piazza.  \n\n\nBefore the deadline, you are NOT to post the solution to the assignment, complete or partial, on Piazza (or any publicly accessible online site).\n\n\nDisallowed Syntax\n\n\nSome programming assignments may explicitly disallow the use of certain syntax. Generally, using syntax or statements which are not yet covered either in class or in the assignment statement is strongly discouraged.  We also discourage the use of certain syntax for this module, (e.g., \n++\n) you should not use them.  The assignments are designed such that you should not need to do so (even though doing so may result in your program being shorter or more efficient). If the objective of the assignment is undermined, the penalty for using such forbidden syntax will be heavy. If in doubt, please ask for clarification.\n\n\nPlagiarism\n\n\nYou are NOT to copy from others or allow others to copy your programs.  We take plagiarism seriously.  See \nour policies\n page for details.\n\n\nThis means that you should also guard your solution carefully, not posting them to publicly accessible places, or change the permissions of the files on the CS1010 PE hosts so that it is accessible by others.\n\n\n\n\nThis guideline is adapted from Aaron Tan's CS1010 guideline.",
            "title": "General Guide"
        },
        {
            "location": "/assignment/index.html#guide-to-programming-assignments",
            "text": "",
            "title": "Guide to Programming Assignments"
        },
        {
            "location": "/assignment/index.html#timeline",
            "text": "There will be weekly take-home programming assignments, each consisting of 2 to 4 questions. \nThese programming assignments collectively contribute to 30% of your final grade.  The programming assignment is released on the CS1010 website every Friday, with a deadline given.  You must submit all questions for each particular programming assignment before the deadline.",
            "title": "Timeline"
        },
        {
            "location": "/assignment/index.html#general-advice",
            "text": "You are advised to (i) spend some time thinking before you begin coding, (ii) practice incremental coding and (iii) test your programs thoroughly.  Remember to spend some time thinking about the algorithm for each question.  Write out the pseudo-code or draw out the flowchart on your own before you start typing in your program.   Incremental coding means do NOT type in the whole long program in a single session and then compile it. Instead, type your program in bits and pieces and compile it incrementally. Try to maintain a compilable program even while you are working on it. Submitting a compilable program that partially works is better than submitting an un-compilable one; this is especially important for your practical exams.   You should test your program thoroughly with your own test data before submission.    Please note that:    You may assume that all input data are correct unless otherwise stated. Hence you do NOT need to do input data validation. This is to allow you to focus on getting the program right, instead of worrying about making your program fool-proof which involves a lot more work.     Copying others' programs or relying on others to help you with these assignments will only offer a short-term reprieve. When Practical Exam (PE) time comes, your inadequacy will be exposed and the consequence would be dire.",
            "title": "General Advice"
        },
        {
            "location": "/assignment/index.html#late-submission",
            "text": "All programming assignments must be submitted on time.  If you need an extension, please ask for one and provide a justification for approval.  Only academic reasons and compassionate reasons can be considered (e.g., representing NUS for a sports event is OK; Attending a wedding is not.)  For late submission, there is a 1% penalty (of the total awarded marks for that particular assignment) for every 5-minute after the deadline, capped at 80%.  For example, if an assignment is awarded 40 marks, and it is submitted 100 minutes after the deadline, the student will get 32 marks instead (20% penalty).  If it is submitted 10 hours after the deadline, the student will get 8 marks (as it has hit the cap of 80% penalty).",
            "title": "Late Submission"
        },
        {
            "location": "/assignment/index.html#method-of-submission",
            "text": "Please follow the instructions provided in each programming assignment to submit the programs to GitHub.  Programs submitted through other means, such as emails, will NOT be accepted.",
            "title": "Method of Submission"
        },
        {
            "location": "/assignment/index.html#identifying-yourself",
            "text": "In every C file that you submit to CS1010, you need to identify yourself by writing your name and tutorial group. Marks will be deducted if you fail to do so. You need to edit the line:  1 @author XXXX (Group YYYY)   and change it to something like:  1 @author Gamora (Group 10)   Please follow the instructions provided in each programming assignment to submit the programs to GitHub.  Programs submitted through other means, such as emails, will NOT be accepted.",
            "title": "Identifying Yourself"
        },
        {
            "location": "/assignment/index.html#grading",
            "text": "Only the final submission of each exercise will be graded.  For each exercise, we will provide you will a limited set of test data.  During grading, we may grade your program with additional test data.  Each programming assignment will be graded differently.  Generally, marks are given for attempt, correctness, design, and style, and documentation.  The weight of each one will be adjusted over the semester.    A program that cannot compile will receive 0 marks for correctness.  Feedback will be provided by the graders on GitHub.",
            "title": "Grading"
        },
        {
            "location": "/assignment/index.html#use-of-piazza",
            "text": "If you have doubts about the problem statements of an assignment, you may raise them on Piazza.  But before that, please read through the problem statements carefully first, and check if the same questions have been asked and answered on the forum.  Please exercise discretion when posting to Piazza.    Before the deadline, you are NOT to post the solution to the assignment, complete or partial, on Piazza (or any publicly accessible online site).",
            "title": "Use of Piazza"
        },
        {
            "location": "/assignment/index.html#disallowed-syntax",
            "text": "Some programming assignments may explicitly disallow the use of certain syntax. Generally, using syntax or statements which are not yet covered either in class or in the assignment statement is strongly discouraged.  We also discourage the use of certain syntax for this module, (e.g.,  ++ ) you should not use them.  The assignments are designed such that you should not need to do so (even though doing so may result in your program being shorter or more efficient). If the objective of the assignment is undermined, the penalty for using such forbidden syntax will be heavy. If in doubt, please ask for clarification.",
            "title": "Disallowed Syntax"
        },
        {
            "location": "/assignment/index.html#plagiarism",
            "text": "You are NOT to copy from others or allow others to copy your programs.  We take plagiarism seriously.  See  our policies  page for details.  This means that you should also guard your solution carefully, not posting them to publicly accessible places, or change the permissions of the files on the CS1010 PE hosts so that it is accessible by others.   This guideline is adapted from Aaron Tan's CS1010 guideline.",
            "title": "Plagiarism"
        },
        {
            "location": "/as01/index.html",
            "text": "Assignment 1\n\n\nDeadline\n\n\n14 September, 2018 (Friday), 6:00pm.\n\n\nPrerequisite\n\n\n\n\nYou are able to access the \nCS1010 programming environment\n.\n\n\nYou are familiar with \nbasic UNIX CLI\n and using terminal-based editor \nvim\n.\n\n\nYou have gone through Exercise 1 and have already setup your \n.gitconfig\n.\n\n\nYou are familiar with the steps of accepting, downloading, and submitting your exercise and assignment.\n\n\nYou are familiar with the directory structure and the common files included in your assignment skeleton.\n\n\n\n\nLearning Outcomes\n\n\n\n\nBe comfortable writing simple C programs that involves arithmetic operations, \nlong\n, \ndouble\n, and \nbool\n types, and conditional \nif\n/\nelse\n statements.\n\n\nBe comfortable breaking down a problem into smaller subproblems which can be resolved using functions, including reusing existing functions written for other programs (with a tweak), writing a function that calls itself, designing what should the inputs and return values/types of a function be.\n\n\n\n\nSetup\n\n\n\n\nClick on this link\n to accept the assignment.\n\n\nLogin to one of the hosts of \nCS1010 programming environment\n\n\nRun:\n\n\n\n\n1\n~cs1010/get-as01\n\n\n\n\n\n\n\n\nYou should see the folder \nas01-<github id>\n in your home directory with the assignment skeleton inside.\n\n\n\n\nSolving The Assignments\n\n\n\n\nEdit the files \ninvest.c\n, \nbox.c\n, \ndigits.c\n, and \ntaxi.c\n to solve the corresponding question as described below.\n\n\nTo compile and run tests with the sample inputs and outputs:\n\n\n\n\n1\nmake \n\n\n\n\n\n\n\n\nThe test cases are given in the \ninputs\n and \noutputs\n subdirectory.  You can use \ncat\n or \nless\n to look at the content of these test cases.  You can add more test cases or edit the given ones if needed.\n\n\n\n\nSubmission\n\n\nWhen you are ready, run the following command to submit:\n\n\n1\n~cs1010/submit-as01\n\n\n\n\n\n\nThe four files \ninvest.c\n, \nbox.c\n, \ndigits.c\n, and \ntaxi.c\n will be uploaded to GitHub.  You can submit multiple times, but only the last submission will be graded.\n\n\nIdentifying Yourself\n\n\nIn every C file that you submit to CS1010, you need to identify yourself by writing your name and tutorial group. Marks will be deducted if you fail to do so. You need to edit the line:\n\n\n1\n@author XXXX (Group YYYY)\n\n\n\n\n\n\nand change it to something like:\n\n\n1\n@author Hermione Granger (Group 9)\n\n\n\n\n\n\nGrading\n\n\nThis assignment contributes towards 3% of your final grade.  The total marks for this assignment is 30.  For Programming Assignment 1, the sole criteria for grading is correctness.\n\n\nQuestion 1: Invest (5 marks)\n\n\nIf you invest \nm\nm\n dollars at \nr\nr\n% interest rate compounded annually, after \nn\nn\n years, your investment will grow to \n\\frac{m(1 - (r/100)^{n+1})}{1 - r/100}\n\\frac{m(1 - (r/100)^{n+1})}{1 - r/100}\n dollars.\n\n\nWrite a program \ninvest.c\n that accepts three integers as input: principal \nm\nm\n, rate \nr\nr\n, and number of years \nn\nn\n, and computes the amount of money earned after \nn\nn\n years.\n\n\nYou may assume that \nr <= 100\n \nr < 100\nr < 100\n.\n\n\nSample Run\n\n\n1\n2\n3\n4\n5\n6\nooiwt@pe111:~/as01-skeleton$ ./invest\n100 10 5\n111.1110\nooiwt@pe111:~/as01-skeleton$ ./invest\n20000 5 10\n21052.6316\n\n\n\n\n\n\nQuestion 2: Box (5 marks)\n\n\nWrite a program \nbox.c\n that reads three positive integers representing the length, width, and height of a box, and output (i) its surface area, and (ii) the length of the diagonal between two vertices of the box that are furthest apart (see figure).\n\n\n\n\nYou may assume that the surface area of the box does not exceed the maximum value representable in the \nlong\n data type.\n\n\nYou should break down the problem into smaller ones:\n\n\n\n\nWrite a new method \narea_of_rectangle\n that computes the area of a rectangle given the width and height of the rectangle, then use it to compute the surface area.\n\n\nModify the method \nhypotenuse_of\n seen in \nUnit 5\n to compute the diagonal of the box.  (hint: pay attention to the type of the parameter and the return value).\n\n\n\n\nSample Run\n\n\n1\n2\n3\n4\n5\n6\nooiwt@pe111:~/as01-skeleton$ ./box \n12 3 10\n372 15.9060\nooiwt@pe111:~/as01-skeleton$ ./box \n10 20 30\n2200 37.4166\n\n\n\n\n\n\nQuestion 3: Digits (5 marks)\n\n\nWrite a program \ndigits.c\n that reads in a non-negative integer, and prints the sum of the individual digits in this integer. \n\n\nFor instance, if the input is \n1933091\n, then the sum is 1 + 9 + 3 + 3 + 0 + 9 + 1 = 26.\n\n\nYou should not use a loop to solve this, but rather, you should write a function \nsum_of_digits\n that takes in an integer and return the sum of the digits of that integer, that calls itself:\n\n\n\n\nif the input to \nsum_of_digits\n has only one digit, return this digit.\n\n\nOtherwise, use the modulo operator \n%\n and integer division \n/\n to extract the last digit (e.g., \n1\n) and the rest of the digits (e.g., \n193309\n) respectively, and call \nsum_of_digits\n on the rest of the digits to find its sum (e.g., 1+9+3+3+0+9 = 25).  Finally we add the last digit to this sum to get the total we seek (e.g., 1 + 25 = 26).\n\n\n\n\nSample Run\n\n\n1\n2\n3\n4\n5\n6\nooiwt@pe111:~/as01-skeleton$ ./digits \n1933091\n26\nooiwt@pe111:~/as01-skeleton$ ./digits \n0\n0\n\n\n\n\n\n\nQuestion 4: Taxi Fare (15 marks)\n\n\nThe taxi fare structure in Singapore must be one of the most complex in the world! Check out:\n\nhttp://www.taxisingapore.com/taxi-fare/\n.\n\n\nFor the purpose of this exercise, we will just use the following simpli\ufb01ed fare structure: \n\n\n\n\n\n\n\n\nBasic Fare\n\n\n\n\n\n\n\n\n\n\n\n\nThe first 1 km or less (Flag Down)\n\n\n$3.40\n\n\n\n\n\n\nEvery 400 m thereafter or less, up to 10.2 km\n\n\n$0.22\n\n\n\n\n\n\nEvery 350 m thereafter or less, after 10.2 km\n\n\n$0.22\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSurcharge\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMonday to Friday\n\n\n6:00 to 9:29\n\n\n25% of metered fare\n\n\n\n\n\n\nDaily\n\n\n18:00 to 23:59\n\n\n25% of metered fare\n\n\n\n\n\n\nDaily\n\n\n0:00 (midnight) to 5:59\n\n\n50% of metered fare\n\n\n\n\n\n\n\n\nNote that the surcharge is applicable based on the boarding time. For instance, if the trip started at 17:50 and ended at 18:10, then no surcharged is incurred.\n\n\nWrite a program \ntaxi.c\n that computes the taxi fare.  The program, called \ntaxi\n, takes in four integers as inputs:\n\n\n\n\nThe first is the day of the week.  It can only be the value \n1\n to \n7\n, \n1\n being Monday, \n7\n being Sunday.\n\n\nThe second and the third is the starting time of the trip: the second input indicates the hours since midnight of the stated day, the third input indicates the minutes since the beginning of the stated hours.\n\n\nThe forth and final input is the distance of the trip, in meters.\n\n\n\n\nYour program should print a single floating point number, which is the cost of the fare in dollars.\n\n\nExamine the following examples for more details:\n\n\nExample 1\n\n\n1\n2\n3\nooiwt@pe111:~/as01-skeleton$ ./taxi \n1 17 59 1000\n3.4000\n\n\n\n\n\n\n\n\nStart: Mon 17:59 \n\n\nDistance: 1,000 m\n\n\n\n\nThe metered fare is $3.40 since the distance travelled is 1km.  The boarding time is before 18:00 so there is no surcharge.  The total fare is $3.40.\n\n\nExample 2\n\n\n1\n2\n3\nooiwt@pe111:~/as01-skeleton$ ./taxi \n1 17 57 2000\n4.0600\n\n\n\n\n\n\n\n\nStart: Mon 17:57 \n\n\nDistance: 2,000 m\n\n\n\n\nThe metered fare for the first 1,000 m (1km) is $3.40.  The next 1,000 m is charged $0.22 for every 400 m (or less) travelled.  The pessengar is charged an additional 3 x $0.22, giving the total of metered fare of $4.06.\n\nThe boarding time is before 18:00 so there is no surcharge.\n\n\nExample 3\n\n\n1\n2\n3\nooiwt@pe111:~/as01-skeleton$ ./taxi \n1 5 50 15000\n17.3100\n\n\n\n\n\n\n\n\nStart: Mon 05:50\n\n\nDistance: 15,000 m\n\n\n\n\nThe metered fare for the first 1,000 m (1km) is $3.40.  The next 9,200 m is charged $0.22 for every 400 m travelled.  The pessengar is charged an additional 23 x $0.22 = $5.06.  The remaining 4,800 m is charged $0.22 for every 350 m (or less) travelled).  The pessengar is charged an additional 14 x $0.22 = $3.08.  The total metered fare is $11.54.\n\n\nThe boarding time is before 6:00 so there is a 50% surcharge.  Total fare is $17.31.\n\n\nHints\n\n\n\n\n\n\nYou can break down this problem into multiple subproblems, each can be solved by a function.  \nWrite one function to answer each question below\n:\n\n\n\n\ngiven the day of the week, is it a weekday? \n\n\ngiven the time of boarding, does it fall under the morning peak hour (6:00 - 9:29)?\n\n\ngiven the time of boarding, does it fall under the evening peak hour (18:00 - 23:59)?\n\n\ngiven the time of boarding, does it fall under the midnight peak hour (0:00 - 5:59)?\n\n\n\n\n\n\n\n\nYou can further breakdown the calculation of fare into two parts: the basic metered fare and the surcharge. Each of these can be its own function.  Think about the four inputs to the \ntaxi\n program.  Which one is needed to compute the metered fare?  Which ones are used to compute the surcharge?  Pass in the appropriate arguments to the function that computes the metered fare and the function that computes the surcharge.",
            "title": "1. Invest, Box, Digits, and Taxi"
        },
        {
            "location": "/as01/index.html#assignment-1",
            "text": "",
            "title": "Assignment 1"
        },
        {
            "location": "/as01/index.html#deadline",
            "text": "14 September, 2018 (Friday), 6:00pm.",
            "title": "Deadline"
        },
        {
            "location": "/as01/index.html#prerequisite",
            "text": "You are able to access the  CS1010 programming environment .  You are familiar with  basic UNIX CLI  and using terminal-based editor  vim .  You have gone through Exercise 1 and have already setup your  .gitconfig .  You are familiar with the steps of accepting, downloading, and submitting your exercise and assignment.  You are familiar with the directory structure and the common files included in your assignment skeleton.",
            "title": "Prerequisite"
        },
        {
            "location": "/as01/index.html#learning-outcomes",
            "text": "Be comfortable writing simple C programs that involves arithmetic operations,  long ,  double , and  bool  types, and conditional  if / else  statements.  Be comfortable breaking down a problem into smaller subproblems which can be resolved using functions, including reusing existing functions written for other programs (with a tweak), writing a function that calls itself, designing what should the inputs and return values/types of a function be.",
            "title": "Learning Outcomes"
        },
        {
            "location": "/as01/index.html#setup",
            "text": "Click on this link  to accept the assignment.  Login to one of the hosts of  CS1010 programming environment  Run:   1 ~cs1010/get-as01    You should see the folder  as01-<github id>  in your home directory with the assignment skeleton inside.",
            "title": "Setup"
        },
        {
            "location": "/as01/index.html#solving-the-assignments",
            "text": "Edit the files  invest.c ,  box.c ,  digits.c , and  taxi.c  to solve the corresponding question as described below.  To compile and run tests with the sample inputs and outputs:   1 make     The test cases are given in the  inputs  and  outputs  subdirectory.  You can use  cat  or  less  to look at the content of these test cases.  You can add more test cases or edit the given ones if needed.",
            "title": "Solving The Assignments"
        },
        {
            "location": "/as01/index.html#submission",
            "text": "When you are ready, run the following command to submit:  1 ~cs1010/submit-as01   The four files  invest.c ,  box.c ,  digits.c , and  taxi.c  will be uploaded to GitHub.  You can submit multiple times, but only the last submission will be graded.",
            "title": "Submission"
        },
        {
            "location": "/as01/index.html#identifying-yourself",
            "text": "In every C file that you submit to CS1010, you need to identify yourself by writing your name and tutorial group. Marks will be deducted if you fail to do so. You need to edit the line:  1 @author XXXX (Group YYYY)   and change it to something like:  1 @author Hermione Granger (Group 9)",
            "title": "Identifying Yourself"
        },
        {
            "location": "/as01/index.html#grading",
            "text": "This assignment contributes towards 3% of your final grade.  The total marks for this assignment is 30.  For Programming Assignment 1, the sole criteria for grading is correctness.",
            "title": "Grading"
        },
        {
            "location": "/as01/index.html#question-1-invest-5-marks",
            "text": "If you invest  m m  dollars at  r r % interest rate compounded annually, after  n n  years, your investment will grow to  \\frac{m(1 - (r/100)^{n+1})}{1 - r/100} \\frac{m(1 - (r/100)^{n+1})}{1 - r/100}  dollars.  Write a program  invest.c  that accepts three integers as input: principal  m m , rate  r r , and number of years  n n , and computes the amount of money earned after  n n  years.  You may assume that  r <= 100   r < 100 r < 100 .",
            "title": "Question 1: Invest (5 marks)"
        },
        {
            "location": "/as01/index.html#sample-run",
            "text": "1\n2\n3\n4\n5\n6 ooiwt@pe111:~/as01-skeleton$ ./invest\n100 10 5\n111.1110\nooiwt@pe111:~/as01-skeleton$ ./invest\n20000 5 10\n21052.6316",
            "title": "Sample Run"
        },
        {
            "location": "/as01/index.html#question-2-box-5-marks",
            "text": "Write a program  box.c  that reads three positive integers representing the length, width, and height of a box, and output (i) its surface area, and (ii) the length of the diagonal between two vertices of the box that are furthest apart (see figure).   You may assume that the surface area of the box does not exceed the maximum value representable in the  long  data type.  You should break down the problem into smaller ones:   Write a new method  area_of_rectangle  that computes the area of a rectangle given the width and height of the rectangle, then use it to compute the surface area.  Modify the method  hypotenuse_of  seen in  Unit 5  to compute the diagonal of the box.  (hint: pay attention to the type of the parameter and the return value).",
            "title": "Question 2: Box (5 marks)"
        },
        {
            "location": "/as01/index.html#sample-run_1",
            "text": "1\n2\n3\n4\n5\n6 ooiwt@pe111:~/as01-skeleton$ ./box \n12 3 10\n372 15.9060\nooiwt@pe111:~/as01-skeleton$ ./box \n10 20 30\n2200 37.4166",
            "title": "Sample Run"
        },
        {
            "location": "/as01/index.html#question-3-digits-5-marks",
            "text": "Write a program  digits.c  that reads in a non-negative integer, and prints the sum of the individual digits in this integer.   For instance, if the input is  1933091 , then the sum is 1 + 9 + 3 + 3 + 0 + 9 + 1 = 26.  You should not use a loop to solve this, but rather, you should write a function  sum_of_digits  that takes in an integer and return the sum of the digits of that integer, that calls itself:   if the input to  sum_of_digits  has only one digit, return this digit.  Otherwise, use the modulo operator  %  and integer division  /  to extract the last digit (e.g.,  1 ) and the rest of the digits (e.g.,  193309 ) respectively, and call  sum_of_digits  on the rest of the digits to find its sum (e.g., 1+9+3+3+0+9 = 25).  Finally we add the last digit to this sum to get the total we seek (e.g., 1 + 25 = 26).",
            "title": "Question 3: Digits (5 marks)"
        },
        {
            "location": "/as01/index.html#sample-run_2",
            "text": "1\n2\n3\n4\n5\n6 ooiwt@pe111:~/as01-skeleton$ ./digits \n1933091\n26\nooiwt@pe111:~/as01-skeleton$ ./digits \n0\n0",
            "title": "Sample Run"
        },
        {
            "location": "/as01/index.html#question-4-taxi-fare-15-marks",
            "text": "The taxi fare structure in Singapore must be one of the most complex in the world! Check out: http://www.taxisingapore.com/taxi-fare/ .  For the purpose of this exercise, we will just use the following simpli\ufb01ed fare structure:      Basic Fare       The first 1 km or less (Flag Down)  $3.40    Every 400 m thereafter or less, up to 10.2 km  $0.22    Every 350 m thereafter or less, after 10.2 km  $0.22        Surcharge        Monday to Friday  6:00 to 9:29  25% of metered fare    Daily  18:00 to 23:59  25% of metered fare    Daily  0:00 (midnight) to 5:59  50% of metered fare     Note that the surcharge is applicable based on the boarding time. For instance, if the trip started at 17:50 and ended at 18:10, then no surcharged is incurred.  Write a program  taxi.c  that computes the taxi fare.  The program, called  taxi , takes in four integers as inputs:   The first is the day of the week.  It can only be the value  1  to  7 ,  1  being Monday,  7  being Sunday.  The second and the third is the starting time of the trip: the second input indicates the hours since midnight of the stated day, the third input indicates the minutes since the beginning of the stated hours.  The forth and final input is the distance of the trip, in meters.   Your program should print a single floating point number, which is the cost of the fare in dollars.  Examine the following examples for more details:",
            "title": "Question 4: Taxi Fare (15 marks)"
        },
        {
            "location": "/as01/index.html#example-1",
            "text": "1\n2\n3 ooiwt@pe111:~/as01-skeleton$ ./taxi \n1 17 59 1000\n3.4000    Start: Mon 17:59   Distance: 1,000 m   The metered fare is $3.40 since the distance travelled is 1km.  The boarding time is before 18:00 so there is no surcharge.  The total fare is $3.40.",
            "title": "Example 1"
        },
        {
            "location": "/as01/index.html#example-2",
            "text": "1\n2\n3 ooiwt@pe111:~/as01-skeleton$ ./taxi \n1 17 57 2000\n4.0600    Start: Mon 17:57   Distance: 2,000 m   The metered fare for the first 1,000 m (1km) is $3.40.  The next 1,000 m is charged $0.22 for every 400 m (or less) travelled.  The pessengar is charged an additional 3 x $0.22, giving the total of metered fare of $4.06. \nThe boarding time is before 18:00 so there is no surcharge.",
            "title": "Example 2"
        },
        {
            "location": "/as01/index.html#example-3",
            "text": "1\n2\n3 ooiwt@pe111:~/as01-skeleton$ ./taxi \n1 5 50 15000\n17.3100    Start: Mon 05:50  Distance: 15,000 m   The metered fare for the first 1,000 m (1km) is $3.40.  The next 9,200 m is charged $0.22 for every 400 m travelled.  The pessengar is charged an additional 23 x $0.22 = $5.06.  The remaining 4,800 m is charged $0.22 for every 350 m (or less) travelled).  The pessengar is charged an additional 14 x $0.22 = $3.08.  The total metered fare is $11.54.  The boarding time is before 6:00 so there is a 50% surcharge.  Total fare is $17.31.",
            "title": "Example 3"
        },
        {
            "location": "/as01/index.html#hints",
            "text": "You can break down this problem into multiple subproblems, each can be solved by a function.   Write one function to answer each question below :   given the day of the week, is it a weekday?   given the time of boarding, does it fall under the morning peak hour (6:00 - 9:29)?  given the time of boarding, does it fall under the evening peak hour (18:00 - 23:59)?  given the time of boarding, does it fall under the midnight peak hour (0:00 - 5:59)?     You can further breakdown the calculation of fare into two parts: the basic metered fare and the surcharge. Each of these can be its own function.  Think about the four inputs to the  taxi  program.  Which one is needed to compute the metered fare?  Which ones are used to compute the surcharge?  Pass in the appropriate arguments to the function that computes the metered fare and the function that computes the surcharge.",
            "title": "Hints"
        },
        {
            "location": "/as01-comments/index.html",
            "text": "Assignment 1: Comments\n\n\nNotes on Marking Schemes\n\n\n\n\nWe apply the penalty to each program independently, i.e., the same mistake repeated in the different program get penalized multiple times.  \n\n\n\n\nYou will receive 0 marks if your program cannot be compiled or is plagiarised from another.\n\n\n\n\n\n\nCode that fails all test cases and showing that student does not understand the main concept tested in each question (writing arithmetic expressions in \ninvest\n, recursion in \ndigits\n, use of functions in \nbox\n, and logical expressions and conditionals in \ntaxi\n), receives 0 marks straight away.\n\n\n\n\n\n\nFor the rest, we start with full marks and start deducting marks for each error.\n\n\n\n\n\n\nWhile the teaching team tries to ensure fair and consistent grading of assignments across all groups, each TA can, at his/her own discretion, and with the approval of Wei Tsang, adjust the grading criteria to align with the messages that they sent to the students in their tutorial group.\n\n\n\n\n\n\nThe following list includes some of the common mistakes we encountered.  \n\n\n\n\n\n\nGeneral Mistakes\n\n\nThis penalty applies once per program (not per occurrence).\n\n\n\n\n-1 for missing type in function declaration or definition\n\n\n-1 for using \nint\n/\nlong\n instead of \nbool\n for boolean functions or variables\n\n\n-1 for using \ndouble\n instead of \nlong\n when it is not necessary (does not involve integer division).  For instance, using \ndouble\n for \ninvest.c\n during calculation is ok, using \ndouble\n for calculating the area of the box is not.\n\n\n-1 for using of \nint\n instead of \nlong\n.  Using \nint\n for this assignment is ok only for \nday\n, \nhour\n, and \nminute\n, where there is an implicit constraint on the range of the value.\n\n\n-1 for failing to use parenthesis (e.g., \na && b || c\n)\n\n\n-1 for unnecessary/unused parameters passed into a function\n\n\n-1 for unnecessary/unused variables declared\n\n\n-1 for not including @author/@group\n\n\n-1 for global variables\n\n\n-1 for unreachable code / return\n\n\n-1 for using \n==\n to compare real numbers\n\n\n\n\nLogical Mistakes (bugs)\n\n\nIn general, -1 for each bug.\n\n\n\n\n-1 for each incorrect logical expression\n\n\n-1 for each incorrect arithmetic expression\n\n\n-1 for each incorrect use of \nif\n-\nelse\n\n\n-1 for each uninitialized variables causing incorrect output.\n\n\n-1 if program prints extra text / newline\n\n\n-1 if the program returns non-zero from \nmain\n even if the program exits successfully.\n\n\n\n\nAnswer Keys\n\n\nInvest\n\n\nThis problem assesses if students know how to use arithmetic operations, parenthesis, and math library properly.  Most common mistakes include using \nfloat\n and \nint\n as data type, which would lead to loss of precision and overflow.  Suppose someone has $2.6 billion in his bank account, using \nint\n would cause an overflow.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n/**\n\n\n * CS1010 Semester 1 AY18/19\n\n\n * Assignment 1: Invest\n\n\n *\n\n\n * Read in three positive integer corresponding to the principal, the\n\n\n * interest rate, and the number of years.  Print the resulting amount\n\n\n * after the given num of years to the standard output.\n\n\n *\n\n\n * @file: invest.c\n\n\n * @author: XXX (Group YYY)\n\n\n */\n\n\n\n#include\n \n\"cs1010.h\"\n\n\n#include\n \n<math.h>\n\n\n\n\nint\n \nmain\n()\n\n\n{\n\n  \nlong\n \nprincipal\n \n=\n \ncs1010_read_long\n();\n\n  \nlong\n \nrate\n \n=\n \ncs1010_read_long\n();\n\n  \nlong\n \nnum_of_years\n \n=\n \ncs1010_read_long\n();\n\n\n  \ndouble\n \nr\n \n=\n \nrate\n/\n100.0\n;\n\n  \ndouble\n \nresult\n \n=\n \nprincipal\n*\n(\n1\n \n-\n \npow\n(\nr\n,\n \nnum_of_years\n \n+\n \n1\n))\n/\n(\n1\n \n-\n \nr\n);\n\n\n  \ncs1010_println_double\n(\nresult\n);\n\n\n}\n\n\n\n\n\n\n\nBox\n\n\nThis problem tests if students know how to write and reuse functions.  \n\n\nSome students wrote different versions of \narea_of_rectangle\n:\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\nlong\n \narea_of_rectangle1\n(\nlong\n \nwidth\n,\n \nlong\n \nheight\n)\n\n\n{\n\n  \nreturn\n \nwidth\n \n*\n \nheight\n;\n\n\n}\n\n\n\nlong\n \narea_of_rectangle2\n(\nlong\n \nwidth\n,\n \nlong\n \nbase\n)\n\n\n{\n\n  \nreturn\n \nwidth\n \n*\n \nbase\n;\n\n\n}\n\n\n\nlong\n \narea_of_rectangle3\n(\nlong\n \nbase\n,\n \nlong\n \nheight\n)\n\n\n{\n\n  \nreturn\n \nbase\n \n*\n \nheight\n;\n\n\n}\n\n\n\n\n\n\ndemonstrating that they do not understand how functions can be reused by passing in different parameters.\n\n\nThis problem also demonstrates how functions written for another problem (calculating the hypotenuse of a triangle in class) can be used to solve a different problem (diagonal of the box).  The \nhypotenuse_of\n function written in class, however, takes in \nlong\n instead of \ndouble\n, so we have to change that.  Some of you also change the \nhypotenuse_of\n method to take in three parameters so that it calculates the diagonal directly.  This solution is fine as well.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n/**\n\n\n * CS1010 Semester 1 AY18/19\n\n\n * Assignment 1: Box\n\n\n *\n\n\n * Read in three positive integer corresponding to the width,\n\n\n * height, and length of a box from the standard input, and\n\n\n * print the total surface area and the length of the diagonal\n\n\n * to the standard output.\n\n\n *\n\n\n * @file: box.c\n\n\n * @author: XXX (Group YYY)\n\n\n */\n\n\n\n#include\n \n\"cs1010.h\"\n\n\n#include\n \n<math.h>\n\n\n\n/**\n\n\n * Calculate the hypotenuse of a triangle.\n\n\n *\n\n\n * @param[in] base The base of the triangle.\n\n\n * @param[in] height The height of the triangle.\n\n\n * @return The hypotenuse of the triangle.\n\n\n */\n\n\ndouble\n \nhypotenuse_of\n(\ndouble\n \nbase\n,\n \ndouble\n \nheight\n)\n\n\n{\n\n  \nreturn\n \nsqrt\n(\nbase\n*\nbase\n \n+\n \nheight\n*\nheight\n);\n\n\n}\n\n\n\n/**\n\n\n * Calculate the area of a rectangle.\n\n\n *\n\n\n * @param[in] width The width of the rectangle.\n\n\n * @param[in] height The height of the rectangle.\n\n\n * @return The surface area of the rectangle.\n\n\n */\n\n\nlong\n \narea_of_rectangle\n(\nlong\n \nwidth\n,\n \nlong\n \nheight\n)\n\n\n{\n\n  \nreturn\n \nwidth\n \n*\n \nheight\n;\n\n\n}\n\n\n\nint\n \nmain\n()\n\n\n{\n\n  \nlong\n \nwidth\n \n=\n \ncs1010_read_long\n();\n\n  \nlong\n \nheight\n \n=\n \ncs1010_read_long\n();\n\n  \nlong\n \nlength\n \n=\n \ncs1010_read_long\n();\n\n\n  \nlong\n \nsurface_area\n \n=\n \n2\n*\narea_of_rectangle\n(\nwidth\n,\n \nheight\n)\n \n+\n\n    \n2\n*\narea_of_rectangle\n(\nwidth\n,\n \nlength\n)\n \n+\n\n    \n2\n*\narea_of_rectangle\n(\nlength\n,\n \nheight\n);\n\n  \ncs1010_print_long\n(\nsurface_area\n);\n\n\n  \ncs1010_print_string\n(\n\" \"\n);\n\n\n  \ndouble\n \nhypotenuse\n \n=\n \nhypotenuse_of\n(\nhypotenuse_of\n(\nwidth\n,\n \nheight\n),\n \nlength\n);\n\n  \ncs1010_println_double\n(\nhypotenuse\n);\n\n\n}\n\n\n\n\n\n\n\nDigits\n\n\nMost students who solve this correctly (without a loop and without segmentation fault) are able to get the idea of how recursion can be used here.  The most common error we see if a mismatch of types, where students use \nint\n leading to failure when we test with a large integer beyond the range of \nint\n.  \n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n/**\n\n\n * CS1010 Semester 1 AY18/19\n\n\n * Assignment 1: Digits\n\n\n *\n\n\n * Read in a positive integer from the standard input and print\n\n\n * the sum of all digits in the integer to the standard output.\n\n\n *\n\n\n * @file: digits.c\n\n\n * @author: XXX (Group YYY)\n\n\n */\n\n\n\n#include\n \n\"cs1010.h\"\n\n\n\n/**\n\n\n * Sum the digits in input.\n\n\n *\n\n\n * @param[in] input The integer whose digits we are summing.\n\n\n * @return The sum of digits in the parameter input.\n\n\n */\n\n\nlong\n \nsum_of_digits\n(\nlong\n \ninput\n)\n\n\n{\n\n  \nif\n \n(\ninput\n \n<\n \n10\n)\n \n{\n\n    \nreturn\n \ninput\n;\n\n  \n}\n\n  \nlong\n \nlast_digit\n \n=\n \ninput\n \n%\n \n10\n;\n\n  \nlong\n \nrest\n \n=\n \ninput\n \n/\n \n10\n;\n\n  \nreturn\n \nlast_digit\n \n+\n \nsum_of_digits\n(\nrest\n);\n\n\n}\n\n\n\nint\n \nmain\n()\n\n\n{\n\n  \nlong\n \ninput\n \n=\n \ncs1010_read_long\n();\n\n  \ncs1010_println_long\n(\nsum_of_digits\n(\ninput\n));\n\n\n}\n\n\n\n\n\n\n\nTaxi\n\n\nThis is a more complex problem.  We hope that students, when thinking about the solution of this problem, can appreciate the importance of breaking down the problem into simpler subproblems so that you can think, solve, and test the sub-solutions, independently, before combining them to solve the larger problem.  \n\n\nAnother objective of this question is to get students to think about what parameters and variables are needed to solve a subproblem.  Students who think through this should realize that to calculate the metered fare only the distance is needed and to calculate the surcharge, only the day and time is needed.  Further, to determine evening peak and midnight peak, only the hour is needed (not minutes nor day).\n\n\nSome common mistakes include being careless in checking for the peak hour surcharge (bug in logical expressions).  \n\n\nSome students use \nceil\n to calculate the metered fare, which is fine (simpler than the sample code below).  But a few students incorrectly use \nround\n instead.  \n\n\n  1\n  2\n  3\n  4\n  5\n  6\n  7\n  8\n  9\n 10\n 11\n 12\n 13\n 14\n 15\n 16\n 17\n 18\n 19\n 20\n 21\n 22\n 23\n 24\n 25\n 26\n 27\n 28\n 29\n 30\n 31\n 32\n 33\n 34\n 35\n 36\n 37\n 38\n 39\n 40\n 41\n 42\n 43\n 44\n 45\n 46\n 47\n 48\n 49\n 50\n 51\n 52\n 53\n 54\n 55\n 56\n 57\n 58\n 59\n 60\n 61\n 62\n 63\n 64\n 65\n 66\n 67\n 68\n 69\n 70\n 71\n 72\n 73\n 74\n 75\n 76\n 77\n 78\n 79\n 80\n 81\n 82\n 83\n 84\n 85\n 86\n 87\n 88\n 89\n 90\n 91\n 92\n 93\n 94\n 95\n 96\n 97\n 98\n 99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n/**\n\n\n * CS1010 Semester 1 AY18/19\n\n\n * Assignment 1: Taxi\n\n\n *\n\n\n * Read in four positive integer corresponding to the day of the week,\n\n\n * the hour and minute of boarding, and the distance traveled.  Print\n\n\n * to the standard output, the fare of the taxi.\n\n\n * height, and length of a box from the standard input, and\n\n\n * print the total surface area and the length of the diagonal\n\n\n * to the standard output.\n\n\n *\n\n\n * @file: taxi.c\n\n\n * @author: XXX (Group YYY)\n\n\n */\n\n\n\n#include\n \n\"cs1010.h\"\n\n\n#include\n \n<stdbool.h>\n\n\n\n/**\n\n\n * Check if a given day is a weekday.\n\n\n *\n\n\n * @param[in] day The day of the week (1 for Monday, 7 for Sunday).\n\n\n * @return true if the day is a weekday, false otherwise.\n\n\n */\n\n\nbool\n \nis_weekday\n(\nlong\n \nday\n)\n\n\n{\n\n  \nreturn\n \n(\nday\n \n>=\n \n1\n \n&&\n \nday\n \n<=\n \n5\n);\n\n\n}\n\n\n\n/**\n\n\n * Check if a given time falls under morning peak hour (6am to 9:29am)\n\n\n *\n\n\n * @param[in] hour The given hour.\n\n\n * @param[in] minute The given minute.\n\n\n * @return true if the given time falls under morning peak hour.  \n\n\n *         false otherwise.\n\n\n */\n\n\nbool\n \nis_morning_peak\n(\nlong\n \nhour\n,\n \nlong\n \nminute\n)\n\n\n{\n\n  \nreturn\n \n(\nhour\n \n>=\n \n6\n \n&&\n \nhour\n \n<\n \n9\n)\n \n||\n \n(\nhour\n \n==\n \n9\n \n&&\n \nminute\n \n<=\n \n29\n);\n\n\n}\n\n\n\n/**\n\n\n * Check if a given time falls under evening peak hour (6pm to 11:59pm).\n\n\n *\n\n\n * @param[in] hour The given hour.\n\n\n * @return true if the given time falls under morning peak hour.  \n\n\n *         false otherwise.\n\n\n */\n\n\nbool\n \nis_evening_peak\n(\nlong\n \nhour\n)\n\n\n{\n\n  \nreturn\n \n(\nhour\n \n>=\n \n18\n \n&&\n \nhour\n \n<=\n \n23\n);\n\n\n}\n\n\n\n/**\n\n\n * Check if a given time falls under midnight peak hour (0:00 to 5:59am).\n\n\n *\n\n\n * @param[in] hour The given hour.\n\n\n * @return true if the given time falls under midnight peak hour.  \n\n\n *         false otherwise.\n\n\n */\n\n\nbool\n \nis_midnight_peak\n(\nlong\n \nhour\n)\n\n\n{\n\n  \nreturn\n \n(\nhour\n \n>=\n \n0\n \n&&\n \nhour\n \n<\n \n6\n);\n\n\n}\n\n\n\n/**\n\n\n * Check if surchange should be applied given day and time.\n\n\n *\n\n\n * @param[in] day Day of the taxi trip\n\n\n * @param[in] hour Hour of boarding time.\n\n\n * @param[in] minute Minute of boarding time\n\n\n * @return The surchage applied (1.0 if no surcharge)).\n\n\n */\n\n\ndouble\n \nsurcharge\n(\nlong\n \nday\n,\n \nlong\n \nhour\n,\n \nlong\n \nminute\n)\n\n\n{\n\n  \nif\n \n(\nis_weekday\n(\nday\n)\n \n&&\n \nis_morning_peak\n(\nhour\n,\n \nminute\n))\n \n{\n\n    \nreturn\n \n1.25\n;\n\n  \n}\n\n  \nif\n \n(\nis_evening_peak\n(\nhour\n))\n \n{\n\n    \nreturn\n \n1.25\n;\n\n  \n}\n\n  \nif\n \n(\nis_midnight_peak\n(\nhour\n))\n \n{\n\n    \nreturn\n \n1.5\n;\n\n  \n}\n\n  \nreturn\n \n1.0\n;\n\n\n}\n\n\n\n/**\n\n\n * Calculate the metered fare for a taxi trip (before surcharge).\n\n\n *\n\n\n * @param[in] distance The distance travelled.\n\n\n */\n\n\ndouble\n \nmetered_fare\n(\nlong\n \ndistance\n)\n\n\n{\n\n  \ndouble\n \nfare\n \n=\n \n3.40\n;\n\n\n  \ndistance\n \n-=\n \n1000\n;\n\n  \nif\n \n(\ndistance\n \n<=\n \n0\n)\n \n{\n\n    \nreturn\n \nfare\n;\n\n  \n}\n\n\n  \nif\n \n(\ndistance\n \n<=\n \n9200\n)\n \n{\n\n    \nfare\n \n+=\n \n0.22\n \n*\n \n(\ndistance\n \n/\n \n400\n);\n\n    \nif\n \n(\ndistance\n \n%\n \n400\n \n>\n \n0\n)\n \n{\n\n      \nfare\n \n+=\n \n0.22\n;\n\n    \n}\n\n  \n}\n \nelse\n \n{\n\n    \nfare\n \n+=\n \n0.22\n \n*\n \n(\n9200\n \n/\n \n400\n);\n\n  \n}\n\n\n  \ndistance\n \n-=\n \n9200\n;\n\n  \nif\n \n(\ndistance\n \n<=\n \n0\n)\n \n{\n\n    \nreturn\n \nfare\n;\n\n  \n}\n\n\n  \nfare\n \n+=\n \n0.22\n \n*\n \n(\ndistance\n \n/\n \n350\n);\n\n  \nif\n \n(\ndistance\n \n%\n \n350\n \n>\n \n0\n)\n \n{\n\n    \nfare\n \n+=\n \n0.22\n;\n\n  \n}\n\n\n  \nreturn\n \nfare\n;\n\n\n}\n\n\n\n/**\n\n\n * Calculate the fare for a taxi trip (including surcharge).\n\n\n *\n\n\n * @param[in] day Day of the taxi trip\n\n\n * @param[in] hour Hour of boarding time\n\n\n * @param[in] minute Minute of boarding time\n\n\n * @param[in] distance The distance travelled\n\n\n */\n\n\ndouble\n \nfare\n(\nlong\n \nday\n,\n \nlong\n \nhour\n,\n \nlong\n \nminute\n,\n \nlong\n \ndistance\n)\n\n\n{\n\n  \nreturn\n \nmetered_fare\n(\ndistance\n)\n \n*\n \nsurcharge\n(\nday\n,\n \nhour\n,\n \nminute\n);\n\n\n}\n\n\n\n\nint\n \nmain\n()\n\n\n{\n\n  \nlong\n \nday\n \n=\n \ncs1010_read_long\n();\n\n  \nlong\n \nstart_hour\n \n=\n \ncs1010_read_long\n();\n\n  \nlong\n \nstart_minute\n \n=\n \ncs1010_read_long\n();\n\n  \nlong\n \ndistance\n \n=\n \ncs1010_read_long\n();\n\n\n  \ncs1010_println_double\n(\nfare\n(\nday\n,\n \nstart_hour\n,\n \nstart_minute\n,\n \ndistance\n));\n\n\n}",
            "title": "1. Comments and Answer Keys"
        },
        {
            "location": "/as01-comments/index.html#assignment-1-comments",
            "text": "",
            "title": "Assignment 1: Comments"
        },
        {
            "location": "/as01-comments/index.html#notes-on-marking-schemes",
            "text": "We apply the penalty to each program independently, i.e., the same mistake repeated in the different program get penalized multiple times.     You will receive 0 marks if your program cannot be compiled or is plagiarised from another.    Code that fails all test cases and showing that student does not understand the main concept tested in each question (writing arithmetic expressions in  invest , recursion in  digits , use of functions in  box , and logical expressions and conditionals in  taxi ), receives 0 marks straight away.    For the rest, we start with full marks and start deducting marks for each error.    While the teaching team tries to ensure fair and consistent grading of assignments across all groups, each TA can, at his/her own discretion, and with the approval of Wei Tsang, adjust the grading criteria to align with the messages that they sent to the students in their tutorial group.    The following list includes some of the common mistakes we encountered.",
            "title": "Notes on Marking Schemes"
        },
        {
            "location": "/as01-comments/index.html#general-mistakes",
            "text": "This penalty applies once per program (not per occurrence).   -1 for missing type in function declaration or definition  -1 for using  int / long  instead of  bool  for boolean functions or variables  -1 for using  double  instead of  long  when it is not necessary (does not involve integer division).  For instance, using  double  for  invest.c  during calculation is ok, using  double  for calculating the area of the box is not.  -1 for using of  int  instead of  long .  Using  int  for this assignment is ok only for  day ,  hour , and  minute , where there is an implicit constraint on the range of the value.  -1 for failing to use parenthesis (e.g.,  a && b || c )  -1 for unnecessary/unused parameters passed into a function  -1 for unnecessary/unused variables declared  -1 for not including @author/@group  -1 for global variables  -1 for unreachable code / return  -1 for using  ==  to compare real numbers",
            "title": "General Mistakes"
        },
        {
            "location": "/as01-comments/index.html#logical-mistakes-bugs",
            "text": "In general, -1 for each bug.   -1 for each incorrect logical expression  -1 for each incorrect arithmetic expression  -1 for each incorrect use of  if - else  -1 for each uninitialized variables causing incorrect output.  -1 if program prints extra text / newline  -1 if the program returns non-zero from  main  even if the program exits successfully.",
            "title": "Logical Mistakes (bugs)"
        },
        {
            "location": "/as01-comments/index.html#answer-keys",
            "text": "",
            "title": "Answer Keys"
        },
        {
            "location": "/as01-comments/index.html#invest",
            "text": "This problem assesses if students know how to use arithmetic operations, parenthesis, and math library properly.  Most common mistakes include using  float  and  int  as data type, which would lead to loss of precision and overflow.  Suppose someone has $2.6 billion in his bank account, using  int  would cause an overflow.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27 /**   * CS1010 Semester 1 AY18/19   * Assignment 1: Invest   *   * Read in three positive integer corresponding to the principal, the   * interest rate, and the number of years.  Print the resulting amount   * after the given num of years to the standard output.   *   * @file: invest.c   * @author: XXX (Group YYY)   */  #include   \"cs1010.h\"  #include   <math.h>  int   main ()  { \n   long   principal   =   cs1010_read_long (); \n   long   rate   =   cs1010_read_long (); \n   long   num_of_years   =   cs1010_read_long (); \n\n   double   r   =   rate / 100.0 ; \n   double   result   =   principal * ( 1   -   pow ( r ,   num_of_years   +   1 )) / ( 1   -   r ); \n\n   cs1010_println_double ( result );  }",
            "title": "Invest"
        },
        {
            "location": "/as01-comments/index.html#box",
            "text": "This problem tests if students know how to write and reuse functions.    Some students wrote different versions of  area_of_rectangle :  1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14 long   area_of_rectangle1 ( long   width ,   long   height )  { \n   return   width   *   height ;  }  long   area_of_rectangle2 ( long   width ,   long   base )  { \n   return   width   *   base ;  }  long   area_of_rectangle3 ( long   base ,   long   height )  { \n   return   base   *   height ;  }    demonstrating that they do not understand how functions can be reused by passing in different parameters.  This problem also demonstrates how functions written for another problem (calculating the hypotenuse of a triangle in class) can be used to solve a different problem (diagonal of the box).  The  hypotenuse_of  function written in class, however, takes in  long  instead of  double , so we have to change that.  Some of you also change the  hypotenuse_of  method to take in three parameters so that it calculates the diagonal directly.  This solution is fine as well.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56 /**   * CS1010 Semester 1 AY18/19   * Assignment 1: Box   *   * Read in three positive integer corresponding to the width,   * height, and length of a box from the standard input, and   * print the total surface area and the length of the diagonal   * to the standard output.   *   * @file: box.c   * @author: XXX (Group YYY)   */  #include   \"cs1010.h\"  #include   <math.h>  /**   * Calculate the hypotenuse of a triangle.   *   * @param[in] base The base of the triangle.   * @param[in] height The height of the triangle.   * @return The hypotenuse of the triangle.   */  double   hypotenuse_of ( double   base ,   double   height )  { \n   return   sqrt ( base * base   +   height * height );  }  /**   * Calculate the area of a rectangle.   *   * @param[in] width The width of the rectangle.   * @param[in] height The height of the rectangle.   * @return The surface area of the rectangle.   */  long   area_of_rectangle ( long   width ,   long   height )  { \n   return   width   *   height ;  }  int   main ()  { \n   long   width   =   cs1010_read_long (); \n   long   height   =   cs1010_read_long (); \n   long   length   =   cs1010_read_long (); \n\n   long   surface_area   =   2 * area_of_rectangle ( width ,   height )   + \n     2 * area_of_rectangle ( width ,   length )   + \n     2 * area_of_rectangle ( length ,   height ); \n   cs1010_print_long ( surface_area ); \n\n   cs1010_print_string ( \" \" ); \n\n   double   hypotenuse   =   hypotenuse_of ( hypotenuse_of ( width ,   height ),   length ); \n   cs1010_println_double ( hypotenuse );  }",
            "title": "Box"
        },
        {
            "location": "/as01-comments/index.html#digits",
            "text": "Most students who solve this correctly (without a loop and without segmentation fault) are able to get the idea of how recursion can be used here.  The most common error we see if a mismatch of types, where students use  int  leading to failure when we test with a large integer beyond the range of  int .     1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34 /**   * CS1010 Semester 1 AY18/19   * Assignment 1: Digits   *   * Read in a positive integer from the standard input and print   * the sum of all digits in the integer to the standard output.   *   * @file: digits.c   * @author: XXX (Group YYY)   */  #include   \"cs1010.h\"  /**   * Sum the digits in input.   *   * @param[in] input The integer whose digits we are summing.   * @return The sum of digits in the parameter input.   */  long   sum_of_digits ( long   input )  { \n   if   ( input   <   10 )   { \n     return   input ; \n   } \n   long   last_digit   =   input   %   10 ; \n   long   rest   =   input   /   10 ; \n   return   last_digit   +   sum_of_digits ( rest );  }  int   main ()  { \n   long   input   =   cs1010_read_long (); \n   cs1010_println_long ( sum_of_digits ( input ));  }",
            "title": "Digits"
        },
        {
            "location": "/as01-comments/index.html#taxi",
            "text": "This is a more complex problem.  We hope that students, when thinking about the solution of this problem, can appreciate the importance of breaking down the problem into simpler subproblems so that you can think, solve, and test the sub-solutions, independently, before combining them to solve the larger problem.    Another objective of this question is to get students to think about what parameters and variables are needed to solve a subproblem.  Students who think through this should realize that to calculate the metered fare only the distance is needed and to calculate the surcharge, only the day and time is needed.  Further, to determine evening peak and midnight peak, only the hour is needed (not minutes nor day).  Some common mistakes include being careless in checking for the peak hour surcharge (bug in logical expressions).    Some students use  ceil  to calculate the metered fare, which is fine (simpler than the sample code below).  But a few students incorrectly use  round  instead.      1\n  2\n  3\n  4\n  5\n  6\n  7\n  8\n  9\n 10\n 11\n 12\n 13\n 14\n 15\n 16\n 17\n 18\n 19\n 20\n 21\n 22\n 23\n 24\n 25\n 26\n 27\n 28\n 29\n 30\n 31\n 32\n 33\n 34\n 35\n 36\n 37\n 38\n 39\n 40\n 41\n 42\n 43\n 44\n 45\n 46\n 47\n 48\n 49\n 50\n 51\n 52\n 53\n 54\n 55\n 56\n 57\n 58\n 59\n 60\n 61\n 62\n 63\n 64\n 65\n 66\n 67\n 68\n 69\n 70\n 71\n 72\n 73\n 74\n 75\n 76\n 77\n 78\n 79\n 80\n 81\n 82\n 83\n 84\n 85\n 86\n 87\n 88\n 89\n 90\n 91\n 92\n 93\n 94\n 95\n 96\n 97\n 98\n 99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147 /**   * CS1010 Semester 1 AY18/19   * Assignment 1: Taxi   *   * Read in four positive integer corresponding to the day of the week,   * the hour and minute of boarding, and the distance traveled.  Print   * to the standard output, the fare of the taxi.   * height, and length of a box from the standard input, and   * print the total surface area and the length of the diagonal   * to the standard output.   *   * @file: taxi.c   * @author: XXX (Group YYY)   */  #include   \"cs1010.h\"  #include   <stdbool.h>  /**   * Check if a given day is a weekday.   *   * @param[in] day The day of the week (1 for Monday, 7 for Sunday).   * @return true if the day is a weekday, false otherwise.   */  bool   is_weekday ( long   day )  { \n   return   ( day   >=   1   &&   day   <=   5 );  }  /**   * Check if a given time falls under morning peak hour (6am to 9:29am)   *   * @param[in] hour The given hour.   * @param[in] minute The given minute.   * @return true if the given time falls under morning peak hour.     *         false otherwise.   */  bool   is_morning_peak ( long   hour ,   long   minute )  { \n   return   ( hour   >=   6   &&   hour   <   9 )   ||   ( hour   ==   9   &&   minute   <=   29 );  }  /**   * Check if a given time falls under evening peak hour (6pm to 11:59pm).   *   * @param[in] hour The given hour.   * @return true if the given time falls under morning peak hour.     *         false otherwise.   */  bool   is_evening_peak ( long   hour )  { \n   return   ( hour   >=   18   &&   hour   <=   23 );  }  /**   * Check if a given time falls under midnight peak hour (0:00 to 5:59am).   *   * @param[in] hour The given hour.   * @return true if the given time falls under midnight peak hour.     *         false otherwise.   */  bool   is_midnight_peak ( long   hour )  { \n   return   ( hour   >=   0   &&   hour   <   6 );  }  /**   * Check if surchange should be applied given day and time.   *   * @param[in] day Day of the taxi trip   * @param[in] hour Hour of boarding time.   * @param[in] minute Minute of boarding time   * @return The surchage applied (1.0 if no surcharge)).   */  double   surcharge ( long   day ,   long   hour ,   long   minute )  { \n   if   ( is_weekday ( day )   &&   is_morning_peak ( hour ,   minute ))   { \n     return   1.25 ; \n   } \n   if   ( is_evening_peak ( hour ))   { \n     return   1.25 ; \n   } \n   if   ( is_midnight_peak ( hour ))   { \n     return   1.5 ; \n   } \n   return   1.0 ;  }  /**   * Calculate the metered fare for a taxi trip (before surcharge).   *   * @param[in] distance The distance travelled.   */  double   metered_fare ( long   distance )  { \n   double   fare   =   3.40 ; \n\n   distance   -=   1000 ; \n   if   ( distance   <=   0 )   { \n     return   fare ; \n   } \n\n   if   ( distance   <=   9200 )   { \n     fare   +=   0.22   *   ( distance   /   400 ); \n     if   ( distance   %   400   >   0 )   { \n       fare   +=   0.22 ; \n     } \n   }   else   { \n     fare   +=   0.22   *   ( 9200   /   400 ); \n   } \n\n   distance   -=   9200 ; \n   if   ( distance   <=   0 )   { \n     return   fare ; \n   } \n\n   fare   +=   0.22   *   ( distance   /   350 ); \n   if   ( distance   %   350   >   0 )   { \n     fare   +=   0.22 ; \n   } \n\n   return   fare ;  }  /**   * Calculate the fare for a taxi trip (including surcharge).   *   * @param[in] day Day of the taxi trip   * @param[in] hour Hour of boarding time   * @param[in] minute Minute of boarding time   * @param[in] distance The distance travelled   */  double   fare ( long   day ,   long   hour ,   long   minute ,   long   distance )  { \n   return   metered_fare ( distance )   *   surcharge ( day ,   hour ,   minute );  }  int   main ()  { \n   long   day   =   cs1010_read_long (); \n   long   start_hour   =   cs1010_read_long (); \n   long   start_minute   =   cs1010_read_long (); \n   long   distance   =   cs1010_read_long (); \n\n   cs1010_println_double ( fare ( day ,   start_hour ,   start_minute ,   distance ));  }",
            "title": "Taxi"
        },
        {
            "location": "/as02/index.html",
            "text": "Assignment 2: Collatz, Weekday, Circle, Pattern\n\n\nDeadline\n\n\n21 September, 2018 (Friday), 6:00pm.\n\n\nPrerequisite\n\n\n\n\nYou are able to access the \nCS1010 programming environment\n.\n\n\nYou are familiar with \nbasic UNIX CLI\n and using terminal-based editor \nvim\n.\n\n\nYou have gone through Exercise 1 and have already set up your \n.gitconfig\n.\n\n\nYou are familiar with the steps of accepting, downloading, and submitting your exercise and assignment.\n\n\nYou are familiar with the directory structure and the common files included in your assignment skeleton.\n\n\n\n\nLearning Outcomes\n\n\n\n\nBe comfortable writing simple C programs that involve arithmetic operations, \nlong\n, \ndouble\n, and \nbool\n types, conditional \nif\n/\nelse\n statements, and loops with \nwhile\n/\nfor\n/\ndo-while\n statements.\n\n\nBe comfortable breaking down a problem into smaller subproblems which can be resolved using functions, including reusing existing functions written for other programs (with a tweak), writing a function that calls itself, designing what should the inputs and return values/types of a function be.\n\n\n\n\nSetup\n\n\n\n\nClick on this link\n to accept the assignment.\n\n\nLogin to one of the hosts of \nCS1010 programming environment\n\n\nRun:\n\n\n\n\n1\n~cs1010/get-as02\n\n\n\n\n\n\n\n\nYou should see the folder \nas02-<github id>\n in your home directory with the assignment skeleton inside.\n\n\n\n\nSolving The Assignments\n\n\n\n\nEdit the files \ncollatz.c\n, \nweekday.c\n, \ncircle.c\n, and \npattern.c\n to solve the corresponding question as described below.\n\n\nYou should break down the problem into smaller subproblems, and write one function for each of the subproblem to solve the problem.  \n\n\nTo compile and run tests with the sample inputs and outputs:\n\n\n\n\n1\nmake\n\n\n\n\n\n\n\n\nThe test cases are given in the \ninputs\n and \noutputs\n subdirectory.  You can use \ncat\n or \nless\n to look at the content of these test cases.  You can add more test cases or edit the given ones if needed.\n\n\n\n\nSubmission\n\n\nWhen you are ready, run the following command to submit:\n\n\n1\n~cs1010/submit-as02\n\n\n\n\n\n\nThe four files \ncollatz.c\n, \nweekday.c\n, \ncircle.c\n, and \npattern.c\n will be uploaded to GitHub.  You can submit multiple times, but only the last submission will be graded.\n\n\n\n\nEditing Your Files in Multiple Locations\n\n\nYou should edit your code only on the CS1010 PE hosts.  If you choose to edit your code in other places, such as directly on Github or in a second location (such as your own laptop), you need to be comfortable with various \ngit\n command to synchronize your code across the different locations, possibly needing to resolve synchronization conflicts.  \n\n\n\n\nOnly the four C files listed above will be submitted.  You can create additional C files for testing different solutions, but eventually, you must put your solution into the corresponding C file provided as the skeleton.\n\n\nIdentifying Yourself\n\n\nIn every C file that you submit to CS1010, you need to identify yourself by writing your name and tutorial group. Marks will be deducted if you fail to do so. You need to edit the line:\n\n\n1\n@author XXXX (Group YYYY)\n\n\n\n\n\n\nand change it to something like:\n\n\n1\n@author Elsa of Arendelle (Group 9)\n\n\n\n\n\n\nGrading\n\n\nThis assignment contributes towards 3% of your final grade.  The total mark for this assignment is 30 marks.  There are two marking criteria: correctness and style.  \n\n\nFor each question, 2 marks are allocated for coding style.  Please refer to the \nCS1010 C Style Guide\n and follow the recommended guideline.\n\n\nThe rest of the marks are allocated to correctness.  Note that passing the tests does not guarantee that your code is correct.  Even if your code produces the correct output all the time, you may still lose marks if you do not write your code properly (e.g., using the most appropriate type, violating the constraints set by the question).\n\n\nQuestion 1: Collatz (6 marks)\n\n\nThe \nCollatz Conjecture\n was introduced by the mathematician Lothar Collatz in 1937.   Also known as the \n3n+1\n3n+1\n conjecture, the problem can be stated very simply but yet no one is able to prove that it is true or false.  The conjecture states the following:\n\n\nConsider the following operation on a positive integer \nn\nn\n: if \nn\nn\n is even, divide it by two; otherwise, triple it and add one.  Suppose we form a sequence of numbers by performing this operation repeatedly, beginning with any positive integer, then this process will eventually reach the number 1, for any initial positive integer \nn\nn\n.\n\n\nFor instance, if \nn = 10\nn = 10\n, then we have the sequence \n10 \\rightarrow 5 \\rightarrow 16 \\rightarrow 8 \\rightarrow 4 \\rightarrow 2 \\rightarrow 1\n10 \\rightarrow 5 \\rightarrow 16 \\rightarrow 8 \\rightarrow 4 \\rightarrow 2 \\rightarrow 1\n.\n\n\nThe smallest number of steps taken by this process for \nn\nn\n to reach 1 is called the \ntotal stopping time\n.  In the example above, the total stopping time for 10 is 6.\n\n\nWrite a program \ncollatz.c\n that reads in a positive integer \nN\nN\n from the standard input and finds out, among the numbers between 1 to \nN\nN\n, inclusive, which one has the largest total stopping time.  If two numbers have the same total stopping time, we break ties by choosing the larger number as the answer.  Your program should print to the standard output, the number with the largest total stopping time and its corresponding total stopping time.\n\n\nSample Run\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\nooiwt@pe114:~/as02-skeleton$ ./collatz\n1\n1\n0\nooiwt@pe114:~/as02-skeleton$ ./collatz\n10\n9\n19\nooiwt@pe114:~/as02-skeleton$ ./collatz\n1000\n871\n178\n\n\n\n\n\n\nQuestion 2: Weekday (6 marks)\n\n\nWrite a program \nweekday.c\n that reads three positive integers representing the year, month, and day of a date respectively, and prints out which day of the week this date is to the standard output.  Possible outputs are \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", and \"Sunday\". The earliest date that can be given as input is January 1, 1900 (which is a Monday).\n\n\nYou may find reusing functions you have written in \nExercise 2\n useful.\n\n\nSample Run\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nooiwt@pe114:~/as02-skeleton$ ./weekday\n1900 1 1\nMonday\nooiwt@pe114:~/as02-skeleton$ ./weekday\n1904 2 29\nMonday\nooiwt@pe114:~/as02-skeleton$ ./weekday\n2018 9 14\nFriday\n\n\n\n\n\n\nQuestion 3: Circle (6 marks)\n\n\nWrite a program \ncircle.c\n that reads in a positive integer \nr\nr\n from the standard input, and prints a circle of radius \nr\nr\n to the standard output.\n\n\nWe can consider this circle as being printed on a canvas of size \n(2r+1) \\times (2r+1)\n(2r+1) \\times (2r+1)\n, with the top left corner being \n(0, 0)\n(0, 0)\n and the center of the circle at the position \n(r, r)\n(r, r)\n.  The figure below shows an example with \nr = 2\nr = 2\n.\n\n\n\n\nFor each location \n(x, y)\n(x, y)\n, let the distance of \n(x, y)\n(x, y)\n to the center be \nd_{x,y}\nd_{x,y}\n.  To print the circle, we print the following for each location \n(x,y)\n(x,y)\n:\n\n\n\n\nif \n|d_{x,y} - r| < 0.1\n|d_{x,y} - r| < 0.1\n, print \n@\n\n\notherwise, if \n|d_{x,y} - r| < 0.3\n|d_{x,y} - r| < 0.3\n, print \nO\n (that's uppercase o, not zero)\n\n\notherwise, if \n|d_{x,y} - r| < 0.5\n|d_{x,y} - r| < 0.5\n, print \n*\n\n\notherwise, if \n|d_{x,y} - r| < 0.7\n|d_{x,y} - r| < 0.7\n, print \n+\n\n\notherwise, print \n (white space)\n\n\n\n\nYour output must contain exactly \n2r+1\n2r+1\n rows, each row exactly \n2r+1\n2r+1\n characters (including the white spaces but excluding the newline).  Note that in the sample runs below, the white spaces are not visible.\n\n\nSample Run\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\nooiwt@pe114:~/as02-skeleton$ ./circle\n1\n*@*\n@ @\n*@*\nooiwt@pe114:~/as02-skeleton$ ./circle\n5\n   *@@@*   \n +@+   +@+\n @       @\n*+       +*\n@         @\n@         @\n@         @\n*+       +*\n @        @\n +@+   +@+\n   *@@@*   \nooiwt@pe114:~/as02-skeleton$ ./circle\n10\n       *O@@@O*       \n     OO+     +OO     \n   +@+         +@+   \n  +O             O+  \n  @               @  \n O+               +O\n O                 O\n*+                 +*\nO                   O\n@                   @\n@                   @\n@                   @\nO                   O\n*+                 +*\n O                 O\n O+               +O\n  @               @  \n  +O             O+  \n   +@+         +@+   \n     OO+     +OO     \n       *O@@@O*       \n\n\n\n\n\n\nQuestion 4: Pattern (12 marks)\n\n\nEven though the sequence of prime numbers appears to be random, mathematicians have found some intriguing patterns related to prime numbers.  In this question, you are asked to write a program to draw a variation of the \n\"Parallax Compression\" pattern discovered by a software engineer, Shaun Gilchrist\n.\n\n\nThe pattern visualizes the distribution of prime number in a triangle, in the following way.  The inputs given are an \ninterval\n \nn\nn\n (\nn \\ge 1\nn \\ge 1\n) and the height of the triangle \nh\nh\n.\n\n\nThe triangle has \nh\nh\n rows.  The first row of the triangle has one cell, the second row has three cells, the third row has five, etc.  The cells are centrally aligned so that visually they form an equilateral triangle.  We call the left-most cell of each row the \nleading cell\n.\n\n\nEach cell in the triangle contains \nn\nn\n integers.  The first cell in the first row contains the numbers 1, 2, ..., \nn\nn\n.  The leading cell of the next row, row 2, contains \nn\nn\n numbers between \nn+1\nn+1\n and \n3n\n3n\n, with increment of 2: i.e., \nn+1, n+3, n+5, .. n+(2n-1)\nn+1, n+3, n+5, .. n+(2n-1)\n.  The leading cell of the next row, row 3, contains the numbers \n3n + 1\n3n + 1\n and \n6n\n6n\n, with increment of 3: i.e., \n3n+1, 3n+4, 3n+7, .. 3n+(3n-2)\n3n+1, 3n+4, 3n+7, .. 3n+(3n-2)\n, etc.  For instance, if \nn\nn\n is 5, the leading cells of the first three rows contain the numbers [1, 2, 3, 4, 5], [6, 8, 10, 12, 14], [16, 19, 22, 25, 28], respectively.\n\n\nThe rest of the cells in each row contains \nn\nn\n numbers where each is one more than a number contained in the cell on its left.  So, in row 2, the numbers in the three cells are [6, 8, 10, 12, 14], [7, 9, 11, 13, 15] and [8, 10, 12, 14, 16].  In row 3, the cells contain [16, 19, 22, 25, 28], [17, 20, 23, 26, 29], [18, 21, 24, 27, 30], [19, 22, 25, 28, 31], and [20, 23, 26, 29, 32].\n\n\nNow, to visualize the distribution of primes, we do the following, for each cell of the triangle that contains \neither 1 or\n at least one prime, we print \n#\n to the standard output at the corresponding position.  Otherwise, we print \n (a white space).\n\n\nYour output must contain exactly \n2r+1\n \nh\nh\n rows, each row exactly \n2r+1\n \n2h-1\n2h-1\n characters (including the white spaces but excluding the newline).  Note that in the sample runs below, the white spaces are not visible.\n\n\nExample 1\n\n\n1\n2\n3\n4\n5\n6\nooiwt@pe114:~/as02-skeleton$ ./pattern\n2 4\n   #   \n  # #  \n ## ##\n# # # #\n\n\n\n\n\n\nSee the figures below:\n\n\n\n\nThe figure above shows the shape of the triangle with height 4.  The shaded locations belong to the triangle.  Each square represents a cell.\n\n\n\n\nThe figure above shows the integers contained in each of the triangle cells with an interval of 2.\n\n\n\n\nThe figure above shows the pattern that emerges if we color each cell that contains at least one prime a darker shade.  In our program, we use \n#\n to represent such a cell.\n\n\nMore Examples\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\nooiwt@pe114:~/as02-skeleton$ ./pattern\n11 11\n          #\n          #\n        ## ##\n       # # # #\n      #### ####\n      # #   # #\n    ###### # ####\n   # # # # # # # #\n  ## ## ## ## ## ##\n  # # # #   # # # #\n###### ### ##########\nooiwt@pe114:~/as02-skeleton$ ./pattern\n100 29\n                            #\n                           # #\n                          ## ##\n                         # # # #\n                        #### ####\n                       #   # #   #\n                      ###### ######\n                     # # # # # # # #\n                    ## ## ## ## ## ##\n                   # #   # # # #   # #\n                  ########## ##########\n                 #   # #   # #   # #   #\n                ############ ############\n               # # #   # # # # # #   # # #\n              ## #  ##  # ## ## #  ##  # ##\n             # # # # # # # # # # # # # # # #\n            ################ ################\n           #   # #   # #   # #   # #   # #   #\n          ################## ##################\n         # #   # # # #   # # # #   # # # #   # #\n        ## ##  # ## #  ## ## ## ##  # ## #  ## ##\n       # # # # #   # # # # # # # # # #   # # # # #\n      ###################### ######################\n     #   # #   # #   # #   # #   # #   # #   # #   #\n    #### #### #### #### #### #### #### #### #### ####\n   # # # # # #   # # # # # # # # # # # #   # # # # # #\n  ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ##\n # # #   # # # # # #   # # # # # #   # # # # # #   # # #\n############################ ############################",
            "title": "2. Collatz, Weekday, Circle, Pattern"
        },
        {
            "location": "/as02/index.html#assignment-2-collatz-weekday-circle-pattern",
            "text": "",
            "title": "Assignment 2: Collatz, Weekday, Circle, Pattern"
        },
        {
            "location": "/as02/index.html#deadline",
            "text": "21 September, 2018 (Friday), 6:00pm.",
            "title": "Deadline"
        },
        {
            "location": "/as02/index.html#prerequisite",
            "text": "You are able to access the  CS1010 programming environment .  You are familiar with  basic UNIX CLI  and using terminal-based editor  vim .  You have gone through Exercise 1 and have already set up your  .gitconfig .  You are familiar with the steps of accepting, downloading, and submitting your exercise and assignment.  You are familiar with the directory structure and the common files included in your assignment skeleton.",
            "title": "Prerequisite"
        },
        {
            "location": "/as02/index.html#learning-outcomes",
            "text": "Be comfortable writing simple C programs that involve arithmetic operations,  long ,  double , and  bool  types, conditional  if / else  statements, and loops with  while / for / do-while  statements.  Be comfortable breaking down a problem into smaller subproblems which can be resolved using functions, including reusing existing functions written for other programs (with a tweak), writing a function that calls itself, designing what should the inputs and return values/types of a function be.",
            "title": "Learning Outcomes"
        },
        {
            "location": "/as02/index.html#setup",
            "text": "Click on this link  to accept the assignment.  Login to one of the hosts of  CS1010 programming environment  Run:   1 ~cs1010/get-as02    You should see the folder  as02-<github id>  in your home directory with the assignment skeleton inside.",
            "title": "Setup"
        },
        {
            "location": "/as02/index.html#solving-the-assignments",
            "text": "Edit the files  collatz.c ,  weekday.c ,  circle.c , and  pattern.c  to solve the corresponding question as described below.  You should break down the problem into smaller subproblems, and write one function for each of the subproblem to solve the problem.    To compile and run tests with the sample inputs and outputs:   1 make    The test cases are given in the  inputs  and  outputs  subdirectory.  You can use  cat  or  less  to look at the content of these test cases.  You can add more test cases or edit the given ones if needed.",
            "title": "Solving The Assignments"
        },
        {
            "location": "/as02/index.html#submission",
            "text": "When you are ready, run the following command to submit:  1 ~cs1010/submit-as02   The four files  collatz.c ,  weekday.c ,  circle.c , and  pattern.c  will be uploaded to GitHub.  You can submit multiple times, but only the last submission will be graded.   Editing Your Files in Multiple Locations  You should edit your code only on the CS1010 PE hosts.  If you choose to edit your code in other places, such as directly on Github or in a second location (such as your own laptop), you need to be comfortable with various  git  command to synchronize your code across the different locations, possibly needing to resolve synchronization conflicts.     Only the four C files listed above will be submitted.  You can create additional C files for testing different solutions, but eventually, you must put your solution into the corresponding C file provided as the skeleton.",
            "title": "Submission"
        },
        {
            "location": "/as02/index.html#identifying-yourself",
            "text": "In every C file that you submit to CS1010, you need to identify yourself by writing your name and tutorial group. Marks will be deducted if you fail to do so. You need to edit the line:  1 @author XXXX (Group YYYY)   and change it to something like:  1 @author Elsa of Arendelle (Group 9)",
            "title": "Identifying Yourself"
        },
        {
            "location": "/as02/index.html#grading",
            "text": "This assignment contributes towards 3% of your final grade.  The total mark for this assignment is 30 marks.  There are two marking criteria: correctness and style.    For each question, 2 marks are allocated for coding style.  Please refer to the  CS1010 C Style Guide  and follow the recommended guideline.  The rest of the marks are allocated to correctness.  Note that passing the tests does not guarantee that your code is correct.  Even if your code produces the correct output all the time, you may still lose marks if you do not write your code properly (e.g., using the most appropriate type, violating the constraints set by the question).",
            "title": "Grading"
        },
        {
            "location": "/as02/index.html#question-1-collatz-6-marks",
            "text": "The  Collatz Conjecture  was introduced by the mathematician Lothar Collatz in 1937.   Also known as the  3n+1 3n+1  conjecture, the problem can be stated very simply but yet no one is able to prove that it is true or false.  The conjecture states the following:  Consider the following operation on a positive integer  n n : if  n n  is even, divide it by two; otherwise, triple it and add one.  Suppose we form a sequence of numbers by performing this operation repeatedly, beginning with any positive integer, then this process will eventually reach the number 1, for any initial positive integer  n n .  For instance, if  n = 10 n = 10 , then we have the sequence  10 \\rightarrow 5 \\rightarrow 16 \\rightarrow 8 \\rightarrow 4 \\rightarrow 2 \\rightarrow 1 10 \\rightarrow 5 \\rightarrow 16 \\rightarrow 8 \\rightarrow 4 \\rightarrow 2 \\rightarrow 1 .  The smallest number of steps taken by this process for  n n  to reach 1 is called the  total stopping time .  In the example above, the total stopping time for 10 is 6.  Write a program  collatz.c  that reads in a positive integer  N N  from the standard input and finds out, among the numbers between 1 to  N N , inclusive, which one has the largest total stopping time.  If two numbers have the same total stopping time, we break ties by choosing the larger number as the answer.  Your program should print to the standard output, the number with the largest total stopping time and its corresponding total stopping time.",
            "title": "Question 1: Collatz (6 marks)"
        },
        {
            "location": "/as02/index.html#sample-run",
            "text": "1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12 ooiwt@pe114:~/as02-skeleton$ ./collatz\n1\n1\n0\nooiwt@pe114:~/as02-skeleton$ ./collatz\n10\n9\n19\nooiwt@pe114:~/as02-skeleton$ ./collatz\n1000\n871\n178",
            "title": "Sample Run"
        },
        {
            "location": "/as02/index.html#question-2-weekday-6-marks",
            "text": "Write a program  weekday.c  that reads three positive integers representing the year, month, and day of a date respectively, and prints out which day of the week this date is to the standard output.  Possible outputs are \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", and \"Sunday\". The earliest date that can be given as input is January 1, 1900 (which is a Monday).  You may find reusing functions you have written in  Exercise 2  useful.",
            "title": "Question 2: Weekday (6 marks)"
        },
        {
            "location": "/as02/index.html#sample-run_1",
            "text": "1\n2\n3\n4\n5\n6\n7\n8\n9 ooiwt@pe114:~/as02-skeleton$ ./weekday\n1900 1 1\nMonday\nooiwt@pe114:~/as02-skeleton$ ./weekday\n1904 2 29\nMonday\nooiwt@pe114:~/as02-skeleton$ ./weekday\n2018 9 14\nFriday",
            "title": "Sample Run"
        },
        {
            "location": "/as02/index.html#question-3-circle-6-marks",
            "text": "Write a program  circle.c  that reads in a positive integer  r r  from the standard input, and prints a circle of radius  r r  to the standard output.  We can consider this circle as being printed on a canvas of size  (2r+1) \\times (2r+1) (2r+1) \\times (2r+1) , with the top left corner being  (0, 0) (0, 0)  and the center of the circle at the position  (r, r) (r, r) .  The figure below shows an example with  r = 2 r = 2 .   For each location  (x, y) (x, y) , let the distance of  (x, y) (x, y)  to the center be  d_{x,y} d_{x,y} .  To print the circle, we print the following for each location  (x,y) (x,y) :   if  |d_{x,y} - r| < 0.1 |d_{x,y} - r| < 0.1 , print  @  otherwise, if  |d_{x,y} - r| < 0.3 |d_{x,y} - r| < 0.3 , print  O  (that's uppercase o, not zero)  otherwise, if  |d_{x,y} - r| < 0.5 |d_{x,y} - r| < 0.5 , print  *  otherwise, if  |d_{x,y} - r| < 0.7 |d_{x,y} - r| < 0.7 , print  +  otherwise, print   (white space)   Your output must contain exactly  2r+1 2r+1  rows, each row exactly  2r+1 2r+1  characters (including the white spaces but excluding the newline).  Note that in the sample runs below, the white spaces are not visible.",
            "title": "Question 3: Circle (6 marks)"
        },
        {
            "location": "/as02/index.html#sample-run_2",
            "text": "1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41 ooiwt@pe114:~/as02-skeleton$ ./circle\n1\n*@*\n@ @\n*@*\nooiwt@pe114:~/as02-skeleton$ ./circle\n5\n   *@@@*   \n +@+   +@+\n @       @\n*+       +*\n@         @\n@         @\n@         @\n*+       +*\n @        @\n +@+   +@+\n   *@@@*   \nooiwt@pe114:~/as02-skeleton$ ./circle\n10\n       *O@@@O*       \n     OO+     +OO     \n   +@+         +@+   \n  +O             O+  \n  @               @  \n O+               +O\n O                 O\n*+                 +*\nO                   O\n@                   @\n@                   @\n@                   @\nO                   O\n*+                 +*\n O                 O\n O+               +O\n  @               @  \n  +O             O+  \n   +@+         +@+   \n     OO+     +OO     \n       *O@@@O*",
            "title": "Sample Run"
        },
        {
            "location": "/as02/index.html#question-4-pattern-12-marks",
            "text": "Even though the sequence of prime numbers appears to be random, mathematicians have found some intriguing patterns related to prime numbers.  In this question, you are asked to write a program to draw a variation of the  \"Parallax Compression\" pattern discovered by a software engineer, Shaun Gilchrist .  The pattern visualizes the distribution of prime number in a triangle, in the following way.  The inputs given are an  interval   n n  ( n \\ge 1 n \\ge 1 ) and the height of the triangle  h h .  The triangle has  h h  rows.  The first row of the triangle has one cell, the second row has three cells, the third row has five, etc.  The cells are centrally aligned so that visually they form an equilateral triangle.  We call the left-most cell of each row the  leading cell .  Each cell in the triangle contains  n n  integers.  The first cell in the first row contains the numbers 1, 2, ...,  n n .  The leading cell of the next row, row 2, contains  n n  numbers between  n+1 n+1  and  3n 3n , with increment of 2: i.e.,  n+1, n+3, n+5, .. n+(2n-1) n+1, n+3, n+5, .. n+(2n-1) .  The leading cell of the next row, row 3, contains the numbers  3n + 1 3n + 1  and  6n 6n , with increment of 3: i.e.,  3n+1, 3n+4, 3n+7, .. 3n+(3n-2) 3n+1, 3n+4, 3n+7, .. 3n+(3n-2) , etc.  For instance, if  n n  is 5, the leading cells of the first three rows contain the numbers [1, 2, 3, 4, 5], [6, 8, 10, 12, 14], [16, 19, 22, 25, 28], respectively.  The rest of the cells in each row contains  n n  numbers where each is one more than a number contained in the cell on its left.  So, in row 2, the numbers in the three cells are [6, 8, 10, 12, 14], [7, 9, 11, 13, 15] and [8, 10, 12, 14, 16].  In row 3, the cells contain [16, 19, 22, 25, 28], [17, 20, 23, 26, 29], [18, 21, 24, 27, 30], [19, 22, 25, 28, 31], and [20, 23, 26, 29, 32].  Now, to visualize the distribution of primes, we do the following, for each cell of the triangle that contains  either 1 or  at least one prime, we print  #  to the standard output at the corresponding position.  Otherwise, we print   (a white space).  Your output must contain exactly  2r+1   h h  rows, each row exactly  2r+1   2h-1 2h-1  characters (including the white spaces but excluding the newline).  Note that in the sample runs below, the white spaces are not visible.",
            "title": "Question 4: Pattern (12 marks)"
        },
        {
            "location": "/as02/index.html#example-1",
            "text": "1\n2\n3\n4\n5\n6 ooiwt@pe114:~/as02-skeleton$ ./pattern\n2 4\n   #   \n  # #  \n ## ##\n# # # #   See the figures below:   The figure above shows the shape of the triangle with height 4.  The shaded locations belong to the triangle.  Each square represents a cell.   The figure above shows the integers contained in each of the triangle cells with an interval of 2.   The figure above shows the pattern that emerges if we color each cell that contains at least one prime a darker shade.  In our program, we use  #  to represent such a cell.",
            "title": "Example 1"
        },
        {
            "location": "/as02/index.html#more-examples",
            "text": "1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44 ooiwt@pe114:~/as02-skeleton$ ./pattern\n11 11\n          #\n          #\n        ## ##\n       # # # #\n      #### ####\n      # #   # #\n    ###### # ####\n   # # # # # # # #\n  ## ## ## ## ## ##\n  # # # #   # # # #\n###### ### ##########\nooiwt@pe114:~/as02-skeleton$ ./pattern\n100 29\n                            #\n                           # #\n                          ## ##\n                         # # # #\n                        #### ####\n                       #   # #   #\n                      ###### ######\n                     # # # # # # # #\n                    ## ## ## ## ## ##\n                   # #   # # # #   # #\n                  ########## ##########\n                 #   # #   # #   # #   #\n                ############ ############\n               # # #   # # # # # #   # # #\n              ## #  ##  # ## ## #  ##  # ##\n             # # # # # # # # # # # # # # # #\n            ################ ################\n           #   # #   # #   # #   # #   # #   #\n          ################## ##################\n         # #   # # # #   # # # #   # # # #   # #\n        ## ##  # ## #  ## ## ## ##  # ## #  ## ##\n       # # # # #   # # # # # # # # # #   # # # # #\n      ###################### ######################\n     #   # #   # #   # #   # #   # #   # #   # #   #\n    #### #### #### #### #### #### #### #### #### ####\n   # # # # # #   # # # # # # # # # # # #   # # # # # #\n  ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ##\n # # #   # # # # # #   # # # # # #   # # # # # #   # # #\n############################ ############################",
            "title": "More Examples"
        },
        {
            "location": "/as02-comments/index.html",
            "text": "Assignment 2: Comments\n\n\nMark Distribution\n\n\nOutput from \nhistogram\n.  Marks are scaled up by 3x.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n          \u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\n  0 - 10\n 10 - 20\n 20 - 30\n 30 - 40  \u2588\n 40 - 50  \u2588\u2588\n 50 - 60\n 60 - 70  \u2588\n 70 - 80  \u2588\n 80 - 90  \u2588\u2588\u2588\u258c\n 90 - 100 \u2588\u2588\u258c\n\n\n\n\n\n\nNotes on Marking Schemes\n\n\n\n\nWe apply the penalty to each program independently, i.e., the same mistake repeated in the different program get penalized multiple times.  \n\n\n\n\nYou will receive 0 marks if your program cannot be compiled or is plagiarised from another.\n\n\n\n\n\n\nCode that fails all test cases and showing that student does not understand the basic concepts receives 0 marks straight away.\n\n\n\n\n\n\nFor the rest, we start with full marks and start deducting marks for each error.\n\n\n\n\n\n\nWhile the teaching team tries to ensure fair and consistent grading of assignments across all groups, each TA can, at his/her own discretion, and with the approval of Wei Tsang, adjust the grading criteria to align with the messages that they sent to the students in their tutorial group.\n\n\n\n\n\n\nStyle\n\n\nTwo marks are allocated for each question. We won't penalize for every violation, but instead, the grader judges whether the code is clean, understandable, properly indented, use proper variable names, etc. 0 - 0.5 marks for very bad style, 1.0 - 1.5 for something in the middle, 2 for an ok code. \n\n\nTo be safe, please follow strictly the CS1010 coding standards.\n\n\nGeneral Mistakes\n\n\nThis penalty applies once per program (not per occurrence).\n\n\n\n\n-1 for missing type in function declaration or definition\n\n\n-1 for using \nint\n/\nlong\n instead of \nbool\n for boolean functions or variables\n\n\n-1 for using \ndouble\n instead of \nlong\n when it is not necessary (does not involve integer division).  For instance, using \ndouble\n for \ninvest.c\n during calculation is ok, using \ndouble\n for calculating the area of the box is not.\n\n\n-1 for using of \nint\n instead of \nlong\n.  Using \nint\n for this assignment is ok only for \nday\n, \nhour\n, and \nminute\n, where there is an implicit constraint on the range of the value.\n\n\n-1 for failing to use parenthesis (e.g., \na && b || c\n)\n\n\n-1 for unnecessary/unused parameters passed into a function\n\n\n-1 for unnecessary/unused variables declared\n\n\n-1 for not including @author/@group\n\n\n-1 for global variables\n\n\n-1 for unreachable code / return\n\n\n-1 for using \n==\n to compare real numbers\n\n\n\n\nLogical Mistakes (bugs)\n\n\nIn general, -1 for each bug.\n\n\n\n\n-1 for each incorrect logical expression\n\n\n-1 for each incorrect arithmetic expression\n\n\n-1 for each incorrect use of \nif\n-\nelse\n\n\n-1 for each uninitialized variables causing incorrect output.\n\n\n-1 if program prints extra text / newline\n\n\n-1 if the program returns non-zero from \nmain\n even if the program exits successfully.\n\n\n\n\nMisunderstanding about \nif\n-\nelse\n\n\nWe noted that there are students who did not understand how \nif\n-\nelse\n works.  For instance, there are students who write this:\n\n\n1\n2\n3\n4\n5\n6\nif\n \n(\nday\n \n==\n \n0\n)\n \n{\n\n    \ncs1010_println_string\n(\n\"Monday\"\n);\n\n\n}\n \n\nif\n \n(\nday\n \n==\n \n1\n)\n \n{\n\n    \ncs1010_println_string\n(\n\"Tuesday\"\n);\n\n\n}\n \n\n\n\n\n\n\nThe above actually compares \nday\n with \n0\n, \n1\n, .. multiple times, even after a match is found, which is redundant.  Since \nday\n can take on only a single value.  The correct way is to use \nelse\n\n\n1\n2\n3\n4\n5\nif\n \n(\nday\n \n==\n \n0\n)\n \n{\n\n    \ncs1010_println_string\n(\n\"Monday\"\n);\n\n\n}\n \nelse\n \nif\n \n(\nday\n \n==\n \n1\n)\n \n{\n\n    \ncs1010_println_string\n(\n\"Tuesday\"\n);\n\n\n}\n \n\n\n\n\n\n\nAnother mistake we see is:\n\n1\n2\n3\n4\n5\nif\n \n(\ndist\n \n>\n \n0.7\n)\n \n{\n\n    \ncs1010_println_string\n(\n\"+\"\n);\n\n\n}\n \nelse\n \nif\n \n(\ndist\n \n<=\n \n0.7\n \n&&\n \ndist\n \n>\n \n0.5\n)\n \n{\n\n    \ncs1010_println_string\n(\n\"*\"\n);\n\n\n}\n \n\n\n\n\n\nThis demonstrates that students do not fully understand the meaning of \nelse\n, which negates the previous condition.  Once we reach the \nelse\n branch, we are guaranteed that \ndist > 0.7\n is false, which means that \ndist <= 0.7\n is true, so the check for \ndist <= 0.7\n is redundant.\n\n\nAnswer Keys\n\n\nCollatz\n\n\nWe can break the problem down into three sub-problems.  So, write three functions:\n\n\n\n\n\n\nGiven a number \nn\nn\n, perform one step of the operation.  This can be solved with a simple \nif-else\n statement.  Most students do not have a problem with this.\n\n\n\n\n\n\nGiven a number \nn\nn\n, find the stopping time.  This involves repeatedly calling \none_collatz_step\n until we reach 1, and count how many steps are needed.  Most students do not have a problem with this.\n\n\n\n\n\n\nGiven a number \nN\nN\n, find the number between 1 to \nN\nN\n, inclusive, that gives the largest stopping time, \nbreaking tie by choosing the larger number\n.\n\n\n\n\n\n\nThis is similar to the max problem that we have seen since Lecture 1, so most students are able to solve this.  About \u2159 of you, however, did not properly break ties by choosing the larger number.  Recall from your Tutorial 1 that, when you compare with \nmax_so_far\n, whether you use \n>\n or \n>=\n makes a big difference here.  You get 1 mark deduction if you do not break ties properly.\n\n\nWeekday\n\n\nLet's look at how to solve this problem without using any formula.  The most straightforward way is to count how many days have passed since January 1, 1900, and do a \n% 7\n.\n\n\nWe can break the problem down into several subproblems.  Suppose the input date is \nyear\n, \nmonth\n and \nday\n,\n\n\n\n\n\n\nCount the number of days from January 1, 1900, to December 31, the year before (i.e., \nyear-1\n).\n\n\nThis can be done by just summing up, in a loop, the days in every year from 1900 to \nyear-1\n, inclusive.  For each year, if it is a leap year, add 366, otherwise, add 365.\n\n\nSome common mistakes include an error in loop terminating condition (either adds one extra year or one less year).\n\n\n\n\n\n\nCheck if a year is a leap year.\n\n\nThis comes straight from Exercise 2.\n\n\n\n\n\n\nCount the number of days since January 1, the current year.  \n\n\nThis subproblem is similar to the problem from Exercise 2.  You have to, however, be careful of whether \nyear\n is a leap year.  (Question 3 from Exercise 2 assumes that the year is not a leap year).  So, you should add 1 to the answer if \nmonth\n is larger than 2 and \nyear\n is a leap year.\n\n\nCommon bugs include: (i) not checking if the current year is a leap year, and (ii) add one day for all months (not just March onwards).\n\n\n\n\n\n\nDetermine the day of the week.\n\n\nFrom (1) and (3) you get the total number of days since January 1, 1900.  We can then do a \n% 7\n.  If we get 0, it is a Monday; 1, a Tuesday; etc.  Some students lose points unnecessarily by having spelling errors in the output.\n\n\nThere are other simpler ways to solve this problem.  Some students use the \nZeller's Algorithm\n, which is perfectly fine too.\n\n\n\n\n\n\nCircle\n\n\nAgain, break it down into several smaller problems.  \n\n\n\n\n\n\nCalculate the distance of a location to the center.\n\n\nMost common issues we see:\n\n\n\n\n\n\nMany of you use \npow(x, 2)\n to square an integer.  \npow\n is a powerful function and is written to be general, so it is slower than just doing \nx*x\n.\n\n\n\n\n\n\nMany of you use \nlabs()\n or \nfabs()\n on the result of a square or a square root function.  This is redundant since the square of a number and the square root of a number is always positive!\n\n\n\n\n\n\n\n\n\n\nDraw each \"pixel\" of the circle.  The drawing part is actually easy.  \n\n\nSuppose you have a function to compute the distance, say, \ndist(row, col, r)\n, and you do this:\n\n1\n2\n3\n4\n5\nif\n \n(\ndist\n(\nrow\n,\n \ncol\n,\n \nr\n)\n \n>\n \n0.7\n)\n \n{\n\n  \ncs1010_println_string\n(\n\"+\"\n);\n\n\n}\n \nelse\n \nif\n \n(\ndist\n(\nrow\n,\n \ncol\n,\n \nr\n)\n \n>\n \n0.5\n)\n \n{\n\n  \ncs1010_println_string\n(\n\"*\"\n);\n\n\n}\n \nelse\n \n..\n\n\n\n\n\n\nThis is functionally correct, but it leads to multiple invocations of \ndist\n and calculation of the distance, even though the result does not change.  When we start to factor in efficiency into grading criteria, you will be penalized for this.\n\n\n\n\n\n\nDraw each row of the circle.\n\n\n\n\n\n\nDraw the circle.\n\n\nMost students have no problem with (3) and (4) above.\n\n\n\n\n\n\nPattern\n\n\nSome students creatively call this the \"Christmas Tree\" problem :) \n\n\nThis might seems daunting at first, but once you break it down into smaller problems, it can be solved fairly easily.  This question is designed to see if students can, at this stage, solve problems by breaking it down into multiple smaller problems -- something that we have been iterating since Lecture 2.\n\n\nLet say the input be the interval \nn\nn\n and height \nh\nh\n.\n\n\nFor this problem, we can break it down into the following sub-problems:\n\n\n\n\n\n\nFind the first number in each leading cell at each row.  Example, for \nn\nn\n = 2, the first number is 1, 3, 7, 13, .. For \nn\nn\n = 5, the first number is 1, 6, 16, 31, 51, ..  This leading number can be calculated with the following loop:\n\n\n1\n2\n3\n4\n5\n6\n7\nlong\n \nleading_number\n(\nlong\n \nrow\n,\n \nlong\n \nn\n)\n \n{\n\n  \nlong\n \nnumber\n \n=\n \n1\n;\n\n  \nfor\n \n(\nlong\n \ni\n \n=\n \n1\n;\n \ni\n \n<=\n \nrow\n;\n \ni\n+=\n \n1\n)\n \n{\n\n    \nnumber\n \n+=\n \ni\n*\nn\n;\n\n  \n}\n\n  \nreturn\n \nnumber\n;\n\n  \n}\n\n\n\n\n\n\n\n\n\n\n\nFind the rest of the \nn-1\nn-1\n numbers in each leading cell at each row.   Once we have the first number, we just loop through the rest of the \nn - 1\nn - 1\n, increment by \nrow + 1\n each time, something like this:\n    \n1\n2\n3\n4\n5\n6\nvoid\n \nprint_pattern\n(\nlong\n \nrow\n,\n \nlong\n \ncol\n,\n \nlong\n \nn\n)\n \n{\n\n  \nlong\n \nnum\n \n=\n \nleading_number\n(\nrow\n,\n \nn\n);\n\n  \nfor\n \n(\nlong\n \ni\n \n=\n \n0\n;\n \ni\n \n<\n \nn\n;\n \ni\n \n+=\n \n1\n)\n \n{\n\n    \nnum\n \n+=\n \n(\nrow\n \n+\n \n1\n);\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\n\n\n\nWe can then find the numbers in the rest of the cells in the same row.\n\n\n1\n2\n3\n4\n5\n6\nvoid\n \nprint_pattern\n(\nlong\n \nrow\n,\n \nlong\n \ncol\n,\n \nlong\n \nn\n)\n \n{\n\n  \nlong\n \nnum\n \n=\n \nleading_number\n(\nrow\n,\n \nn\n)\n \n+\n \ncol\n;\n \n// note the change here\n\n  \nfor\n \n(\nlong\n \ni\n \n=\n \n0\n;\n \ni\n \n<\n \nn\n;\n \ni\n \n+=\n \n1\n)\n \n{\n\n    \nnum\n \n+=\n \n(\nrow\n \n+\n \n1\n);\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\n\n\n\n\nThe steps above give us the number in each cell, all we need to do now is to decide whether to print \n#\n or \n.  Suppose we have a function \nis_prime\n, we can do this:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\nvoid\n \nprint_pattern\n(\nlong\n \nrow\n,\n \nlong\n \ncol\n,\n \nlong\n \nn\n)\n \n{\n\n  \nlong\n \nnum\n \n=\n \nleading_number\n(\nrow\n,\n \nn\n)\n \n+\n \ncol\n;\n \n// note the change here\n\n  \nbool\n \nfound\n \n=\n \nfalse\n;\n\n  \nfor\n \n(\nlong\n \ni\n \n=\n \n0\n;\n \ni\n \n<\n \nn\n \n&&\n \n!\nfound\n;\n \ni\n \n+=\n \n1\n)\n \n{\n\n    \nif\n \n(\nnum\n \n==\n \n1\n \n||\n \nis_prime\n(\nnum\n))\n \n{\n\n      \ncs1010_print_string\n(\n\"#\"\n);\n\n      \nfound\n \n=\n \ntrue\n;\n\n    \n}\n \nelse\n \n{\n\n      \nnum\n \n+=\n \n(\nrow\n \n+\n \n1\n);\n\n    \n}\n\n  \n}\n\n  \nif\n \n(\n!\nfound\n)\n \n{\n\n    \ncs1010_print_string\n(\n\" \"\n);\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\n\n\n\n\nNow, let's figure out how to check if a number is prime.  You have seen this problem in Exercise 3.  But there are different solutions, with different degrees of efficiency. \n\n\nHere is the first version:\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\nbool\n \nis_prime\n(\nlong\n \nn\n)\n\n\n{\n\n  \nbool\n \nis_prime\n \n=\n \ntrue\n;\n\n  \nfor\n \n(\nlong\n \ni\n \n=\n \n2\n;\n \ni\n \n<=\n \nn\n \n-\n \n1\n;\n \ni\n++\n)\n \n{\n\n    \nif\n \n(\nn\n \n%\n \ni\n \n==\n \n0\n)\n \n{\n\n      \nis_prime\n \n=\n \nfalse\n;\n\n    \n}\n\n  \n}\n\n  \nreturn\n \nis_prime\n;\n\n\n}\n\n\n\n\n\n\nIt checks all numbers between 2 to \nn - 1\n, if there is a number \ni\n by which \nn\n is divisible, then \nn\n is not prime.\n\n\nThis is an incredibly slow implementation even though it is correct. The most glaring issue is that it continues to check, if even though it has found an \"evidence\" that \nn\n is not a prime.\n\n\nWhat we should do, instead, is to immediately bail out of the function once we found that \nn\n is not a prime.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nbool\n \nis_prime\n(\nlong\n \nn\n)\n\n\n{\n\n  \nfor\n \n(\nlong\n \ni\n \n=\n \n2\n;\n \ni\n \n<=\n \nn\n \n-\n \n1\n;\n \ni\n++\n)\n \n{\n\n    \nif\n \n(\nn\n \n%\n \ni\n \n==\n \n0\n)\n \n{\n\n      \nreturn\n \nfalse\n;\n\n    \n}\n\n  \n}\n\n  \nreturn\n \ntrue\n;\n\n\n}\n\n\n\n\n\n\n\nWe can do even better.  Since the smaller integer factor is 2, there is actually no need to check if \nn\n is divisible by anything larger than \nn/2\n.  For instance, to check if 17 is prime, there is no need to check if 17 is divisible by 9, 10, 11, 12, .. 16.  So we can skip checking half the number! \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nbool\n \nis_prime\n(\nlong\n \nn\n)\n\n\n{\n\n  \nfor\n \n(\nlong\n \ni\n \n=\n \n2\n;\n \ni\n \n<=\n \nn\n/\n2\n;\n \ni\n++\n)\n \n{\n\n    \nif\n \n(\nn\n \n%\n \ni\n \n==\n \n0\n)\n \n{\n\n      \nreturn\n \nfalse\n;\n\n    \n}\n\n  \n}\n\n  \nreturn\n \ntrue\n;\n\n\n}\n\n\n\n\n\n\n\nCan we do better?  It turned out, yes.  Suppose \nn\n is a composite number is equals to \na * b\n, for some integer \na\n and \nb\n.  One of these two numbers must be smaller or equal to square root of \nn\n.  (Spend a moment to think about why -- if you are taking CS1231, try to prove this by contradiction.)  So, we do not have to check beyond the square root of \nn\n.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nbool\n \nis_prime\n(\nlong\n \nn\n)\n\n\n{\n\n  \nfor\n \n(\nlong\n \ni\n \n=\n \n2\n;\n \ni\n \n<=\n \nsqrt\n(\nn\n);\n \ni\n++\n)\n \n{\n\n    \nif\n \n(\nn\n \n%\n \ni\n \n==\n \n0\n)\n \n{\n\n      \nreturn\n \nfalse\n;\n\n    \n}\n\n  \n}\n\n  \nreturn\n \ntrue\n;\n\n\n}\n\n\n\n\n\n\n\nWe can further optimize this.  Some of you actually use the fact that every prime besides 2 and 3 must be of the form \n6k - 1\n or \n6k + 1\n and use this to speed up the \nis_prime()\n function.  \n\n\n\n\n\n\nNow, coming back to printing the Christmas tree.  Now that we know what to print in each cell, we just need to write functions to print each row and each col, padding the pattern properly to be a triangle.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\nvoid\n \nprint_blanks\n(\nlong\n \nwidth\n)\n \n{\n\n  \nfor\n \n(\nlong\n \ni\n \n=\n \n0\n;\n \ni\n \n<\n \nwidth\n;\n \ni\n \n+=\n \n1\n)\n \n{\n\n    \ncs1010_print_string\n(\n\" \"\n);\n\n  \n}\n\n\n}\n\n\n\nvoid\n \nprint_triangle\n(\nlong\n \nrow\n,\n \nlong\n \nwidth\n,\n \nlong\n \nn\n)\n \n{\n\n  \nfor\n \n(\nlong\n \ni\n \n=\n \n0\n;\n \ni\n \n<\n \nwidth\n;\n \ni\n \n+=\n \n1\n)\n \n{\n\n    \nprint_pattern\n(\nrow\n,\n \ni\n,\n \nn\n);\n\n  \n}\n\n\n}\n\n\n\nvoid\n \ndraw_triangle\n(\nlong\n \nh\n,\n \nlong\n \nn\n)\n \n{\n\n  \nfor\n \n(\nlong\n \nrow\n \n=\n \n0\n;\n \nrow\n \n<\n \nh\n;\n \nrow\n \n+=\n \n1\n)\n \n{\n\n    \nprint_blanks\n(\nh\n \n-\n \nrow\n \n-\n \n1\n);\n\n    \nprint_triangle\n(\nrow\n,\n \n2\n*\nrow\n \n+\n \n1\n,\n \nn\n);\n\n    \nprint_blanks\n(\nh\n \n-\n \nrow\n \n-\n \n1\n);\n\n    \ncs1010_println_string\n(\n\"\"\n);\n\n  \n}\n\n\n}",
            "title": "2. Comments and Answer Keys"
        },
        {
            "location": "/as02-comments/index.html#assignment-2-comments",
            "text": "",
            "title": "Assignment 2: Comments"
        },
        {
            "location": "/as02-comments/index.html#mark-distribution",
            "text": "Output from  histogram .  Marks are scaled up by 3x.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11           \u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\n  0 - 10\n 10 - 20\n 20 - 30\n 30 - 40  \u2588\n 40 - 50  \u2588\u2588\n 50 - 60\n 60 - 70  \u2588\n 70 - 80  \u2588\n 80 - 90  \u2588\u2588\u2588\u258c\n 90 - 100 \u2588\u2588\u258c",
            "title": "Mark Distribution"
        },
        {
            "location": "/as02-comments/index.html#notes-on-marking-schemes",
            "text": "We apply the penalty to each program independently, i.e., the same mistake repeated in the different program get penalized multiple times.     You will receive 0 marks if your program cannot be compiled or is plagiarised from another.    Code that fails all test cases and showing that student does not understand the basic concepts receives 0 marks straight away.    For the rest, we start with full marks and start deducting marks for each error.    While the teaching team tries to ensure fair and consistent grading of assignments across all groups, each TA can, at his/her own discretion, and with the approval of Wei Tsang, adjust the grading criteria to align with the messages that they sent to the students in their tutorial group.",
            "title": "Notes on Marking Schemes"
        },
        {
            "location": "/as02-comments/index.html#style",
            "text": "Two marks are allocated for each question. We won't penalize for every violation, but instead, the grader judges whether the code is clean, understandable, properly indented, use proper variable names, etc. 0 - 0.5 marks for very bad style, 1.0 - 1.5 for something in the middle, 2 for an ok code.   To be safe, please follow strictly the CS1010 coding standards.",
            "title": "Style"
        },
        {
            "location": "/as02-comments/index.html#general-mistakes",
            "text": "This penalty applies once per program (not per occurrence).   -1 for missing type in function declaration or definition  -1 for using  int / long  instead of  bool  for boolean functions or variables  -1 for using  double  instead of  long  when it is not necessary (does not involve integer division).  For instance, using  double  for  invest.c  during calculation is ok, using  double  for calculating the area of the box is not.  -1 for using of  int  instead of  long .  Using  int  for this assignment is ok only for  day ,  hour , and  minute , where there is an implicit constraint on the range of the value.  -1 for failing to use parenthesis (e.g.,  a && b || c )  -1 for unnecessary/unused parameters passed into a function  -1 for unnecessary/unused variables declared  -1 for not including @author/@group  -1 for global variables  -1 for unreachable code / return  -1 for using  ==  to compare real numbers",
            "title": "General Mistakes"
        },
        {
            "location": "/as02-comments/index.html#logical-mistakes-bugs",
            "text": "In general, -1 for each bug.   -1 for each incorrect logical expression  -1 for each incorrect arithmetic expression  -1 for each incorrect use of  if - else  -1 for each uninitialized variables causing incorrect output.  -1 if program prints extra text / newline  -1 if the program returns non-zero from  main  even if the program exits successfully.",
            "title": "Logical Mistakes (bugs)"
        },
        {
            "location": "/as02-comments/index.html#misunderstanding-about-if-else",
            "text": "We noted that there are students who did not understand how  if - else  works.  For instance, there are students who write this:  1\n2\n3\n4\n5\n6 if   ( day   ==   0 )   { \n     cs1010_println_string ( \"Monday\" );  }   if   ( day   ==   1 )   { \n     cs1010_println_string ( \"Tuesday\" );  }     The above actually compares  day  with  0 ,  1 , .. multiple times, even after a match is found, which is redundant.  Since  day  can take on only a single value.  The correct way is to use  else  1\n2\n3\n4\n5 if   ( day   ==   0 )   { \n     cs1010_println_string ( \"Monday\" );  }   else   if   ( day   ==   1 )   { \n     cs1010_println_string ( \"Tuesday\" );  }     Another mistake we see is: 1\n2\n3\n4\n5 if   ( dist   >   0.7 )   { \n     cs1010_println_string ( \"+\" );  }   else   if   ( dist   <=   0.7   &&   dist   >   0.5 )   { \n     cs1010_println_string ( \"*\" );  }     This demonstrates that students do not fully understand the meaning of  else , which negates the previous condition.  Once we reach the  else  branch, we are guaranteed that  dist > 0.7  is false, which means that  dist <= 0.7  is true, so the check for  dist <= 0.7  is redundant.",
            "title": "Misunderstanding about if-else"
        },
        {
            "location": "/as02-comments/index.html#answer-keys",
            "text": "",
            "title": "Answer Keys"
        },
        {
            "location": "/as02-comments/index.html#collatz",
            "text": "We can break the problem down into three sub-problems.  So, write three functions:    Given a number  n n , perform one step of the operation.  This can be solved with a simple  if-else  statement.  Most students do not have a problem with this.    Given a number  n n , find the stopping time.  This involves repeatedly calling  one_collatz_step  until we reach 1, and count how many steps are needed.  Most students do not have a problem with this.    Given a number  N N , find the number between 1 to  N N , inclusive, that gives the largest stopping time,  breaking tie by choosing the larger number .    This is similar to the max problem that we have seen since Lecture 1, so most students are able to solve this.  About \u2159 of you, however, did not properly break ties by choosing the larger number.  Recall from your Tutorial 1 that, when you compare with  max_so_far , whether you use  >  or  >=  makes a big difference here.  You get 1 mark deduction if you do not break ties properly.",
            "title": "Collatz"
        },
        {
            "location": "/as02-comments/index.html#weekday",
            "text": "Let's look at how to solve this problem without using any formula.  The most straightforward way is to count how many days have passed since January 1, 1900, and do a  % 7 .  We can break the problem down into several subproblems.  Suppose the input date is  year ,  month  and  day ,    Count the number of days from January 1, 1900, to December 31, the year before (i.e.,  year-1 ).  This can be done by just summing up, in a loop, the days in every year from 1900 to  year-1 , inclusive.  For each year, if it is a leap year, add 366, otherwise, add 365.  Some common mistakes include an error in loop terminating condition (either adds one extra year or one less year).    Check if a year is a leap year.  This comes straight from Exercise 2.    Count the number of days since January 1, the current year.    This subproblem is similar to the problem from Exercise 2.  You have to, however, be careful of whether  year  is a leap year.  (Question 3 from Exercise 2 assumes that the year is not a leap year).  So, you should add 1 to the answer if  month  is larger than 2 and  year  is a leap year.  Common bugs include: (i) not checking if the current year is a leap year, and (ii) add one day for all months (not just March onwards).    Determine the day of the week.  From (1) and (3) you get the total number of days since January 1, 1900.  We can then do a  % 7 .  If we get 0, it is a Monday; 1, a Tuesday; etc.  Some students lose points unnecessarily by having spelling errors in the output.  There are other simpler ways to solve this problem.  Some students use the  Zeller's Algorithm , which is perfectly fine too.",
            "title": "Weekday"
        },
        {
            "location": "/as02-comments/index.html#circle",
            "text": "Again, break it down into several smaller problems.      Calculate the distance of a location to the center.  Most common issues we see:    Many of you use  pow(x, 2)  to square an integer.   pow  is a powerful function and is written to be general, so it is slower than just doing  x*x .    Many of you use  labs()  or  fabs()  on the result of a square or a square root function.  This is redundant since the square of a number and the square root of a number is always positive!      Draw each \"pixel\" of the circle.  The drawing part is actually easy.    Suppose you have a function to compute the distance, say,  dist(row, col, r) , and you do this: 1\n2\n3\n4\n5 if   ( dist ( row ,   col ,   r )   >   0.7 )   { \n   cs1010_println_string ( \"+\" );  }   else   if   ( dist ( row ,   col ,   r )   >   0.5 )   { \n   cs1010_println_string ( \"*\" );  }   else   ..    This is functionally correct, but it leads to multiple invocations of  dist  and calculation of the distance, even though the result does not change.  When we start to factor in efficiency into grading criteria, you will be penalized for this.    Draw each row of the circle.    Draw the circle.  Most students have no problem with (3) and (4) above.",
            "title": "Circle"
        },
        {
            "location": "/as02-comments/index.html#pattern",
            "text": "Some students creatively call this the \"Christmas Tree\" problem :)   This might seems daunting at first, but once you break it down into smaller problems, it can be solved fairly easily.  This question is designed to see if students can, at this stage, solve problems by breaking it down into multiple smaller problems -- something that we have been iterating since Lecture 2.  Let say the input be the interval  n n  and height  h h .  For this problem, we can break it down into the following sub-problems:    Find the first number in each leading cell at each row.  Example, for  n n  = 2, the first number is 1, 3, 7, 13, .. For  n n  = 5, the first number is 1, 6, 16, 31, 51, ..  This leading number can be calculated with the following loop:  1\n2\n3\n4\n5\n6\n7 long   leading_number ( long   row ,   long   n )   { \n   long   number   =   1 ; \n   for   ( long   i   =   1 ;   i   <=   row ;   i +=   1 )   { \n     number   +=   i * n ; \n   } \n   return   number ; \n   }      Find the rest of the  n-1 n-1  numbers in each leading cell at each row.   Once we have the first number, we just loop through the rest of the  n - 1 n - 1 , increment by  row + 1  each time, something like this:\n     1\n2\n3\n4\n5\n6 void   print_pattern ( long   row ,   long   col ,   long   n )   { \n   long   num   =   leading_number ( row ,   n ); \n   for   ( long   i   =   0 ;   i   <   n ;   i   +=   1 )   { \n     num   +=   ( row   +   1 ); \n   }  }      We can then find the numbers in the rest of the cells in the same row.  1\n2\n3\n4\n5\n6 void   print_pattern ( long   row ,   long   col ,   long   n )   { \n   long   num   =   leading_number ( row ,   n )   +   col ;   // note the change here \n   for   ( long   i   =   0 ;   i   <   n ;   i   +=   1 )   { \n     num   +=   ( row   +   1 ); \n   }  }      The steps above give us the number in each cell, all we need to do now is to decide whether to print  #  or  .  Suppose we have a function  is_prime , we can do this:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15 void   print_pattern ( long   row ,   long   col ,   long   n )   { \n   long   num   =   leading_number ( row ,   n )   +   col ;   // note the change here \n   bool   found   =   false ; \n   for   ( long   i   =   0 ;   i   <   n   &&   ! found ;   i   +=   1 )   { \n     if   ( num   ==   1   ||   is_prime ( num ))   { \n       cs1010_print_string ( \"#\" ); \n       found   =   true ; \n     }   else   { \n       num   +=   ( row   +   1 ); \n     } \n   } \n   if   ( ! found )   { \n     cs1010_print_string ( \" \" ); \n   }  }      Now, let's figure out how to check if a number is prime.  You have seen this problem in Exercise 3.  But there are different solutions, with different degrees of efficiency.   Here is the first version:  1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10 bool   is_prime ( long   n )  { \n   bool   is_prime   =   true ; \n   for   ( long   i   =   2 ;   i   <=   n   -   1 ;   i ++ )   { \n     if   ( n   %   i   ==   0 )   { \n       is_prime   =   false ; \n     } \n   } \n   return   is_prime ;  }    It checks all numbers between 2 to  n - 1 , if there is a number  i  by which  n  is divisible, then  n  is not prime.  This is an incredibly slow implementation even though it is correct. The most glaring issue is that it continues to check, if even though it has found an \"evidence\" that  n  is not a prime.  What we should do, instead, is to immediately bail out of the function once we found that  n  is not a prime.  1\n2\n3\n4\n5\n6\n7\n8\n9 bool   is_prime ( long   n )  { \n   for   ( long   i   =   2 ;   i   <=   n   -   1 ;   i ++ )   { \n     if   ( n   %   i   ==   0 )   { \n       return   false ; \n     } \n   } \n   return   true ;  }    We can do even better.  Since the smaller integer factor is 2, there is actually no need to check if  n  is divisible by anything larger than  n/2 .  For instance, to check if 17 is prime, there is no need to check if 17 is divisible by 9, 10, 11, 12, .. 16.  So we can skip checking half the number!   1\n2\n3\n4\n5\n6\n7\n8\n9 bool   is_prime ( long   n )  { \n   for   ( long   i   =   2 ;   i   <=   n / 2 ;   i ++ )   { \n     if   ( n   %   i   ==   0 )   { \n       return   false ; \n     } \n   } \n   return   true ;  }    Can we do better?  It turned out, yes.  Suppose  n  is a composite number is equals to  a * b , for some integer  a  and  b .  One of these two numbers must be smaller or equal to square root of  n .  (Spend a moment to think about why -- if you are taking CS1231, try to prove this by contradiction.)  So, we do not have to check beyond the square root of  n .  1\n2\n3\n4\n5\n6\n7\n8\n9 bool   is_prime ( long   n )  { \n   for   ( long   i   =   2 ;   i   <=   sqrt ( n );   i ++ )   { \n     if   ( n   %   i   ==   0 )   { \n       return   false ; \n     } \n   } \n   return   true ;  }    We can further optimize this.  Some of you actually use the fact that every prime besides 2 and 3 must be of the form  6k - 1  or  6k + 1  and use this to speed up the  is_prime()  function.      Now, coming back to printing the Christmas tree.  Now that we know what to print in each cell, we just need to write functions to print each row and each col, padding the pattern properly to be a triangle.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20 void   print_blanks ( long   width )   { \n   for   ( long   i   =   0 ;   i   <   width ;   i   +=   1 )   { \n     cs1010_print_string ( \" \" ); \n   }  }  void   print_triangle ( long   row ,   long   width ,   long   n )   { \n   for   ( long   i   =   0 ;   i   <   width ;   i   +=   1 )   { \n     print_pattern ( row ,   i ,   n ); \n   }  }  void   draw_triangle ( long   h ,   long   n )   { \n   for   ( long   row   =   0 ;   row   <   h ;   row   +=   1 )   { \n     print_blanks ( h   -   row   -   1 ); \n     print_triangle ( row ,   2 * row   +   1 ,   n ); \n     print_blanks ( h   -   row   -   1 ); \n     cs1010_println_string ( \"\" ); \n   }  }",
            "title": "Pattern"
        },
        {
            "location": "/as03/index.html",
            "text": "Assignment 3: Kendall, Histogram, CountingSort\n\n\nDeadline\n\n\n5 October, 2018 (Friday), 6:00pm.\n\n\nPrerequisite\n\n\n\n\nYou are able to access the \nCS1010 programming environment\n.\n\n\nYou are familiar with \nbasic UNIX CLI\n and using terminal-based editor \nvim\n.\n\n\nYou have gone through Exercise 1 and have already set up your \n.gitconfig\n.\n\n\nYou are familiar with the steps of accepting, downloading, and submitting your exercise and assignment.\n\n\nYou are familiar with the directory structure and the common files included in your assignment skeleton.\n\n\n\n\nLearning Outcomes\n\n\n\n\nBe comfortable writing C programs that involve arithmetic operations, \nlong\n, \ndouble\n, \nbool\n, and \nchar\n types, conditional \nif\n/\nelse\n statements, loops with \nwhile\n/\nfor\n/\ndo-while\n statements, and arrays.\n\n\nBe comfortable breaking down a problem into smaller subproblems which can be resolved using functions, including reusing existing functions written for other programs (with a tweak), writing a function that calls itself, designing what should the inputs and return values/types of a function be.\n\n\n\n\nSetup\n\n\n\n\nClick on this link\n to accept the assignment.\n\n\nLogin to one of the hosts of \nCS1010 programming environment\n\n\nRun:\n\n\n\n\n1\n~cs1010/get-as03\n\n\n\n\n\n\n\n\nYou should see the folder \nas03-<github id>\n in your home directory with the assignment skeleton inside.\n\n\n\n\nSolving The Assignments\n\n\n\n\nEdit the files \nkandall.c\n, \nhistogram.c\n, \ncountingsort.c\n, to solve the corresponding question as described below.\n\n\nYou should break down the problem into smaller subproblems, and write one function for each of the subproblem to solve the problem.  \n\n\nTo compile and run tests with the sample inputs and outputs:\n\n\n\n\n1\nmake\n\n\n\n\n\n\n\n\nThe test cases are given in the \ninputs\n and \noutputs\n subdirectory.  You can use \ncat\n or \nless\n to look at the content of these test cases.  You can add more test cases or edit the given ones if needed.\n\n\n\n\nSubmission\n\n\nWhen you are ready, run the following command to submit:\n\n\n1\n~cs1010/submit-as03\n\n\n\n\n\n\nThe four files \nkendall.c\n, \nhistogram.c\n, \ncountingsort.c\n, will be uploaded to GitHub.  You can submit multiple times, but only the last submission will be graded.\n\n\n\n\nEditing Your Files in Multiple Locations\n\n\nYou should edit your code only on the CS1010 PE hosts.  If you choose to edit your code in other places, such as directly on Github or in a second location (such as your own laptop), you need to be comfortable with various \ngit\n command to synchronize your code across the different locations, possibly needing to resolve synchronization conflicts.  \n\n\n\n\nOnly the four C files listed above will be submitted.  You can create additional C files for testing different solutions, but eventually, you must put your solution into the corresponding C file provided as the skeleton.\n\n\nIdentifying Yourself\n\n\nIn every C file that you submit to CS1010, you need to identify yourself by writing your name and tutorial group. Marks will be deducted if you fail to do so. You need to edit the line:\n\n\n1\n@author XXXX (Group YYYY)\n\n\n\n\n\n\nand change it to something like:\n\n\n1\n@author Peter Parker (Group 9)\n\n\n\n\n\n\nGrading\n\n\nThis assignment contributes towards 3% of your final grade.  The total mark for this assignment is 30 marks.  There are two marking criteria: correctness and style.  \n\n\nFor each question, 2 marks are allocated for coding style.  Please refer to the \nCS1010 C Style Guide\n and follow the recommended guideline.\n\n\nThe rest of the marks are allocated to correctness.  Note that passing the tests does not guarantee that your code is correct.  Even if your code produces the correct output all the time, you may still lose marks if you do not write your code properly (e.g., using the most appropriate type, violating the constraints set by the question).\n\n\nWe reserve the right to penalize students for using banned C syntax in the assignments.  In addition, each grader at his or her own discretion can penalze students for repeating mistakes / bad practices from the student's past assignments (even if it was just a warning with no marks deducted in the earlier assignments).\n\n\nQuestion 1: Kendall (10 marks)\n\n\nSuppose that we are given a set of items and we ask two different parties to rank the items according to some order.  We may get two different order of the items.  How do we measure how similar (or dissimilar) the two rankings are?\n\n\nFor example, consider a search engine that returns a list of web pages ranked by their relevance to the search query.  A user may not always agree with the ranking of the search engine and may judge the relevance of the search result differently, i.e., the user may have his or her own ranking.  This measurement of similarity between the ranking by the search engine and the ranking by the user gives us a metric on how good the search engine result is.  The more similar it is to the ranking of the user, the better the search engine is in ranking in the search results.\n\n\nOne way to measure the similarity of two rankings is the \nKendall tau distance\n.  You will write a program \nkendall\n that calculates the \nnormalized\n Kendall tau distance for this question.\n\n\nWe will represent a ranking by the order of the items.  The first item is ranked 1, second is ranked 2, and so on.  To simplify the problem, we take one of the ranking that we want to calculate the Kendall tau distance on, and label the items sequentially, as the sequence 1, 2, 3, 4, 5, ...\nn\nn\n, where \nn\nn\n is the number of items.  We call this the \nbase\n ranking.  The other ranking will then be a permutation of the numbers 1 to \nn\nn\n.\n\n\nFor example, suppost we have three items A, B, C. the first ranking ranks the items as B, C, A.  The second ranking ranks the items C, A, B.  After relabelling the first ranking as 1, 2, 3, the second ranking becomes 2, 3, 1.\n\n\nThe Kendall tau distance counts the number of pairs of items in one ranking that are ranked in different order in the other ranking.  In the example above, we have three possible pairs:\n\n\n\n\n\n\n\n\nPair\n\n\nRanking 1\n\n\nRanking 2\n\n\n\n\n\n\n\n\n\n\nA-B\n\n\nB then A\n\n\nA then B\n\n\n\n\n\n\nA-C\n\n\nC then A\n\n\nC then A\n\n\n\n\n\n\nB-C\n\n\nB then C\n\n\nC then B\n\n\n\n\n\n\n\n\nOut of the three pairs, the pair A-B and B-C are ordered differently in the two rankings, so that Kendall tau distance is 2.\n\n\nThe normalized Kendall tau distance is the ratio of the number of pairs ranked in different order to all possible number of pairs.\n\n\nIn the example above, the \nnormalized\n Kendall distance is \u2154 = 0.6666.\n\n\nYour program should read the following from the standard input:\n\n\n\n\nThe first positive integer, \nn\nn\n, is the number of items (\nn > 1\nn > 1\n).\n\n\nThe next \nn\nn\n numbers is a permutation of integers between 1 to \nn\nn\n. This corresponds to the ranking of the items from 1 to \nn\nn\n.  \n\n\n\n\nYour program should print the normalized Kendall tau distance between the ranking read above and the base ranking (1, 2, 3, .. \nn\nn\n) to the standard output.\n\n\nSample Run\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\nooiwt@pe118:~/as03-skeleton$ ./kendall\n3\n2 3 1\n0.6667\nooiwt@pe118:~/as03-skeleton$ ./kendall\n10\n1 2 3 4 5 6 7 8 9 10\n0.0000\nooiwt@pe118:~/as03-skeleton$ ./kendall\n6\n6 5 4 3 2 1\n1.0000\n\n\n\n\n\n\nQuestion 2: Histogram (10 marks)\n\n\nIt is often useful to visualize the distribution of numerical data using a histogram.  In this question, you will write a program called \nhistogram\n that plots the histogram for real numbers ranged between 0 and 100 (inclusive). \n\n\nOur histogram will have 10 buckets, \nb_0, b_1, ... b_9\nb_0, b_1, ... b_9\n.  The bucket \nb_i\nb_i\n corresponds to the interval [\n10i, 10(i+1)\n10i, 10(i+1)\n) (includes \n10i\n10i\n, but excludes \n10(i+1)\n10(i+1)\n), \nexcept \nb_9\nb_9\n, which includes 100\n.  \n\n\nTo plot the histogram, we count how many percent of the data falls into each bucket.  Let the percentage of data that falls into bucket \nb_i\nb_i\n be \nk_i\nk_i\n%.  We set the length of each bar in histogram to be at most 10 characters, so we scale down \nk_i\nk_i\n by 10 to get the length \nl_i\nl_i\n.\n\n\nWe then draw on the screen using character \"\u2588\" and \"\u258c\", according to the following rules:\n\n\n\n\nIf \nl_i\nl_i\n is an integer, then we draw \"\u2588\" \nl_i\nl_i\n times.  \n\n\nOtherwise, if \nx < l_i \\le x + 0.5\nx < l_i \\le x + 0.5\n for some integer \nx\nx\n, then we draw \"\u2588\" \nx\nx\n times followed by a \"\u258c\".\n\n\nOtherwise, if \nx + 0.5 < l_i < x + 1\nx + 0.5 < l_i < x + 1\n for some integer \nx\nx\n, then we draw \"\u2588\" \nx+1\nx+1\n times.\n\n\n\n\nYour program should read the following from the standard input:\n\n\n\n\na positive integer \nn\nn\n, followed by\n\n\nn\nn\n real numbers, corresponding to data to plot the histogram with.\n\n\n\n\nYour program should print the axis and labels, as well as the bars for the histogram as shown in the same run.\nThe code to print both axis and labels are already given in the skeleton \nhistogram.c\n.  The string that corresponding to \"\u2588\" and \"\u258c\" are also given in the code, defined as \nBLOCK\n and \nHALF_BLOCK\n.\n\n\nSample Run\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\nooiwt@pe118:~/as03-skeleton$ ./histogram\n10\n25 35 35 45 45 45 45 55 55 65\n          \u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\n  0 - 10  \n 10 - 20  \n 20 - 30  \u2588\n 30 - 40  \u2588\u2588\n 40 - 50  \u2588\u2588\u2588\u2588\n 50 - 60  \u2588\u2588\n 60 - 70  \u2588\n 70 - 80  \n 80 - 90  \n 90 - 100 \nooiwt@pe118:~/as03-skeleton$ ./histogram\n1\n100\n          \u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\n  0 - 10\n 10 - 20\n 20 - 30\n 30 - 40\n 40 - 50\n 50 - 60\n 60 - 70\n 70 - 80\n 80 - 90\n 90 - 100 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\nooiwt@pe118:~/as03-skeleton$ ./histogram < inputs/histogram.5.in\n          \u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\n  0 - 10  \u258c\n 10 - 20  \u258c\n 20 - 30\n 30 - 40  \u258c\n 40 - 50\n 50 - 60  \u258c\n 60 - 70  \u2588\n 70 - 80  \u2588\u2588\n 80 - 90  \u2588\u2588\u2588\u2588\u2588\u258c\n 90 - 100 \u2588\u2588\n\n\n\n\n\n\nThe last histogram above plots the actual data from your Assignment 1 marks (scaled up 3x to have the range of 0 - 90).\n\n\nQuestion 3: CountingSort (10 marks)\n\n\nSorting is a fundamental computational problem: given a list of items, we want to rearrange the items in some order.\n\n\nIn this question, you will write you first sorting algorithm, called \ncounting sort\n.  This is an extremely fast algorithm for sorting positive integers if the range of the integers are limited.\n\n\nThe idea of counting sort is that, given the list of integers (each guranteed to be between 1 to \nk\nk\n) to sort, we count how many times 1 appear in the list, how many times 2 appears in the list, etc.  Finally, we print out each number between 1 to \nk\nk\n according to how many times they appear in the list, skipping those numbers who do not appear.\n\n\nFor instance, suppose we have 6 integers between 1 to 9: \n5 5 3 2 8 2\n.  We first count how many times each number appears.  Then we print the sorted list the following way: \n2\n appears twice, so we print \n\n1\n2\n2\n2\n\n\n\n\n\nThe number 3 appears once, we print\n\n1\n3\n\n\n\n\n\nThe number 5 appears twice, we print \n\n1\n2\n5\n5\n\n\n\n\n\nFinally 8 appears once, we print \n\n1\n8\n\n\n\n\n\nThe printed output is thus \n\n1\n2\n3\n4\n5\n6\n2\n2\n3\n5\n5\n8\n\n\n\n\n\nwhich is the numbers sorted in increasing order.  \n\n\nWrite a program \ncountingsort.c\n that reads the following in order from the standard input:\n\n\n\n\nn\nn\n the number of integers to sort\n\n\nk\nk\n the maximum value of the integers to sort\n\n\nThe next \nn\nn\n numbers are the integers to be sorted, each guaranteed to be between 1 and \nk\nk\n.\n\n\n\n\nSort the integers using the algorithms above and print them in increasing order to the standard output, one integer on each line.  Note that if you use any other algorithms to sort the numbers, you will be penalized heavily.\n\n\nInput Validation:\n For this question, you need to validate that the numbers are actually ranged between 1 and \nk\nk\n.  Any inputs that are not in this range must be omitted in the output.\n\n\nSample Run\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\nooiwt@pe118:~/as03-skeleton$ ./countingsort\n6 9 \n5 5 3 2 8 2\n2\n2\n3\n5\n5\n8\nooiwt@pe118:~/as03-skeleton$ ./countingsort\n3 1000 \n256 872 112\n112\n256\n872\nooiwt@pe118:~/as03-skeleton$ ./countingsort\n4 3\n3 2 -3 2\n2\n2\n3",
            "title": "3. Kendall, Histogram, CountingSort"
        },
        {
            "location": "/as03/index.html#assignment-3-kendall-histogram-countingsort",
            "text": "",
            "title": "Assignment 3: Kendall, Histogram, CountingSort"
        },
        {
            "location": "/as03/index.html#deadline",
            "text": "5 October, 2018 (Friday), 6:00pm.",
            "title": "Deadline"
        },
        {
            "location": "/as03/index.html#prerequisite",
            "text": "You are able to access the  CS1010 programming environment .  You are familiar with  basic UNIX CLI  and using terminal-based editor  vim .  You have gone through Exercise 1 and have already set up your  .gitconfig .  You are familiar with the steps of accepting, downloading, and submitting your exercise and assignment.  You are familiar with the directory structure and the common files included in your assignment skeleton.",
            "title": "Prerequisite"
        },
        {
            "location": "/as03/index.html#learning-outcomes",
            "text": "Be comfortable writing C programs that involve arithmetic operations,  long ,  double ,  bool , and  char  types, conditional  if / else  statements, loops with  while / for / do-while  statements, and arrays.  Be comfortable breaking down a problem into smaller subproblems which can be resolved using functions, including reusing existing functions written for other programs (with a tweak), writing a function that calls itself, designing what should the inputs and return values/types of a function be.",
            "title": "Learning Outcomes"
        },
        {
            "location": "/as03/index.html#setup",
            "text": "Click on this link  to accept the assignment.  Login to one of the hosts of  CS1010 programming environment  Run:   1 ~cs1010/get-as03    You should see the folder  as03-<github id>  in your home directory with the assignment skeleton inside.",
            "title": "Setup"
        },
        {
            "location": "/as03/index.html#solving-the-assignments",
            "text": "Edit the files  kandall.c ,  histogram.c ,  countingsort.c , to solve the corresponding question as described below.  You should break down the problem into smaller subproblems, and write one function for each of the subproblem to solve the problem.    To compile and run tests with the sample inputs and outputs:   1 make    The test cases are given in the  inputs  and  outputs  subdirectory.  You can use  cat  or  less  to look at the content of these test cases.  You can add more test cases or edit the given ones if needed.",
            "title": "Solving The Assignments"
        },
        {
            "location": "/as03/index.html#submission",
            "text": "When you are ready, run the following command to submit:  1 ~cs1010/submit-as03   The four files  kendall.c ,  histogram.c ,  countingsort.c , will be uploaded to GitHub.  You can submit multiple times, but only the last submission will be graded.   Editing Your Files in Multiple Locations  You should edit your code only on the CS1010 PE hosts.  If you choose to edit your code in other places, such as directly on Github or in a second location (such as your own laptop), you need to be comfortable with various  git  command to synchronize your code across the different locations, possibly needing to resolve synchronization conflicts.     Only the four C files listed above will be submitted.  You can create additional C files for testing different solutions, but eventually, you must put your solution into the corresponding C file provided as the skeleton.",
            "title": "Submission"
        },
        {
            "location": "/as03/index.html#identifying-yourself",
            "text": "In every C file that you submit to CS1010, you need to identify yourself by writing your name and tutorial group. Marks will be deducted if you fail to do so. You need to edit the line:  1 @author XXXX (Group YYYY)   and change it to something like:  1 @author Peter Parker (Group 9)",
            "title": "Identifying Yourself"
        },
        {
            "location": "/as03/index.html#grading",
            "text": "This assignment contributes towards 3% of your final grade.  The total mark for this assignment is 30 marks.  There are two marking criteria: correctness and style.    For each question, 2 marks are allocated for coding style.  Please refer to the  CS1010 C Style Guide  and follow the recommended guideline.  The rest of the marks are allocated to correctness.  Note that passing the tests does not guarantee that your code is correct.  Even if your code produces the correct output all the time, you may still lose marks if you do not write your code properly (e.g., using the most appropriate type, violating the constraints set by the question).  We reserve the right to penalize students for using banned C syntax in the assignments.  In addition, each grader at his or her own discretion can penalze students for repeating mistakes / bad practices from the student's past assignments (even if it was just a warning with no marks deducted in the earlier assignments).",
            "title": "Grading"
        },
        {
            "location": "/as03/index.html#question-1-kendall-10-marks",
            "text": "Suppose that we are given a set of items and we ask two different parties to rank the items according to some order.  We may get two different order of the items.  How do we measure how similar (or dissimilar) the two rankings are?  For example, consider a search engine that returns a list of web pages ranked by their relevance to the search query.  A user may not always agree with the ranking of the search engine and may judge the relevance of the search result differently, i.e., the user may have his or her own ranking.  This measurement of similarity between the ranking by the search engine and the ranking by the user gives us a metric on how good the search engine result is.  The more similar it is to the ranking of the user, the better the search engine is in ranking in the search results.  One way to measure the similarity of two rankings is the  Kendall tau distance .  You will write a program  kendall  that calculates the  normalized  Kendall tau distance for this question.  We will represent a ranking by the order of the items.  The first item is ranked 1, second is ranked 2, and so on.  To simplify the problem, we take one of the ranking that we want to calculate the Kendall tau distance on, and label the items sequentially, as the sequence 1, 2, 3, 4, 5, ... n n , where  n n  is the number of items.  We call this the  base  ranking.  The other ranking will then be a permutation of the numbers 1 to  n n .  For example, suppost we have three items A, B, C. the first ranking ranks the items as B, C, A.  The second ranking ranks the items C, A, B.  After relabelling the first ranking as 1, 2, 3, the second ranking becomes 2, 3, 1.  The Kendall tau distance counts the number of pairs of items in one ranking that are ranked in different order in the other ranking.  In the example above, we have three possible pairs:     Pair  Ranking 1  Ranking 2      A-B  B then A  A then B    A-C  C then A  C then A    B-C  B then C  C then B     Out of the three pairs, the pair A-B and B-C are ordered differently in the two rankings, so that Kendall tau distance is 2.  The normalized Kendall tau distance is the ratio of the number of pairs ranked in different order to all possible number of pairs.  In the example above, the  normalized  Kendall distance is \u2154 = 0.6666.  Your program should read the following from the standard input:   The first positive integer,  n n , is the number of items ( n > 1 n > 1 ).  The next  n n  numbers is a permutation of integers between 1 to  n n . This corresponds to the ranking of the items from 1 to  n n .     Your program should print the normalized Kendall tau distance between the ranking read above and the base ranking (1, 2, 3, ..  n n ) to the standard output.",
            "title": "Question 1: Kendall (10 marks)"
        },
        {
            "location": "/as03/index.html#sample-run",
            "text": "1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12 ooiwt@pe118:~/as03-skeleton$ ./kendall\n3\n2 3 1\n0.6667\nooiwt@pe118:~/as03-skeleton$ ./kendall\n10\n1 2 3 4 5 6 7 8 9 10\n0.0000\nooiwt@pe118:~/as03-skeleton$ ./kendall\n6\n6 5 4 3 2 1\n1.0000",
            "title": "Sample Run"
        },
        {
            "location": "/as03/index.html#question-2-histogram-10-marks",
            "text": "It is often useful to visualize the distribution of numerical data using a histogram.  In this question, you will write a program called  histogram  that plots the histogram for real numbers ranged between 0 and 100 (inclusive).   Our histogram will have 10 buckets,  b_0, b_1, ... b_9 b_0, b_1, ... b_9 .  The bucket  b_i b_i  corresponds to the interval [ 10i, 10(i+1) 10i, 10(i+1) ) (includes  10i 10i , but excludes  10(i+1) 10(i+1) ),  except  b_9 b_9 , which includes 100 .    To plot the histogram, we count how many percent of the data falls into each bucket.  Let the percentage of data that falls into bucket  b_i b_i  be  k_i k_i %.  We set the length of each bar in histogram to be at most 10 characters, so we scale down  k_i k_i  by 10 to get the length  l_i l_i .  We then draw on the screen using character \"\u2588\" and \"\u258c\", according to the following rules:   If  l_i l_i  is an integer, then we draw \"\u2588\"  l_i l_i  times.    Otherwise, if  x < l_i \\le x + 0.5 x < l_i \\le x + 0.5  for some integer  x x , then we draw \"\u2588\"  x x  times followed by a \"\u258c\".  Otherwise, if  x + 0.5 < l_i < x + 1 x + 0.5 < l_i < x + 1  for some integer  x x , then we draw \"\u2588\"  x+1 x+1  times.   Your program should read the following from the standard input:   a positive integer  n n , followed by  n n  real numbers, corresponding to data to plot the histogram with.   Your program should print the axis and labels, as well as the bars for the histogram as shown in the same run.\nThe code to print both axis and labels are already given in the skeleton  histogram.c .  The string that corresponding to \"\u2588\" and \"\u258c\" are also given in the code, defined as  BLOCK  and  HALF_BLOCK .",
            "title": "Question 2: Histogram (10 marks)"
        },
        {
            "location": "/as03/index.html#sample-run_1",
            "text": "1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40 ooiwt@pe118:~/as03-skeleton$ ./histogram\n10\n25 35 35 45 45 45 45 55 55 65\n          \u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\n  0 - 10  \n 10 - 20  \n 20 - 30  \u2588\n 30 - 40  \u2588\u2588\n 40 - 50  \u2588\u2588\u2588\u2588\n 50 - 60  \u2588\u2588\n 60 - 70  \u2588\n 70 - 80  \n 80 - 90  \n 90 - 100 \nooiwt@pe118:~/as03-skeleton$ ./histogram\n1\n100\n          \u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\n  0 - 10\n 10 - 20\n 20 - 30\n 30 - 40\n 40 - 50\n 50 - 60\n 60 - 70\n 70 - 80\n 80 - 90\n 90 - 100 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\nooiwt@pe118:~/as03-skeleton$ ./histogram < inputs/histogram.5.in\n          \u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\n  0 - 10  \u258c\n 10 - 20  \u258c\n 20 - 30\n 30 - 40  \u258c\n 40 - 50\n 50 - 60  \u258c\n 60 - 70  \u2588\n 70 - 80  \u2588\u2588\n 80 - 90  \u2588\u2588\u2588\u2588\u2588\u258c\n 90 - 100 \u2588\u2588   The last histogram above plots the actual data from your Assignment 1 marks (scaled up 3x to have the range of 0 - 90).",
            "title": "Sample Run"
        },
        {
            "location": "/as03/index.html#question-3-countingsort-10-marks",
            "text": "Sorting is a fundamental computational problem: given a list of items, we want to rearrange the items in some order.  In this question, you will write you first sorting algorithm, called  counting sort .  This is an extremely fast algorithm for sorting positive integers if the range of the integers are limited.  The idea of counting sort is that, given the list of integers (each guranteed to be between 1 to  k k ) to sort, we count how many times 1 appear in the list, how many times 2 appears in the list, etc.  Finally, we print out each number between 1 to  k k  according to how many times they appear in the list, skipping those numbers who do not appear.  For instance, suppose we have 6 integers between 1 to 9:  5 5 3 2 8 2 .  We first count how many times each number appears.  Then we print the sorted list the following way:  2  appears twice, so we print  1\n2 2\n2   The number 3 appears once, we print 1 3   The number 5 appears twice, we print  1\n2 5\n5   Finally 8 appears once, we print  1 8   The printed output is thus  1\n2\n3\n4\n5\n6 2\n2\n3\n5\n5\n8   which is the numbers sorted in increasing order.    Write a program  countingsort.c  that reads the following in order from the standard input:   n n  the number of integers to sort  k k  the maximum value of the integers to sort  The next  n n  numbers are the integers to be sorted, each guaranteed to be between 1 and  k k .   Sort the integers using the algorithms above and print them in increasing order to the standard output, one integer on each line.  Note that if you use any other algorithms to sort the numbers, you will be penalized heavily.  Input Validation:  For this question, you need to validate that the numbers are actually ranged between 1 and  k k .  Any inputs that are not in this range must be omitted in the output.",
            "title": "Question 3: CountingSort (10 marks)"
        },
        {
            "location": "/as03/index.html#sample-run_2",
            "text": "1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21 ooiwt@pe118:~/as03-skeleton$ ./countingsort\n6 9 \n5 5 3 2 8 2\n2\n2\n3\n5\n5\n8\nooiwt@pe118:~/as03-skeleton$ ./countingsort\n3 1000 \n256 872 112\n112\n256\n872\nooiwt@pe118:~/as03-skeleton$ ./countingsort\n4 3\n3 2 -3 2\n2\n2\n3",
            "title": "Sample Run"
        },
        {
            "location": "/as03-comments/index.html",
            "text": "Assignment 3: Comments\n\n\nMark Distribution\n\n\nThe output from \nhistogram\n.  Marks are scaled up by 3x.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n          \u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\n  0 - 10  \u258c\n 10 - 20  \u258c\n 20 - 30\n 30 - 40  \u258c\n 40 - 50  \u258c\n 50 - 60  \u258c\n 60 - 70  \u2588\n 70 - 80  \u2588\u2588\u2588\u2588\n 80 - 90  \u2588\u2588\u2588\n 90 - 100 \u2588\u2588\u258c\n\n\n\n\n\n\nNotes on Marking Schemes\n\n\n\n\nWe apply the penalty to each program independently, i.e., the same mistake repeated in the different program get penalized multiple times.  \n\n\n\n\nYou will receive 0 marks if your program cannot be compiled or is plagiarised from another.\n\n\n\n\n\n\nCode that fails all test cases and showing that student does not understand the basic concepts receives 0 marks straight away.\n\n\n\n\n\n\nFor the rest, we start with full marks and start deducting marks for each error.\n\n\n\n\n\n\nWhile the teaching team tries to ensure fair and consistent grading of assignments across all groups, each TA can, at his/her own discretion, and with the approval of Wei Tsang, adjust the grading criteria to align with the messages that they sent to the students in their tutorial group.\n\n\n\n\n\n\nStyle\n\n\nTwo marks are allocated for each question. We won't penalize for every violation, but instead, the grader judges whether the code is clean, understandable, properly indented, use proper variable names, etc. 0 - 0.5 marks for very bad style, 1.0 - 1.5 for something in the middle, 2 for an ok code. \n\n\nTo be safe, please follow strictly the CS1010 coding standards.\n\n\nGeneral Mistakes\n\n\nThis penalty applies once per program (not per occurrence).\n\n\n\n\n-1 for missing type in function declaration or definition\n\n\n-1 for using \nint\n/\nlong\n instead of \nbool\n for boolean functions or variables\n\n\n-1 for using \ndouble\n instead of \nlong\n when it is not necessary (does not involve integer division).  For instance, using \ndouble\n for \ninvest.c\n during calculation is ok, using \ndouble\n for calculating the area of the box is not.\n\n\n-1 for using of \nint\n instead of \nlong\n.  Using \nint\n for this assignment is ok only for \nday\n, \nhour\n, and \nminute\n, where there is an implicit constraint on the range of the value.\n\n\n-1 for failing to use parenthesis (e.g., \na && b || c\n)\n\n\n-1 for unnecessary/unused parameters passed into a function\n\n\n-1 for unnecessary/unused variables declared\n\n\n-1 for not including @author/@group\n\n\n-1 for global variables\n\n\n-1 for unreachable code / return\n\n\n-1 for using \n==\n to compare real numbers\n\n\n\n\nLogical Mistakes (bugs)\n\n\nIn general, -1 for each bug.\n\n\n\n\n-1 for each incorrect logical expression\n\n\n-1 for each incorrect arithmetic expression\n\n\n-1 for each incorrect use of \nif\n-\nelse\n\n\n-1 for each uninitialized variables causing incorrect output.\n\n\n-1 if program prints extra text / newline\n\n\n-1 if the program returns non-zero from \nmain\n even if the program exits successfully.\n\n\n\n\nNote: we didn't deduct marks for using VLA for this assignment, as you have not learned about \nmalloc\n/\ncalloc\n yet. \n\n\nAnswer Keys\n\n\nKendall\n\n\nWe need to count the total number of inversions in a given array.  I break this problem into two:\n\n\n\n\n\n\nGiven an element \na_i\na_i\n, how many elements are out of the order with respect to this element?   \n\n\n\n\n\n\nWe then sum up the total number of elements out of order, for each \na_i\na_i\n.  \n\n\n\n\n\n\nThis question should be quite straightforward, except that we need to consider the following:\n\n\n\n\n\n\nif the pair \na_i\na_i\n and \na_j\na_j\n are out of order, then we can count this pair as \none\n inversion only.  We need to fix a convention on how we account for inversion. I use convention that we count the inversion if \ni < j\ni < j\n and $a_i > \na_j\na_j\n.  In other words, for the subproblem 1 above, we only need to check for inversions for each element \na_j\na_j\n, if \nj > i\nj > i\n.\n\n\n\n\n\n\na_i\na_i\n shouldn't be the last element since there is no \nj\nj\n that is bigger than \ni\ni\n.\n\n\n\n\n\n\nSlightly more \u2158 of the class get this question correct, with full marks.  Well done!\n\n\n(The snippet for this program can be found in \nUnit 22\n on efficiency).\n\n\nHistogram\n\n\nTo solve this problem, we should break the problem into two steps.  First, we go through the data and count the number of items in each basket.  This can be done with the following snippet.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n#define NUM_OF_BUCKETS 10\n\n\n#define MAX_SCORE 100\n\n \n:\n\n\n/**\n\n\n * Populate the buckets of the histogram based on the input array marks, containing\n\n\n * num_of_items items.\n\n\n *\n\n\n * @param[in] histogram Counters to store how many items fall into each bucket.\n\n\n * @param[in] num_of_items The number of input marks to sort into the buckets.\n\n\n * @param[in] marks An array of marks to be sorted into the buckets.\n\n\n */\n\n\nvoid\n \npopulate_histogram\n(\nlong\n \nhistogram\n[\nNUM_OF_BUCKETS\n],\n \nint\n \nnum_of_items\n,\n \nconst\n \ndouble\n \nmarks\n[\nnum_of_items\n])\n\n\n{\n\n  \ndouble\n \ninterval\n \n=\n \nMAX_SCORE\n/\n(\nNUM_OF_BUCKETS\n*\n1.0\n);\n\n  \nfor\n \n(\nlong\n \ni\n \n=\n \n0\n;\n \ni\n \n<\n \nnum_of_items\n;\n \ni\n \n+=\n \n1\n)\n \n{\n\n    \nlong\n \nbucket\n \n=\n \nmarks\n[\ni\n]\n/\ninterval\n;\n\n    \nif\n \n(\nbucket\n \n==\n \nNUM_OF_BUCKETS\n)\n \n{\n\n      \nbucket\n \n-=\n \n1\n;\n\n    \n}\n\n\n    \nhistogram\n[\nbucket\n]\n \n+=\n \n1\n;\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\nThe only tricky part of this code is what happens if \nmarks[i]\n is 100, in which case, \nmarks[i]/interval\n would lead to \nbucket\n being \n10\n.  Since the indices to the buckets are \nhistogram[0]\n,..., \nhistogram[9]\n only, we would be writing into a memory location that we do not own if we increment \nhistogram[10]\n.  For this question, we were told that 100 belongs to \nb_9\nb_9\n.  So, we need to decrement the variable \nbucket\n by 1.\n\n\nSecond, after populating the buckets, we need to draw out the histogram:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n#define BAR_LENGTH 10.0\n\n   \n:\n\n  \ndouble\n \nheight\n[\nNUM_OF_BUCKETS\n];\n\n  \nfor\n \n(\nlong\n \ni\n \n=\n \n0\n;\n \ni\n \n<\n \nNUM_OF_BUCKETS\n;\n \ni\n \n+=\n \n1\n)\n \n{\n\n    \ncs1010_print_string\n(\naxis_labels\n[\ni\n]);\n\n\n    \nheight\n[\ni\n]\n \n=\n \nBAR_LENGTH\n*\nhistogram\n[\ni\n]\n/\nnum_of_items\n;\n\n\n    \n// Print full blocks\n\n    \nlong\n \nnum_of_cells\n \n=\n \nfloor\n(\nheight\n[\ni\n]);\n\n    \nfor\n \n(\nlong\n \nj\n \n=\n \n0\n;\n \nj\n \n<\n \nnum_of_cells\n;\n \nj\n \n+=\n \n1\n)\n \n{\n\n      \ncs1010_print_string\n(\nBLOCK\n);\n\n    \n}\n\n\n    \n// Print final half-block, block or no block if height is integer\n\n    \ndouble\n \ndelta\n \n=\n \nheight\n[\ni\n]\n \n-\n \nfloor\n(\nheight\n[\ni\n]);\n\n\n    \nif\n \n(\ndelta\n \n>\n \n0.5\n)\n \n{\n\n      \ncs1010_print_string\n(\nBLOCK\n);\n\n    \n}\n \nelse\n \nif\n \n(\ndelta\n \n>\n \n0\n)\n \n{\n\n      \ncs1010_print_string\n(\nHALF_BLOCK\n);\n\n    \n}\n\n\n    \ncs1010_println_string\n(\n\"\"\n);\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\nThe purpose of this question to see how arrays can be used as a list (the input marks) and a lookup table (for histogram frequency, height, and y-axis).\n\n\nThis should be quite straightforward.  At least \u2158 of the class received 9 marks or above for this.  Well done!  \n\n\nThere are some students, however, who tried to compare \ndouble\n variable using \n==\n operator and got deducted one mark for it.  Revisit \nUnit 08\n if you have doubts about why we should never compare \ndouble\n variable using \n==\n.\n\n\nAnother common mistake that students make, at least at the beginning of doing this assignment, is to use \ncs1010_read_long()\n to read a \ndouble\n.  The function \ncs1010_read_long()\n gives a warning if it is used to read a \ndouble\n value.  This is one of the advantages of using the CS1010 library to read instead of the \nscanf\n functions.  \nscanf\n would just silently failed and you would be left scratching your head why your code does not work!\n\n\nCounting Sort\n\n\nThis is the assignment question that most students are having trouble with.\n\n\nStudents who do not follow the instructions and use any other sorting algorithm (e.g., bubble sort) will receive 0 for correctness.\n\n\nStudents who just loop through the array and prints out all the numbers, without counting, will get at most 2 marks for correctness.  The question clearly asked you to count.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n// A 2 mark solution\n\n\nfor\n \n(\nint\n \ni\n \n=\n \n1\n;\n \ni\n \n<=\n \nk\n;\n \ni\n \n+=\n \n1\n)\n \n{\n\n  \nfor\n \n(\nint\n \nj\n \n=\n \n0\n;\n \nj\n \n<\n \nn\n;\n \nj\n \n+=\n \n1\n)\n \n{\n\n    \nif\n \n(\na\n[\nj\n]\n \n==\n \ni\n)\n \n{\n\n      \ncs1010_println_long\n(\ni\n);\n\n    \n}\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\nStudents who just loop through the array and count, but goes through it multiple times to store the frequency of each number, will get at most 4 marks for correctness.  Here, you are not exploiting array properly to help you solve the problem!\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n// A 4 mark solution\n\n\nlong\n \ncounter\n[\nk\n+\n1\n]\n \n=\n \n{\n0\n};\n\n\n\nfor\n \n(\nint\n \ni\n \n=\n \n1\n;\n \ni\n \n<=\n \nk\n;\n \ni\n \n+=\n \n1\n)\n \n{\n\n  \nfor\n \n(\nint\n \nj\n \n=\n \n0\n;\n \nj\n \n<\n \nn\n;\n \nj\n \n+=\n \n1\n)\n \n{\n\n    \nif\n \n(\na\n[\nj\n]\n \n==\n \ni\n)\n \n{\n\n      \ncounter\n[\ni\n]\n \n+=\n \n1\n;\n\n    \n}\n\n  \n}\n\n\n}\n\n\n\nfor\n \n(\nint\n \ni\n \n=\n \n1\n;\n \ni\n \n<=\n \nk\n;\n \ni\n \n+=\n \n1\n)\n \n{\n\n  \nfor\n \n(\nint\n \nj\n \n=\n \n0\n;\n \nj\n \n<\n \ncounter\n[\ni\n];\n \nj\n \n+=\n \n1\n)\n \n{\n\n    \ncs1010_println_long\n(\ni\n);\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\nIn the code above, the \ncounter\n array is useless, since we could have just use a simple counter variable (instead of an array) to achieve the same thing!\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n// A 4 mark solution\n\n\nfor\n \n(\nint\n \ni\n \n=\n \n1\n;\n \ni\n \n<=\n \nk\n;\n \ni\n \n+=\n \n1\n)\n \n{\n\n  \nlong\n \ncounter\n \n=\n \n0\n;\n\n  \nfor\n \n(\nint\n \nj\n \n=\n \n0\n;\n \nj\n \n<\n \nn\n;\n \nj\n \n+=\n \n1\n)\n \n{\n\n    \nif\n \n(\na\n[\nj\n]\n \n==\n \ni\n)\n \n{\n\n      \ncounter\n \n+=\n \n1\n;\n\n    \n}\n\n  \n}\n\n  \nfor\n \n(\nint\n \nj\n \n=\n \n0\n;\n \nj\n \n<\n \ncounter\n;\n \nj\n \n+=\n \n1\n)\n \n{\n\n    \ncs1010_println_long\n(\ni\n);\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\nWhat we are looking for, and the \"mental leap\" that we want to see in the students, is how we can use an array as a lookup table to store the frequency counters.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n// An 8 mark solution\n\n\nlong\n \ncounter\n[\nk\n+\n1\n]\n \n=\n \n{\n0\n};\n\n\n\nfor\n \n(\nint\n \nj\n \n=\n \n0\n;\n \nj\n \n<\n \nn\n;\n \nj\n \n+=\n \n1\n)\n \n{\n\n  \ncounter\n[\na\n[\nj\n]]\n \n+=\n \n1\n;\n\n\n}\n\n\n\nfor\n \n(\nint\n \ni\n \n=\n \n1\n;\n \ni\n \n<=\n \nk\n;\n \ni\n \n+=\n \n1\n)\n \n{\n\n  \nfor\n \n(\nint\n \nj\n \n=\n \n0\n;\n \nj\n \n<\n \ncounter\n[\ni\n];\n \nj\n \n+=\n \n1\n)\n \n{\n\n    \ncs1010_println_long\n(\ni\n);\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\nOnly about half the class get this.  But hopefully, after this assignment, everyone gets how powerful a lookup table is as a problem-solving tool.\n\n\nA final comment about the loop:\n\n\n1\n2\n3\nfor\n \n(\nint\n \nj\n \n=\n \n0\n;\n \nj\n \n<\n \nn\n;\n \nj\n \n+=\n \n1\n)\n \n{\n\n  \ncounter\n[\na\n[\nj\n]]\n \n+=\n \n1\n;\n\n\n}\n\n\n\n\n\n\n\nWe should not actually write code that looks like this unless we can be sure that \na[j]\n is within range of 1 and \nk\nk\n.  There is a reason that we ask you to validate the input for this question, but not for any other questions.  Because, for this question, if you do not validate the input, it is very easy to access a location that is out-of-bounds of your array and crash your program.\n\n\n1\n2\n3\n4\n5\nfor\n \n(\nint\n \nj\n \n=\n \n0\n;\n \nj\n \n<\n \nn\n;\n \nj\n \n+=\n \n1\n)\n \n{\n\n  \nif\n \n(\na\n[\nj\n]\n \n>=\n \n1\n \n&&\n \na\n[\nj\n]\n \n<=\n \nk\n)\n \n{\n\n    \ncounter\n[\na\n[\nj\n]]\n \n+=\n \n1\n;\n\n  \n}\n\n\n}",
            "title": "3. Comments and Answer Keys"
        },
        {
            "location": "/as03-comments/index.html#assignment-3-comments",
            "text": "",
            "title": "Assignment 3: Comments"
        },
        {
            "location": "/as03-comments/index.html#mark-distribution",
            "text": "The output from  histogram .  Marks are scaled up by 3x.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11           \u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\n  0 - 10  \u258c\n 10 - 20  \u258c\n 20 - 30\n 30 - 40  \u258c\n 40 - 50  \u258c\n 50 - 60  \u258c\n 60 - 70  \u2588\n 70 - 80  \u2588\u2588\u2588\u2588\n 80 - 90  \u2588\u2588\u2588\n 90 - 100 \u2588\u2588\u258c",
            "title": "Mark Distribution"
        },
        {
            "location": "/as03-comments/index.html#notes-on-marking-schemes",
            "text": "We apply the penalty to each program independently, i.e., the same mistake repeated in the different program get penalized multiple times.     You will receive 0 marks if your program cannot be compiled or is plagiarised from another.    Code that fails all test cases and showing that student does not understand the basic concepts receives 0 marks straight away.    For the rest, we start with full marks and start deducting marks for each error.    While the teaching team tries to ensure fair and consistent grading of assignments across all groups, each TA can, at his/her own discretion, and with the approval of Wei Tsang, adjust the grading criteria to align with the messages that they sent to the students in their tutorial group.",
            "title": "Notes on Marking Schemes"
        },
        {
            "location": "/as03-comments/index.html#style",
            "text": "Two marks are allocated for each question. We won't penalize for every violation, but instead, the grader judges whether the code is clean, understandable, properly indented, use proper variable names, etc. 0 - 0.5 marks for very bad style, 1.0 - 1.5 for something in the middle, 2 for an ok code.   To be safe, please follow strictly the CS1010 coding standards.",
            "title": "Style"
        },
        {
            "location": "/as03-comments/index.html#general-mistakes",
            "text": "This penalty applies once per program (not per occurrence).   -1 for missing type in function declaration or definition  -1 for using  int / long  instead of  bool  for boolean functions or variables  -1 for using  double  instead of  long  when it is not necessary (does not involve integer division).  For instance, using  double  for  invest.c  during calculation is ok, using  double  for calculating the area of the box is not.  -1 for using of  int  instead of  long .  Using  int  for this assignment is ok only for  day ,  hour , and  minute , where there is an implicit constraint on the range of the value.  -1 for failing to use parenthesis (e.g.,  a && b || c )  -1 for unnecessary/unused parameters passed into a function  -1 for unnecessary/unused variables declared  -1 for not including @author/@group  -1 for global variables  -1 for unreachable code / return  -1 for using  ==  to compare real numbers",
            "title": "General Mistakes"
        },
        {
            "location": "/as03-comments/index.html#logical-mistakes-bugs",
            "text": "In general, -1 for each bug.   -1 for each incorrect logical expression  -1 for each incorrect arithmetic expression  -1 for each incorrect use of  if - else  -1 for each uninitialized variables causing incorrect output.  -1 if program prints extra text / newline  -1 if the program returns non-zero from  main  even if the program exits successfully.   Note: we didn't deduct marks for using VLA for this assignment, as you have not learned about  malloc / calloc  yet.",
            "title": "Logical Mistakes (bugs)"
        },
        {
            "location": "/as03-comments/index.html#answer-keys",
            "text": "",
            "title": "Answer Keys"
        },
        {
            "location": "/as03-comments/index.html#kendall",
            "text": "We need to count the total number of inversions in a given array.  I break this problem into two:    Given an element  a_i a_i , how many elements are out of the order with respect to this element?       We then sum up the total number of elements out of order, for each  a_i a_i .      This question should be quite straightforward, except that we need to consider the following:    if the pair  a_i a_i  and  a_j a_j  are out of order, then we can count this pair as  one  inversion only.  We need to fix a convention on how we account for inversion. I use convention that we count the inversion if  i < j i < j  and $a_i >  a_j a_j .  In other words, for the subproblem 1 above, we only need to check for inversions for each element  a_j a_j , if  j > i j > i .    a_i a_i  shouldn't be the last element since there is no  j j  that is bigger than  i i .    Slightly more \u2158 of the class get this question correct, with full marks.  Well done!  (The snippet for this program can be found in  Unit 22  on efficiency).",
            "title": "Kendall"
        },
        {
            "location": "/as03-comments/index.html#histogram",
            "text": "To solve this problem, we should break the problem into two steps.  First, we go through the data and count the number of items in each basket.  This can be done with the following snippet.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23 #define NUM_OF_BUCKETS 10  #define MAX_SCORE 100 \n  :  /**   * Populate the buckets of the histogram based on the input array marks, containing   * num_of_items items.   *   * @param[in] histogram Counters to store how many items fall into each bucket.   * @param[in] num_of_items The number of input marks to sort into the buckets.   * @param[in] marks An array of marks to be sorted into the buckets.   */  void   populate_histogram ( long   histogram [ NUM_OF_BUCKETS ],   int   num_of_items ,   const   double   marks [ num_of_items ])  { \n   double   interval   =   MAX_SCORE / ( NUM_OF_BUCKETS * 1.0 ); \n   for   ( long   i   =   0 ;   i   <   num_of_items ;   i   +=   1 )   { \n     long   bucket   =   marks [ i ] / interval ; \n     if   ( bucket   ==   NUM_OF_BUCKETS )   { \n       bucket   -=   1 ; \n     } \n\n     histogram [ bucket ]   +=   1 ; \n   }  }    The only tricky part of this code is what happens if  marks[i]  is 100, in which case,  marks[i]/interval  would lead to  bucket  being  10 .  Since the indices to the buckets are  histogram[0] ,...,  histogram[9]  only, we would be writing into a memory location that we do not own if we increment  histogram[10] .  For this question, we were told that 100 belongs to  b_9 b_9 .  So, we need to decrement the variable  bucket  by 1.  Second, after populating the buckets, we need to draw out the histogram:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26 #define BAR_LENGTH 10.0 \n    : \n   double   height [ NUM_OF_BUCKETS ]; \n   for   ( long   i   =   0 ;   i   <   NUM_OF_BUCKETS ;   i   +=   1 )   { \n     cs1010_print_string ( axis_labels [ i ]); \n\n     height [ i ]   =   BAR_LENGTH * histogram [ i ] / num_of_items ; \n\n     // Print full blocks \n     long   num_of_cells   =   floor ( height [ i ]); \n     for   ( long   j   =   0 ;   j   <   num_of_cells ;   j   +=   1 )   { \n       cs1010_print_string ( BLOCK ); \n     } \n\n     // Print final half-block, block or no block if height is integer \n     double   delta   =   height [ i ]   -   floor ( height [ i ]); \n\n     if   ( delta   >   0.5 )   { \n       cs1010_print_string ( BLOCK ); \n     }   else   if   ( delta   >   0 )   { \n       cs1010_print_string ( HALF_BLOCK ); \n     } \n\n     cs1010_println_string ( \"\" ); \n   }  }    The purpose of this question to see how arrays can be used as a list (the input marks) and a lookup table (for histogram frequency, height, and y-axis).  This should be quite straightforward.  At least \u2158 of the class received 9 marks or above for this.  Well done!    There are some students, however, who tried to compare  double  variable using  ==  operator and got deducted one mark for it.  Revisit  Unit 08  if you have doubts about why we should never compare  double  variable using  == .  Another common mistake that students make, at least at the beginning of doing this assignment, is to use  cs1010_read_long()  to read a  double .  The function  cs1010_read_long()  gives a warning if it is used to read a  double  value.  This is one of the advantages of using the CS1010 library to read instead of the  scanf  functions.   scanf  would just silently failed and you would be left scratching your head why your code does not work!",
            "title": "Histogram"
        },
        {
            "location": "/as03-comments/index.html#counting-sort",
            "text": "This is the assignment question that most students are having trouble with.  Students who do not follow the instructions and use any other sorting algorithm (e.g., bubble sort) will receive 0 for correctness.  Students who just loop through the array and prints out all the numbers, without counting, will get at most 2 marks for correctness.  The question clearly asked you to count.  1\n2\n3\n4\n5\n6\n7\n8 // A 2 mark solution  for   ( int   i   =   1 ;   i   <=   k ;   i   +=   1 )   { \n   for   ( int   j   =   0 ;   j   <   n ;   j   +=   1 )   { \n     if   ( a [ j ]   ==   i )   { \n       cs1010_println_long ( i ); \n     } \n   }  }    Students who just loop through the array and count, but goes through it multiple times to store the frequency of each number, will get at most 4 marks for correctness.  Here, you are not exploiting array properly to help you solve the problem!   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16 // A 4 mark solution  long   counter [ k + 1 ]   =   { 0 };  for   ( int   i   =   1 ;   i   <=   k ;   i   +=   1 )   { \n   for   ( int   j   =   0 ;   j   <   n ;   j   +=   1 )   { \n     if   ( a [ j ]   ==   i )   { \n       counter [ i ]   +=   1 ; \n     } \n   }  }  for   ( int   i   =   1 ;   i   <=   k ;   i   +=   1 )   { \n   for   ( int   j   =   0 ;   j   <   counter [ i ];   j   +=   1 )   { \n     cs1010_println_long ( i ); \n   }  }    In the code above, the  counter  array is useless, since we could have just use a simple counter variable (instead of an array) to achieve the same thing!   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12 // A 4 mark solution  for   ( int   i   =   1 ;   i   <=   k ;   i   +=   1 )   { \n   long   counter   =   0 ; \n   for   ( int   j   =   0 ;   j   <   n ;   j   +=   1 )   { \n     if   ( a [ j ]   ==   i )   { \n       counter   +=   1 ; \n     } \n   } \n   for   ( int   j   =   0 ;   j   <   counter ;   j   +=   1 )   { \n     cs1010_println_long ( i ); \n   }  }    What we are looking for, and the \"mental leap\" that we want to see in the students, is how we can use an array as a lookup table to store the frequency counters.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12 // An 8 mark solution  long   counter [ k + 1 ]   =   { 0 };  for   ( int   j   =   0 ;   j   <   n ;   j   +=   1 )   { \n   counter [ a [ j ]]   +=   1 ;  }  for   ( int   i   =   1 ;   i   <=   k ;   i   +=   1 )   { \n   for   ( int   j   =   0 ;   j   <   counter [ i ];   j   +=   1 )   { \n     cs1010_println_long ( i ); \n   }  }    Only about half the class get this.  But hopefully, after this assignment, everyone gets how powerful a lookup table is as a problem-solving tool.  A final comment about the loop:  1\n2\n3 for   ( int   j   =   0 ;   j   <   n ;   j   +=   1 )   { \n   counter [ a [ j ]]   +=   1 ;  }    We should not actually write code that looks like this unless we can be sure that  a[j]  is within range of 1 and  k k .  There is a reason that we ask you to validate the input for this question, but not for any other questions.  Because, for this question, if you do not validate the input, it is very easy to access a location that is out-of-bounds of your array and crash your program.  1\n2\n3\n4\n5 for   ( int   j   =   0 ;   j   <   n ;   j   +=   1 )   { \n   if   ( a [ j ]   >=   1   &&   a [ j ]   <=   k )   { \n     counter [ a [ j ]]   +=   1 ; \n   }  }",
            "title": "Counting Sort"
        },
        {
            "location": "/as04/index.html",
            "text": "Assignment 4: SelectionSort, Add, Mastermind\n\n\nDeadline\n\n\n12 October, 2018 (Friday), 6:00pm.\n\n\nPrerequisite\n\n\n\n\nYou are able to access the \nCS1010 programming environment\n.\n\n\nYou are familiar with \nbasic UNIX CLI\n and using terminal-based editor \nvim\n.\n\n\nYou have gone through Exercise 1 and have already set up your \n.gitconfig\n.\n\n\nYou are familiar with the steps of accepting, downloading, and submitting your exercise and assignment.\n\n\nYou are familiar with the directory structure and the common files included in your assignment skeleton.\n\n\n\n\nLearning Outcomes\n\n\n\n\nBe comfortable writing C programs that involve arithmetic operations, \nlong\n, \ndouble\n, \nbool\n, and \nchar\n types, conditional \nif\n/\nelse\n statements, loops with \nwhile\n/\nfor\n/\ndo-while\n statements, arrays, and strings.\n\n\nBe comfortable breaking down a problem into smaller subproblems which can be resolved using functions, including reusing existing functions written for other programs (with a tweak), writing a function that calls itself, designing what should the inputs and return values/types of a function be.\n\n\n\n\nSetup\n\n\n\n\nClick on this link\n to accept the assignment.\n\n\nLogin to one of the hosts of \nCS1010 programming environment\n\n\nRun:\n\n\n\n\n1\n~cs1010/get-as04\n\n\n\n\n\n\n\n\nYou should see the folder \nas04-<github id>\n in your home directory with the assignment skeleton inside.\n\n\n\n\nSolving The Assignments\n\n\n\n\nEdit the files \nselectionsort.c\n, \nadd.c\n, \nmastermind.c\n, to solve the corresponding question as described below.\n\n\nYou should break down the problem into smaller subproblems, and write one function for each of the subproblem to solve the problem.  \n\n\nTo compile and run tests with the sample inputs and outputs:\n\n\n\n\n1\nmake\n\n\n\n\n\n\n\n\nThe test cases are given in the \ninputs\n and \noutputs\n subdirectory.  You can use \ncat\n or \nless\n to look at the content of these test cases.  You can add more test cases or edit the given ones if needed.\n\n\n\n\nSubmission\n\n\nWhen you are ready, run the following command to submit:\n\n\n1\n~cs1010/submit-as04\n\n\n\n\n\n\nThe files \nselectionsort.c\n, \nadd.c\n, \nmastermind.c\n, will be uploaded to GitHub.  You can submit multiple times, but only the last submission will be graded.\n\n\n\n\nEditing Your Files in Multiple Locations\n\n\nYou should edit your code only on the CS1010 PE hosts.  If you choose to edit your code in other places, such as directly on Github or in a second location (such as your own laptop), you need to be comfortable with various \ngit\n command to synchronize your code across the different locations, possibly needing to resolve synchronization conflicts.  \n\n\n\n\nOnly the C files listed above will be submitted.  You can create additional C files for testing different solutions, but eventually, you must put your solution into the corresponding C file provided as the skeleton.\n\n\nIdentifying Yourself\n\n\nIn every C file that you submit to CS1010, you need to identify yourself by writing your name and tutorial group. Marks will be deducted if you fail to do so. You need to edit the line:\n\n\n1\n@author XXXX (Group YYYY)\n\n\n\n\n\n\nand change it to something like:\n\n\n1\n@author Jean Luc Picard (Group 9)\n\n\n\n\n\n\nGrading\n\n\nThis assignment contributes towards 4% of your final grade.  The total mark for this assignment is 40 marks.  There are three marking criteria: correctness, documentation, and style.  \n\n\n\n\nDocumentation: For each question, two marks are allocated for documentation.  Please refer to the \ndocumentation\n and follow the recommended format.  You need to explain the purpose of every file, function, and parameter.  Logic in your code that is not obvious should be explained as well.\n\n\nStyle: For each question, two marks are allocated for style.  Please refer to the \nCS1010 C Style Guide\n and follow the recommended guideline.  \n\n\nCorrectness: The rest of the marks are allocated to correctness.  Note that passing the tests does not guarantee that your code is correct.  Correctness here is defined in the broad sense of using the various programming constructs in C (type, function, variable, loops, conditionals, arithmetic expressions, logical expressions) \nproperly\n, not just producing the correct output and bug-free.  \n\n\n\n\nWe reserve the right to penalize students for using banned C syntax in the assignments.  In addition, each grader at his or her own discretion can penalize students for repeating mistakes / bad practices from the student's past assignments (even if it was just a warning with no marks deducted in the earlier assignments).\n\n\nQuestion 1: SelectionSort (10 marks)\n\n\nYou have implemented counting sort, a simple and fast sorting algorithm that works on integers with limited range.  But if the range of possible values to be sorted is huge or unlimited, then, counting sort does not work so well, and we need a different kind of sorting algorithm.\n\n\nIn this question, you are asked to implement selection sort.  The idea behind selection sort is simple, and we will illustrate with the sequence \n15 23 16 4 42 8\n.  To sort an array with \nn\nn\n values in increasing order, selection sort first finds the maximum value, then moves it into its proper place, that is, the last position.  This move is achieved by swapping the value currently in the last position with the maximum value.  For instance,\nfor \n15 23 16 4 42 8\n, \n42\n is the maximum value and \n8\n wrongly occupies the position reserved for the maximum value.  After the first step, the array becomes \n15 23 16 4 8 42\n.\n\n\nWe now focus on sorting the first \nn-1\nn-1\n values in the array (since the maximum is in place).  To do this, we find the second largest value, and move it to the second last position.  The array becomes \n15 8 16 4 23 48\n after this second step.\n\n\nThe algorithm continues, moving the third largest value into place, the fourth largest value into place, etc., until the array is sorted.  The table below shows the evolution of the array.\n\n\n\n\n\n\n\n\nStep\n\n\nArray\n\n\nRemarks\n\n\n\n\n\n\n\n\n\n\n0\n\n\n15 23 16 4 42 8\n\n\nInput Array\n\n\n\n\n\n\n1\n\n\n15 23 16 4  8 42\n\n\nSwap 42 and 8\n\n\n\n\n\n\n2\n\n\n15 8 16 4  23 42\n\n\nSwap 23 and 8\n\n\n\n\n\n\n3\n\n\n15 8 4 16 23 42\n\n\nSwap 16 and 4\n\n\n\n\n\n\n4\n\n\n4 8 15 16 23 42\n\n\nSwap 15 and 4\n\n\n\n\n\n\n5\n\n\n4 8 15 16 23 42\n\n\n8 happens to already be in position\n\n\n\n\n\n\n6\n\n\n4 8 15 16 23 42\n\n\n4 must already be in position\n\n\n\n\n\n\n\n\nWrite a program \nselectionsort\n that, reads the following, from the standard input,\n\n\n\n\nn\nn\n, the number of integers to sort\n\n\nfollowed by \nn\nn\n integers\n\n\n\n\ninto an array, and prints, to the standard output, \nn - 1\nn - 1\n lines, each line showing the array after moving the largest or the next largest element into position.\n\n\nYou can assume that the input list of \nn\nn\n integers to be sorted are unique -- i.e., no repetition.\n\n\nSample Run\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\nooiwt@pe119:~/as04-skeleton$ ./selectionsort\n6 15 23 16 4 42 8\n15 23 16 4 8 42\n15 8 16 4 23 42\n15 8 4 16 23 42\n4 8 15 16 23 42\n4 8 15 16 23 42\nooiwt@pe119:~/as04-skeleton$ ./selectionsort\n3 0 4 8\n0 4 8\n0 4 8\nooiwt@pe119:~/as04-skeleton$ ./selectionsort\n5 1 3 5 4 2\n1 3 2 4 5\n1 3 2 4 5\n1 2 3 4 5\n1 2 3 4 5\n\n\n\n\n\n\nQuestion 2: Add (15 marks)\n\n\nIn this question, you are asked to write a program that adds two \nnon-negative\n numbers which can be arbitrarily large.  The types provided by C can only represent a number up to a certain value.  We have seen that \nlong long int\n is not even big enough to represent 21!.  \n\n\nFor this question, we will represent a number using an arbitrarily long string consisting of characters (of type \nchar\n) \n'0'\n to \n'9'\n (note: not integer 0 to 9).  C supports arithmetic operations on \nchar\n values as well.  To convert between the numerical value of a digit character, we can do the following:\n\n\n\n\nTo convert from a digit character to its numerical value, we subtract the \nchar\n \n'0'\n.  For instance, \n'6' - '0'\n will give us the value \n6\n.\n\n\nTo convert from a numerical value of a digit to its character, we add the \nchar\n \n'0'\n.  For instance, \n6 + '0'\n will give us the character \n'6'\n.\n\n\n\n\nYou can read a sequence of non-space characters from the standard input using \ncs1010_read_word\n, and print a sequence of characters (i.e., a string) to the standard output using \ncs1010_println_string\n.\n\n\nWrite a program \nadd\n that reads from the standard input two \nnon-negative\n numbers represented as strings consisting of digits '0' to '9', and prints to the standard output the sum of the two numbers.\n\n\nYou will likely need to use the C standard library function \nstrlen\n, which returns you the number of characters in a string (excluding the terminating '\\0').  Look up on how to use this function on your own.\n\n\nSample Run\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\nooiwt@pe119:~/as04-skeleton$ ./add\n1\n1\n2\nooiwt@pe119:~/as04-skeleton$ ./add\n7\n8\n15\nooiwt@pe119:~/as04-skeleton$ ./add\n999999\n1\n1000000\nooiwt@pe119:~/as04-skeleton$ ./add\n1400060514000605140006051400605\n19330911933091193309119330911933091\n19332311993605193914259336963333696\n\n\n\n\n\n\nQuestion 3: Mastermind (15 marks)\n\n\n\n\nPhoto by \nfl\u00f6schen\n, \nsome right reserved\n\n\nMastermind is a board game played by two players, a \ncoder\n and a \ncodebreaker\n.  The coder creates a code consists of four color pegs, chosen from pegs of six different colors (cyan, green, red, blue, purple, orange).  Repetition of the same colors is allowed.  The codebreaker's task is to guess the colors of the pegs and the order their appears in the code.\n\n\nThe game proceeds in rounds.  In each round, the codebreaker tries to guess the code by specifying the colors and the order of the colors.  The coder then provides feedback to the codebreaker, with two smaller pegs of black and white color.  A black color peg is placed if the codebreaker guesses correctly a peg in both position and color.  A white color peg is placed if the codebreaker guesses correctly a peg in color but not in the position.  Based on the feedback, the codebreaker guesses again in the next round.  In the actual board game, the codebreaker wins if he guesses correctly every color in the correct order.  The coder wins if the codebreaker failed to guess correctly after 8 guesses.\n\n\nWrite a program called \nmastermind\n that simulates the Mastermind game.  The program first reads in the code from the standard inputs.  We denote the colors with their initials, \nc\n, \ng\n, \nr\n, \nb\n, \np\n, \no\n.  Hence, the code is a 4-letter word.  For instance, the code \nprob\n corresponds the pegs purple, red, orange, blue, in that order.  It then reads in a sequence of guesses, each is a 4-letter word consists of the letter \nc\n, \ng\n, \nr\n, \nb\n, \np\n, \no\n.  For each guess, the program prints out two numbers, the first is the number of pegs that are correct in both position and color.  The second, is the number of pegs that are correct in color but not position.  Note that we do not double count, so the total of these two numbers is at most 4.\n\n\nFor example,  if the code is \nprob\n and the guess is \nborg\n, the program prints \n0 3\n.  Since none of the guesses is correct in both color and position.  The three colors \nb\n, \no\n, \nr\n, however, appear in the code, albeit in a different position.  Suppose the guess is \nrrrr\n, the program prints \n1 0\n.  The third \nr\n is the guess appears in the correct position and correct color.  There is no other \nr\n in the code, so the second number is 0.  This example illustrates that we do not double count.  We do not match the other \nr\ns in the guess to the \nr\n in the code, once the \nr\n in the code has been matched.\n\n\nThe program terminates when the guess is the same as the code.\n\n\nSample Run\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\nooiwt@pe119:~/as04-skeleton$ ./mastermind\nprob\nborg\n0 3\nrrrr\n1 0\nbbbb\n1 0\noorr\n0 2\nprob\n4 0\nooiwt@pe119:~/as04-skeleton$ ./mastermind\ncccp\nborg\n0 0\nprob\n0 1\noooc\n0 1\ncrrc\n1 1\npcpc\n1 2\ncpcp\n3 0\ncccp\n4 0",
            "title": "4. SelectionSort, Add, Mastermind"
        },
        {
            "location": "/as04/index.html#assignment-4-selectionsort-add-mastermind",
            "text": "",
            "title": "Assignment 4: SelectionSort, Add, Mastermind"
        },
        {
            "location": "/as04/index.html#deadline",
            "text": "12 October, 2018 (Friday), 6:00pm.",
            "title": "Deadline"
        },
        {
            "location": "/as04/index.html#prerequisite",
            "text": "You are able to access the  CS1010 programming environment .  You are familiar with  basic UNIX CLI  and using terminal-based editor  vim .  You have gone through Exercise 1 and have already set up your  .gitconfig .  You are familiar with the steps of accepting, downloading, and submitting your exercise and assignment.  You are familiar with the directory structure and the common files included in your assignment skeleton.",
            "title": "Prerequisite"
        },
        {
            "location": "/as04/index.html#learning-outcomes",
            "text": "Be comfortable writing C programs that involve arithmetic operations,  long ,  double ,  bool , and  char  types, conditional  if / else  statements, loops with  while / for / do-while  statements, arrays, and strings.  Be comfortable breaking down a problem into smaller subproblems which can be resolved using functions, including reusing existing functions written for other programs (with a tweak), writing a function that calls itself, designing what should the inputs and return values/types of a function be.",
            "title": "Learning Outcomes"
        },
        {
            "location": "/as04/index.html#setup",
            "text": "Click on this link  to accept the assignment.  Login to one of the hosts of  CS1010 programming environment  Run:   1 ~cs1010/get-as04    You should see the folder  as04-<github id>  in your home directory with the assignment skeleton inside.",
            "title": "Setup"
        },
        {
            "location": "/as04/index.html#solving-the-assignments",
            "text": "Edit the files  selectionsort.c ,  add.c ,  mastermind.c , to solve the corresponding question as described below.  You should break down the problem into smaller subproblems, and write one function for each of the subproblem to solve the problem.    To compile and run tests with the sample inputs and outputs:   1 make    The test cases are given in the  inputs  and  outputs  subdirectory.  You can use  cat  or  less  to look at the content of these test cases.  You can add more test cases or edit the given ones if needed.",
            "title": "Solving The Assignments"
        },
        {
            "location": "/as04/index.html#submission",
            "text": "When you are ready, run the following command to submit:  1 ~cs1010/submit-as04   The files  selectionsort.c ,  add.c ,  mastermind.c , will be uploaded to GitHub.  You can submit multiple times, but only the last submission will be graded.   Editing Your Files in Multiple Locations  You should edit your code only on the CS1010 PE hosts.  If you choose to edit your code in other places, such as directly on Github or in a second location (such as your own laptop), you need to be comfortable with various  git  command to synchronize your code across the different locations, possibly needing to resolve synchronization conflicts.     Only the C files listed above will be submitted.  You can create additional C files for testing different solutions, but eventually, you must put your solution into the corresponding C file provided as the skeleton.",
            "title": "Submission"
        },
        {
            "location": "/as04/index.html#identifying-yourself",
            "text": "In every C file that you submit to CS1010, you need to identify yourself by writing your name and tutorial group. Marks will be deducted if you fail to do so. You need to edit the line:  1 @author XXXX (Group YYYY)   and change it to something like:  1 @author Jean Luc Picard (Group 9)",
            "title": "Identifying Yourself"
        },
        {
            "location": "/as04/index.html#grading",
            "text": "This assignment contributes towards 4% of your final grade.  The total mark for this assignment is 40 marks.  There are three marking criteria: correctness, documentation, and style.     Documentation: For each question, two marks are allocated for documentation.  Please refer to the  documentation  and follow the recommended format.  You need to explain the purpose of every file, function, and parameter.  Logic in your code that is not obvious should be explained as well.  Style: For each question, two marks are allocated for style.  Please refer to the  CS1010 C Style Guide  and follow the recommended guideline.    Correctness: The rest of the marks are allocated to correctness.  Note that passing the tests does not guarantee that your code is correct.  Correctness here is defined in the broad sense of using the various programming constructs in C (type, function, variable, loops, conditionals, arithmetic expressions, logical expressions)  properly , not just producing the correct output and bug-free.     We reserve the right to penalize students for using banned C syntax in the assignments.  In addition, each grader at his or her own discretion can penalize students for repeating mistakes / bad practices from the student's past assignments (even if it was just a warning with no marks deducted in the earlier assignments).",
            "title": "Grading"
        },
        {
            "location": "/as04/index.html#question-1-selectionsort-10-marks",
            "text": "You have implemented counting sort, a simple and fast sorting algorithm that works on integers with limited range.  But if the range of possible values to be sorted is huge or unlimited, then, counting sort does not work so well, and we need a different kind of sorting algorithm.  In this question, you are asked to implement selection sort.  The idea behind selection sort is simple, and we will illustrate with the sequence  15 23 16 4 42 8 .  To sort an array with  n n  values in increasing order, selection sort first finds the maximum value, then moves it into its proper place, that is, the last position.  This move is achieved by swapping the value currently in the last position with the maximum value.  For instance,\nfor  15 23 16 4 42 8 ,  42  is the maximum value and  8  wrongly occupies the position reserved for the maximum value.  After the first step, the array becomes  15 23 16 4 8 42 .  We now focus on sorting the first  n-1 n-1  values in the array (since the maximum is in place).  To do this, we find the second largest value, and move it to the second last position.  The array becomes  15 8 16 4 23 48  after this second step.  The algorithm continues, moving the third largest value into place, the fourth largest value into place, etc., until the array is sorted.  The table below shows the evolution of the array.     Step  Array  Remarks      0  15 23 16 4 42 8  Input Array    1  15 23 16 4  8 42  Swap 42 and 8    2  15 8 16 4  23 42  Swap 23 and 8    3  15 8 4 16 23 42  Swap 16 and 4    4  4 8 15 16 23 42  Swap 15 and 4    5  4 8 15 16 23 42  8 happens to already be in position    6  4 8 15 16 23 42  4 must already be in position     Write a program  selectionsort  that, reads the following, from the standard input,   n n , the number of integers to sort  followed by  n n  integers   into an array, and prints, to the standard output,  n - 1 n - 1  lines, each line showing the array after moving the largest or the next largest element into position.  You can assume that the input list of  n n  integers to be sorted are unique -- i.e., no repetition.",
            "title": "Question 1: SelectionSort (10 marks)"
        },
        {
            "location": "/as04/index.html#sample-run",
            "text": "1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17 ooiwt@pe119:~/as04-skeleton$ ./selectionsort\n6 15 23 16 4 42 8\n15 23 16 4 8 42\n15 8 16 4 23 42\n15 8 4 16 23 42\n4 8 15 16 23 42\n4 8 15 16 23 42\nooiwt@pe119:~/as04-skeleton$ ./selectionsort\n3 0 4 8\n0 4 8\n0 4 8\nooiwt@pe119:~/as04-skeleton$ ./selectionsort\n5 1 3 5 4 2\n1 3 2 4 5\n1 3 2 4 5\n1 2 3 4 5\n1 2 3 4 5",
            "title": "Sample Run"
        },
        {
            "location": "/as04/index.html#question-2-add-15-marks",
            "text": "In this question, you are asked to write a program that adds two  non-negative  numbers which can be arbitrarily large.  The types provided by C can only represent a number up to a certain value.  We have seen that  long long int  is not even big enough to represent 21!.    For this question, we will represent a number using an arbitrarily long string consisting of characters (of type  char )  '0'  to  '9'  (note: not integer 0 to 9).  C supports arithmetic operations on  char  values as well.  To convert between the numerical value of a digit character, we can do the following:   To convert from a digit character to its numerical value, we subtract the  char   '0' .  For instance,  '6' - '0'  will give us the value  6 .  To convert from a numerical value of a digit to its character, we add the  char   '0' .  For instance,  6 + '0'  will give us the character  '6' .   You can read a sequence of non-space characters from the standard input using  cs1010_read_word , and print a sequence of characters (i.e., a string) to the standard output using  cs1010_println_string .  Write a program  add  that reads from the standard input two  non-negative  numbers represented as strings consisting of digits '0' to '9', and prints to the standard output the sum of the two numbers.  You will likely need to use the C standard library function  strlen , which returns you the number of characters in a string (excluding the terminating '\\0').  Look up on how to use this function on your own.",
            "title": "Question 2: Add (15 marks)"
        },
        {
            "location": "/as04/index.html#sample-run_1",
            "text": "1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16 ooiwt@pe119:~/as04-skeleton$ ./add\n1\n1\n2\nooiwt@pe119:~/as04-skeleton$ ./add\n7\n8\n15\nooiwt@pe119:~/as04-skeleton$ ./add\n999999\n1\n1000000\nooiwt@pe119:~/as04-skeleton$ ./add\n1400060514000605140006051400605\n19330911933091193309119330911933091\n19332311993605193914259336963333696",
            "title": "Sample Run"
        },
        {
            "location": "/as04/index.html#question-3-mastermind-15-marks",
            "text": "Photo by  fl\u00f6schen ,  some right reserved  Mastermind is a board game played by two players, a  coder  and a  codebreaker .  The coder creates a code consists of four color pegs, chosen from pegs of six different colors (cyan, green, red, blue, purple, orange).  Repetition of the same colors is allowed.  The codebreaker's task is to guess the colors of the pegs and the order their appears in the code.  The game proceeds in rounds.  In each round, the codebreaker tries to guess the code by specifying the colors and the order of the colors.  The coder then provides feedback to the codebreaker, with two smaller pegs of black and white color.  A black color peg is placed if the codebreaker guesses correctly a peg in both position and color.  A white color peg is placed if the codebreaker guesses correctly a peg in color but not in the position.  Based on the feedback, the codebreaker guesses again in the next round.  In the actual board game, the codebreaker wins if he guesses correctly every color in the correct order.  The coder wins if the codebreaker failed to guess correctly after 8 guesses.  Write a program called  mastermind  that simulates the Mastermind game.  The program first reads in the code from the standard inputs.  We denote the colors with their initials,  c ,  g ,  r ,  b ,  p ,  o .  Hence, the code is a 4-letter word.  For instance, the code  prob  corresponds the pegs purple, red, orange, blue, in that order.  It then reads in a sequence of guesses, each is a 4-letter word consists of the letter  c ,  g ,  r ,  b ,  p ,  o .  For each guess, the program prints out two numbers, the first is the number of pegs that are correct in both position and color.  The second, is the number of pegs that are correct in color but not position.  Note that we do not double count, so the total of these two numbers is at most 4.  For example,  if the code is  prob  and the guess is  borg , the program prints  0 3 .  Since none of the guesses is correct in both color and position.  The three colors  b ,  o ,  r , however, appear in the code, albeit in a different position.  Suppose the guess is  rrrr , the program prints  1 0 .  The third  r  is the guess appears in the correct position and correct color.  There is no other  r  in the code, so the second number is 0.  This example illustrates that we do not double count.  We do not match the other  r s in the guess to the  r  in the code, once the  r  in the code has been matched.  The program terminates when the guess is the same as the code.",
            "title": "Question 3: Mastermind (15 marks)"
        },
        {
            "location": "/as04/index.html#sample-run_2",
            "text": "1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28 ooiwt@pe119:~/as04-skeleton$ ./mastermind\nprob\nborg\n0 3\nrrrr\n1 0\nbbbb\n1 0\noorr\n0 2\nprob\n4 0\nooiwt@pe119:~/as04-skeleton$ ./mastermind\ncccp\nborg\n0 0\nprob\n0 1\noooc\n0 1\ncrrc\n1 1\npcpc\n1 2\ncpcp\n3 0\ncccp\n4 0",
            "title": "Sample Run"
        },
        {
            "location": "/as04-comments/index.html",
            "text": "Assignment 4: Comments\n\n\nNotes on Marking Schemes\n\n\n\n\nWe apply the penalty to each program independently, i.e., the same mistake repeated in the different program get penalized multiple times.  \n\n\n\n\nYou will receive 0 marks if your program cannot be compiled or is plagiarised from another.\n\n\n\n\n\n\nCode that fails all test cases and showing that student does not understand the basic concepts receives 0 marks straight away.\n\n\n\n\n\n\nFor the rest, we start with full marks and start deducting marks for each error.\n\n\n\n\n\n\nWhile the teaching team tries to ensure fair and consistent grading of assignments across all groups, each TA can, at his/her own discretion, and with the approval of Wei Tsang, adjust the grading criteria to align with the messages that they sent to the students in their tutorial group.\n\n\n\n\n\n\nStyle\n\n\nTwo marks are allocated for each question. We won't penalize for every violation, but instead, the grader judges whether the code is clean, understandable, properly indented, use proper variable names, etc. 0 - 0.5 marks for very bad style, 1.0 - 1.5 for something in the middle, 2 for an ok code. \n\n\nTo be safe, please follow strictly the CS1010 coding standards.\n\n\nDocumentation\n\n\nTwo marks are allocated for each question. We do not penalize for formatting errors violation in Assignment 4.  If you did not document your function, parameters, return values, or document wrongly (e.g., confused between \n@param[out]\n with \n@return\n, you will get a deduction of 1 mark.  You get 0 if there is no documentation at all.  \n\n\nThe following are common formatting errors:\n\n\n\n\n@param\n command used in a comment that is not attached to a function declaration \n\n\n@return\n command used in a comment that is attached to a function returning \nvoid\n \n\n\nParameter name not found in the function declaration.  You should put the name of the variable only, exclude the type, \n*\n, \n[]\n.\n\n\nPutting \n@param\n with the parameter name, but no description of what the parameter does.\n\n\nMissing \n[in]\n, \n[out]\n, or \n[in,out]\n.  Note that there is no space after \n,\n in \n[in,out]\n. \n\n\n\n\nGeneral Mistakes\n\n\nThis penalty applies once per program (not per occurrence).\n\n\n\n\n-1 for missing type in function declaration or definition\n\n\n-1 for using \nint\n/\nlong\n instead of \nbool\n for boolean functions or variables\n\n\n-1 for using \ndouble\n instead of \nlong\n when it is not necessary (does not involve integer division).  For instance, using \ndouble\n for \ninvest.c\n during calculation is ok, using \ndouble\n for calculating the area of the box is not.\n\n\n-1 for using of \nint\n instead of \nlong\n.  Using \nint\n for this assignment is ok only for \nday\n, \nhour\n, and \nminute\n, where there is an implicit constraint on the range of the value.\n\n\n-1 for failing to use parenthesis (e.g., \na && b || c\n)\n\n\n-1 for unnecessary/unused parameters passed into a function\n\n\n-1 for unnecessary/unused variables declared\n\n\n-1 for not including @author/@group\n\n\n-1 for global variables\n\n\n-1 for unreachable code / return\n\n\n-1 for using \n==\n to compare real numbers\n\n\nnew\n -1 for using variable length array\n\n\nnew\n -1 for extra elements in the array initializers\n\n\nnew\n -1 for hardcoding the size of the array, hoping that it is big enough.\n\n\nnew\n -1 for memory leaks\n\n\n\n\nLogical Mistakes (bugs)\n\n\nIn general, -1 for each bug.\n\n\n\n\n-1 for each incorrect logical expression\n\n\n-1 for each incorrect arithmetic expression\n\n\n-1 for each incorrect use of \nif\n-\nelse\n\n\n-1 for each uninitialized variables causing incorrect output.\n\n\n-1 if program prints extra text / newline\n\n\n-1 if the program returns non-zero from \nmain\n even if the program exits successfully.\n\n\n\n\nAnswer Keys\n\n\nSelectionSort\n\n\nThis is an easy question, but unfortunately, less than half the class received full marks.  Most of these are due to lack of documentation >.<\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n/**\n\n\n * Sort the input array list using selection sort.\n\n\n *\n\n\n * @param[in] length The size of the array\n\n\n * @param[in,out] list The array to sort\n\n\n */\n\n\nvoid\n \nselection_sort\n(\nlong\n \nlength\n,\n \nlong\n \nlist\n[\nlength\n])\n\n\n{\n\n  \nlong\n \nlast\n \n=\n \nlength\n;\n\n  \nfor\n \n(\nlong\n \ni\n \n=\n \n1\n;\n \ni\n \n<=\n \nlength\n \n-\n \n1\n;\n \ni\n \n+=\n \n1\n)\n \n{\n\n    \nlong\n \ncurr_pos\n \n=\n \nlast\n \n-\n \n1\n;\n\n    \n// Find the position of the max number between list[0]..list[last-1]\n\n    \nlong\n \nmax_pos\n \n=\n \nmax\n(\nlast\n,\n \nlist\n);\n\n    \nif\n \n(\nmax_pos\n \n!=\n \ncurr_pos\n)\n \n{\n\n      \nlong\n \ntemp\n \n=\n \nlist\n[\nmax_pos\n];\n\n      \nlist\n[\nmax_pos\n]\n \n=\n \nlist\n[\ncurr_pos\n];\n\n      \nlist\n[\ncurr_pos\n]\n \n=\n \ntemp\n;\n\n    \n}\n\n    \nprint\n(\nlength\n,\n \nlist\n);\n\n    \nlast\n \n-=\n \n1\n;\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\nThe only common mistake we see here is that the \nmax\n function does not handle negative values.  \n\n\nAdd\n\n\nThe most common mistake is accessing memory locations outside of the bound of the array.  This is usually due to careless mistakes (forgetting to allocate an extra space for null character at the end of the string, or forgetting to allocate the extra carry).\n\n\nI have seen lots of code that compute the addition in one long chunk of code, making it hard to read, understand, and debug.  Remember to practice decomposition -- breaking down the problem into smaller subproblems, and solve each one by writing a small function.\n\n\nFor me, I broke down the tasks of adding two arbitrary large integers to adding two digits (with a possible carry):\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n**\n\n \n*\n \nPerform\n \na\n \nsingle\n \ndigit\n \naddition\n.\n  \nThe\n \ndigits\n \nare\n \nstored\n \nin\n\n \n*\n \nchar\n \nform\n.\n\n \n*\n\n \n*\n \n@\npre\n \na\n \nand\n \nb\n \ncan\n \nonly\n \nbe\n \n'0'\n,\n \n'1'\n,\n \n..\n \n'9'\n\n \n*\n \n@\nparam\n[\nin\n]\n             \na\n \nThe\n \nfirst\n \noperand\n \nof\n \naddition\n \n(\nin\n \nchar\n)\n\n \n*\n \n@\nparam\n[\nin\n]\n             \nb\n \nThe\n \nsecond\n \noperand\n \nof\n \naddition\n \n(\nin\n \nchar\n)\n\n \n*\n \n@\nparam\n[\nin\n,\nout\n]\n \nhas_carry\n \nWhether\n \nwe\n \nshould\n \nadd\n \na\n \ncarry\n \nwhen\n \nadding\n\n \n*\n                          \na\n \n+\n \nb\n.\n  \nIf\n \na\n \n+\n \nb\n \ngenerates\n \na\n \ncarry\n,\n \n*\nhas_carry\n\n \n*\n                          \nwill\n \nbe\n \nset\n \nto\n \ntrue\n,\n \notherwise\n \nto\n \nfalse\n.\n\n \n*\n\n \n*\n \n@\nreturn\n \nThe\n \nleast\n \nsignificant\n \ndigit\n \nof\n \na\n+\nb\n \n(\nas\n \nchar\n)\n\n \n*/\n\n\nchar\n \nadd_digit\n(\nchar\n \na\n,\n \nchar\n \nb\n,\n \nbool\n \n*\nhas_carry\n)\n\n\n{\n\n  \nlong\n \nsum\n \n=\n \n(\na\n \n-\n \n'0'\n)\n \n+\n \n(\nb\n \n-\n \n'0'\n);\n\n  \nchar\n \nresult\n;\n\n  \nif\n \n(\n*\nhas_carry\n)\n \n{\n\n    \nsum\n \n+=\n \n1\n;\n\n  \n}\n\n  \nif\n \n(\nsum\n \n>=\n \n10\n)\n \n{\n\n    \nresult\n \n=\n \n(\nsum\n \n%\n \n10\n)\n \n+\n \n'0'\n;\n\n    \n*\nhas_carry\n \n=\n \ntrue\n;\n\n  \n}\n \nelse\n \n{\n\n    \nresult\n \n=\n \nsum\n \n+\n \n'0'\n;\n\n    \n*\nhas_carry\n \n=\n \nfalse\n;\n\n  \n}\n\n  \nreturn\n \nresult\n;\n\n\n}\n\n\n\n\n\n\n\nThen, I add digits by digits, starting from least significant digits.  Some students reverse the strings and add from the front -- which is unnecessary. \n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n  \nlong\n \nlen1\n \n=\n \nstrlen\n(\noperand1\n);\n\n  \nlong\n \nlen2\n \n=\n \nstrlen\n(\noperand2\n);\n\n  \nlong\n \nmax\n \n=\n \n(\nlen1\n \n>\n \nlen2\n)\n \n?\n \nlen1\n \n:\n \nlen2\n;\n\n\n  \nchar\n \nresult\n[\nmax\n \n+\n \n2\n];\n\n  \nresult\n[\nmax\n \n+\n \n1\n]\n \n=\n \n'\\0'\n;\n\n\n  \n// starting from the back, add digit by digit\n\n  \nlong\n \ni\n \n=\n \nlen1\n \n-\n \n1\n;\n\n  \nlong\n \nj\n \n=\n \nlen2\n \n-\n \n1\n;\n\n  \nlong\n \nk\n \n=\n \nmax\n;\n\n  \nbool\n \nhas_carry\n \n=\n \nfalse\n;\n\n  \nwhile\n \n(\ni\n \n>=\n \n0\n \n&&\n \nj\n \n>=\n \n0\n)\n \n{\n\n    \nresult\n[\nk\n]\n \n=\n \nadd_digit\n(\noperand1\n[\ni\n],\n \noperand2\n[\nj\n],\n \n&\nhas_carry\n);\n\n    \ni\n \n-=\n \n1\n;\n\n    \nj\n \n-=\n \n1\n;\n\n    \nk\n \n-=\n \n1\n;\n\n  \n}\n\n\n\n\n\n\n\nOnce I exit the while loop, I have either \ni < 0 || j < 0\n.  I have exhausted the digits in one of the operands.   I figure out which one and continue to add 0 to the remaining operand.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n// done with the shorter number.  Now handle the rest.\n\n  \nchar\n \n*\nrest\n;\n\n  \nif\n \n(\nj\n \n>=\n \n0\n)\n \n{\n\n    \nrest\n \n=\n \noperand2\n;\n\n  \n}\n \nelse\n \n{\n\n    \nrest\n \n=\n \noperand1\n;\n\n    \nj\n \n=\n \ni\n;\n\n  \n}\n\n\n  \nwhile\n \n(\nj\n \n>=\n \n0\n)\n \n{\n\n    \nresult\n[\nk\n]\n \n=\n \nadd_digit\n(\nrest\n[\nj\n],\n \n'0'\n,\n \n&\nhas_carry\n);\n\n    \nk\n \n-=\n \n1\n;\n\n    \nj\n \n-=\n \n1\n;\n\n  \n}\n\n\n\n\n\n\n\nFinally, I check if there is a carry and print out the content accordingly:\n\n\n1\n2\n3\n4\n5\n6\n \nif\n \n(\nhas_carry\n)\n \n{\n\n    \nresult\n[\nk\n]\n \n=\n \n'1'\n;\n\n    \ncs1010_println_string\n(\nresult\n);\n\n  \n}\n \nelse\n \n{\n\n    \ncs1010_println_string\n(\n&\nresult\n[\n1\n]);\n\n  \n}\n\n\n\n\n\n\n\nSome students store each digit in a \nlong\n or \nint\n, which makes it easier to handle the final carry.  This approach takes more memory than storing a \nchar\n but is fine.\n\n\nMasterMind\n\n\nOne way to solve \nmastermind\n is to keep a temporary array (I called it \nmarked\n) that stores the same content as \nanswer\n but once we found a match, we \"checked off\" the character so that id does not match again.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n#define MATCHED ' '\n\n\n  \nfor\n \n(\nlong\n \ni\n \n=\n \n0\n;\n \ni\n \n<\n \nPUZZLE_SIZE\n;\n \ni\n \n+=\n \n1\n)\n \n{\n\n    \nmarked\n[\ni\n]\n \n=\n \nanswer\n[\ni\n];\n\n  \n}\n\n  \nlong\n \nsame_color_same_pos\n \n=\n \n0\n;\n\n  \nlong\n \nsame_color_diff_pos\n \n=\n \n0\n;\n\n  \nfor\n \n(\nlong\n \ni\n \n=\n \n0\n;\n \ni\n \n<\n \nPUZZLE_SIZE\n;\n \ni\n \n+=\n \n1\n)\n \n{\n\n    \nif\n \n(\nguess\n[\ni\n]\n \n==\n \nmarked\n[\ni\n])\n \n{\n\n      \nsame_color_same_pos\n \n+=\n \n1\n;\n\n      \nmarked\n[\ni\n]\n \n=\n \nMATCHED\n;\n\n    \n}\n\n  \n}\n\n\n  \nfor\n \n(\nlong\n \ni\n \n=\n \n0\n;\n \ni\n \n<\n \nPUZZLE_SIZE\n;\n \ni\n \n+=\n \n1\n)\n \n{\n\n    \nbool\n \nfound\n \n=\n \nfalse\n;\n\n    \nfor\n \n(\nlong\n \nj\n \n=\n \n0\n;\n \nj\n \n<\n \nPUZZLE_SIZE\n \n&&\n \n!\nfound\n;\n \nj\n \n+=\n \n1\n)\n \n{\n\n      \nif\n \n(\nguess\n[\ni\n]\n \n!=\n \nanswer\n[\ni\n]\n \n&&\n \nguess\n[\ni\n]\n \n==\n \nmarked\n[\nj\n])\n \n{\n\n        \nsame_color_diff_pos\n \n+=\n \n1\n;\n\n        \nfound\n \n=\n \ntrue\n;\n\n        \nmarked\n[\nj\n]\n \n=\n \nMATCHED\n;\n\n      \n}\n\n    \n}\n\n  \n}\n\n\n\n\n\n\n\nThe two output numbers are \nsame_color_same_pos\n and \nsame_color_diff_pos\n.\n\n\nDespite being asked and clarified on Piazza at least twice, some students still stopped the game after 8 guesses.  Please (i) read the question carefully, and (ii) read Piazza.",
            "title": "4. Comments and Answer Keys"
        },
        {
            "location": "/as04-comments/index.html#assignment-4-comments",
            "text": "",
            "title": "Assignment 4: Comments"
        },
        {
            "location": "/as04-comments/index.html#notes-on-marking-schemes",
            "text": "We apply the penalty to each program independently, i.e., the same mistake repeated in the different program get penalized multiple times.     You will receive 0 marks if your program cannot be compiled or is plagiarised from another.    Code that fails all test cases and showing that student does not understand the basic concepts receives 0 marks straight away.    For the rest, we start with full marks and start deducting marks for each error.    While the teaching team tries to ensure fair and consistent grading of assignments across all groups, each TA can, at his/her own discretion, and with the approval of Wei Tsang, adjust the grading criteria to align with the messages that they sent to the students in their tutorial group.",
            "title": "Notes on Marking Schemes"
        },
        {
            "location": "/as04-comments/index.html#style",
            "text": "Two marks are allocated for each question. We won't penalize for every violation, but instead, the grader judges whether the code is clean, understandable, properly indented, use proper variable names, etc. 0 - 0.5 marks for very bad style, 1.0 - 1.5 for something in the middle, 2 for an ok code.   To be safe, please follow strictly the CS1010 coding standards.",
            "title": "Style"
        },
        {
            "location": "/as04-comments/index.html#documentation",
            "text": "Two marks are allocated for each question. We do not penalize for formatting errors violation in Assignment 4.  If you did not document your function, parameters, return values, or document wrongly (e.g., confused between  @param[out]  with  @return , you will get a deduction of 1 mark.  You get 0 if there is no documentation at all.    The following are common formatting errors:   @param  command used in a comment that is not attached to a function declaration   @return  command used in a comment that is attached to a function returning  void    Parameter name not found in the function declaration.  You should put the name of the variable only, exclude the type,  * ,  [] .  Putting  @param  with the parameter name, but no description of what the parameter does.  Missing  [in] ,  [out] , or  [in,out] .  Note that there is no space after  ,  in  [in,out] .",
            "title": "Documentation"
        },
        {
            "location": "/as04-comments/index.html#general-mistakes",
            "text": "This penalty applies once per program (not per occurrence).   -1 for missing type in function declaration or definition  -1 for using  int / long  instead of  bool  for boolean functions or variables  -1 for using  double  instead of  long  when it is not necessary (does not involve integer division).  For instance, using  double  for  invest.c  during calculation is ok, using  double  for calculating the area of the box is not.  -1 for using of  int  instead of  long .  Using  int  for this assignment is ok only for  day ,  hour , and  minute , where there is an implicit constraint on the range of the value.  -1 for failing to use parenthesis (e.g.,  a && b || c )  -1 for unnecessary/unused parameters passed into a function  -1 for unnecessary/unused variables declared  -1 for not including @author/@group  -1 for global variables  -1 for unreachable code / return  -1 for using  ==  to compare real numbers  new  -1 for using variable length array  new  -1 for extra elements in the array initializers  new  -1 for hardcoding the size of the array, hoping that it is big enough.  new  -1 for memory leaks",
            "title": "General Mistakes"
        },
        {
            "location": "/as04-comments/index.html#logical-mistakes-bugs",
            "text": "In general, -1 for each bug.   -1 for each incorrect logical expression  -1 for each incorrect arithmetic expression  -1 for each incorrect use of  if - else  -1 for each uninitialized variables causing incorrect output.  -1 if program prints extra text / newline  -1 if the program returns non-zero from  main  even if the program exits successfully.",
            "title": "Logical Mistakes (bugs)"
        },
        {
            "location": "/as04-comments/index.html#answer-keys",
            "text": "",
            "title": "Answer Keys"
        },
        {
            "location": "/as04-comments/index.html#selectionsort",
            "text": "This is an easy question, but unfortunately, less than half the class received full marks.  Most of these are due to lack of documentation >.<   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22 /**   * Sort the input array list using selection sort.   *   * @param[in] length The size of the array   * @param[in,out] list The array to sort   */  void   selection_sort ( long   length ,   long   list [ length ])  { \n   long   last   =   length ; \n   for   ( long   i   =   1 ;   i   <=   length   -   1 ;   i   +=   1 )   { \n     long   curr_pos   =   last   -   1 ; \n     // Find the position of the max number between list[0]..list[last-1] \n     long   max_pos   =   max ( last ,   list ); \n     if   ( max_pos   !=   curr_pos )   { \n       long   temp   =   list [ max_pos ]; \n       list [ max_pos ]   =   list [ curr_pos ]; \n       list [ curr_pos ]   =   temp ; \n     } \n     print ( length ,   list ); \n     last   -=   1 ; \n   }  }    The only common mistake we see here is that the  max  function does not handle negative values.",
            "title": "SelectionSort"
        },
        {
            "location": "/as04-comments/index.html#add",
            "text": "The most common mistake is accessing memory locations outside of the bound of the array.  This is usually due to careless mistakes (forgetting to allocate an extra space for null character at the end of the string, or forgetting to allocate the extra carry).  I have seen lots of code that compute the addition in one long chunk of code, making it hard to read, understand, and debug.  Remember to practice decomposition -- breaking down the problem into smaller subproblems, and solve each one by writing a small function.  For me, I broke down the tasks of adding two arbitrary large integers to adding two digits (with a possible carry):   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29 ** \n  *   Perform   a   single   digit   addition .    The   digits   are   stored   in \n  *   char   form . \n  * \n  *   @ pre   a   and   b   can   only   be   '0' ,   '1' ,   ..   '9' \n  *   @ param [ in ]               a   The   first   operand   of   addition   ( in   char ) \n  *   @ param [ in ]               b   The   second   operand   of   addition   ( in   char ) \n  *   @ param [ in , out ]   has_carry   Whether   we   should   add   a   carry   when   adding \n  *                            a   +   b .    If   a   +   b   generates   a   carry ,   * has_carry \n  *                            will   be   set   to   true ,   otherwise   to   false . \n  * \n  *   @ return   The   least   significant   digit   of   a + b   ( as   char ) \n  */  char   add_digit ( char   a ,   char   b ,   bool   * has_carry )  { \n   long   sum   =   ( a   -   '0' )   +   ( b   -   '0' ); \n   char   result ; \n   if   ( * has_carry )   { \n     sum   +=   1 ; \n   } \n   if   ( sum   >=   10 )   { \n     result   =   ( sum   %   10 )   +   '0' ; \n     * has_carry   =   true ; \n   }   else   { \n     result   =   sum   +   '0' ; \n     * has_carry   =   false ; \n   } \n   return   result ;  }    Then, I add digits by digits, starting from least significant digits.  Some students reverse the strings and add from the front -- which is unnecessary.    1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18    long   len1   =   strlen ( operand1 ); \n   long   len2   =   strlen ( operand2 ); \n   long   max   =   ( len1   >   len2 )   ?   len1   :   len2 ; \n\n   char   result [ max   +   2 ]; \n   result [ max   +   1 ]   =   '\\0' ; \n\n   // starting from the back, add digit by digit \n   long   i   =   len1   -   1 ; \n   long   j   =   len2   -   1 ; \n   long   k   =   max ; \n   bool   has_carry   =   false ; \n   while   ( i   >=   0   &&   j   >=   0 )   { \n     result [ k ]   =   add_digit ( operand1 [ i ],   operand2 [ j ],   & has_carry ); \n     i   -=   1 ; \n     j   -=   1 ; \n     k   -=   1 ; \n   }    Once I exit the while loop, I have either  i < 0 || j < 0 .  I have exhausted the digits in one of the operands.   I figure out which one and continue to add 0 to the remaining operand.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14 // done with the shorter number.  Now handle the rest. \n   char   * rest ; \n   if   ( j   >=   0 )   { \n     rest   =   operand2 ; \n   }   else   { \n     rest   =   operand1 ; \n     j   =   i ; \n   } \n\n   while   ( j   >=   0 )   { \n     result [ k ]   =   add_digit ( rest [ j ],   '0' ,   & has_carry ); \n     k   -=   1 ; \n     j   -=   1 ; \n   }    Finally, I check if there is a carry and print out the content accordingly:  1\n2\n3\n4\n5\n6   if   ( has_carry )   { \n     result [ k ]   =   '1' ; \n     cs1010_println_string ( result ); \n   }   else   { \n     cs1010_println_string ( & result [ 1 ]); \n   }    Some students store each digit in a  long  or  int , which makes it easier to handle the final carry.  This approach takes more memory than storing a  char  but is fine.",
            "title": "Add"
        },
        {
            "location": "/as04-comments/index.html#mastermind",
            "text": "One way to solve  mastermind  is to keep a temporary array (I called it  marked ) that stores the same content as  answer  but once we found a match, we \"checked off\" the character so that id does not match again.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24 #define MATCHED ' ' \n\n   for   ( long   i   =   0 ;   i   <   PUZZLE_SIZE ;   i   +=   1 )   { \n     marked [ i ]   =   answer [ i ]; \n   } \n   long   same_color_same_pos   =   0 ; \n   long   same_color_diff_pos   =   0 ; \n   for   ( long   i   =   0 ;   i   <   PUZZLE_SIZE ;   i   +=   1 )   { \n     if   ( guess [ i ]   ==   marked [ i ])   { \n       same_color_same_pos   +=   1 ; \n       marked [ i ]   =   MATCHED ; \n     } \n   } \n\n   for   ( long   i   =   0 ;   i   <   PUZZLE_SIZE ;   i   +=   1 )   { \n     bool   found   =   false ; \n     for   ( long   j   =   0 ;   j   <   PUZZLE_SIZE   &&   ! found ;   j   +=   1 )   { \n       if   ( guess [ i ]   !=   answer [ i ]   &&   guess [ i ]   ==   marked [ j ])   { \n         same_color_diff_pos   +=   1 ; \n         found   =   true ; \n         marked [ j ]   =   MATCHED ; \n       } \n     } \n   }    The two output numbers are  same_color_same_pos  and  same_color_diff_pos .  Despite being asked and clarified on Piazza at least twice, some students still stopped the game after 8 guesses.  Please (i) read the question carefully, and (ii) read Piazza.",
            "title": "MasterMind"
        },
        {
            "location": "/as05/index.html",
            "text": "Assignment 5: Social, Life\n\n\nDeadline\n\n\n19 October, 2018 (Friday), 6:00pm.\n\n\nPrerequisite\n\n\n\n\nYou are able to access the \nCS1010 programming environment\n.\n\n\nYou are familiar with \nbasic UNIX CLI\n and using terminal-based editor \nvim\n.\n\n\nYou have gone through Exercise 1 and have already set up your \n.gitconfig\n.\n\n\nYou are familiar with the steps of accepting, downloading, and submitting your exercise and assignment.\n\n\nYou are familiar with the directory structure and the common files included in your assignment skeleton.\n\n\n\n\nLearning Outcomes\n\n\n\n\nBe comfortable writing C programs that involve arithmetic operations, \nlong\n, \ndouble\n, \nbool\n, and \nchar\n types, conditional \nif\n/\nelse\n statements, loops with \nwhile\n/\nfor\n/\ndo-while\n statements, arrays (including 2D arrays), strings, pointers, and dynamic memory allocation.\n\n\nBe comfortable breaking down a problem into smaller subproblems which can be resolved using functions, including reusing existing functions written for other programs (with a tweak), writing a function that calls itself, designing what should the inputs and return values/types of a function be.\n\n\n\n\nSetup\n\n\n\n\nClick on this link\n to accept the assignment.\n\n\nLogin to one of the hosts of \nCS1010 programming environment\n\n\nRun:\n\n\n\n\n1\n~cs1010/get-as05\n\n\n\n\n\n\n\n\nYou should see the folder \nas05-<github id>\n in your home directory with the assignment skeleton inside.\n\n\n\n\nSolving The Assignments\n\n\n\n\nEdit the files \nsocial.c\n and \nlife.c\n to solve the corresponding question as described below.\n\n\nYou should break down the problem into smaller subproblems, and write one function for each of the subproblem to solve the problem.  \n\n\nTo compile and run tests with the sample inputs and outputs:\n\n\n\n\n1\nmake\n\n\n\n\n\n\n\n\n\n\nThe test cases are given in the \ninputs\n and \noutputs\n subdirectory.  You can use \ncat\n or \nless\n to look at the content of these test cases.  You can add more test cases or edit the given ones if needed.\n\n\n\n\n\n\n new \n For Question 2, Life, there is no automated testing.  So you will not see \nlife\n:\n \npassed\n as per usual.  Instead, you should run each test case manually and view the resulting animation.  If an animation is too big to fit into your terminal, try enlarging the terminal or reducing the size of the terminal fonts.  The largest canvas is 100 rows and 100 cols.\n\n\n\n\n\n\nSubmission\n\n\nWhen you are ready, run the following command to submit:\n\n\n1\n~cs1010/submit-as05\n\n\n\n\n\n\nThe files \nsocial.c\n and \nlife.c\n will be uploaded to GitHub.  You can submit multiple times, but only the last submission will be graded.\n\n\n\n\nEditing Your Files in Multiple Locations\n\n\nYou should edit your code only on the CS1010 PE hosts.  If you choose to edit your code in other places, such as directly on Github or in a second location (such as your own laptop), you need to be comfortable with various \ngit\n command to synchronize your code across the different locations, possibly needing to resolve synchronization conflicts.  \n\n\n\n\nOnly the C files listed above will be submitted.  You can create additional C files for testing different solutions, but eventually, you must put your solution into the corresponding C file provided as the skeleton.\n\n\nIdentifying Yourself\n\n\nIn every C file that you submit to CS1010, you need to identify yourself by writing your name and tutorial group. Marks will be deducted if you fail to do so. You need to edit the line:\n\n\n1\n@author XXXX (Group YYYY)\n\n\n\n\n\n\nand change it to something like:\n\n\n1\n@author Mikasa Ackermann\n\n\n\n\n\n\nGrading\n\n\nThis assignment contributes towards 3% of your final grade.  The total mark for this assignment is 30 marks.  There are three marking criteria: correctness, documentation, and style.  \n\n\n\n\nDocumentation: For each question, two marks are allocated for documentation.  Please refer to the \ndocumentation\n and follow the recommended format.  You need to explain the purpose of every file, function, and parameter.  Logic in your code that is not obvious should be explained as well.\n\n\n new \n Style: Marks are no longer allocated for style, but we will deduct up to 2 marks if you have a serious violation of the style guideline.  Please refer to the \nCS1010 C Style Guide\n and follow the recommended guideline.\n\n\nCorrectness: The rest of the marks are allocated to correctness.  Note that passing the tests does not guarantee that your code is correct.  Correctness here is defined in the broad sense of using the various programming constructs in C (type, function, variable, loops, arrays, pointers, conditionals, arithmetic expressions, logical expressions) \nproperly\n, not just producing the correct output and bug-free.  \n\n\n\n\nWe reserve the right to penalize students for using banned C syntax in the assignments.  In addition, each grader at his or her own discretion can penalize students for repeating mistakes / bad practices from the student's past assignments (even if it was just a warning with no marks deducted in the earlier assignments).\n\n\nQuestion 1: Social (15 marks)\n\n\nThe idea of \nsix degrees of separation\n states that everyone in the world is connected to every other person by at most 6 hops.  Suppose that a person \nA\nA\n is a friend of a person \nB\nB\n, then we say that \nA\nA\n is one hop away from \nB\nB\n.  Consider a friend of \nB\nB\n, say \nC\nC\n, who is not a friend of \nA\nA\n.  So \nC\nC\n is a friend of a friend of \nA\nA\n.  We say that \nC\nC\n is two hops away from \nA\nA\n.  Six degree of separation generally means there is a chain of friendship that can connect any two people in the world with no more than 6 hops. \n\n\nIn this question, we are going to compute the chain of friendships up to the \nk\nk\n degree.  Suppose there are \nn\nn\n people, and we know the social network of these \nn\nn\n people -- i.e., we know who is friend with who. \nWrite a program \nsocial\n to compute a social network representing who is connected to who via a friendship chain of degree \nk\nk\n.  \n\n\nWe assume that friendship is bi-directional -- if \nA\nA\n is a friend of \nB\nB\n, then \nB\nB\n is a friend of \nA\nA\n.  Because of this, we can represent a social network as a lower triangular matrix (\nusing jagged 2D array\n).  A proper type to store in each element of the matrix is \nbool\n.  To simplify our life, however, we store each element of the matrix as a \nchar\n, with \n'1'\n representing a friendship connection, \n'0'\n otherwise. The social network for \nn\nn\n people is thus an array of \nn\nn\n strings, each string containing characters of \n'0'\n and \n'1'\n only.  The first row of the matrix is a string of length one; the second row is of length two; third row, length three, etc.  The last character of each string (i.e., the diagonal of the matrix) is \n1\n since everyone is a friend with him/herself.\n\n\nFor instance, suppose we have the following social network, with Row 1 for Person \nA\nA\n, Row 2 for Person \nB\nB\n, Row 3 for Person \nC\nC\n.\n\n1\n2\n3\n1\n01\n011\n\n\n\n\n\nThe social network above indicates that \nB\nB\n and \nC\nC\n are friends with each other.  \nA\nA\n is not a friend with neither.  \n\n\nAs another example, the social network below shows an extra person \nD\nD\n (Row 4).\n\n1\n2\n3\n4\n1\n01\n011\n1011\n\n\n\n\n\nD\nD\n is friend with both \nA\nA\n and \nC\nC\n.\n\n\nSuppose now we consider the social network of degree 2.  \nA\nA\n is two hops away from \nC\nC\n (\nA\nA\n knows \nD\nD\n and \nD\nD\n knows \nC\nC\n).  \nB\nB\n is also two hops away from \nD\nD\n (\nB\nB\n knows \nC\nC\n and \nC\nC\n knows \nD\nD\n).  The generated social network of degree 2 becomes:\n\n1\n2\n3\n4\n1\n01\n111\n1111\n\n\n\n\n\nNote that we cannot say everyone is connected to everyone else up to degree 2 in this example since \nA\nA\n is not a friend of a friend of \nB\nB\n -- i.e., \nA\nA\n and \nB\nB\n are still not connected, even if we consider a friendship chain of degree 2.\n\n\nWrite a program \nsocial\n, that reads from standard input two positive integers \nn\nn\n and \nk\nk\n, followed by \nn\nn\n lines of strings consisting of \n'1'\n or \n'0'\n representing the social network of these \nn\nn\n people.\n\nPrint, to the standard output, the social network formed by a friendship chain of degree \nk\nk\n.  Finally, print, to the standard output, \nYES\n if everyone is connected to everyone within k hops, or \nNO\n otherwise.\n\n\nThe purpose of this question is for you to practice using a jagged 2D array.  Hence, \nyou are not allowed to store the input matrix or intermediate matrices using a rectangular array\n, or you risk being penalized heavily for this question.\n\n\nSample Run\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\nooiwt@pe119:~/as05-skeleton$ cat inputs/social.1.in\n3 1\n1\n11\n011\nooiwt@pe119:~/as05-skeleton$ ./social < inputs/social.1.in\n1\n11\n011\nNO\nooiwt@pe119:~/as05-skeleton$ cat inputs/social.2.in\n4 2\n1\n01\n011\n1011\nooiwt@pe119:~/as05-skeleton$ ./social < inputs/social.2.in\n1\n01\n111\n1111\nNO\nooiwt@pe119:~/as05-skeleton$ cat inputs/social.3.in\n5 2\n1\n11\n011\n0011\n10011\nooiwt@pe119:~/as05-skeleton$ ./social < inputs/social.3.in\n1\n11\n111\n1111\n11111\nYES\n\n\n\n\n\n\nQuestion 2: Life (15 marks)\n\n\nThe \"Game of Life\" is a game played on a two-dimensional orthogonal grid of square cells, while each cell has only two possible states: alive or dead. The game is played in iterations. During each iteration, each cell becomes alive or dead, depending on the state of its four neighboring cells in the previous iteration. Interesting patterns and moving behavior can be created, sometimes infinitely, from an initial state. Refer to \nwiki page\n for more details if you are interested. \n\n\nIn this problem, we are going to simulate a game of life for a certain number of iterations, given a starting state. Here is a complete description of the rules of the simulation.\n\n\n\n\n\n\nThe universe is a bounded plane and can be simply referred to as a two-dimensional orthogonal grid of square cells with \nn\nn\n rows and \nm\nm\n columns. For convenience, we let row indexes as 0 to \nn-1\nn-1\n from top to bottom, and column indexes as 0 to \nm-1\nm-1\n from left to right. So in total, there are \nn \\times m\nn \\times m\n cells.\n\n\n\n\n\n\nThe neighbor of a cell is defined as the eight cells that are either horizontally, vertically, or diagonally connected to the cell.\n\n\n\n\n\n\nAn initial state is given, with each cell is marked as either \"live\" or \"dead\".\n\n\n\n\n\n\nIn each iteration, a cell may switch its state, according to rules below, by referring to the state of the previous iteration:\n\n\n\n\nAny live cell with fewer than two live neighbors becomes dead\n\n\nAny live cell with two or three live neighbors remains alive.\n\n\nAny live cell with more than three live neighbors becomes dead.\n\n\nAny dead cell with exactly three live neighbors becomes alive\n\n\nBorder cells, i.e., cells with row number 0 or \nn-1\nn-1\n, or column number 0 or \nm-1\nm-1\n, are always dead. This is to simplify and bound the universe.\n\n\n\n\n\n\n\n\nWrite a program \nlife\n that reads, from the standard inputs, three positive integers \nn\nn\n (\nn > 2\nn > 2\n), \nm\nm\n (\nm > 2\nm > 2\n) and \nk\nk\n, where \nn\nn\n and \nm\nm\n denotes the number of rows and number of columns of the universe (an \nn\\times m\nn\\times m\n grid), and \nk\nk\n is the number of iterations to simulate.  It then reads, from the standard input, \nn\nn\n rows, with \nm\nm\n characters in each row representing the initial state.  Each character is either alive (\n'#'\n) or dead (\n'.'\n). \n\n\nThe program then prints, to standard output, an animation of the universe for \nk\nk\n iterations.  The output should only contain \nn\nn\n rows with \nm\nm\n characters in each row.  Similarly, you must use \n#\n to represent a live cell, and \n.\n to represents a dead cell.\n\n\nAnimation on Screen\n\n\nWe have provided a few lines of code in the skeleton file.  You should insert this at appropriate places:\n\n\n1\n2\n3\n4\n5\n  char clear_screen[] = { 27, '[', '2', 'J',27, '[', ';', 'H'};\n     :\n  cs1010_print_string(clear_screen);\n  // TODO(by student) draw the universe\n  usleep(250*1000);\n\n\n\n\n\n\nLine 1 in the code above defines a special string that, when printed, will clear the screen and place the cursor on the top left corner of the terminal.   Line 5 calls the system function \nusleep\n that takes in the number of microseconds.  Calling \nusleep\n causes the program to pause for that amount of time.  We set the sleeping time to 250ms.  You can reduce if you wish but you must not increase this beyond 250ms or your program might fail when we test it during grading.\n\n\nSample Inputs\n\n\n\n\n\n\nThe pattern from \nlife.1.in\n is called a blinker.\n  \n\n\n\n\n\n\nThe pattern from \nlife.2.in\n is called a pentadecathlon.\n  \n\n\n\n\n\n\nThe pattern from \nlife.4.in\n is called a pulsar.\n  \n\n\n\n\n\n\nWe provide a total of seven patterns for your to play with.  \n\n\nIf you wish the check if your output is correct, you can still redirect the output from \nlife\n to a file, and compare it with the corresponding output under the output directory using the \ndiff\n command:\n\n\n1\n2\nooiwt@pe119:~/as05-skeleton$ ./life < inputs/life.3.in > OUT\nooiwt@pe119:~/as05-skeleton$ diff OUT outputs/life.3.out\n\n\n\n\n\n\nIf \ndiff\n does not list any differences, then the output from your \nlife\n is the same as the expected output.\n\n\nStudents interested to play more game of life can also check out \nLifeWiki\n for more patterns and spiral-click into various information about this game.",
            "title": "5. Social, Life"
        },
        {
            "location": "/as05/index.html#assignment-5-social-life",
            "text": "",
            "title": "Assignment 5: Social, Life"
        },
        {
            "location": "/as05/index.html#deadline",
            "text": "19 October, 2018 (Friday), 6:00pm.",
            "title": "Deadline"
        },
        {
            "location": "/as05/index.html#prerequisite",
            "text": "You are able to access the  CS1010 programming environment .  You are familiar with  basic UNIX CLI  and using terminal-based editor  vim .  You have gone through Exercise 1 and have already set up your  .gitconfig .  You are familiar with the steps of accepting, downloading, and submitting your exercise and assignment.  You are familiar with the directory structure and the common files included in your assignment skeleton.",
            "title": "Prerequisite"
        },
        {
            "location": "/as05/index.html#learning-outcomes",
            "text": "Be comfortable writing C programs that involve arithmetic operations,  long ,  double ,  bool , and  char  types, conditional  if / else  statements, loops with  while / for / do-while  statements, arrays (including 2D arrays), strings, pointers, and dynamic memory allocation.  Be comfortable breaking down a problem into smaller subproblems which can be resolved using functions, including reusing existing functions written for other programs (with a tweak), writing a function that calls itself, designing what should the inputs and return values/types of a function be.",
            "title": "Learning Outcomes"
        },
        {
            "location": "/as05/index.html#setup",
            "text": "Click on this link  to accept the assignment.  Login to one of the hosts of  CS1010 programming environment  Run:   1 ~cs1010/get-as05    You should see the folder  as05-<github id>  in your home directory with the assignment skeleton inside.",
            "title": "Setup"
        },
        {
            "location": "/as05/index.html#solving-the-assignments",
            "text": "Edit the files  social.c  and  life.c  to solve the corresponding question as described below.  You should break down the problem into smaller subproblems, and write one function for each of the subproblem to solve the problem.    To compile and run tests with the sample inputs and outputs:   1 make     The test cases are given in the  inputs  and  outputs  subdirectory.  You can use  cat  or  less  to look at the content of these test cases.  You can add more test cases or edit the given ones if needed.     new   For Question 2, Life, there is no automated testing.  So you will not see  life :   passed  as per usual.  Instead, you should run each test case manually and view the resulting animation.  If an animation is too big to fit into your terminal, try enlarging the terminal or reducing the size of the terminal fonts.  The largest canvas is 100 rows and 100 cols.",
            "title": "Solving The Assignments"
        },
        {
            "location": "/as05/index.html#submission",
            "text": "When you are ready, run the following command to submit:  1 ~cs1010/submit-as05   The files  social.c  and  life.c  will be uploaded to GitHub.  You can submit multiple times, but only the last submission will be graded.   Editing Your Files in Multiple Locations  You should edit your code only on the CS1010 PE hosts.  If you choose to edit your code in other places, such as directly on Github or in a second location (such as your own laptop), you need to be comfortable with various  git  command to synchronize your code across the different locations, possibly needing to resolve synchronization conflicts.     Only the C files listed above will be submitted.  You can create additional C files for testing different solutions, but eventually, you must put your solution into the corresponding C file provided as the skeleton.",
            "title": "Submission"
        },
        {
            "location": "/as05/index.html#identifying-yourself",
            "text": "In every C file that you submit to CS1010, you need to identify yourself by writing your name and tutorial group. Marks will be deducted if you fail to do so. You need to edit the line:  1 @author XXXX (Group YYYY)   and change it to something like:  1 @author Mikasa Ackermann",
            "title": "Identifying Yourself"
        },
        {
            "location": "/as05/index.html#grading",
            "text": "This assignment contributes towards 3% of your final grade.  The total mark for this assignment is 30 marks.  There are three marking criteria: correctness, documentation, and style.     Documentation: For each question, two marks are allocated for documentation.  Please refer to the  documentation  and follow the recommended format.  You need to explain the purpose of every file, function, and parameter.  Logic in your code that is not obvious should be explained as well.   new   Style: Marks are no longer allocated for style, but we will deduct up to 2 marks if you have a serious violation of the style guideline.  Please refer to the  CS1010 C Style Guide  and follow the recommended guideline.  Correctness: The rest of the marks are allocated to correctness.  Note that passing the tests does not guarantee that your code is correct.  Correctness here is defined in the broad sense of using the various programming constructs in C (type, function, variable, loops, arrays, pointers, conditionals, arithmetic expressions, logical expressions)  properly , not just producing the correct output and bug-free.     We reserve the right to penalize students for using banned C syntax in the assignments.  In addition, each grader at his or her own discretion can penalize students for repeating mistakes / bad practices from the student's past assignments (even if it was just a warning with no marks deducted in the earlier assignments).",
            "title": "Grading"
        },
        {
            "location": "/as05/index.html#question-1-social-15-marks",
            "text": "The idea of  six degrees of separation  states that everyone in the world is connected to every other person by at most 6 hops.  Suppose that a person  A A  is a friend of a person  B B , then we say that  A A  is one hop away from  B B .  Consider a friend of  B B , say  C C , who is not a friend of  A A .  So  C C  is a friend of a friend of  A A .  We say that  C C  is two hops away from  A A .  Six degree of separation generally means there is a chain of friendship that can connect any two people in the world with no more than 6 hops.   In this question, we are going to compute the chain of friendships up to the  k k  degree.  Suppose there are  n n  people, and we know the social network of these  n n  people -- i.e., we know who is friend with who. \nWrite a program  social  to compute a social network representing who is connected to who via a friendship chain of degree  k k .    We assume that friendship is bi-directional -- if  A A  is a friend of  B B , then  B B  is a friend of  A A .  Because of this, we can represent a social network as a lower triangular matrix ( using jagged 2D array ).  A proper type to store in each element of the matrix is  bool .  To simplify our life, however, we store each element of the matrix as a  char , with  '1'  representing a friendship connection,  '0'  otherwise. The social network for  n n  people is thus an array of  n n  strings, each string containing characters of  '0'  and  '1'  only.  The first row of the matrix is a string of length one; the second row is of length two; third row, length three, etc.  The last character of each string (i.e., the diagonal of the matrix) is  1  since everyone is a friend with him/herself.  For instance, suppose we have the following social network, with Row 1 for Person  A A , Row 2 for Person  B B , Row 3 for Person  C C . 1\n2\n3 1\n01\n011   The social network above indicates that  B B  and  C C  are friends with each other.   A A  is not a friend with neither.    As another example, the social network below shows an extra person  D D  (Row 4). 1\n2\n3\n4 1\n01\n011\n1011   D D  is friend with both  A A  and  C C .  Suppose now we consider the social network of degree 2.   A A  is two hops away from  C C  ( A A  knows  D D  and  D D  knows  C C ).   B B  is also two hops away from  D D  ( B B  knows  C C  and  C C  knows  D D ).  The generated social network of degree 2 becomes: 1\n2\n3\n4 1\n01\n111\n1111   Note that we cannot say everyone is connected to everyone else up to degree 2 in this example since  A A  is not a friend of a friend of  B B  -- i.e.,  A A  and  B B  are still not connected, even if we consider a friendship chain of degree 2.  Write a program  social , that reads from standard input two positive integers  n n  and  k k , followed by  n n  lines of strings consisting of  '1'  or  '0'  representing the social network of these  n n  people. \nPrint, to the standard output, the social network formed by a friendship chain of degree  k k .  Finally, print, to the standard output,  YES  if everyone is connected to everyone within k hops, or  NO  otherwise.  The purpose of this question is for you to practice using a jagged 2D array.  Hence,  you are not allowed to store the input matrix or intermediate matrices using a rectangular array , or you risk being penalized heavily for this question.",
            "title": "Question 1: Social (15 marks)"
        },
        {
            "location": "/as05/index.html#sample-run",
            "text": "1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36 ooiwt@pe119:~/as05-skeleton$ cat inputs/social.1.in\n3 1\n1\n11\n011\nooiwt@pe119:~/as05-skeleton$ ./social < inputs/social.1.in\n1\n11\n011\nNO\nooiwt@pe119:~/as05-skeleton$ cat inputs/social.2.in\n4 2\n1\n01\n011\n1011\nooiwt@pe119:~/as05-skeleton$ ./social < inputs/social.2.in\n1\n01\n111\n1111\nNO\nooiwt@pe119:~/as05-skeleton$ cat inputs/social.3.in\n5 2\n1\n11\n011\n0011\n10011\nooiwt@pe119:~/as05-skeleton$ ./social < inputs/social.3.in\n1\n11\n111\n1111\n11111\nYES",
            "title": "Sample Run"
        },
        {
            "location": "/as05/index.html#question-2-life-15-marks",
            "text": "The \"Game of Life\" is a game played on a two-dimensional orthogonal grid of square cells, while each cell has only two possible states: alive or dead. The game is played in iterations. During each iteration, each cell becomes alive or dead, depending on the state of its four neighboring cells in the previous iteration. Interesting patterns and moving behavior can be created, sometimes infinitely, from an initial state. Refer to  wiki page  for more details if you are interested.   In this problem, we are going to simulate a game of life for a certain number of iterations, given a starting state. Here is a complete description of the rules of the simulation.    The universe is a bounded plane and can be simply referred to as a two-dimensional orthogonal grid of square cells with  n n  rows and  m m  columns. For convenience, we let row indexes as 0 to  n-1 n-1  from top to bottom, and column indexes as 0 to  m-1 m-1  from left to right. So in total, there are  n \\times m n \\times m  cells.    The neighbor of a cell is defined as the eight cells that are either horizontally, vertically, or diagonally connected to the cell.    An initial state is given, with each cell is marked as either \"live\" or \"dead\".    In each iteration, a cell may switch its state, according to rules below, by referring to the state of the previous iteration:   Any live cell with fewer than two live neighbors becomes dead  Any live cell with two or three live neighbors remains alive.  Any live cell with more than three live neighbors becomes dead.  Any dead cell with exactly three live neighbors becomes alive  Border cells, i.e., cells with row number 0 or  n-1 n-1 , or column number 0 or  m-1 m-1 , are always dead. This is to simplify and bound the universe.     Write a program  life  that reads, from the standard inputs, three positive integers  n n  ( n > 2 n > 2 ),  m m  ( m > 2 m > 2 ) and  k k , where  n n  and  m m  denotes the number of rows and number of columns of the universe (an  n\\times m n\\times m  grid), and  k k  is the number of iterations to simulate.  It then reads, from the standard input,  n n  rows, with  m m  characters in each row representing the initial state.  Each character is either alive ( '#' ) or dead ( '.' ).   The program then prints, to standard output, an animation of the universe for  k k  iterations.  The output should only contain  n n  rows with  m m  characters in each row.  Similarly, you must use  #  to represent a live cell, and  .  to represents a dead cell.",
            "title": "Question 2: Life (15 marks)"
        },
        {
            "location": "/as05/index.html#animation-on-screen",
            "text": "We have provided a few lines of code in the skeleton file.  You should insert this at appropriate places:  1\n2\n3\n4\n5   char clear_screen[] = { 27, '[', '2', 'J',27, '[', ';', 'H'};\n     :\n  cs1010_print_string(clear_screen);\n  // TODO(by student) draw the universe\n  usleep(250*1000);   Line 1 in the code above defines a special string that, when printed, will clear the screen and place the cursor on the top left corner of the terminal.   Line 5 calls the system function  usleep  that takes in the number of microseconds.  Calling  usleep  causes the program to pause for that amount of time.  We set the sleeping time to 250ms.  You can reduce if you wish but you must not increase this beyond 250ms or your program might fail when we test it during grading.",
            "title": "Animation on Screen"
        },
        {
            "location": "/as05/index.html#sample-inputs",
            "text": "The pattern from  life.1.in  is called a blinker.\n      The pattern from  life.2.in  is called a pentadecathlon.\n      The pattern from  life.4.in  is called a pulsar.\n      We provide a total of seven patterns for your to play with.    If you wish the check if your output is correct, you can still redirect the output from  life  to a file, and compare it with the corresponding output under the output directory using the  diff  command:  1\n2 ooiwt@pe119:~/as05-skeleton$ ./life < inputs/life.3.in > OUT\nooiwt@pe119:~/as05-skeleton$ diff OUT outputs/life.3.out   If  diff  does not list any differences, then the output from your  life  is the same as the expected output.  Students interested to play more game of life can also check out  LifeWiki  for more patterns and spiral-click into various information about this game.",
            "title": "Sample Inputs"
        },
        {
            "location": "/as05-comments/index.html",
            "text": "Assignment 5: Comments\n\n\nNotes on Marking Schemes\n\n\n\n\nWe apply the penalty to each program independently, i.e., the same mistake repeated in the different program get penalized multiple times.  \n\n\n\n\nYou will receive 0 marks if your program cannot be compiled or is plagiarised from another.\n\n\n\n\n\n\nCode that fails all test cases and showing that student does not understand the basic concepts receives 0 marks straight away.\n\n\n\n\n\n\nFor the rest, we start with full marks and start deducting marks for each error.\n\n\n\n\n\n\nWhile the teaching team tries to ensure fair and consistent grading of assignments across all groups, each TA can, at his/her own discretion, and with the approval of Wei Tsang, adjust the grading criteria to align with the messages that they sent to the students in their tutorial group.\n\n\n\n\n\n\nStyle\n\n\nNo style marks are allocated for each question, but if you code is hard to understand, not properly indented, use non-descriptive variable names, etc, we will deduct up to 2 marks. \n\n\nTo be safe, please follow strictly the CS1010 coding standards.\n\n\nDocumentation\n\n\nTwo marks are allocated for each question. We do not penalize for formatting errors violation in Assignment 5.  If you did not document your function, parameters, return values, or document wrongly (e.g., confused between \n@param[out]\n with \n@return\n, you will get a deduction of 1 mark.  You get 0 if there is no documentation at all.  \n\n\nThe following are common formatting errors:\n\n\n\n\n@param\n command used in a comment that is not attached to a function declaration \n\n\n@return\n command used in a comment that is attached to a function returning \nvoid\n \n\n\nParameter name not found in the function declaration.  You should put the name of the variable only, exclude the type, \n*\n, \n[]\n.\n\n\nPutting \n@param\n with the parameter name, but no description of what the parameter does.\n\n\nMissing \n[in]\n, \n[out]\n, or \n[in,out]\n.  Note that there is no space after \n,\n in \n[in,out]\n. \n\n\n\n\nGeneral Mistakes\n\n\nThis penalty applies once per program (not per occurrence).\n\n\n\n\n-1 for missing type in function declaration or definition\n\n\n-1 for using \nint\n/\nlong\n instead of \nbool\n for boolean functions or variables\n\n\n-1 for using \ndouble\n instead of \nlong\n when it is not necessary (does not involve integer division).  For instance, using \ndouble\n for \ninvest.c\n during calculation is ok, using \ndouble\n for calculating the area of the box is not.\n\n\n-1 for using of \nint\n instead of \nlong\n.  Using \nint\n for this assignment is ok only for \nday\n, \nhour\n, and \nminute\n, where there is an implicit constraint on the range of the value.\n\n\n-1 for failing to use parenthesis (e.g., \na && b || c\n)\n\n\n-1 for unnecessary/unused parameters passed into a function\n\n\n-1 for unnecessary/unused variables declared\n\n\n-1 for not including @author/@group\n\n\n-1 for global variables\n\n\n-1 for unreachable code / return\n\n\n-1 for using \n==\n to compare real numbers\n\n\n-1 for using variable length array\n\n\n-1 for extra elements in the array initializers\n\n\n-1 for hardcoding the size of the array, hoping that it is big enough.\n\n\n-1 for memory leaks\n\n\n\n\nLogical Mistakes (bugs)\n\n\nIn general, -1 for each bug.\n\n\n\n\n-1 for each incorrect logical expression\n\n\n-1 for each incorrect arithmetic expression\n\n\n-1 for each incorrect use of \nif\n-\nelse\n\n\n-1 for each uninitialized variables causing incorrect output.\n\n\n-1 if program prints extra text / newline\n\n\n-1 if the program returns non-zero from \nmain\n even if the program exits successfully.\n\n\n\n\nAssignment 5: Memory Errors\n\n\nMemory leaks are memory errors are especially serious in Assignment 5.  About 70% of you have at least one memory-related bugs.  \n\n\nA common error is to allocate a 2D array like this:\n\n\n1\n2\n3\n4\n5\nchar\n \n**\nmatrix\n \n=\n \ncalloc\n(\nm\n,\n \nsizeof\n(\nchar\n \n*\n));\n\n\nfor\n \n(\ni\n \n=\n \n0\n;\n \ni\n \n<\n \nm\n;\n \ni\n \n+=\n \n1\n)\n \n{\n \n  \nmatrix\n[\ni\n]\n \n=\n \ncalloc\n(\nn\n,\n \nsizeof\n(\nchar\n));\n\n  \nmatrix\n[\ni\n]\n \n=\n \ncs1010_read_word\n();\n\n\n}\n\n\n\n\n\n\n\nNote that here you are reassigning \nmatrix[i]\n that originally points to the memory region returned by \ncalloc\n to the memory returned by \ncs1010_read_word\n.  The memory returned by \ncalloc\n is now unreachable and cannot be free.\n\n\nAfter using \nmatrix\n, you should free them \n\n\n1\n2\n3\n4\nfor\n \n(\ni\n \n=\n \n0\n;\n \ni\n \n<\n \nm\n;\n \ni\n \n+=\n \n1\n)\n \n{\n \n  \nfree\n(\nmatrix\n[\ni\n]);\n\n\n}\n\n\nfree\n(\nmatrix\n);\n\n\n\n\n\n\n\nAnother common memory error is the failure to consider the terminating null character in the allocation of string.  If your string is of size \nn\nn\n, then you need to allocate \nn+1\nn+1\n characters for the string.\n\n\nAnswer Keys\n\n\nSocial\n\n\nThis is not meant to be a hard question.  There is a similar question (where \nk\nk\n is infinity and the array is not jagged) appeared in the final exam of CS1010 Semester 2 AY17/18.  Unexpectedly, many students struggled with it as a programming assignment.  \n\n\nThere are several issues with most submissions I read.  First, many students did not separate out the representation (using a jagged array) from the operation (checking if two person is a friend).  This is despite a similar question is asked in Problem 19.2.\n\n\nIf you do not write a function similar to \ndist\n from Problem 19.2, to check if two person is a friend, then the complexity of your solution increases significantly, as you have to deal with looping through the right column or the right row.  Many bugs occur due to students forgetting to consider scanning through a row or a column.  It is easier if you write a function that looks like the following:\n\n\n1\n2\n3\n4\n5\n6\nbool\n \nis_friend\n(\nchar\n \n**\nnetwork\n,\n \nint\n \ni\n,\n \nint\n \nj\n)\n \n{\n\n  \nif\n \n(\ni\n \n>=\n \nj\n)\n \n{\n\n    \nreturn\n \nnetwork\n[\ni\n][\nj\n]\n \n==\n \nFRIEND\n;\n\n  \n}\n\n  \nreturn\n \nnetwork\n[\nj\n][\ni\n]\n \n==\n \nFRIEND\n;\n\n\n}\n\n\n\n\n\n\n\nThen you no longer have to worry about whether to traverse by row or by column!\n\n\nWith the issue of how to access a jagged array out of the way, let's focus on how to find the \nk\nk\n-hop friendships among the people.  \n\n\nSome of you tried to employ complicated methods (using recursion and advanced CS2040/C concepts such as breadth-first-search or depth-first-search) to find the \nk\nk\n-hop friendships directly.  If you managed to do it, then bravo, you have learned something beyond CS1010 and are one step ahead of your peers!  But I actually did not expect students to do this.  My approach, as usual, is to break down the problem into smaller ones that we can solve.  So let's try to find a 2-hop friendship first.  How can we build the social network of 2-hop friendship?  If two person \ni\ni\n and \nj\nj\n are not yet connected, we find a third person \nm\nm\n who is a mutual friend between the two of them.  If we can find such a third person \nm\nm\n, then \ni\ni\n and \nj\nj\n are a 2-hop friend.  We can do something like this:\n\n\n1\n2\n3\n4\n5\n6\n7\n8\nchar\n \nis_connected\n(\nlong\n \nn\n,\n \nchar\n \n**\ndegree_one\n,\n \nlong\n \ni\n,\n \nlong\n \nj\n)\n \n{\n\n  \nfor\n \n(\nint\n \nm\n \n=\n \n0\n;\n \nm\n \n<\n \nn\n;\n \nm\n \n+=\n \n1\n)\n \n{\n\n    \nif\n \n(\nis_friend\n(\ndegree_one\n,\n \ni\n,\n \nm\n)\n \n&&\n \nis_friend\n(\ndegree_one\n,\n \nm\n,\n \nj\n))\n \n{\n\n      \nreturn\n \nFRIEND\n;\n\n    \n}\n\n  \n}\n\n  \nreturn\n \nSTRANGER\n;\n\n\n}\n\n\n\n\n\n\n\n(I have #defined \nFRIEND\n to be \n'1'\n and \nSTRANGER\n to be \n'0'\n)\n\n\nNow we can just loop through every pair \ni\ni\n and \nj\nj\n \n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\nvoid\n \ncompute_degree_2\n(\nlong\n \nn\n,\n \nchar\n \n**\ndegree_one\n,\n \nchar\n \n**\ndegree_two\n)\n \n{\n\n  \nfor\n \n(\nint\n \ni\n \n=\n \n0\n;\n \ni\n \n<\n \nn\n;\n \ni\n \n+=\n \n1\n)\n \n{\n\n    \nfor\n \n(\nint\n \nj\n \n=\n \n0\n;\n \nj\n \n<=\n \ni\n;\n \nj\n \n+=\n \n1\n)\n \n{\n\n      \nif\n \n(\nis_friend\n(\ndegree_one\n,\n \ni\n,\n \nj\n))\n \n{\n\n        \ndegree_two\n[\ni\n][\nj\n]\n \n=\n \nFRIEND\n;\n\n      \n}\n \nelse\n \n{\n\n        \ndegree_two\n[\ni\n][\nj\n]\n \n=\n \nis_connected\n(\nn\n,\n \ndegree_one\n,\n \ni\n,\n \nj\n);\n\n      \n}\n\n    \n}\n\n  \n}\n\n\n}\n\n\n\n\n\n\nThere is an important point in the code above, we need to store the resulting network in a new 2D array (I called it \ndegree_two\n) instead of updating the network in place:\n\n\n1\n2\n  \n// not like this\n\n  \ndegree_one\n[\ni\n][\nj\n]\n \n=\n \nis_connected\n(\nn\n,\n \ndegree_one\n,\n \ni\n,\n \nj\n);\n\n\n\n\n\n\n\nSome students stored the results back into the original 2D array, and as a result get the wrong output.  This is the same for the next question \nlife\n -- but it is easier to visualize and see the bug in \nlife\n.\n\n\nAnd now we have constructed the social network of two hops.  How do we construct a network of three hops?  Well, a 3-hop relationship means that there must be someone \nm\nm\n, who is a 1-hop friend of \ni\ni\n and 2-hop friend of \nj\nj\n.  We can make this more general: a \nh\nh\n-hop relationship means that there must be someone \nm\nm\n who is a 1-hop friend of \ni\ni\n and (\nh-1\nh-1\n)-hop friend of \nj\nj\n.\n\n\nWe can thus modify \ncompute_degree_2\n to \ncompute_degree_h\n, making the code more general.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n/**\n\n\n * Checks if i and j has a common friend\n\n\n * @param[in] n The number of users\n\n\n * @param[in] degree_one The 1-hop friendship information\n\n\n * @param[in] degree_h The h-hop friendship information\n\n\n * @param[in] i A user\n\n\n * @param[in] j Another user\n\n\n * @return FRIEND if i and j has a (h+1)-hop connection, STRANGER otherwise.\n\n\n */\n\n\nchar\n \nis_connected\n(\nlong\n \nn\n,\n \nchar\n \n**\ndegree_one\n,\n \nchar\n \n**\ndegree_h_minus_1\n,\n \nlong\n \ni\n,\n \nlong\n \nj\n)\n \n{\n\n  \nfor\n \n(\nint\n \nm\n \n=\n \n0\n;\n \nm\n \n<\n \nn\n;\n \nm\n \n+=\n \n1\n)\n \n{\n\n    \nif\n \n(\nis_friend\n(\ndegree_one\n,\n \ni\n,\n \nm\n)\n \n&&\n \nis_friend\n(\ndegree_h_minus_1\n,\n \nm\n,\n \nj\n))\n \n{\n\n      \nreturn\n \nFRIEND\n;\n\n    \n}\n\n  \n}\n\n  \nreturn\n \nSTRANGER\n;\n\n\n}\n\n\n\n\n\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n/**\n\n\n * Computers the h-hop friendship for the whole network.\n\n\n * @param[in] n          The number of users.\n\n\n * @param[in] degree_one The 1-hop friendship network\n\n\n * @param[in] degree_h_minus_1   The (h-1)-hop friendship network\n\n\n * @param[out] degree_h   The h-hop friendship network\n\n\n */\n\n\nvoid\n \ncompute_degree_h\n(\nlong\n \nn\n,\n \nchar\n \n**\ndegree_one\n,\n \nchar\n \n**\ndegree_h_minus_1\n,\n \nchar\n \n**\ndegree_h\n)\n \n{\n\n  \nfor\n \n(\nint\n \ni\n \n=\n \n0\n;\n \ni\n \n<\n \nn\n;\n \ni\n \n+=\n \n1\n)\n \n{\n\n    \nfor\n \n(\nint\n \nj\n \n=\n \n0\n;\n \nj\n \n<=\n \ni\n;\n \nj\n \n+=\n \n1\n)\n \n{\n\n      \nif\n \n(\nis_friend\n(\ndegree_h_minus_1\n,\n \ni\n,\n \nj\n))\n \n{\n\n        \ndegree_h\n[\ni\n][\nj\n]\n \n=\n \nFRIEND\n;\n\n      \n}\n \nelse\n \n{\n\n        \ndegree_h\n[\ni\n][\nj\n]\n \n=\n \nis_connected\n(\nn\n,\n \ndegree_one\n,\n \ndegree_h_minus_1\n,\n \ni\n,\n \nj\n);\n\n      \n}\n\n    \n}\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\nNote that we need three 2D arrays now, one storing (\nh-1\nh-1\n)-hop friendship, one storing 1-hop friendship, and one more to store the newly computed \nh\nh\n-hop friendship.  Once we finish computed the \nh\nh\n-hop friendship, we do not need the array storing \n(h-1)\n(h-1)\n-hop friendship anymore and we can deallocate it (or better still, reuse it for \nh+1\nh+1\n-hop).\n\n\nFinally, we are ready to calculate the \nk\nk\n-hop friendship:\n\n\n1\n2\n3\n4\nfor\n \n(\nint\n \nh\n \n=\n \n1\n;\n \nh\n \n<\n \nk\n;\n \nh\n \n+=\n \n1\n)\n \n{\n\n  \ncompute_degree_h\n(\nn\n,\n \ndegree_one\n,\n \ndegree_h_minus_1\n,\n \ndegree_h\n);\n\n  \nswap\n(\n&\ndegree_h_minus_1\n,\n \n&\ndegree_h\n);\n\n\n}\n\n\n\n\n\n\n\nThe call to \nswap\n is how we put the results of \nh\nh\n-hop friendship into the array \ndegree_h_minus_1\n, getting ready to be read for the next loop, and get the 2D array \ndegree_h\n ready to store new results for the next loop.\n\n\nLife\n\n\nMost students do not have any problem solving \nlife\n.   The most common bugs are memory-related, which we have explained above.  The gist of the solution to \nlife\n falls on the three functions below:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n/**\n\n\n * Count the number of neighbors that is alive.\n\n\n *\n\n\n * @param[in] universe The game of life universe\n\n\n * @param[in] i The row coordinate of the current cell whose\n\n\n *              neighbors we are counting.\n\n\n * @param[in] j The column coordinate of the current cell whose\n\n\n *              neighbors we are counting.\n\n\n * @return The number of live neighbors.\n\n\n */\n\n\nint\n \ncount_live_neighbor\n(\nchar\n \n**\nuniverse\n,\n \nlong\n \ni\n,\n \nlong\n \nj\n)\n \n{\n\n  \nlong\n \ncount\n \n=\n \n0\n;\n\n  \nfor\n \n(\nlong\n \nx\n \n=\n \n-\n1\n;\n \nx\n \n<=\n \n1\n;\n \nx\n \n+=\n \n1\n)\n \n{\n\n    \nfor\n \n(\nlong\n \ny\n \n=\n \n-\n1\n;\n \ny\n \n<=\n \n1\n;\n \ny\n \n+=\n \n1\n)\n \n{\n\n      \nif\n \n(\nx\n \n!=\n \n0\n \n||\n \ny\n \n!=\n \n0\n)\n \n{\n\n        \nif\n \n(\nis_alive\n(\nuniverse\n[\ni\n+\nx\n][\nj\n+\ny\n]))\n \n{\n\n          \ncount\n \n+=\n \n1\n;\n\n        \n}\n\n      \n}\n\n    \n}\n\n  \n}\n\n  \nreturn\n \ncount\n;\n\n\n}\n\n\n\n\n\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n/**\n\n\n * Update the cell (i, j) in the universe.\n\n\n *\n\n\n * @param[in] universe The game of life universe\n\n\n * @param[in] i The row coordinate of the current cell we are updating\n\n\n * @param[in] j The column coordinate of the current cell we are updating\n\n\n * @return The new status of the cell (DEAD or LIVE)\n\n\n */\n\n\nchar\n \nupdate_cell\n(\nchar\n \n**\nuniverse\n,\n \nlong\n \ni\n,\n \nlong\n \nj\n)\n \n{\n\n  \nint\n \nlive_neighbor_count\n \n=\n \ncount_live_neighbor\n(\nuniverse\n,\n \ni\n,\n \nj\n);\n\n  \nif\n \n(\nis_alive\n(\nuniverse\n[\ni\n][\nj\n]))\n \n{\n\n    \nif\n \n(\nlive_neighbor_count\n \n<\n \n2\n \n||\n \nlive_neighbor_count\n \n>\n \n3\n)\n \n{\n\n      \nreturn\n \nDEAD\n;\n\n    \n}\n\n  \n}\n \nelse\n \n{\n\n    \nif\n \n(\nlive_neighbor_count\n \n==\n \n3\n)\n \n{\n\n      \nreturn\n \nLIVE\n;\n\n    \n}\n\n  \n}\n\n  \nreturn\n \nuniverse\n[\ni\n][\nj\n];\n\n\n}\n\n\n\n\n\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n/**\n\n\n * Simulate one step of the game of life.\n\n\n *\n\n\n * @param[in] nrows The number of rows\n\n\n * @param[in] ncols The number of columns\n\n\n * @param[in] universe The curr game of life universe\n\n\n * @param[out] new_universe The updated game of life universe\n\n\n */\n\n\nvoid\n \nsimulate_game\n(\nlong\n \nnrows\n,\n \nlong\n \nncols\n,\n \nchar\n \n**\nuniverse\n,\n \nchar\n \n**\nnext_universe\n)\n \n{\n\n  \nfor\n \n(\nlong\n \ni\n \n=\n \n1\n;\n \ni\n \n<\n \nnrows\n-\n1\n;\n \ni\n \n+=\n \n1\n)\n \n{\n\n    \nfor\n \n(\nlong\n \nj\n \n=\n \n1\n;\n \nj\n \n<\n \nncols\n-\n1\n;\n \nj\n \n+=\n \n1\n)\n \n{\n\n      \nnext_universe\n[\ni\n][\nj\n]\n \n=\n \nupdate_cell\n(\nuniverse\n,\n \ni\n,\n \nj\n);\n\n    \n}\n\n  \n}\n\n\n}",
            "title": "5. Comments and Answer Keys"
        },
        {
            "location": "/as05-comments/index.html#assignment-5-comments",
            "text": "",
            "title": "Assignment 5: Comments"
        },
        {
            "location": "/as05-comments/index.html#notes-on-marking-schemes",
            "text": "We apply the penalty to each program independently, i.e., the same mistake repeated in the different program get penalized multiple times.     You will receive 0 marks if your program cannot be compiled or is plagiarised from another.    Code that fails all test cases and showing that student does not understand the basic concepts receives 0 marks straight away.    For the rest, we start with full marks and start deducting marks for each error.    While the teaching team tries to ensure fair and consistent grading of assignments across all groups, each TA can, at his/her own discretion, and with the approval of Wei Tsang, adjust the grading criteria to align with the messages that they sent to the students in their tutorial group.",
            "title": "Notes on Marking Schemes"
        },
        {
            "location": "/as05-comments/index.html#style",
            "text": "No style marks are allocated for each question, but if you code is hard to understand, not properly indented, use non-descriptive variable names, etc, we will deduct up to 2 marks.   To be safe, please follow strictly the CS1010 coding standards.",
            "title": "Style"
        },
        {
            "location": "/as05-comments/index.html#documentation",
            "text": "Two marks are allocated for each question. We do not penalize for formatting errors violation in Assignment 5.  If you did not document your function, parameters, return values, or document wrongly (e.g., confused between  @param[out]  with  @return , you will get a deduction of 1 mark.  You get 0 if there is no documentation at all.    The following are common formatting errors:   @param  command used in a comment that is not attached to a function declaration   @return  command used in a comment that is attached to a function returning  void    Parameter name not found in the function declaration.  You should put the name of the variable only, exclude the type,  * ,  [] .  Putting  @param  with the parameter name, but no description of what the parameter does.  Missing  [in] ,  [out] , or  [in,out] .  Note that there is no space after  ,  in  [in,out] .",
            "title": "Documentation"
        },
        {
            "location": "/as05-comments/index.html#general-mistakes",
            "text": "This penalty applies once per program (not per occurrence).   -1 for missing type in function declaration or definition  -1 for using  int / long  instead of  bool  for boolean functions or variables  -1 for using  double  instead of  long  when it is not necessary (does not involve integer division).  For instance, using  double  for  invest.c  during calculation is ok, using  double  for calculating the area of the box is not.  -1 for using of  int  instead of  long .  Using  int  for this assignment is ok only for  day ,  hour , and  minute , where there is an implicit constraint on the range of the value.  -1 for failing to use parenthesis (e.g.,  a && b || c )  -1 for unnecessary/unused parameters passed into a function  -1 for unnecessary/unused variables declared  -1 for not including @author/@group  -1 for global variables  -1 for unreachable code / return  -1 for using  ==  to compare real numbers  -1 for using variable length array  -1 for extra elements in the array initializers  -1 for hardcoding the size of the array, hoping that it is big enough.  -1 for memory leaks",
            "title": "General Mistakes"
        },
        {
            "location": "/as05-comments/index.html#logical-mistakes-bugs",
            "text": "In general, -1 for each bug.   -1 for each incorrect logical expression  -1 for each incorrect arithmetic expression  -1 for each incorrect use of  if - else  -1 for each uninitialized variables causing incorrect output.  -1 if program prints extra text / newline  -1 if the program returns non-zero from  main  even if the program exits successfully.",
            "title": "Logical Mistakes (bugs)"
        },
        {
            "location": "/as05-comments/index.html#assignment-5-memory-errors",
            "text": "Memory leaks are memory errors are especially serious in Assignment 5.  About 70% of you have at least one memory-related bugs.    A common error is to allocate a 2D array like this:  1\n2\n3\n4\n5 char   ** matrix   =   calloc ( m ,   sizeof ( char   * ));  for   ( i   =   0 ;   i   <   m ;   i   +=   1 )   {  \n   matrix [ i ]   =   calloc ( n ,   sizeof ( char )); \n   matrix [ i ]   =   cs1010_read_word ();  }    Note that here you are reassigning  matrix[i]  that originally points to the memory region returned by  calloc  to the memory returned by  cs1010_read_word .  The memory returned by  calloc  is now unreachable and cannot be free.  After using  matrix , you should free them   1\n2\n3\n4 for   ( i   =   0 ;   i   <   m ;   i   +=   1 )   {  \n   free ( matrix [ i ]);  }  free ( matrix );    Another common memory error is the failure to consider the terminating null character in the allocation of string.  If your string is of size  n n , then you need to allocate  n+1 n+1  characters for the string.",
            "title": "Assignment 5: Memory Errors"
        },
        {
            "location": "/as05-comments/index.html#answer-keys",
            "text": "",
            "title": "Answer Keys"
        },
        {
            "location": "/as05-comments/index.html#social",
            "text": "This is not meant to be a hard question.  There is a similar question (where  k k  is infinity and the array is not jagged) appeared in the final exam of CS1010 Semester 2 AY17/18.  Unexpectedly, many students struggled with it as a programming assignment.    There are several issues with most submissions I read.  First, many students did not separate out the representation (using a jagged array) from the operation (checking if two person is a friend).  This is despite a similar question is asked in Problem 19.2.  If you do not write a function similar to  dist  from Problem 19.2, to check if two person is a friend, then the complexity of your solution increases significantly, as you have to deal with looping through the right column or the right row.  Many bugs occur due to students forgetting to consider scanning through a row or a column.  It is easier if you write a function that looks like the following:  1\n2\n3\n4\n5\n6 bool   is_friend ( char   ** network ,   int   i ,   int   j )   { \n   if   ( i   >=   j )   { \n     return   network [ i ][ j ]   ==   FRIEND ; \n   } \n   return   network [ j ][ i ]   ==   FRIEND ;  }    Then you no longer have to worry about whether to traverse by row or by column!  With the issue of how to access a jagged array out of the way, let's focus on how to find the  k k -hop friendships among the people.    Some of you tried to employ complicated methods (using recursion and advanced CS2040/C concepts such as breadth-first-search or depth-first-search) to find the  k k -hop friendships directly.  If you managed to do it, then bravo, you have learned something beyond CS1010 and are one step ahead of your peers!  But I actually did not expect students to do this.  My approach, as usual, is to break down the problem into smaller ones that we can solve.  So let's try to find a 2-hop friendship first.  How can we build the social network of 2-hop friendship?  If two person  i i  and  j j  are not yet connected, we find a third person  m m  who is a mutual friend between the two of them.  If we can find such a third person  m m , then  i i  and  j j  are a 2-hop friend.  We can do something like this:  1\n2\n3\n4\n5\n6\n7\n8 char   is_connected ( long   n ,   char   ** degree_one ,   long   i ,   long   j )   { \n   for   ( int   m   =   0 ;   m   <   n ;   m   +=   1 )   { \n     if   ( is_friend ( degree_one ,   i ,   m )   &&   is_friend ( degree_one ,   m ,   j ))   { \n       return   FRIEND ; \n     } \n   } \n   return   STRANGER ;  }    (I have #defined  FRIEND  to be  '1'  and  STRANGER  to be  '0' )  Now we can just loop through every pair  i i  and  j j    1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11 void   compute_degree_2 ( long   n ,   char   ** degree_one ,   char   ** degree_two )   { \n   for   ( int   i   =   0 ;   i   <   n ;   i   +=   1 )   { \n     for   ( int   j   =   0 ;   j   <=   i ;   j   +=   1 )   { \n       if   ( is_friend ( degree_one ,   i ,   j ))   { \n         degree_two [ i ][ j ]   =   FRIEND ; \n       }   else   { \n         degree_two [ i ][ j ]   =   is_connected ( n ,   degree_one ,   i ,   j ); \n       } \n     } \n   }  }    There is an important point in the code above, we need to store the resulting network in a new 2D array (I called it  degree_two ) instead of updating the network in place:  1\n2    // not like this \n   degree_one [ i ][ j ]   =   is_connected ( n ,   degree_one ,   i ,   j );    Some students stored the results back into the original 2D array, and as a result get the wrong output.  This is the same for the next question  life  -- but it is easier to visualize and see the bug in  life .  And now we have constructed the social network of two hops.  How do we construct a network of three hops?  Well, a 3-hop relationship means that there must be someone  m m , who is a 1-hop friend of  i i  and 2-hop friend of  j j .  We can make this more general: a  h h -hop relationship means that there must be someone  m m  who is a 1-hop friend of  i i  and ( h-1 h-1 )-hop friend of  j j .  We can thus modify  compute_degree_2  to  compute_degree_h , making the code more general.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17 /**   * Checks if i and j has a common friend   * @param[in] n The number of users   * @param[in] degree_one The 1-hop friendship information   * @param[in] degree_h The h-hop friendship information   * @param[in] i A user   * @param[in] j Another user   * @return FRIEND if i and j has a (h+1)-hop connection, STRANGER otherwise.   */  char   is_connected ( long   n ,   char   ** degree_one ,   char   ** degree_h_minus_1 ,   long   i ,   long   j )   { \n   for   ( int   m   =   0 ;   m   <   n ;   m   +=   1 )   { \n     if   ( is_friend ( degree_one ,   i ,   m )   &&   is_friend ( degree_h_minus_1 ,   m ,   j ))   { \n       return   FRIEND ; \n     } \n   } \n   return   STRANGER ;  }     1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18 /**   * Computers the h-hop friendship for the whole network.   * @param[in] n          The number of users.   * @param[in] degree_one The 1-hop friendship network   * @param[in] degree_h_minus_1   The (h-1)-hop friendship network   * @param[out] degree_h   The h-hop friendship network   */  void   compute_degree_h ( long   n ,   char   ** degree_one ,   char   ** degree_h_minus_1 ,   char   ** degree_h )   { \n   for   ( int   i   =   0 ;   i   <   n ;   i   +=   1 )   { \n     for   ( int   j   =   0 ;   j   <=   i ;   j   +=   1 )   { \n       if   ( is_friend ( degree_h_minus_1 ,   i ,   j ))   { \n         degree_h [ i ][ j ]   =   FRIEND ; \n       }   else   { \n         degree_h [ i ][ j ]   =   is_connected ( n ,   degree_one ,   degree_h_minus_1 ,   i ,   j ); \n       } \n     } \n   }  }    Note that we need three 2D arrays now, one storing ( h-1 h-1 )-hop friendship, one storing 1-hop friendship, and one more to store the newly computed  h h -hop friendship.  Once we finish computed the  h h -hop friendship, we do not need the array storing  (h-1) (h-1) -hop friendship anymore and we can deallocate it (or better still, reuse it for  h+1 h+1 -hop).  Finally, we are ready to calculate the  k k -hop friendship:  1\n2\n3\n4 for   ( int   h   =   1 ;   h   <   k ;   h   +=   1 )   { \n   compute_degree_h ( n ,   degree_one ,   degree_h_minus_1 ,   degree_h ); \n   swap ( & degree_h_minus_1 ,   & degree_h );  }    The call to  swap  is how we put the results of  h h -hop friendship into the array  degree_h_minus_1 , getting ready to be read for the next loop, and get the 2D array  degree_h  ready to store new results for the next loop.",
            "title": "Social"
        },
        {
            "location": "/as05-comments/index.html#life",
            "text": "Most students do not have any problem solving  life .   The most common bugs are memory-related, which we have explained above.  The gist of the solution to  life  falls on the three functions below:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23 /**   * Count the number of neighbors that is alive.   *   * @param[in] universe The game of life universe   * @param[in] i The row coordinate of the current cell whose   *              neighbors we are counting.   * @param[in] j The column coordinate of the current cell whose   *              neighbors we are counting.   * @return The number of live neighbors.   */  int   count_live_neighbor ( char   ** universe ,   long   i ,   long   j )   { \n   long   count   =   0 ; \n   for   ( long   x   =   - 1 ;   x   <=   1 ;   x   +=   1 )   { \n     for   ( long   y   =   - 1 ;   y   <=   1 ;   y   +=   1 )   { \n       if   ( x   !=   0   ||   y   !=   0 )   { \n         if   ( is_alive ( universe [ i + x ][ j + y ]))   { \n           count   +=   1 ; \n         } \n       } \n     } \n   } \n   return   count ;  }     1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21 /**   * Update the cell (i, j) in the universe.   *   * @param[in] universe The game of life universe   * @param[in] i The row coordinate of the current cell we are updating   * @param[in] j The column coordinate of the current cell we are updating   * @return The new status of the cell (DEAD or LIVE)   */  char   update_cell ( char   ** universe ,   long   i ,   long   j )   { \n   int   live_neighbor_count   =   count_live_neighbor ( universe ,   i ,   j ); \n   if   ( is_alive ( universe [ i ][ j ]))   { \n     if   ( live_neighbor_count   <   2   ||   live_neighbor_count   >   3 )   { \n       return   DEAD ; \n     } \n   }   else   { \n     if   ( live_neighbor_count   ==   3 )   { \n       return   LIVE ; \n     } \n   } \n   return   universe [ i ][ j ];  }     1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15 /**   * Simulate one step of the game of life.   *   * @param[in] nrows The number of rows   * @param[in] ncols The number of columns   * @param[in] universe The curr game of life universe   * @param[out] new_universe The updated game of life universe   */  void   simulate_game ( long   nrows ,   long   ncols ,   char   ** universe ,   char   ** next_universe )   { \n   for   ( long   i   =   1 ;   i   <   nrows - 1 ;   i   +=   1 )   { \n     for   ( long   j   =   1 ;   j   <   ncols - 1 ;   j   +=   1 )   { \n       next_universe [ i ][ j ]   =   update_cell ( universe ,   i ,   j ); \n     } \n   }  }",
            "title": "Life"
        },
        {
            "location": "/as06/index.html",
            "text": "Assignment 6: Permutation 1 2 3\n\n\nDeadline\n\n\n26 October, 2018 (Friday), 23:59pm \nNew time\n\n\nPrerequisite\n\n\n\n\nYou are able to access the \nCS1010 programming environment\n.\n\n\nYou are familiar with \nbasic UNIX CLI\n and using terminal-based editor \nvim\n.\n\n\nYou have gone through Exercise 1 and have already set up your \n.gitconfig\n.\n\n\nYou are familiar with the steps of accepting, downloading, and submitting your exercise and assignment.\n\n\nYou are familiar with the directory structure and the common files included in your assignment skeleton.\n\n\n\n\nLearning Outcomes\n\n\n\n\nBe comfortable writing C programs that involve arithmetic operations, \nlong\n, \ndouble\n, \nbool\n, and \nchar\n types, conditional \nif\n/\nelse\n statements, loops with \nwhile\n/\nfor\n/\ndo-while\n statements, arrays (including 2D arrays), strings, pointers, and dynamic memory allocation.\n\n\nBe comfortable breaking down a problem into smaller subproblems which can be resolved using functions, including reusing existing functions written for other programs (with a tweak), writing a function that calls itself, designing what should the inputs and return values/types of a function be.\n\n\n(new)\n Be able to analyze the problem and come up with solutions to problems that are efficient, through eliminating redundant and repetitive work.\n\n\n\n\nSetup\n\n\n\n\nClick on this link\n to accept the assignment.\n\n\nLogin to one of the hosts of \nCS1010 programming environment\n\n\nRun:\n\n\n\n\n1\n~cs1010/get-as06\n\n\n\n\n\n\n\n\nYou should see the folder \nas06-<github id>\n in your home directory with the assignment skeleton inside.\n\n\n\n\nSolving The Assignments\n\n\n\n\nEdit the files \npermutate1.c\n, \npermutate2.c\n, \npermutate3.c\n to solve the corresponding question as described below.\n\n\nYou should break down the problem into smaller subproblems, and write one function for each of the subproblem to solve the problem.  \n\n\n(new)\n You should solve each problem using the most straightforward algorithm that you can think of first.  Make sure that it runs correctly before trying to improve the efficiency of the algorithm.\n\n\nTo compile and run tests with the sample inputs and outputs:\n\n\n\n\n1\nmake\n\n\n\n\n\n\n\n\nA minimal set of test cases\n are given in the \ninputs\n and \noutputs\n subdirectory.  You can use \ncat\n or \nless\n to look at the content of these test cases.  You \nshould\n add more test cases or edit the given ones \nto extensively test your programs\n.\n\n\n\n\nSubmission\n\n\nWhen you are ready, run the following command to submit:\n\n\n1\n~cs1010/submit-as06\n\n\n\n\n\n\nThe C files given will be uploaded to GitHub.  You can submit multiple times, but only the last submission will be graded.\n\n\n\n\nEditing Your Files in Multiple Locations\n\n\nYou should edit your code only on the CS1010 PE hosts.  If you choose to edit your code in other places, such as directly on Github or in a second location (such as your own laptop), you need to be comfortable with various \ngit\n command to synchronize your code across the different locations, possibly needing to resolve synchronization conflicts.  \n\n\n\n\nOnly the C files listed above will be submitted.  You can create additional C files for testing different solutions, but eventually, you must put your solution into the corresponding C file provided as the skeleton.\n\n\nIdentifying Yourself\n\n\nIn every C file that you submit to CS1010, you need to identify yourself by writing your name and tutorial group. Marks will be deducted if you fail to do so. You need to edit the line:\n\n\n1\n@author XXXX (Group YYYY)\n\n\n\n\n\n\nand change it to something like:\n\n\n1\n@author Sheldon Cooper (Group 09)\n\n\n\n\n\n\nGrading\n\n\nThis assignment contributes towards 3% of your final grade.  The total mark for this assignment is 30 marks.  There are four marking criteria: efficiency, correctness, documentation, and style.  \n\n\n\n\n(new)\n Efficiency: For each question, some marks are allocated for efficiency.  See the question for the breakdown and marking criteria for efficiency.\n\n\nDocumentation: For each question, two marks are allocated for documentation.  Please refer to the \ndocumentation\n and follow the recommended format.  You need to explain the purpose of every file, function, and parameter.  Logic in your code that is not obvious should be explained as well.\n\n\nCorrectness: The rest of the marks are allocated to correctness.  Note that passing the tests does not guarantee that your code is correct.  Correctness here is defined in the broad sense of using the various programming constructs in C (type, function, variable, loops, arrays, pointers, conditionals, arithmetic expressions, logical expressions) \nproperly\n, not just producing the correct output and bug-free.  \n\n\nStyle: Marks are no longer allocated for style, but we will deduct up to 2 marks if you have a serious violation of the style guideline.  Please refer to the \nCS1010 C Style Guide\n and follow the recommended guideline.\n\n\n\n\nWe reserve the right to penalize students for using banned C syntax in the assignments.  In addition, each grader at his or her own discretion can penalize students for repeating mistakes / bad practices from the student's past assignments (even if it was just a warning with no marks deducted in the earlier assignments).\n\n\nQuestion 1: Permutation 1 (6 marks)\n\n\nWrite a program \npermutation1\n, that, given two list of numbers, \nL_1\nL_1\n and \nL_2\nL_2\n, checks if \nL_2\nL_2\n is a permutation of \nL_1\nL_1\n.   We say one list is a permutation of another, if the two lists contain exactly the same numbers, but possibly in different order.  For instance, the list \n1 3 4 9 10 10\n is a permutation of \n10 9 10 3 1 4\n, since they contain the same numbers in different order.  \n\n\nYour program should read, from the standard input,\n\n\n\n\na positive integer \nn\nn\n, \n\n\na list \nL_1\nL_1\n, consists of \nn\nn\n integer values\n\n\na list \nL_2\nL_2\n, consists of \nn\nn\n integer values\n\n\n\n\nand print, to the standard output, \nYES\n if \nL_2\nL_2\n is a permutation of \nL_1\nL_1\n, and \nNO\n otherwise.\nYour solution must take no more than \nO(n^2)\nO(n^2)\n time.\n\n\nThe grading criteria for this question is:\n\n\n\n\n\n\n\n\n\n\nMarks\n\n\n\n\n\n\n\n\n\n\nDocumentation\n\n\n2\n\n\n\n\n\n\nCorrectness\n\n\n3\n\n\n\n\n\n\nEfficiency\n\n\n1\n\n\n\n\n\n\n\n\nA solution that takes longer than \nO(n^2)\nO(n^2)\n will receive 0 marks for efficiency.  Furthermore, your solution needs to be correct to receive marks for efficiency.\n\n\nQuestion 2: Permutation 2 (10 marks)\n\n\nWrite a program \npermutation2\n, that, given two strings, consists of alphabets 'a' to 'z', \nS_1\nS_1\n and \nS_2\nS_2\n, checks if \nS_2\nS_2\n is a permutation of \nS_1\nS_1\n.  We say a string is a permutation of another, if the two strings contain exactly the same alphabets, but possibly in different order.  For instance, \nnus\n is a permutation of \nsun\n.\n\n\nYour program should read, from the standard input,\n\n\n\n\na string \nS_1\nS_1\n, consists of \nn\nn\n lowercase alphabets (\na\n to \nz\n)\n\n\na string \nS_2\nS_2\n, consists of \nn\nn\n lowercase alphabets (\na\n to \nz\n)\n\n\n\n\nand print, to the standard output, \nYES\n if \nS_2\nS_2\n is a permutation of \nS_1\nS_1\n, and \nNO\n otherwise.\n\n\nYour solution must take no more than \nO(n)\nO(n)\n time.  \n\n\nThe grading criteria for this question is:\n\n\n\n\n\n\n\n\n\n\nMarks\n\n\n\n\n\n\n\n\n\n\nDocumentation\n\n\n2\n\n\n\n\n\n\nCorrectness\n\n\n3\n\n\n\n\n\n\nEfficiency\n\n\n5\n\n\n\n\n\n\n\n\nA solution that takes longer than \nO(n)\nO(n)\n will receive 0 marks for efficiency.  Furthermore, your solution needs to be correct to receive marks for efficiency.\n\n\nQuestion 3: Permutation 3 (14 marks)\n\n\nWrite a program \npermutation3\n, that, given two strings, consists of alphabets 'a' to 'z', \nS_1\nS_1\n and \nS_2\nS_2\n, checks if \nS_2\n \nS_1\nS_1\n is a permutation of some substring of \nS_1\n \nS_2\nS_2\n.  A substring of length \nk\nk\n is a consecutive sequence of \nk\nk\n characters from a string.\n\n\nFor instance, \nnus\n is a permutation of a substring of \nsuntec\n, since \nsuntec\n contains \nsun\n.  \nntu\n is also a permutation of a substring of \nsuntec\n, since \nsuntec\n contains \nunt\n.  \nsmu\n is not a permutation of any substring of \nsuntec\n.\n\n\nYour program should read, from the standard input,\n\n\n\n\na string \nS_1\nS_1\n, consists of \nk\nk\n characters, chosen from \na\n to \nz\n\n\na string \nS_2\nS_2\n, consists of \nn\nn\n characters, chosen from \na\n to \nz\n\n\n\n\nand print, to the standard output, \nYES\n if \nS_1\nS_1\n is a permutation of some substring of length \nk\nk\n from \nS_2\nS_2\n, and \nNO\n otherwise.\n\n\nThe grading criteria for this question is:\n\n\n\n\n\n\n\n\n\n\nMarks\n\n\n\n\n\n\n\n\n\n\nDocumentation\n\n\n2\n\n\n\n\n\n\nCorrectness\n\n\n5\n\n\n\n\n\n\nEfficiency\n\n\n7\n\n\n\n\n\n\n\n\nYour solution needs to be correct to receive marks for efficiency.  The efficiency marks are given as follows:\n\n\n\n\nO(nk^2)\nO(nk^2)\n solution: 2 marks\n\n\nO(nk)\nO(nk)\n solution: 4 marks\n\n\nO(n+k)\nO(n+k)\n solution: 7 marks\n\n\n\n\n\n\nHint\n\n\nAvoid repetitive work!",
            "title": "6. Permutation 1 2 3"
        },
        {
            "location": "/as06/index.html#assignment-6-permutation-1-2-3",
            "text": "",
            "title": "Assignment 6: Permutation 1 2 3"
        },
        {
            "location": "/as06/index.html#deadline",
            "text": "26 October, 2018 (Friday), 23:59pm  New time",
            "title": "Deadline"
        },
        {
            "location": "/as06/index.html#prerequisite",
            "text": "You are able to access the  CS1010 programming environment .  You are familiar with  basic UNIX CLI  and using terminal-based editor  vim .  You have gone through Exercise 1 and have already set up your  .gitconfig .  You are familiar with the steps of accepting, downloading, and submitting your exercise and assignment.  You are familiar with the directory structure and the common files included in your assignment skeleton.",
            "title": "Prerequisite"
        },
        {
            "location": "/as06/index.html#learning-outcomes",
            "text": "Be comfortable writing C programs that involve arithmetic operations,  long ,  double ,  bool , and  char  types, conditional  if / else  statements, loops with  while / for / do-while  statements, arrays (including 2D arrays), strings, pointers, and dynamic memory allocation.  Be comfortable breaking down a problem into smaller subproblems which can be resolved using functions, including reusing existing functions written for other programs (with a tweak), writing a function that calls itself, designing what should the inputs and return values/types of a function be.  (new)  Be able to analyze the problem and come up with solutions to problems that are efficient, through eliminating redundant and repetitive work.",
            "title": "Learning Outcomes"
        },
        {
            "location": "/as06/index.html#setup",
            "text": "Click on this link  to accept the assignment.  Login to one of the hosts of  CS1010 programming environment  Run:   1 ~cs1010/get-as06    You should see the folder  as06-<github id>  in your home directory with the assignment skeleton inside.",
            "title": "Setup"
        },
        {
            "location": "/as06/index.html#solving-the-assignments",
            "text": "Edit the files  permutate1.c ,  permutate2.c ,  permutate3.c  to solve the corresponding question as described below.  You should break down the problem into smaller subproblems, and write one function for each of the subproblem to solve the problem.    (new)  You should solve each problem using the most straightforward algorithm that you can think of first.  Make sure that it runs correctly before trying to improve the efficiency of the algorithm.  To compile and run tests with the sample inputs and outputs:   1 make    A minimal set of test cases  are given in the  inputs  and  outputs  subdirectory.  You can use  cat  or  less  to look at the content of these test cases.  You  should  add more test cases or edit the given ones  to extensively test your programs .",
            "title": "Solving The Assignments"
        },
        {
            "location": "/as06/index.html#submission",
            "text": "When you are ready, run the following command to submit:  1 ~cs1010/submit-as06   The C files given will be uploaded to GitHub.  You can submit multiple times, but only the last submission will be graded.   Editing Your Files in Multiple Locations  You should edit your code only on the CS1010 PE hosts.  If you choose to edit your code in other places, such as directly on Github or in a second location (such as your own laptop), you need to be comfortable with various  git  command to synchronize your code across the different locations, possibly needing to resolve synchronization conflicts.     Only the C files listed above will be submitted.  You can create additional C files for testing different solutions, but eventually, you must put your solution into the corresponding C file provided as the skeleton.",
            "title": "Submission"
        },
        {
            "location": "/as06/index.html#identifying-yourself",
            "text": "In every C file that you submit to CS1010, you need to identify yourself by writing your name and tutorial group. Marks will be deducted if you fail to do so. You need to edit the line:  1 @author XXXX (Group YYYY)   and change it to something like:  1 @author Sheldon Cooper (Group 09)",
            "title": "Identifying Yourself"
        },
        {
            "location": "/as06/index.html#grading",
            "text": "This assignment contributes towards 3% of your final grade.  The total mark for this assignment is 30 marks.  There are four marking criteria: efficiency, correctness, documentation, and style.     (new)  Efficiency: For each question, some marks are allocated for efficiency.  See the question for the breakdown and marking criteria for efficiency.  Documentation: For each question, two marks are allocated for documentation.  Please refer to the  documentation  and follow the recommended format.  You need to explain the purpose of every file, function, and parameter.  Logic in your code that is not obvious should be explained as well.  Correctness: The rest of the marks are allocated to correctness.  Note that passing the tests does not guarantee that your code is correct.  Correctness here is defined in the broad sense of using the various programming constructs in C (type, function, variable, loops, arrays, pointers, conditionals, arithmetic expressions, logical expressions)  properly , not just producing the correct output and bug-free.    Style: Marks are no longer allocated for style, but we will deduct up to 2 marks if you have a serious violation of the style guideline.  Please refer to the  CS1010 C Style Guide  and follow the recommended guideline.   We reserve the right to penalize students for using banned C syntax in the assignments.  In addition, each grader at his or her own discretion can penalize students for repeating mistakes / bad practices from the student's past assignments (even if it was just a warning with no marks deducted in the earlier assignments).",
            "title": "Grading"
        },
        {
            "location": "/as06/index.html#question-1-permutation-1-6-marks",
            "text": "Write a program  permutation1 , that, given two list of numbers,  L_1 L_1  and  L_2 L_2 , checks if  L_2 L_2  is a permutation of  L_1 L_1 .   We say one list is a permutation of another, if the two lists contain exactly the same numbers, but possibly in different order.  For instance, the list  1 3 4 9 10 10  is a permutation of  10 9 10 3 1 4 , since they contain the same numbers in different order.    Your program should read, from the standard input,   a positive integer  n n ,   a list  L_1 L_1 , consists of  n n  integer values  a list  L_2 L_2 , consists of  n n  integer values   and print, to the standard output,  YES  if  L_2 L_2  is a permutation of  L_1 L_1 , and  NO  otherwise.\nYour solution must take no more than  O(n^2) O(n^2)  time.  The grading criteria for this question is:      Marks      Documentation  2    Correctness  3    Efficiency  1     A solution that takes longer than  O(n^2) O(n^2)  will receive 0 marks for efficiency.  Furthermore, your solution needs to be correct to receive marks for efficiency.",
            "title": "Question 1: Permutation 1 (6 marks)"
        },
        {
            "location": "/as06/index.html#question-2-permutation-2-10-marks",
            "text": "Write a program  permutation2 , that, given two strings, consists of alphabets 'a' to 'z',  S_1 S_1  and  S_2 S_2 , checks if  S_2 S_2  is a permutation of  S_1 S_1 .  We say a string is a permutation of another, if the two strings contain exactly the same alphabets, but possibly in different order.  For instance,  nus  is a permutation of  sun .  Your program should read, from the standard input,   a string  S_1 S_1 , consists of  n n  lowercase alphabets ( a  to  z )  a string  S_2 S_2 , consists of  n n  lowercase alphabets ( a  to  z )   and print, to the standard output,  YES  if  S_2 S_2  is a permutation of  S_1 S_1 , and  NO  otherwise.  Your solution must take no more than  O(n) O(n)  time.    The grading criteria for this question is:      Marks      Documentation  2    Correctness  3    Efficiency  5     A solution that takes longer than  O(n) O(n)  will receive 0 marks for efficiency.  Furthermore, your solution needs to be correct to receive marks for efficiency.",
            "title": "Question 2: Permutation 2 (10 marks)"
        },
        {
            "location": "/as06/index.html#question-3-permutation-3-14-marks",
            "text": "Write a program  permutation3 , that, given two strings, consists of alphabets 'a' to 'z',  S_1 S_1  and  S_2 S_2 , checks if  S_2   S_1 S_1  is a permutation of some substring of  S_1   S_2 S_2 .  A substring of length  k k  is a consecutive sequence of  k k  characters from a string.  For instance,  nus  is a permutation of a substring of  suntec , since  suntec  contains  sun .   ntu  is also a permutation of a substring of  suntec , since  suntec  contains  unt .   smu  is not a permutation of any substring of  suntec .  Your program should read, from the standard input,   a string  S_1 S_1 , consists of  k k  characters, chosen from  a  to  z  a string  S_2 S_2 , consists of  n n  characters, chosen from  a  to  z   and print, to the standard output,  YES  if  S_1 S_1  is a permutation of some substring of length  k k  from  S_2 S_2 , and  NO  otherwise.  The grading criteria for this question is:      Marks      Documentation  2    Correctness  5    Efficiency  7     Your solution needs to be correct to receive marks for efficiency.  The efficiency marks are given as follows:   O(nk^2) O(nk^2)  solution: 2 marks  O(nk) O(nk)  solution: 4 marks  O(n+k) O(n+k)  solution: 7 marks    Hint  Avoid repetitive work!",
            "title": "Question 3: Permutation 3 (14 marks)"
        },
        {
            "location": "/as06-comments/index.html",
            "text": "Assignment 6: Comments\n\n\nNotes on Marking Schemes\n\n\nFor brevity, I won't repeat the detailed marking scheme, as it is the same as before.  One major change is that we start to deduct marks for documentation format errors.\n\n\nThe other major change is that we start to award marks based on the efficiency of the solution.\n\n\nPermutation 1\n\n\nIf the code does not produce the correct output, 0 marks for both efficiency and correctness.\n\n\nIf the code produces the correct output, give up to 3 marks for correctness. If the solution is in O(n^2), then add 1 marks for efficiency. If it is slower than O(n^2), 0 marks for efficiency.\n\n\nPermutation 2\n\n\nIf the code does not produce the correct output, 0 marks for both efficiency and correctness.\n\n\nIf the code produces the correct output, then give up to 3 marks for correctness. If the solution is in O(n), then add 5 marks for efficiency. If it is slower than O(n), 0 marks for efficiency.\n\n\nIf the code does unnecessary or repetitive work (e.g., compute strlen repeatedly even if the string does not change). We may deduct 1 mark per occurrence of such inefficient code even if the code still runs in the same big O.\n\n\nPermutation 3\n\n\nIf the code does not produce the correct output, 0 marks for both efficiency and correctness.\n\n\nIf the code produces the correct output, then give up to 5 marks for correctness. Maximum marks for efficiency: 2 for O(nk^2) solution, 4 for O(nk) and 7 for O(n+k).\n\n\nSame as before, if students are doing unnecessary work or repetitive work (e.g., compute strlen repeatedly even if the string does not change). You can deduct 1 mark per occurrence of such inefficient code even if the code still runs in the same big O (they have been told).\n\n\nAnswer Keys\n\n\nPermutation 1\n\n\nThis is an easy question since the limit for this is \nO(n^2)\nO(n^2)\n.  There are many different ways to solve this.  A solution is to sort the input arrays using either selection sort, bubble sort, or insertion sort then checks if both arrays are equal.  If you know of a faster sort (quick sort or merge sort -- CS2040C stuff) then you can actually solve this in \nO(n \\log n)\nO(n \\log n)\n time.\n\n\nAnother approach is the following: for every element in \nL_1\nL_1\n, look for it in \nL_2\nL_2\n, then remove the matched element from the \nL_2\nL_2\n.  If we can find every element of \nL_1\nL_1\n in \nL_2\nL_2\n, then they are a permutation of each other.\n\n\nThe tricky part here is how to remove the matched element in \nL_2\nL_2\n.  If you remove the matched element by shifting the elements in \nL_2\nL_2\n to \"cover the hole\", you will end up with a \nO(n^3)\nO(n^3)\n algorithm.  You might also want to erase the element by setting the element to 0 or -1 (similar to \nmastermind\n).  But, since 0 and -1 are both valid inputs, we can't distinguish between an erased element and a valid input in this case.   A better way is to move the matched element to the end of the array (similar to selection sort) and don't check it again.  \n\n\nSome students take the solution for Permutation 2 and apply it to Permutation 1.  This does not work, since for Permutation 2 the range of the elements is small (lowercase alphabets), while for Permutation 1, it's all possible integers!  \n\n\nPermutation 2\n\n\nWe can solve Permutation 2 using the same solution as Permutation 1 -- sorting the input arrays and then checking if they are equal.  But since the range of the elements is small (only 26 possibilities), we can use counting sort.  Actually, we do not even need to sort!  We just count how many times each alphabet appears in \nS_1\nS_1\n and in \nS_2\nS_2\n.  If every alphabet appears the same number of times in \nS_1\nS_1\n and in \nS_2\nS_2\n, then \nS_2\nS_2\n is a permutation of \nS_1\nS_1\n.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n/**\n\n\n * Initialize a frequency array counting how many times each letter\n\n\n * appears in a string.\n\n\n *\n\n\n * @param[in] len The length of the string.\n\n\n * @param[in] s The string\n\n\n * @param[out] freq The frequency array.\n\n\n */\n\n\nvoid\n \nbuild_frequency_array\n(\nlong\n \nlen\n,\n \nconst\n \nchar\n \ns\n[\nlen\n],\n \nlong\n \nfreq\n[\n26\n])\n \n{\n\n  \nfor\n \n(\nlong\n \ni\n \n=\n \n0\n;\n \ni\n \n<\n \n26\n;\n \ni\n \n+=\n \n1\n)\n \n{\n\n    \nfreq\n[\ni\n]\n \n=\n \n0\n;\n\n  \n}\n\n  \nfor\n \n(\nlong\n \ni\n \n=\n \n0\n;\n \ni\n \n<\n \nlen\n;\n \ni\n \n+=\n \n1\n)\n \n{\n\n    \nfreq\n[\ns\n[\ni\n]\n-\n'a'\n]\n \n+=\n \n1\n;\n\n  \n}\n\n\n}\n\n\n\n/**\n\n\n * Compares if two strings are permutation of each other, by\n\n\n * checking their frequency array.\n\n\n *\n\n\n * @param[in] freq1 The frequency array for the first string.\n\n\n * @param[in] freq2 The frequency array for the second string.\n\n\n *\n\n\n * @return true if the two strings contains the same frequency\n\n\n *         array, false otherwise.\n\n\n */\n\n\nbool\n \nis_permutation\n(\nconst\n \nlong\n \nfreq1\n[\n26\n],\n \nconst\n \nlong\n \nfreq2\n[\n26\n])\n \n{\n\n  \nfor\n \n(\nlong\n \ni\n \n=\n \n0\n;\n \ni\n \n<\n \n26\n;\n \ni\n \n+=\n \n1\n)\n \n{\n\n    \nif\n \n(\nfreq1\n[\ni\n]\n \n!=\n \nfreq2\n[\ni\n])\n \n{\n\n      \nreturn\n \nfalse\n;\n\n    \n}\n\n  \n}\n\n  \nreturn\n \ntrue\n;\n\n\n}\n\n\n\n\n\n\n\nPermutation 3\n\n\nThis is a more interesting and challenging question.  Let's see first how we can solve this naively.  A straightforward method is to find all possible substring of length \nk\nk\n from \nS_2\nS_2\n, and then use the solution to Permutation 1 to solve it.  We have to check $O(n-k) = \nO(n)\nO(n)\n such possible substrings, and each check takes \nO(k^2)\nO(k^2)\n time.  \n\n\nIf we use the solution of Permutation 2 to check each substring, each check takes \nO(k)\nO(k)\n time only, and so the total running time is \nO(nk)\nO(nk)\n.  Doing so would already give you 11 out of 14 marks!\n\n\nTo get \nO(n + k)\nO(n + k)\n time, we need a bit of analyzing to avoid redundant work.  Let's think about how we find all possible substring of length \nk\nk\n from a string \ns\n.  We can scan from left to right, checking substring \ns[0]..s[k-1]\n, then \ns[1]..s[k]\n, then \ns[2]..s[k+1]\n.  Remember that, from the solution of Permutation 2, \"checking\" means that we count how many times each alphabet appears in the string \ns[0]..s[k-1]\n, in the string \ns[1]..s[k]\n etc.  But do we really need to re-count everything everytime we check a new substring?  The principle of avoiding repetitive work applies here -- the two substrings \ns[0]..s[k-1]\n and \ns[1]..s[k]\n share a common substring \ns[1]..s[k-1]\n so we do not really need to count those alphabets again!\n\n\nAs such, we can just update incrementally the number of occurances of each alphabet, by decrementing the count for \ns[0]\n, and incrementing the count for \ns[k]\n.  As we move from \ns[1]..s[k]\n to \ns[2]..s[k+1]\n, we decrement the count for \ns[1]\n and increment the count for \ns[k+1]\n, etc.  This can be done in constant time (irrespective of \nk\nk\n and \nn\nn\n), or \nO(1)\nO(1)\n time.\n\n\nSo now, we can start by setting up an array counting how many times each of the \nk\nk\n characters appear -- this takes \nO(k)\nO(k)\n time.  Then scan through \nO(n)\nO(n)\n substring, for each one update the counting array and compare in \nO(1)\nO(1)\n time.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n/**\n\n\n * Update the frequency table for a new subtring of length k of s2,\n\n\n * starting from position start.\n\n\n *\n\n\n * @pre start >= 1 && start <= n - k.  The input string s2 contains \n\n\n *      only 'a'-'z'.\n\n\n * @param[in,out] freq The frequency table to update.\n\n\n * @param[in] s2 The string.\n\n\n * @param[in] start The beginning position of the substring.\n\n\n * @param[in] k The length of the substring.\n\n\n */\n\n\nvoid\n \nupdate_frequency\n(\nlong\n \nfreq2\n[\n26\n],\n \nconst\n \nchar\n \n*\ns2\n,\n \nint\n \nstart\n,\n \nint\n \nk\n)\n \n{\n\n  \nfreq2\n[\ns2\n[\nstart\n-\n1\n]\n-\n'a'\n]\n \n-=\n \n1\n;\n\n  \nfreq2\n[\ns2\n[\nstart\n+\nk\n-\n1\n]\n-\n'a'\n]\n \n+=\n \n1\n;\n\n\n}\n\n\n\n/**\n\n\n * Find if s1 is a permutation of a substring of s2.\n\n\n *\n\n\n * @param[in] s1 The (shorter) string.\n\n\n * @param[in] s2 The string to search for a permutation of s1 in.\n\n\n *\n\n\n * @return true if s1 is a permutation of a substring of s2.\n\n\n */\n\n\nbool\n \nfind_permutation\n(\nchar\n \n*\ns1\n,\n \nchar\n \n*\ns2\n)\n \n{\n\n  \nlong\n \nk\n \n=\n \nstrlen\n(\ns1\n);\n\n  \nlong\n \nn\n \n=\n \nstrlen\n(\ns2\n);\n\n\n  \nlong\n \nfreq1\n[\n26\n];\n\n  \nlong\n \nfreq2\n[\n26\n];\n\n\n  \nbuild_frequency_array\n(\nk\n,\n \ns1\n,\n \nfreq1\n);\n\n  \nbuild_frequency_array\n(\nk\n,\n \ns2\n,\n \nfreq2\n);\n\n\n  \nif\n \n(\nis_permutation\n(\nfreq1\n,\n \nfreq2\n))\n \n{\n\n    \nreturn\n \ntrue\n;\n\n  \n}\n\n\n  \nfor\n \n(\nlong\n \nstart\n \n=\n \n1\n;\n \nstart\n \n<=\n \nn\n \n-\n \nk\n;\n \nstart\n \n+=\n \n1\n)\n \n{\n\n    \nupdate_frequency\n(\nfreq2\n,\n \ns2\n,\n \nstart\n,\n \nk\n);\n\n    \nif\n \n(\nis_permutation\n(\nfreq1\n,\n \nfreq2\n))\n \n{\n\n      \nreturn\n \ntrue\n;\n\n    \n}\n\n  \n}\n\n  \nreturn\n \nfalse\n;\n\n\n}",
            "title": "6. Comments and Answer Keys"
        },
        {
            "location": "/as06-comments/index.html#assignment-6-comments",
            "text": "",
            "title": "Assignment 6: Comments"
        },
        {
            "location": "/as06-comments/index.html#notes-on-marking-schemes",
            "text": "For brevity, I won't repeat the detailed marking scheme, as it is the same as before.  One major change is that we start to deduct marks for documentation format errors.  The other major change is that we start to award marks based on the efficiency of the solution.",
            "title": "Notes on Marking Schemes"
        },
        {
            "location": "/as06-comments/index.html#permutation-1",
            "text": "If the code does not produce the correct output, 0 marks for both efficiency and correctness.  If the code produces the correct output, give up to 3 marks for correctness. If the solution is in O(n^2), then add 1 marks for efficiency. If it is slower than O(n^2), 0 marks for efficiency.",
            "title": "Permutation 1"
        },
        {
            "location": "/as06-comments/index.html#permutation-2",
            "text": "If the code does not produce the correct output, 0 marks for both efficiency and correctness.  If the code produces the correct output, then give up to 3 marks for correctness. If the solution is in O(n), then add 5 marks for efficiency. If it is slower than O(n), 0 marks for efficiency.  If the code does unnecessary or repetitive work (e.g., compute strlen repeatedly even if the string does not change). We may deduct 1 mark per occurrence of such inefficient code even if the code still runs in the same big O.",
            "title": "Permutation 2"
        },
        {
            "location": "/as06-comments/index.html#permutation-3",
            "text": "If the code does not produce the correct output, 0 marks for both efficiency and correctness.  If the code produces the correct output, then give up to 5 marks for correctness. Maximum marks for efficiency: 2 for O(nk^2) solution, 4 for O(nk) and 7 for O(n+k).  Same as before, if students are doing unnecessary work or repetitive work (e.g., compute strlen repeatedly even if the string does not change). You can deduct 1 mark per occurrence of such inefficient code even if the code still runs in the same big O (they have been told).",
            "title": "Permutation 3"
        },
        {
            "location": "/as06-comments/index.html#answer-keys",
            "text": "",
            "title": "Answer Keys"
        },
        {
            "location": "/as06-comments/index.html#permutation-1_1",
            "text": "This is an easy question since the limit for this is  O(n^2) O(n^2) .  There are many different ways to solve this.  A solution is to sort the input arrays using either selection sort, bubble sort, or insertion sort then checks if both arrays are equal.  If you know of a faster sort (quick sort or merge sort -- CS2040C stuff) then you can actually solve this in  O(n \\log n) O(n \\log n)  time.  Another approach is the following: for every element in  L_1 L_1 , look for it in  L_2 L_2 , then remove the matched element from the  L_2 L_2 .  If we can find every element of  L_1 L_1  in  L_2 L_2 , then they are a permutation of each other.  The tricky part here is how to remove the matched element in  L_2 L_2 .  If you remove the matched element by shifting the elements in  L_2 L_2  to \"cover the hole\", you will end up with a  O(n^3) O(n^3)  algorithm.  You might also want to erase the element by setting the element to 0 or -1 (similar to  mastermind ).  But, since 0 and -1 are both valid inputs, we can't distinguish between an erased element and a valid input in this case.   A better way is to move the matched element to the end of the array (similar to selection sort) and don't check it again.    Some students take the solution for Permutation 2 and apply it to Permutation 1.  This does not work, since for Permutation 2 the range of the elements is small (lowercase alphabets), while for Permutation 1, it's all possible integers!",
            "title": "Permutation 1"
        },
        {
            "location": "/as06-comments/index.html#permutation-2_1",
            "text": "We can solve Permutation 2 using the same solution as Permutation 1 -- sorting the input arrays and then checking if they are equal.  But since the range of the elements is small (only 26 possibilities), we can use counting sort.  Actually, we do not even need to sort!  We just count how many times each alphabet appears in  S_1 S_1  and in  S_2 S_2 .  If every alphabet appears the same number of times in  S_1 S_1  and in  S_2 S_2 , then  S_2 S_2  is a permutation of  S_1 S_1 .   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35 /**   * Initialize a frequency array counting how many times each letter   * appears in a string.   *   * @param[in] len The length of the string.   * @param[in] s The string   * @param[out] freq The frequency array.   */  void   build_frequency_array ( long   len ,   const   char   s [ len ],   long   freq [ 26 ])   { \n   for   ( long   i   =   0 ;   i   <   26 ;   i   +=   1 )   { \n     freq [ i ]   =   0 ; \n   } \n   for   ( long   i   =   0 ;   i   <   len ;   i   +=   1 )   { \n     freq [ s [ i ] - 'a' ]   +=   1 ; \n   }  }  /**   * Compares if two strings are permutation of each other, by   * checking their frequency array.   *   * @param[in] freq1 The frequency array for the first string.   * @param[in] freq2 The frequency array for the second string.   *   * @return true if the two strings contains the same frequency   *         array, false otherwise.   */  bool   is_permutation ( const   long   freq1 [ 26 ],   const   long   freq2 [ 26 ])   { \n   for   ( long   i   =   0 ;   i   <   26 ;   i   +=   1 )   { \n     if   ( freq1 [ i ]   !=   freq2 [ i ])   { \n       return   false ; \n     } \n   } \n   return   true ;  }",
            "title": "Permutation 2"
        },
        {
            "location": "/as06-comments/index.html#permutation-3_1",
            "text": "This is a more interesting and challenging question.  Let's see first how we can solve this naively.  A straightforward method is to find all possible substring of length  k k  from  S_2 S_2 , and then use the solution to Permutation 1 to solve it.  We have to check $O(n-k) =  O(n) O(n)  such possible substrings, and each check takes  O(k^2) O(k^2)  time.    If we use the solution of Permutation 2 to check each substring, each check takes  O(k) O(k)  time only, and so the total running time is  O(nk) O(nk) .  Doing so would already give you 11 out of 14 marks!  To get  O(n + k) O(n + k)  time, we need a bit of analyzing to avoid redundant work.  Let's think about how we find all possible substring of length  k k  from a string  s .  We can scan from left to right, checking substring  s[0]..s[k-1] , then  s[1]..s[k] , then  s[2]..s[k+1] .  Remember that, from the solution of Permutation 2, \"checking\" means that we count how many times each alphabet appears in the string  s[0]..s[k-1] , in the string  s[1]..s[k]  etc.  But do we really need to re-count everything everytime we check a new substring?  The principle of avoiding repetitive work applies here -- the two substrings  s[0]..s[k-1]  and  s[1]..s[k]  share a common substring  s[1]..s[k-1]  so we do not really need to count those alphabets again!  As such, we can just update incrementally the number of occurances of each alphabet, by decrementing the count for  s[0] , and incrementing the count for  s[k] .  As we move from  s[1]..s[k]  to  s[2]..s[k+1] , we decrement the count for  s[1]  and increment the count for  s[k+1] , etc.  This can be done in constant time (irrespective of  k k  and  n n ), or  O(1) O(1)  time.  So now, we can start by setting up an array counting how many times each of the  k k  characters appear -- this takes  O(k) O(k)  time.  Then scan through  O(n) O(n)  substring, for each one update the counting array and compare in  O(1) O(1)  time.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46 /**   * Update the frequency table for a new subtring of length k of s2,   * starting from position start.   *   * @pre start >= 1 && start <= n - k.  The input string s2 contains    *      only 'a'-'z'.   * @param[in,out] freq The frequency table to update.   * @param[in] s2 The string.   * @param[in] start The beginning position of the substring.   * @param[in] k The length of the substring.   */  void   update_frequency ( long   freq2 [ 26 ],   const   char   * s2 ,   int   start ,   int   k )   { \n   freq2 [ s2 [ start - 1 ] - 'a' ]   -=   1 ; \n   freq2 [ s2 [ start + k - 1 ] - 'a' ]   +=   1 ;  }  /**   * Find if s1 is a permutation of a substring of s2.   *   * @param[in] s1 The (shorter) string.   * @param[in] s2 The string to search for a permutation of s1 in.   *   * @return true if s1 is a permutation of a substring of s2.   */  bool   find_permutation ( char   * s1 ,   char   * s2 )   { \n   long   k   =   strlen ( s1 ); \n   long   n   =   strlen ( s2 ); \n\n   long   freq1 [ 26 ]; \n   long   freq2 [ 26 ]; \n\n   build_frequency_array ( k ,   s1 ,   freq1 ); \n   build_frequency_array ( k ,   s2 ,   freq2 ); \n\n   if   ( is_permutation ( freq1 ,   freq2 ))   { \n     return   true ; \n   } \n\n   for   ( long   start   =   1 ;   start   <=   n   -   k ;   start   +=   1 )   { \n     update_frequency ( freq2 ,   s2 ,   start ,   k ); \n     if   ( is_permutation ( freq1 ,   freq2 ))   { \n       return   true ; \n     } \n   } \n   return   false ;  }",
            "title": "Permutation 3"
        },
        {
            "location": "/as07/index.html",
            "text": "Assignment 7: Peak, Scripts, Inversion\n\n\nDeadline\n\n\n2 November 2018 (Friday), 23:59pm\n\n\nPrerequisites\n\n\n\n\nYou are able to access the \nCS1010 programming environment\n.\n\n\nYou are familiar with \nbasic UNIX CLI\n and using terminal-based editor \nvim\n.\n\n\nYou have gone through Exercise 1 and have already set up your \n.gitconfig\n.\n\n\nYou are familiar with the steps of accepting, downloading, and submitting your exercise and assignment.\n\n\nYou are familiar with the directory structure and the common files included in your assignment skeleton.\n\n\n\n\nLearning Outcomes\n\n\n\n\nBe comfortable writing C programs that involve arithmetic operations, \nlong\n, \ndouble\n, \nbool\n, and \nchar\n types, conditional \nif\n/\nelse\n statements, loops with \nwhile\n/\nfor\n/\ndo-while\n statements, arrays (including 2D arrays), strings, pointers, and dynamic memory allocation.\n\n\nBe comfortable designing algorithms related to solve computational problems related to searching and sorting, within the given big-O time efficiency bound.\n\n\nBe comfortable breaking down a problem into smaller subproblems which can be resolved using functions, including reusing existing functions written for other programs (with a tweak), writing a function that calls itself, designing what should the inputs and return values/types of a function be.\n\n\nBe able to analyze the problem and come up with solutions to problems that are efficient, through eliminating redundant and repetitive work.\n\n\n\n\nSetup\n\n\n\n\nClick on this link\n to accept the assignment.\n\n\nLogin to one of the hosts of \nCS1010 programming environment\n\n\nRun:\n\n\n\n\n1\n~cs1010/get-as07\n\n\n\n\n\n\n\n\nYou should see the folder \nas07-<github id>\n in your home directory with the assignment skeleton inside.\n\n\n\n\nSolving The Assignments\n\n\n\n\nEdit the files \npeak.c\n,\nscripts.c\n,\ninversion.c\n to solve the corresponding question as described below.\n\n\nYou should break down the problem into smaller subproblems, and write one function for each of the subproblem to solve the problem.  \n\n\nTo compile and run tests with the sample inputs and outputs:\n\n\n\n\n1\nmake\n\n\n\n\n\n\n\n\nA minimal set of test cases\n are given in the \ninputs\n and \noutputs\n subdirectory.  You can use \ncat\n or \nless\n to look at the content of these test cases.  You \nshould\n add more test cases or edit the given ones \nto extensively test your programs\n.\n\n\n\n\nSubmission\n\n\nWhen you are ready, run the following command to submit:\n\n\n1\n~cs1010/submit-as07\n\n\n\n\n\n\nThe C files given will be uploaded to GitHub.  You can submit multiple times, but only the last submission will be graded.\n\n\n\n\nEditing Your Files in Multiple Locations\n\n\nYou should edit your code only on the CS1010 PE hosts.  If you choose to edit your code in other places, such as directly on Github or in a second location (such as your own laptop), you need to be comfortable with various \ngit\n command to synchronize your code across the different locations, possibly needing to resolve synchronization conflicts.  \n\n\n\n\nOnly the C files listed above will be submitted.  You can create additional C files for testing different solutions, but eventually, you must put your solution into the corresponding C file provided as the skeleton.\n\n\nIdentifying Yourself\n\n\nIn every C file that you submit to CS1010, you need to identify yourself by writing your name and tutorial group. Marks will be deducted if you fail to do so. You need to edit the line:\n\n\n1\n@author XXXX (Group YYYY)\n\n\n\n\n\n\nand change it to something like:\n\n\n1\n@author Sarah J. Connor (Group 09)\n\n\n\n\n\n\nGrading\n\n\nThis assignment contributes towards \n3%\n 4% of your final grade.  The total mark for this assignment is \n 30 \n 40 marks.  There are five marking criteria: design, efficiency, correctness, documentation, and style.  \n\n\n\n\nDesign: 2 marks. You should break down your program into smaller functions, each one performs a single coherent task or solves a well-defined subproblem.  You should avoid repetitive code that can be factored out as a function.  Writing everything in a single long function \nmain\n or cutting-and-pasting code would likely cause you to loose mark for this criteria.\n\n\nEfficiency: See the question for the breakdown and marking criteria for efficiency.\n\n\nCorrectness: The rest of the marks are allocated to correctness.  Note that passing the tests does not guarantee that your code is correct.  Correctness here is defined in the broad sense of using the various programming constructs in C (type, function, variable, loops, arrays, pointers, conditionals, arithmetic expressions, logical expressions) \nproperly\n, not just producing the correct output and bug-free.  \n\n\nStyle: Marks are no longer allocated for style, but we will deduct up to 2 marks if you have a serious violation of the style guideline.  Please refer to the \nCS1010 C Style Guide\n and follow the recommended guideline.\n\n\nDocumentation: Marks are no longer allocated for documentation, but we will deduct up to 2 marks if you do not document the functions in your code properly.  Please refer to the \ndocumentation\n and follow the recommended format.  We have added the compilation flag \n-Wdocumentation\n to help you identify documentation errors.  You need to explain the purpose of every file, function, and parameter.  Logic in your code that is not obvious should be explained as well.\n\n\n\n\nWe reserve the right to penalize students for using banned C syntax in the assignments.  In addition, each grader at his or her own discretion can penalize students for repeating mistakes / bad practices from the student's past assignments (even if it was just a warning with no marks deducted in the earlier assignments).\n\n\nQuestion 1: Peak (10 marks)\n\n\nJohn helped his professor, Professor Reese, to conduct a topographic survey of a piece of land.   He walked in a straight line, noting down the elevation of the land at every centimeter. After he is done, he passed the data to Professor Reese.  The professor then asked him, \"what is the peak elevation of the land?\"  John did not know the answer!  He could write a program to scan through the millions of data points he collected, but he knew that, since you have taken CS1010, you can do a better job.  So, John asked for your help.\n\n\nYou first clarify the problem with John: \"What is a peak?\"  To which John explained that a peak is a location that is strictly higher than the surrounding locations.   You then asked: \"Is it guaranteed that there is exactly one peak?\"  John then explained the pattern in the data: the elevation always either remains the same or increases as he walks.  After he passed the peak, the elevation always either remains the same, or decreases.  But he cannot remember if he ever encountered a peak -- it might be possible that the elevations data is always non-decreasing, or non-increasing, or there is a flat plateau where there are multiple highest locations with the same elevation.  So, a peak might not exist.  But if there is a peak, it is guaranteed that there is exactly one peak.\n\n\n\"Please, can you help me solve it in \nO(log n)\nO(log n)\n time?\"  John pleaded.  \"Piece of cake!\"  You said.\n\n\nWrite a program \npeak\n that reads from the standard input the following:\n\n\n\n\nAn integer \nn\nn\n (\nn \\ge 3\nn \\ge 3\n), followed by\n\n\nn\nn\n integers, each representing the elevation of a location surveyed by John\n\n\n\n\nThen, prints, to the standard output, the index of the location of the peak if it exists, or \nno peak\n if a peak does not exist.   The first elevation has an index of 0.\n\n\nAn \nO(n)\nO(n)\n solution is trivial.  You will get 0 marks if your solution simply scans through the array linearly looking for an elevation that is the peak.  That is what John would do anyway!  To get full marks for correctness and efficiency for this solution, your code should run in \nO(log n)\nO(log n)\n time when the input elevations are all distinct.  Your code is allowed to take longer than \nO(log n)\nO(log n)\n if there are equal elevations in the input data, with the extreme case of \nO(n)\nO(n)\n when all elevation values are the same (the land is completely flat).\n\n\nSample Run\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\nooiwt@pe119:~/as07-weitsang$ cat inputs/peak.1.in\n5\n1 3 5 4 2\nooiwt@pe119:~/as07-weitsang$ ./peak < inputs/peak.1.in\n2\nooiwt@pe119:~/as07-weitsang$ cat inputs/peak.2.in\n3\n1 2 3\nooiwt@pe119:~/as07-weitsang$ ./peak < inputs/peak.2.in\nno peak\nooiwt@pe119:~/as07-weitsang$ cat inputs/peak.3.in\n4\n-1 2 2 -1\nooiwt@pe119:~/as07-weitsang$ ./peak < inputs/peak.3.in\nno peak\n\n\n\n\n\n\nQuestion 2: Scripts (10 marks)\n\n\nProfessor Reese is teaching a huge class at the university.  He finished grading a test and he asked John to help him enter the grades into IVLE grade book, in increasing order of the student id.  John asked the professor, \"Are the scripts sorted?\", to which the professor answered, \"Almost!  The top portion of the pile is sorted in increasing order.  The rest, in decreasing order.\"  The professor then left after saying \"Hasta la vista, baby,\" leaving John to wonder how to deal with the test scripts.  John needed to sort the scripts in increasing order of the student id.  So he messaged you to help him figure out an efficient algorithm to do this.  \"No problemo!\", you said, \"Can be done in \nO(n)\nO(n)\n!\"  You said.  So you went ahead and wrote out the following program to show John how he can solve his problem in \nO(n)\nO(n)\n time.\n\n\nWrite a program \nscripts\n that reads, from the standard input, the following:\n\n\n\n\nAn integer \nn\nn\n (\nn \\ge 1\nn \\ge 1\n), followed by\n\n\nn\nn\n integers, each representing the student ids.\n\n\n\n\nThe student ids are unique, i.e., there is no duplicate in the inputs.  The student ids from the inputs are arranged in such a way that, the first \nk\nk\n are in increasing order, the remaining \nn - k\nn - k\n are in decreasing order.  \nk\nk\n is not given in the input, and \n0 \\le k \\le n\n0 \\le k \\le n\n.\n\n\nThen, prints, to the standard output, the student ids in increasing order.\n\n\nAn \nO(n^2)\nO(n^2)\n or \nO(n log n)\nO(n log n)\n solution is trivial.  You will get 0 marks for correctness and efficiency if your solution simply uses one of the existing sorting algorithms to sort the scripts.  Note also that you cannot use counting sort here since a student id can be represented with an arbitrarily large integer (but still fit in a \nlong\n).   \n\n\nHint: Allocate an output array and populate it with integers taken either from the front or from the back of the input array depending on which one is larger.\n\n\nSample Run\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\nooiwt@pe119:~/as07-weitsang$ cat inputs/scripts.1.in\n5 \n1 3 5 4 2\nooiwt@pe119:~/as07-weitsang$ ./scripts < inputs/scripts.2.in\n1 2 3 4 5\nooiwt@pe119:~/as07-weitsang$ cat inputs/scripts.2.in\n3\n1 20 300\nooiwt@pe119:~/as07-weitsang$ ./scripts < inputs/scripts.2.in\n1 20 300\nooiwt@pe119:~/as07-weitsang$ cat inputs/scripts.3.in\n1\n-100\nooiwt@pe119:~/as07-weitsang$ ./scripts < inputs/scripts.3.in\n-100\n\n\n\n\n\n\nQuestion 3: Inversion (20 marks)\n\n\nProfessor Reese called John in the evening.  \"Mr. Connor, I told you that the pile of scripts is almost sorted.  But I do not know what it means by \nalmost\n actually.  Can you help me figured out how to quantify that?\"  John is clueless as well.  So he called you.  \"Ah, I learned this in CS1010 Assignment 3,\" you boasted, \"we can count the number of inversions.\"  You then go on to explain that an inversion is a pair of scripts that are out of order.  A perfectly sorted pile of scripts would have zero inversion, and an inversely sorted pile of scripts would have \nn \\times (n-1)/2\nn \\times (n-1)/2\n inversions.  \"Let me help you to do this, in \nO(n)\nO(n)\n time!\"\n\n\nWrite a program \ninversion\n that reads, from the standard input, the following:\n\n\n\n\nAn integer \nn\nn\n (\nn \\ge 1\nn \\ge 1\n), followed by\n\n\nn\nn\n integers, each representing the student ids.\n\n\n\n\nThe student ids are unique, i.e., there is no duplicate in the inputs.  The student ids from the inputs are arranged in such a way that, the first \nk\nk\n are in increasing order, the remaining \nn - k\nn - k\n are in decreasing order.  \nk\nk\n is not given in the input, and \n0 \\le k \\le n\n0 \\le k \\le n\n.\n\n\nYou program should then prints, to the standard output, the number of inversions in the input.\n\n\nYou have already solved this problem in Assignment 3 in \nO(n^2)\nO(n^2)\n time, so, an \nO(n^2)\nO(n^2)\n solution would receive 0 marks.  An \nO(n log n)\nO(n log n)\n solution will get 10 marks for correctness and efficiency at most (Hint for \nO(n log n)\nO(n log n)\n solution: binary search).  To get full marks for correctness and efficiency, you need to produce an \nO(n)\nO(n)\n solution (Hint for \nO(n)\nO(n)\n: sort).\n\n\nSample Run\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\nooiwt@pe119:~/as07-weitsang$ cat inputs/inversion.1.in\n5 \n1 3 5 4 2\nooiwt@pe119:~/as07-weitsang$ ./inversion < inputs/inversion.2.in\n4\nooiwt@pe119:~/as07-weitsang$ cat inputs/inversion.2.in\n3\n1 20 300\nooiwt@pe119:~/as07-weitsang$ ./inversion < inputs/inversion.2.in\n0\nooiwt@pe119:~/as07-weitsang$ cat inputs/inversion.3.in\n1\n-100\nooiwt@pe119:~/as07-weitsang$ ./inversion < inputs/inversion.3.in\n0\n\n\n\n\n\n\n\n\nBug in Sample Output\n\n\nIf you retrieve the assignment before 8am Saturday morning, your sample output for \ninversion.1.out\n says \n5\n, but it should be \n4\n. The inversions are \n5 4\n, \n3 2\n, \n5 2\n, and \n4 2\n.",
            "title": "7. Peak, Scripts, Inversion"
        },
        {
            "location": "/as07/index.html#assignment-7-peak-scripts-inversion",
            "text": "",
            "title": "Assignment 7: Peak, Scripts, Inversion"
        },
        {
            "location": "/as07/index.html#deadline",
            "text": "2 November 2018 (Friday), 23:59pm",
            "title": "Deadline"
        },
        {
            "location": "/as07/index.html#prerequisites",
            "text": "You are able to access the  CS1010 programming environment .  You are familiar with  basic UNIX CLI  and using terminal-based editor  vim .  You have gone through Exercise 1 and have already set up your  .gitconfig .  You are familiar with the steps of accepting, downloading, and submitting your exercise and assignment.  You are familiar with the directory structure and the common files included in your assignment skeleton.",
            "title": "Prerequisites"
        },
        {
            "location": "/as07/index.html#learning-outcomes",
            "text": "Be comfortable writing C programs that involve arithmetic operations,  long ,  double ,  bool , and  char  types, conditional  if / else  statements, loops with  while / for / do-while  statements, arrays (including 2D arrays), strings, pointers, and dynamic memory allocation.  Be comfortable designing algorithms related to solve computational problems related to searching and sorting, within the given big-O time efficiency bound.  Be comfortable breaking down a problem into smaller subproblems which can be resolved using functions, including reusing existing functions written for other programs (with a tweak), writing a function that calls itself, designing what should the inputs and return values/types of a function be.  Be able to analyze the problem and come up with solutions to problems that are efficient, through eliminating redundant and repetitive work.",
            "title": "Learning Outcomes"
        },
        {
            "location": "/as07/index.html#setup",
            "text": "Click on this link  to accept the assignment.  Login to one of the hosts of  CS1010 programming environment  Run:   1 ~cs1010/get-as07    You should see the folder  as07-<github id>  in your home directory with the assignment skeleton inside.",
            "title": "Setup"
        },
        {
            "location": "/as07/index.html#solving-the-assignments",
            "text": "Edit the files  peak.c , scripts.c , inversion.c  to solve the corresponding question as described below.  You should break down the problem into smaller subproblems, and write one function for each of the subproblem to solve the problem.    To compile and run tests with the sample inputs and outputs:   1 make    A minimal set of test cases  are given in the  inputs  and  outputs  subdirectory.  You can use  cat  or  less  to look at the content of these test cases.  You  should  add more test cases or edit the given ones  to extensively test your programs .",
            "title": "Solving The Assignments"
        },
        {
            "location": "/as07/index.html#submission",
            "text": "When you are ready, run the following command to submit:  1 ~cs1010/submit-as07   The C files given will be uploaded to GitHub.  You can submit multiple times, but only the last submission will be graded.   Editing Your Files in Multiple Locations  You should edit your code only on the CS1010 PE hosts.  If you choose to edit your code in other places, such as directly on Github or in a second location (such as your own laptop), you need to be comfortable with various  git  command to synchronize your code across the different locations, possibly needing to resolve synchronization conflicts.     Only the C files listed above will be submitted.  You can create additional C files for testing different solutions, but eventually, you must put your solution into the corresponding C file provided as the skeleton.",
            "title": "Submission"
        },
        {
            "location": "/as07/index.html#identifying-yourself",
            "text": "In every C file that you submit to CS1010, you need to identify yourself by writing your name and tutorial group. Marks will be deducted if you fail to do so. You need to edit the line:  1 @author XXXX (Group YYYY)   and change it to something like:  1 @author Sarah J. Connor (Group 09)",
            "title": "Identifying Yourself"
        },
        {
            "location": "/as07/index.html#grading",
            "text": "This assignment contributes towards  3%  4% of your final grade.  The total mark for this assignment is   30   40 marks.  There are five marking criteria: design, efficiency, correctness, documentation, and style.     Design: 2 marks. You should break down your program into smaller functions, each one performs a single coherent task or solves a well-defined subproblem.  You should avoid repetitive code that can be factored out as a function.  Writing everything in a single long function  main  or cutting-and-pasting code would likely cause you to loose mark for this criteria.  Efficiency: See the question for the breakdown and marking criteria for efficiency.  Correctness: The rest of the marks are allocated to correctness.  Note that passing the tests does not guarantee that your code is correct.  Correctness here is defined in the broad sense of using the various programming constructs in C (type, function, variable, loops, arrays, pointers, conditionals, arithmetic expressions, logical expressions)  properly , not just producing the correct output and bug-free.    Style: Marks are no longer allocated for style, but we will deduct up to 2 marks if you have a serious violation of the style guideline.  Please refer to the  CS1010 C Style Guide  and follow the recommended guideline.  Documentation: Marks are no longer allocated for documentation, but we will deduct up to 2 marks if you do not document the functions in your code properly.  Please refer to the  documentation  and follow the recommended format.  We have added the compilation flag  -Wdocumentation  to help you identify documentation errors.  You need to explain the purpose of every file, function, and parameter.  Logic in your code that is not obvious should be explained as well.   We reserve the right to penalize students for using banned C syntax in the assignments.  In addition, each grader at his or her own discretion can penalize students for repeating mistakes / bad practices from the student's past assignments (even if it was just a warning with no marks deducted in the earlier assignments).",
            "title": "Grading"
        },
        {
            "location": "/as07/index.html#question-1-peak-10-marks",
            "text": "John helped his professor, Professor Reese, to conduct a topographic survey of a piece of land.   He walked in a straight line, noting down the elevation of the land at every centimeter. After he is done, he passed the data to Professor Reese.  The professor then asked him, \"what is the peak elevation of the land?\"  John did not know the answer!  He could write a program to scan through the millions of data points he collected, but he knew that, since you have taken CS1010, you can do a better job.  So, John asked for your help.  You first clarify the problem with John: \"What is a peak?\"  To which John explained that a peak is a location that is strictly higher than the surrounding locations.   You then asked: \"Is it guaranteed that there is exactly one peak?\"  John then explained the pattern in the data: the elevation always either remains the same or increases as he walks.  After he passed the peak, the elevation always either remains the same, or decreases.  But he cannot remember if he ever encountered a peak -- it might be possible that the elevations data is always non-decreasing, or non-increasing, or there is a flat plateau where there are multiple highest locations with the same elevation.  So, a peak might not exist.  But if there is a peak, it is guaranteed that there is exactly one peak.  \"Please, can you help me solve it in  O(log n) O(log n)  time?\"  John pleaded.  \"Piece of cake!\"  You said.  Write a program  peak  that reads from the standard input the following:   An integer  n n  ( n \\ge 3 n \\ge 3 ), followed by  n n  integers, each representing the elevation of a location surveyed by John   Then, prints, to the standard output, the index of the location of the peak if it exists, or  no peak  if a peak does not exist.   The first elevation has an index of 0.  An  O(n) O(n)  solution is trivial.  You will get 0 marks if your solution simply scans through the array linearly looking for an elevation that is the peak.  That is what John would do anyway!  To get full marks for correctness and efficiency for this solution, your code should run in  O(log n) O(log n)  time when the input elevations are all distinct.  Your code is allowed to take longer than  O(log n) O(log n)  if there are equal elevations in the input data, with the extreme case of  O(n) O(n)  when all elevation values are the same (the land is completely flat).",
            "title": "Question 1: Peak (10 marks)"
        },
        {
            "location": "/as07/index.html#sample-run",
            "text": "1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15 ooiwt@pe119:~/as07-weitsang$ cat inputs/peak.1.in\n5\n1 3 5 4 2\nooiwt@pe119:~/as07-weitsang$ ./peak < inputs/peak.1.in\n2\nooiwt@pe119:~/as07-weitsang$ cat inputs/peak.2.in\n3\n1 2 3\nooiwt@pe119:~/as07-weitsang$ ./peak < inputs/peak.2.in\nno peak\nooiwt@pe119:~/as07-weitsang$ cat inputs/peak.3.in\n4\n-1 2 2 -1\nooiwt@pe119:~/as07-weitsang$ ./peak < inputs/peak.3.in\nno peak",
            "title": "Sample Run"
        },
        {
            "location": "/as07/index.html#question-2-scripts-10-marks",
            "text": "Professor Reese is teaching a huge class at the university.  He finished grading a test and he asked John to help him enter the grades into IVLE grade book, in increasing order of the student id.  John asked the professor, \"Are the scripts sorted?\", to which the professor answered, \"Almost!  The top portion of the pile is sorted in increasing order.  The rest, in decreasing order.\"  The professor then left after saying \"Hasta la vista, baby,\" leaving John to wonder how to deal with the test scripts.  John needed to sort the scripts in increasing order of the student id.  So he messaged you to help him figure out an efficient algorithm to do this.  \"No problemo!\", you said, \"Can be done in  O(n) O(n) !\"  You said.  So you went ahead and wrote out the following program to show John how he can solve his problem in  O(n) O(n)  time.  Write a program  scripts  that reads, from the standard input, the following:   An integer  n n  ( n \\ge 1 n \\ge 1 ), followed by  n n  integers, each representing the student ids.   The student ids are unique, i.e., there is no duplicate in the inputs.  The student ids from the inputs are arranged in such a way that, the first  k k  are in increasing order, the remaining  n - k n - k  are in decreasing order.   k k  is not given in the input, and  0 \\le k \\le n 0 \\le k \\le n .  Then, prints, to the standard output, the student ids in increasing order.  An  O(n^2) O(n^2)  or  O(n log n) O(n log n)  solution is trivial.  You will get 0 marks for correctness and efficiency if your solution simply uses one of the existing sorting algorithms to sort the scripts.  Note also that you cannot use counting sort here since a student id can be represented with an arbitrarily large integer (but still fit in a  long ).     Hint: Allocate an output array and populate it with integers taken either from the front or from the back of the input array depending on which one is larger.",
            "title": "Question 2: Scripts (10 marks)"
        },
        {
            "location": "/as07/index.html#sample-run_1",
            "text": "1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15 ooiwt@pe119:~/as07-weitsang$ cat inputs/scripts.1.in\n5 \n1 3 5 4 2\nooiwt@pe119:~/as07-weitsang$ ./scripts < inputs/scripts.2.in\n1 2 3 4 5\nooiwt@pe119:~/as07-weitsang$ cat inputs/scripts.2.in\n3\n1 20 300\nooiwt@pe119:~/as07-weitsang$ ./scripts < inputs/scripts.2.in\n1 20 300\nooiwt@pe119:~/as07-weitsang$ cat inputs/scripts.3.in\n1\n-100\nooiwt@pe119:~/as07-weitsang$ ./scripts < inputs/scripts.3.in\n-100",
            "title": "Sample Run"
        },
        {
            "location": "/as07/index.html#question-3-inversion-20-marks",
            "text": "Professor Reese called John in the evening.  \"Mr. Connor, I told you that the pile of scripts is almost sorted.  But I do not know what it means by  almost  actually.  Can you help me figured out how to quantify that?\"  John is clueless as well.  So he called you.  \"Ah, I learned this in CS1010 Assignment 3,\" you boasted, \"we can count the number of inversions.\"  You then go on to explain that an inversion is a pair of scripts that are out of order.  A perfectly sorted pile of scripts would have zero inversion, and an inversely sorted pile of scripts would have  n \\times (n-1)/2 n \\times (n-1)/2  inversions.  \"Let me help you to do this, in  O(n) O(n)  time!\"  Write a program  inversion  that reads, from the standard input, the following:   An integer  n n  ( n \\ge 1 n \\ge 1 ), followed by  n n  integers, each representing the student ids.   The student ids are unique, i.e., there is no duplicate in the inputs.  The student ids from the inputs are arranged in such a way that, the first  k k  are in increasing order, the remaining  n - k n - k  are in decreasing order.   k k  is not given in the input, and  0 \\le k \\le n 0 \\le k \\le n .  You program should then prints, to the standard output, the number of inversions in the input.  You have already solved this problem in Assignment 3 in  O(n^2) O(n^2)  time, so, an  O(n^2) O(n^2)  solution would receive 0 marks.  An  O(n log n) O(n log n)  solution will get 10 marks for correctness and efficiency at most (Hint for  O(n log n) O(n log n)  solution: binary search).  To get full marks for correctness and efficiency, you need to produce an  O(n) O(n)  solution (Hint for  O(n) O(n) : sort).",
            "title": "Question 3: Inversion (20 marks)"
        },
        {
            "location": "/as07/index.html#sample-run_2",
            "text": "1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15 ooiwt@pe119:~/as07-weitsang$ cat inputs/inversion.1.in\n5 \n1 3 5 4 2\nooiwt@pe119:~/as07-weitsang$ ./inversion < inputs/inversion.2.in\n4\nooiwt@pe119:~/as07-weitsang$ cat inputs/inversion.2.in\n3\n1 20 300\nooiwt@pe119:~/as07-weitsang$ ./inversion < inputs/inversion.2.in\n0\nooiwt@pe119:~/as07-weitsang$ cat inputs/inversion.3.in\n1\n-100\nooiwt@pe119:~/as07-weitsang$ ./inversion < inputs/inversion.3.in\n0    Bug in Sample Output  If you retrieve the assignment before 8am Saturday morning, your sample output for  inversion.1.out  says  5 , but it should be  4 . The inversions are  5 4 ,  3 2 ,  5 2 , and  4 2 .",
            "title": "Sample Run"
        },
        {
            "location": "/as07-comments/index.html",
            "text": "Assignment 7: Comments\n\n\nNotes on Marking Schemes\n\n\nFor brevity, I won't repeat the detailed marking scheme, as it is the same as before.  One major change is that we start to deduct marks for documentation format errors.\n\n\nThe other major change is that we start to award marks based on the efficiency of the solution.\n\n\nAnswer Keys\n\n\nPeak\n\n\nFor an array with distinct elements, we need to take \nO(\\log n)\nO(\\log n)\n steps.  This hints that we need to cut down the possiblity of where the peak is by half at every comparison.  We can do something similar to binary search -- to check the middle element, and use it to decide where the peak could be.\n\n\nHere are the six cases:\n\n\n\n\n\n\n\n\nThe more tricky case is what happen when the middle point has the same elevation on either side.  In which case, we cannot tell where the peak is and we will have to search both sides for the peak.  This is the reason why if the elevation is not distinct, then the running time is more than \nO(\\log n)\nO(\\log n)\n (but still less than \nO(n)\nO(n)\n).\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n**\n\n \n*\n \nCheck\n \nif\n \nthere\n'\ns\n \na\n \npeak\n \n(\nan\n \nelevation\n \nthat\n \nis\n \nhigher\n \nthan\n\n \n*\n \nboth\n \npoints\n \non\n \nits\n \nleft\n \nand\n \nright\n \nside\n)\n \nin\n \nthe\n \nrange\n\n \n*\n \na\n[\nstart\n]..\na\n[\nend\n].\n\n \n*\n\n \n*\n \n@\nparam\n[\nin\n]\n \na\n \nThe\n \narray\n \nof\n \nelevations\n.\n\n \n*\n \n@\nparam\n[\nin\n]\n \nstart\n \nThe\n \nstaring\n \nindex\n.\n\n \n*\n \n@\nparam\n[\nin\n]\n \nend\n \nThe\n \nending\n \nindex\n.\n\n \n*\n \n@\nreturn\n \nReturn\n \nthe\n \nindex\n \nof\n \npeak\n,\n \nor\n \nNO_PEAK\n \nif\n \nno\n \npeak\n \nexists\n\n \n*/\n\n\n#define NO_PEAK (-1)\n\n\n\nlong\n \nfind_peak\n(\nconst\n \nlong\n \na\n[],\n \nlong\n \nstart\n,\n \nlong\n \nend\n)\n \n{\n\n  \n// There is no peak if less than 3 elements.\n\n  \nif\n \n(\nend\n \n<\n \nstart\n \n+\n \n2\n)\n \n{\n\n    \nreturn\n \nNO_PEAK\n;\n\n  \n}\n\n\n  \nlong\n \nmid\n \n=\n \n(\nstart\n \n+\n \nend\n)\n \n/\n \n2\n;\n\n\n  \n// mid is higher than the nearby points, and hence it's a peak\n\n  \nif\n \n(\na\n[\nmid\n \n-\n \n1\n]\n \n<\n \na\n[\nmid\n]\n \n&&\n \na\n[\nmid\n \n+\n \n1\n]\n \n<\n \na\n[\nmid\n])\n \n{\n\n    \nreturn\n \nmid\n;\n\n  \n}\n\n\n  \n// mid is at the same height as both left and right.  We have to\n\n  \n// check both sides for peak.  Let's do the left side first.\n\n  \nif\n \n(\na\n[\nmid\n \n-\n \n1\n]\n \n==\n \na\n[\nmid\n]\n \n&&\n \na\n[\nmid\n \n+\n \n1\n]\n \n==\n \na\n[\nmid\n])\n \n{\n\n    \nlong\n \nposition\n \n=\n \nfind_peak\n(\na\n,\n \nstart\n,\n \nmid\n);\n\n    \nif\n \n(\nposition\n \n!=\n \nNO_PEAK\n)\n \n{\n\n      \nreturn\n \nposition\n;\n\n    \n}\n\n    \n// There is no peak on the left side.  Check the right side.\n\n    \nreturn\n \nfind_peak\n(\na\n,\n \nmid\n,\n \nend\n);\n\n  \n}\n\n\n  \n// Check for peak on the right side.\n\n  \nif\n \n(\na\n[\nmid\n \n-\n \n1\n]\n \n<=\n \na\n[\nmid\n]\n \n&&\n \na\n[\nmid\n \n+\n \n1\n]\n \n>=\n \na\n[\nmid\n])\n \n{\n\n    \nreturn\n \nfind_peak\n(\na\n,\n \nmid\n,\n \nend\n);\n\n  \n}\n\n\n  \n// Check for peak on the left side.\n\n  \n// { (a[mid - 1] >= a[mid] && a[mid + 1] <= a[mid]) }\n\n  \nreturn\n \nfind_peak\n(\na\n,\n \nstart\n,\n \nmid\n);\n\n\n}\n\n\n\n\n\n\n\nScripts\n\n\nThe hint for this one is actually pretty obvious. So there is nothing to say :)  Here is the code:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n/**\n\n\n * Given an array in[] of integers containing an increasing sequence\n\n\n * followed by a decresing sequence, rearrange the array so that\n\n\n * it becomes sorted.\n\n\n * @param[in]  len The length of the array in[].\n\n\n * @param[in]  in  The input array to be sorted.\n\n\n * @param[out] out The output array.\n\n\n * @pre The array in contains a (possibly empty) increasing sequence\n\n\n *      followed by a decreasing sequence.\n\n\n * @post The array out is sorted.\n\n\n */\n\n\nvoid\n \nsort\n(\nlong\n \nlen\n,\n \nconst\n \nlong\n \nin\n[\nlen\n],\n \nlong\n \n*\nout\n)\n \n{\n\n  \nlong\n \nleft\n \n=\n \n0\n;\n\n  \nlong\n \nright\n \n=\n \nlen\n \n-\n \n1\n;\n\n  \nlong\n \nout_pos\n \n=\n \n0\n;\n\n  \nwhile\n \n(\nleft\n \n<=\n \nright\n)\n \n{\n\n    \nif\n \n(\nin\n[\nleft\n]\n \n<\n \nin\n[\nright\n])\n \n{\n\n      \nout\n[\nout_pos\n]\n \n=\n \nin\n[\nleft\n];\n\n      \nleft\n \n+=\n \n1\n;\n\n    \n}\n \nelse\n \n{\n\n      \nout\n[\nout_pos\n]\n \n=\n \nin\n[\nright\n];\n\n      \nright\n \n-=\n \n1\n;\n\n    \n}\n\n    \nout_pos\n \n+=\n \n1\n;\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\nI can, however, add a few more words on this.  This algorithm, which merges two sorted array into one, is better known as, well, the merge algorithm, and it is a basic step in a fast sorting algorithm called merge sort, which runs in \nO(n \\log n)\nO(n \\log n)\n.  The basic idea of merge sort is to split an input array into two halves, recursively sort each half.  Now you have a situation similar to John's, which you can merge into a sorted array in \nO(n)\nO(n)\n time.  It's pretty cool.  You can check out the animation from \nVisualgo\n\n\nInversion\n\n\nFor 20 marks, you just need one line of code -- if you know what you are doing.  Let me show you the solution first -- which is a modified version of the \nsort\n function from \nscripts\n:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\nlong\n \ncount_inversions\n(\nlong\n \nlen\n,\n \nlong\n \nin\n[\nlen\n])\n \n{\n\n  \nlong\n \nleft\n \n=\n \n0\n;\n\n  \nlong\n \nright\n \n=\n \nlen\n \n-\n \n1\n;\n\n  \nlong\n \nsum\n \n=\n \n0\n;\n\n  \nwhile\n \n(\nleft\n \n<=\n \nright\n)\n \n{\n\n    \nif\n \n(\nin\n[\nleft\n]\n \n<\n \nin\n[\nright\n])\n \n{\n\n      \nleft\n \n+=\n \n1\n;\n\n    \n}\n \nelse\n \n{\n\n      \nsum\n \n+=\n \nright\n \n-\n \nleft\n;\n  \n// <- 20 marks\n\n      \nright\n \n-=\n \n1\n;\n\n    \n}\n\n  \n}\n\n  \nreturn\n \nsum\n;\n\n\n}\n\n\n\n\n\n\n\nLet's analyze the problem and see how to come up with this solution.\n\n\nWhen we count inversions, we need to be careful about counting every pair once.  This is something you should have learned from \nkendall\n.   So we have to decide, for an element, whether we want to count inversions to the left or to the right of the element (but not both).   In our solution, we decided to count the inversions for elements to the left -- in other words, for an element \nin[i]\n, we count the number of elements from   \nin[0]..in[i-1]\n that are bigger than \nin[i]\n.\n\n\nAn \nO(n^2)\nO(n^2)\n solution scans from \nin[0]\n to \nin[i-1]\n, for each \ni\n.  This is a double-loop solution that will given you 0 marks.  \n\n\nTo get a faster solution, let's look at an example input below:\n\n\n\n\nThe blue elements are already sorted, so each element \nin[i]\n here does not contribute to the count on the number of inversions.\n\n\nThe purple elements, however, are inversely sorted so they contributes to the number of inversions.  Every purple elements on the left of \nin[i]\n is one inversion.  But that is not all, some of the blue elements are larger than \nin[i]\n, so we have to count those inversions as well.  The figure below shows that \nin[6]\n contributes 4 to the number of inversions since there are 4 elements to its left that is larger.\n\n\n\n\nNow, the question is how to find how many blue elements are larger than \nin[i]\n.  The hints give some ideas.\n\n\nThe first hint is to use binary search.  Since the blue elements are sorted, we can use binary search to find the position in which we should insert \nin[i]\n.  (There is a in-class tutorial programming exercise on this).  That takes \nO(\\log n)\nO(\\log n)\n time for each element.  So the running time for this approach is \nO(n \\log n)\nO(n \\log n)\n.  \n\n\nThe second hint is to use sort, which we just solved in the problem \nscripts\n.  Here is the sorting algorithm, again:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\nvoid\n \nsort\n(\nlong\n \nlen\n,\n \nconst\n \nlong\n \nin\n[\nlen\n],\n \nlong\n \n*\nout\n)\n \n{\n\n  \nlong\n \nleft\n \n=\n \n0\n;\n\n  \nlong\n \nright\n \n=\n \nlen\n \n-\n \n1\n;\n\n  \nlong\n \nout_pos\n \n=\n \n0\n;\n\n  \nwhile\n \n(\nleft\n \n<=\n \nright\n)\n \n{\n\n    \nif\n \n(\nin\n[\nleft\n]\n \n<\n \nin\n[\nright\n])\n \n{\n\n      \nout\n[\nout_pos\n]\n \n=\n \nin\n[\nleft\n];\n\n      \nleft\n \n+=\n \n1\n;\n\n    \n}\n \nelse\n \n{\n\n      \nout\n[\nout_pos\n]\n \n=\n \nin\n[\nright\n];\n\n      \nright\n \n-=\n \n1\n;\n\n    \n}\n\n    \nout_pos\n \n+=\n \n1\n;\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\nWhy does this algorithm work?   This algorithm actually maintains the following invariant\n\n1\n2\n3\nEvery element in in[0]..in[left-1] < min(in[left], in[right])\nEvery element in in[right+1]..in[len-1] < min(in[left], in[right])\nEvery element in in[left+1]..in[right-1] > min(in[left], in[right])\n\n\n\n\n\nwhich is why putting the minimum of \nin[left]\n and \nin[right]\n to the output array ensures that it is in sorted order.\n\n\nThe figures below illustrate this invariant -- elements in \nin[0]..in[left-1]\n and \nin[right+1]..in[len-1]\n are in gray.\n\n\n\n\nSince we only move \nleft\n or \nright\n on the smaller of the \nin[left]\n or \nin[right]\n, the invariant is maintained in every loop. \n\n\nLet's consider the case where \nin[right] < in[left]\n.    We can simplify the invariants to:\n\n\n1\n2\n3\nEvery element in in[0]..in[left-1] < in[right]\nEvery element in in[right+1]..in[len-1] < in[right]\nEvery element in in[left]..in[right-1] > in[right] \n\n\n\n\n\n\nThe last invariant is the key to count the inversions -- we can conclude that \nin[right]\n contributes (\nright\n - 1) - \nleft\n + 1 inversions to the total count.   Hence the line:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\nlong\n \ncount_inversions\n(\nlong\n \nlen\n,\n \nlong\n \nin\n[\nlen\n])\n \n{\n\n  \nlong\n \nleft\n \n=\n \n0\n;\n\n  \nlong\n \nright\n \n=\n \nlen\n \n-\n \n1\n;\n\n  \nlong\n \nsum\n \n=\n \n0\n;\n\n  \nwhile\n \n(\nleft\n \n<=\n \nright\n)\n \n{\n\n    \nif\n \n(\nin\n[\nleft\n]\n \n<\n \nin\n[\nright\n])\n \n{\n\n      \nleft\n \n+=\n \n1\n;\n\n    \n}\n \nelse\n \n{\n\n      \nsum\n \n+=\n \nright\n \n-\n \nleft\n;\n  \n// <- 20 marks\n\n      \nright\n \n-=\n \n1\n;\n\n    \n}\n\n  \n}\n\n  \nreturn\n \nsum\n;\n\n\n}\n\n\n\n\n\n\n\nI think this question illustrates strongly my point at the very first lecture: writing code is easy, but knowing what to write is not!",
            "title": "7. Comments and Answer Keys"
        },
        {
            "location": "/as07-comments/index.html#assignment-7-comments",
            "text": "",
            "title": "Assignment 7: Comments"
        },
        {
            "location": "/as07-comments/index.html#notes-on-marking-schemes",
            "text": "For brevity, I won't repeat the detailed marking scheme, as it is the same as before.  One major change is that we start to deduct marks for documentation format errors.  The other major change is that we start to award marks based on the efficiency of the solution.",
            "title": "Notes on Marking Schemes"
        },
        {
            "location": "/as07-comments/index.html#answer-keys",
            "text": "",
            "title": "Answer Keys"
        },
        {
            "location": "/as07-comments/index.html#peak",
            "text": "For an array with distinct elements, we need to take  O(\\log n) O(\\log n)  steps.  This hints that we need to cut down the possiblity of where the peak is by half at every comparison.  We can do something similar to binary search -- to check the middle element, and use it to decide where the peak could be.  Here are the six cases:     The more tricky case is what happen when the middle point has the same elevation on either side.  In which case, we cannot tell where the peak is and we will have to search both sides for the peak.  This is the reason why if the elevation is not distinct, then the running time is more than  O(\\log n) O(\\log n)  (but still less than  O(n) O(n) ).   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45 ** \n  *   Check   if   there ' s   a   peak   ( an   elevation   that   is   higher   than \n  *   both   points   on   its   left   and   right   side )   in   the   range \n  *   a [ start ].. a [ end ]. \n  * \n  *   @ param [ in ]   a   The   array   of   elevations . \n  *   @ param [ in ]   start   The   staring   index . \n  *   @ param [ in ]   end   The   ending   index . \n  *   @ return   Return   the   index   of   peak ,   or   NO_PEAK   if   no   peak   exists \n  */  #define NO_PEAK (-1)  long   find_peak ( const   long   a [],   long   start ,   long   end )   { \n   // There is no peak if less than 3 elements. \n   if   ( end   <   start   +   2 )   { \n     return   NO_PEAK ; \n   } \n\n   long   mid   =   ( start   +   end )   /   2 ; \n\n   // mid is higher than the nearby points, and hence it's a peak \n   if   ( a [ mid   -   1 ]   <   a [ mid ]   &&   a [ mid   +   1 ]   <   a [ mid ])   { \n     return   mid ; \n   } \n\n   // mid is at the same height as both left and right.  We have to \n   // check both sides for peak.  Let's do the left side first. \n   if   ( a [ mid   -   1 ]   ==   a [ mid ]   &&   a [ mid   +   1 ]   ==   a [ mid ])   { \n     long   position   =   find_peak ( a ,   start ,   mid ); \n     if   ( position   !=   NO_PEAK )   { \n       return   position ; \n     } \n     // There is no peak on the left side.  Check the right side. \n     return   find_peak ( a ,   mid ,   end ); \n   } \n\n   // Check for peak on the right side. \n   if   ( a [ mid   -   1 ]   <=   a [ mid ]   &&   a [ mid   +   1 ]   >=   a [ mid ])   { \n     return   find_peak ( a ,   mid ,   end ); \n   } \n\n   // Check for peak on the left side. \n   // { (a[mid - 1] >= a[mid] && a[mid + 1] <= a[mid]) } \n   return   find_peak ( a ,   start ,   mid );  }",
            "title": "Peak"
        },
        {
            "location": "/as07-comments/index.html#scripts",
            "text": "The hint for this one is actually pretty obvious. So there is nothing to say :)  Here is the code:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26 /**   * Given an array in[] of integers containing an increasing sequence   * followed by a decresing sequence, rearrange the array so that   * it becomes sorted.   * @param[in]  len The length of the array in[].   * @param[in]  in  The input array to be sorted.   * @param[out] out The output array.   * @pre The array in contains a (possibly empty) increasing sequence   *      followed by a decreasing sequence.   * @post The array out is sorted.   */  void   sort ( long   len ,   const   long   in [ len ],   long   * out )   { \n   long   left   =   0 ; \n   long   right   =   len   -   1 ; \n   long   out_pos   =   0 ; \n   while   ( left   <=   right )   { \n     if   ( in [ left ]   <   in [ right ])   { \n       out [ out_pos ]   =   in [ left ]; \n       left   +=   1 ; \n     }   else   { \n       out [ out_pos ]   =   in [ right ]; \n       right   -=   1 ; \n     } \n     out_pos   +=   1 ; \n   }  }    I can, however, add a few more words on this.  This algorithm, which merges two sorted array into one, is better known as, well, the merge algorithm, and it is a basic step in a fast sorting algorithm called merge sort, which runs in  O(n \\log n) O(n \\log n) .  The basic idea of merge sort is to split an input array into two halves, recursively sort each half.  Now you have a situation similar to John's, which you can merge into a sorted array in  O(n) O(n)  time.  It's pretty cool.  You can check out the animation from  Visualgo",
            "title": "Scripts"
        },
        {
            "location": "/as07-comments/index.html#inversion",
            "text": "For 20 marks, you just need one line of code -- if you know what you are doing.  Let me show you the solution first -- which is a modified version of the  sort  function from  scripts :   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14 long   count_inversions ( long   len ,   long   in [ len ])   { \n   long   left   =   0 ; \n   long   right   =   len   -   1 ; \n   long   sum   =   0 ; \n   while   ( left   <=   right )   { \n     if   ( in [ left ]   <   in [ right ])   { \n       left   +=   1 ; \n     }   else   { \n       sum   +=   right   -   left ;    // <- 20 marks \n       right   -=   1 ; \n     } \n   } \n   return   sum ;  }    Let's analyze the problem and see how to come up with this solution.  When we count inversions, we need to be careful about counting every pair once.  This is something you should have learned from  kendall .   So we have to decide, for an element, whether we want to count inversions to the left or to the right of the element (but not both).   In our solution, we decided to count the inversions for elements to the left -- in other words, for an element  in[i] , we count the number of elements from    in[0]..in[i-1]  that are bigger than  in[i] .  An  O(n^2) O(n^2)  solution scans from  in[0]  to  in[i-1] , for each  i .  This is a double-loop solution that will given you 0 marks.    To get a faster solution, let's look at an example input below:   The blue elements are already sorted, so each element  in[i]  here does not contribute to the count on the number of inversions.  The purple elements, however, are inversely sorted so they contributes to the number of inversions.  Every purple elements on the left of  in[i]  is one inversion.  But that is not all, some of the blue elements are larger than  in[i] , so we have to count those inversions as well.  The figure below shows that  in[6]  contributes 4 to the number of inversions since there are 4 elements to its left that is larger.   Now, the question is how to find how many blue elements are larger than  in[i] .  The hints give some ideas.  The first hint is to use binary search.  Since the blue elements are sorted, we can use binary search to find the position in which we should insert  in[i] .  (There is a in-class tutorial programming exercise on this).  That takes  O(\\log n) O(\\log n)  time for each element.  So the running time for this approach is  O(n \\log n) O(n \\log n) .    The second hint is to use sort, which we just solved in the problem  scripts .  Here is the sorting algorithm, again:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15 void   sort ( long   len ,   const   long   in [ len ],   long   * out )   { \n   long   left   =   0 ; \n   long   right   =   len   -   1 ; \n   long   out_pos   =   0 ; \n   while   ( left   <=   right )   { \n     if   ( in [ left ]   <   in [ right ])   { \n       out [ out_pos ]   =   in [ left ]; \n       left   +=   1 ; \n     }   else   { \n       out [ out_pos ]   =   in [ right ]; \n       right   -=   1 ; \n     } \n     out_pos   +=   1 ; \n   }  }    Why does this algorithm work?   This algorithm actually maintains the following invariant 1\n2\n3 Every element in in[0]..in[left-1] < min(in[left], in[right])\nEvery element in in[right+1]..in[len-1] < min(in[left], in[right])\nEvery element in in[left+1]..in[right-1] > min(in[left], in[right])   which is why putting the minimum of  in[left]  and  in[right]  to the output array ensures that it is in sorted order.  The figures below illustrate this invariant -- elements in  in[0]..in[left-1]  and  in[right+1]..in[len-1]  are in gray.   Since we only move  left  or  right  on the smaller of the  in[left]  or  in[right] , the invariant is maintained in every loop.   Let's consider the case where  in[right] < in[left] .    We can simplify the invariants to:  1\n2\n3 Every element in in[0]..in[left-1] < in[right]\nEvery element in in[right+1]..in[len-1] < in[right]\nEvery element in in[left]..in[right-1] > in[right]    The last invariant is the key to count the inversions -- we can conclude that  in[right]  contributes ( right  - 1) -  left  + 1 inversions to the total count.   Hence the line:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14 long   count_inversions ( long   len ,   long   in [ len ])   { \n   long   left   =   0 ; \n   long   right   =   len   -   1 ; \n   long   sum   =   0 ; \n   while   ( left   <=   right )   { \n     if   ( in [ left ]   <   in [ right ])   { \n       left   +=   1 ; \n     }   else   { \n       sum   +=   right   -   left ;    // <- 20 marks \n       right   -=   1 ; \n     } \n   } \n   return   sum ;  }    I think this question illustrates strongly my point at the very first lecture: writing code is easy, but knowing what to write is not!",
            "title": "Inversion"
        },
        {
            "location": "/as08/index.html",
            "text": "Assignment 8: Maze, Fill\n\n\nDeadline\n\n\n9 November 2018 (Friday), 23:59 pm\n\n\nPrerequisites\n\n\n\n\nYou are able to access the \nCS1010 programming environment\n.\n\n\nYou are familiar with \nbasic UNIX CLI\n and using terminal-based editor \nvim\n.\n\n\nYou have gone through Exercise 1 and have already set up your \n.gitconfig\n.\n\n\nYou are familiar with the steps of accepting, downloading, and submitting your exercise and assignment.\n\n\nYou are familiar with the directory structure and the common files included in your assignment skeleton.\n\n\n\n\nLearning Outcomes\n\n\n\n\nBe comfortable writing C programs that involve arithmetic operations, \nlong\n, \ndouble\n, \nbool\n, and \nchar\n types, conditional \nif\n/\nelse\n statements, loops with \nwhile\n/\nfor\n/\ndo-while\n statements, arrays (including 2D arrays), strings, pointers, and dynamic memory allocation.\n\n\n{++Be able to design and implement recursive search algorithms with correct pruning to prevent repetitive or redunant work.\n\n\nBe comfortable breaking down a problem into smaller subproblems which can be resolved using functions, including reusing existing functions written for other programs (with a tweak), writing a function that calls itself, designing what should the inputs and return values/types of a function be.\n\n\nBe able to analyze the problem and come up with solutions to problems that are efficient, through eliminating redundant and repetitive work.\n\n\n\n\nSetup\n\n\n\n\nAccept the assignment\n\n\nLogin to one of the hosts of \nCS1010 programming environment\n\n\nRun:\n\n\n\n\n1\n~cs1010/get-as08\n\n\n\n\n\n\n\n\nYou should see the folder \nas08-<github id>\n in your home directory with the assignment skeleton inside.\n\n\n\n\nSolving The Assignments\n\n\n\n\nEdit the C files to solve the corresponding question as described below.\n\n\nYou should break down the problem into smaller subproblems, and write one function for each of the subproblem to solve the problem.  \n\n\nTo compile and run tests with the sample inputs and outputs:\n\n\n\n\n1\nmake\n\n\n\n\n\n\n\n\nA minimal set of test cases are given in the \ninputs\n and \noutputs\n subdirectory.  You can use \ncat\n or \nless\n to look at the content of these test cases.  You should add more test cases or edit the given ones to extensively test your programs.\n\n\n\n\nSubmission\n\n\nWhen you are ready, run the following command to submit:\n\n\n1\n~cs1010/submit-as08\n\n\n\n\n\n\nThe C files given will be uploaded to GitHub.  You can submit multiple times, but only the last submission will be graded.\n\n\n\n\nEditing Your Files in Multiple Locations\n\n\nYou should edit your code only on the CS1010 PE hosts.  If you choose to edit your code in other places, such as directly on Github or in a second location (such as your own laptop), you need to be comfortable with various \ngit\n command to synchronize your code across the different locations, possibly needing to resolve synchronization conflicts.  \n\n\nOnly the C files listed above will be submitted.  You can create additional C files for testing different solutions, but eventually, you must put your solution into the corresponding C file provided as the skeleton.\n\n\n\n\nIdentifying Yourself\n\n\nIn every C file that you submit to CS1010, you need to identify yourself by writing your name and tutorial group. Marks will be deducted if you fail to do so. You need to edit the line:\n\n\n1\n@author XXXX (Group YYYY)\n\n\n\n\n\n\nand change it to something like:\n\n\n1\n@author Fox Mulder\n\n\n\n\n\n\nGrading\n\n\nThis assignment contributes towards 3% of your final grade.  The total mark for this assignment is 30 marks.  There are five marking criteria: design, efficiency, correctness, documentation, and style.  \n\n\n\n\nDesign: 2 marks. You should break down your program into smaller functions, each one performs a single coherent task or solves a well-defined subproblem.  You should avoid repetitive code that can be factored out as a function.  Writing everything in a single long function \nmain\n or cutting-and-pasting code would likely cause you to lose marks for this criteria.\n\n\nEfficiency: See the question for the breakdown and marking criteria for efficiency.\n\n\nCorrectness: The rest of the marks are allocated to correctness.  Note that passing the tests does not guarantee that your code is correct.  Correctness here is defined in the broad sense of using the various programming constructs in C (type, function, variable, loops, arrays, pointers, conditionals, arithmetic expressions, logical expressions) \nproperly\n, not just producing the correct output and bug-free.  \n\n\nStyle: Marks are no longer allocated for style, but we will deduct up to 2 marks if you have a serious violation of the style guideline.  Please refer to the \nCS1010 C Style Guide\n and follow the recommended guideline.\n\n\nDocumentation: Marks are no longer allocated for documentation, but we will deduct up to 2 marks if you do not document the functions in your code properly.  Please refer to the \ndocumentation\n and follow the recommended format.  We have added the compilation flag \n-Wdocumentation\n to help you identify documentation errors.  You need to explain the purpose of every file, function, and parameter.  Logic in your code that is not obvious should be explained as well.\n\n\n\n\nWe reserve the right to penalize students for using banned C syntax in the assignments.  In addition, each grader at his or her own discretion can penalize students for repeating mistakes / bad practices from the student's past assignments (even if it was just a warning with no marks deducted in the earlier assignments).\n\n\nQuestion 1: Maze (15 marks)\n\n\nAgent Scully woke up and found herself in the dark.  She figured out that she is in a maze.  She has to find her way out, if there is one!\n\n\nThe maze can be simplified as a \nm \\times n\nm \\times n\n cells. Each cell can be of the following:\n\n\n\n\n'#' denotes a segment of a wall.  Noone can pass through the walls.\n\n\n'.' denotes an empty space\n\n\n'@' denotes where Scully is at currently. It is also an empty space\n\n\n\n\nAnytime Scully reaches a border cell (a cell in either the top-most or bottom-most row or left-most or right-most column), she escapes the maze and can go save her partner Agent Mulder.  She can only move from one empty space to another adjacent cell in one step.  Two cells are adjacent if they share a common edge. \n\n\nScully took CS1010, and she got a concrete plan to seek a way out by trial and error.\nShe follows \nstrictly\n the following strategy to find a way through the maze starting from her initial position.  At each time step, \n\n\n\n\nShe looks for an empty adjacent cell that has never been visited yet, in the sequence of up/right/down/left to the current cell she is at.  If there is an empty adjacent cell, she moves to that cell.  The cell she moves to is now visited.\n\n\nIf no empty, unvisited, adjacent cell exists, she backtracks on the path that she comes from, moving one step back, and repeat 1 again.\n\n\n\n\nIn this way, Scully will explore the maze in a systematic manner, with no repetitive visit of any cell more than once except when she backtracks.  She will stop when successfully escaped the maze, or finds that there is no way out after backtracking all the way back to the original position.  She is completely trapped within the maze and now must wait for Agent Mulder to come and free her.\n\n\nWrite a program \nmaze.c\n, that reads from standard input. First, read two positive integers \nm\nm\n and \nn\nn\n, followed by \nm\nm\n lines of \nn\nn\n characters in each line that represents the maze setup.  One and only one \n@\n will be present in the maze setup.\n\n\nThe program then prints, to standard output, an animation of \nk\nk\n iterations. The output should only contain \nm\nm\n rows with \nn\nn\n characters in each row, with an additional row at last.  Similarly, you must use \n#\n to represent a wall, a \n.\n to represents an empty space, and \n@\n to represent where Scully is at.  After printing the maze, your program prints the number of steps that Scully has made.\n\n\nYou should use recursion to explore the maze and look for a way out. \n\n\nHere is an example.  The following is the starting position of Scully and the maze.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n###########\n#.#.....#.#\n#.#####.#.#\n#.#...#.#.#\n#.#.#.....#\n#.#.##.#.##\n#@#.#..#..#\n#...#.#.#..\n###########\n0\n\n\n\n\n\n\nScully firstly moves five steps up:\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n###########\n#@#.....#.#\n#.#####.#.#\n#.#...#.#.#\n#.#.#.....#\n#.#.##.#.##\n#.#.#..#..#\n#...#.#.#..\n###########\n5\n\n\n\n\n\nAt this point, Scully is stuck since there is no more adjacent empty cell that has not been visited.\nScully then backtracks:\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n###########\n#.#.....#.#\n#.#####.#.#\n#.#...#.#.#\n#.#.#.....#\n#.#.##.#.##\n#@#.#..#..#\n#...#.#.#..\n###########\n10\n\n\n\n\n\nScully then moves down:\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n###########\n#.#.....#.#\n#.#####.#.#\n#.#...#.#.#\n#.#.#.....#\n#.#.##.#.##\n#.#.#..#..#\n#@..#.#.#..\n###########\n11\n\n\n\n\n\nThen right:\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n###########\n#.#.....#.#\n#.#####.#.#\n#.#...#.#.#\n#.#.#.....#\n#.#.##.#.##\n#.#.#..#..#\n#..@#.#.#..\n###########\n13\n\n\n\n\n\nThen up:\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n###########\n#.#.....#.#\n#.#####.#.#\n#.#@..#.#.#\n#.#.#.....#\n#.#.##.#.##\n#.#.#..#..#\n#...#.#.#..\n###########\n17\n\n\n\n\n\nThen right (two steps) and then down (two steps) and then right (two step):\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n###########\n#.#.....#.#\n#.#####.#.#\n#.#...#.#.#\n#.#.#..@..#\n#.#.##.#.##\n#.#.#..#..#\n#...#.#.#..\n###########\n22\n\n\n\n\n\n\nThen Scully moves up and left, and she is stuck again.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n###########\n#.#@....#.#\n#.#####.#.#\n#.#...#.#.#\n#.#.#.....#\n#.#.##.#.##\n#.#.#..#..#\n#...#.#.#..\n###########\n29\n\n\n\n\n\n\nAt this point she backtracks:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n###########\n#.#.....#.#\n#.#####.#.#\n#.#...#.#.#\n#.#.#..@..#\n#.#.##.#.##\n#.#.#..#..#\n#...#.#.#..\n###########\n36\n\n\n\n\n\n\nMoves right, and up, and stuck again!\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n###########\n#.#.....#@#\n#.#####.#.#\n#.#...#.#.#\n#.#.#.....#\n#.#.##.#.##\n#.#.#..#..#\n#...#.#.#..\n###########\n41\n\n\n\n\nShe backtracks again,\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n###########\n#.#.....#.#\n#.#####.#.#\n#.#...#.#.#\n#.#.#...@.#\n#.#.##.#.##\n#.#.#..#..#\n#...#.#.#..\n###########\n45\n\n\n\n\n\n\nThis time she found her way out!\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n###########\n#.#.....#.#\n#.#####.#.#\n#.#...#.#.#\n#.#.#.....#\n#.#.##.#.##\n#.#.#..#..#\n#...#.#.#.@\n###########\n50\n\n\n\n\n\n\nIt took her a total of 50 steps to exit the maze.\n\n\nAnimation on Screen\n\n\nWe have provided a few lines of code in the skeleton file.  You should insert this at appropriate places:\n\n\n1\n2\n3\n4\n5\nchar clear_screen[] = { 27, '[', '2', 'J',27, '[', ';', 'H', '\\0'};\n   :\ncs1010_print_string(clear_screen);\n\nusleep(250*1000); // you can change the interval here without affecting the correctness of the program.\n\n\n\n\n\n\nLine 1 in the code above defines a special string that, when printed, will clear the screen and place the cursor on the top left corner of the terminal.   Line 5 calls the system function \nusleep\n that takes in the number of microseconds.  Calling \nusleep\n causes the program to pause for that amount of time.  Sleeping time in input file is set to to 250ms (250000) and you can freely change the value if you wish. During grading, sleeping time in all inputs are 0.\n\n\nHint: You need to strictly follow the described strategy and sequence of exploration. Do not forget to print the initial matrix, and final matrix Your solution must take no more than \nO(mn)\nO(mn)\n time.  \n\n\nThe grading criteria for this question is:\n\n\n\n\n\n\n\n\n\n\nMarks\n\n\n\n\n\n\n\n\n\n\nDesign\n\n\n2\n\n\n\n\n\n\nCorrectness\n\n\n5\n\n\n\n\n\n\nEfficiency\n\n\n8\n\n\n\n\n\n\n\n\nSample Run\n\n\n\n\n\n\nmaze.1.in\n\n  \n\n\n\n\n\n\nmaze.2.in\n\n  \n\n\n\n\n\n\nWe also included a larger maze \nmaze.3.in\n for you to play with but there is no corresponding output file for this.  This maze would take Scully 900 steps to find out that she is stuck in the maze!\n\n\nQuestion 2: Fill (15 marks)\n\n\nScully is attending a drawing class today. She has already completed her work, but the teacher is not satisfied with her choice of colors and wants her to re-color some parts. She asks you, a programming genius, to help.\n\n\nScully's drawing can be simplified as a 2D array of size \nm \\times n\nm \\times n\n, with colors '0' to '9'. The drawing consists of several objects. Each object can be viewed as connected areas of cells of the same color. Two cells are connected if they share a common edge, i.e. a cell will have at most 4 connected cells.\n\n\nWrite a program, \nfill.c\n, to help Scully re-color her drawing according to her teacher's requirement. It reads from standard input two positive integers \nm\nm\n and \nn\nn\n in the first line, followed by \nm\nm\n lines of strings. Each string is of length \nn\nn\n, consisting of only characters '0' to '9'.  The next line is a positive integer \nq\nq\n, which is the number of color changes the teacher requires.  Following this, there are \nq\nq\n lines with three integers on each line: \nx_i\nx_i\n, \ny_i\ny_i\n, and \nc_i\nc_i\n. It means to color the object containing pixel (\nx_i\nx_i\n, \ny_i\ny_i\n) to the color \nc_i\nc_i\n.  We denote the top left pixel to be \n(0,0)\n(0,0)\n and the indices increases towards the right and down.\n\n\nThe program shall prints to standard output, the drawing after re-coloring the objects according to the teacher's commands according to the order of the input.  Note that one object can be re-colored multiple times.\n\n\nYou should use recursion to complete the coloring process. \n\n\nYour solution must take no more than \nO(mnq)\nO(mnq)\n time.  \n\n\nThe grading criteria for this question is:\n\n\n\n\n\n\n\n\n\n\nMarks\n\n\n\n\n\n\n\n\n\n\nDesign\n\n\n2\n\n\n\n\n\n\nCorrectness\n\n\n5\n\n\n\n\n\n\nEfficiency\n\n\n8\n\n\n\n\n\n\n\n\nSample run\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\nooiwt@pe119:~/as08-skeleton$ cat inputs/fill.1.in\n5 5\n00110\n00110\n00000\n11040\n01100\n2\n0 3 2\n4 1 3\nooiwt@pe119:~/as08-skeleton$ ./fill < inputs/fill.1.in\n00220\n00220\n00000\n33040\n03300\nooiwt@pe119:~/as08-skeleton$ cat inputs/fill.2.in\n5 5\n11111\n11111\n11111\n11111\n11111\n2\n0 3 2\n4 1 3\nooiwt@pe119:~/as08-skeleton$ ./fill < inputs/fill.2.in\n33333\n33333\n33333\n33333\n33333",
            "title": "8. Maze, Fill"
        },
        {
            "location": "/as08/index.html#assignment-8-maze-fill",
            "text": "",
            "title": "Assignment 8: Maze, Fill"
        },
        {
            "location": "/as08/index.html#deadline",
            "text": "9 November 2018 (Friday), 23:59 pm",
            "title": "Deadline"
        },
        {
            "location": "/as08/index.html#prerequisites",
            "text": "You are able to access the  CS1010 programming environment .  You are familiar with  basic UNIX CLI  and using terminal-based editor  vim .  You have gone through Exercise 1 and have already set up your  .gitconfig .  You are familiar with the steps of accepting, downloading, and submitting your exercise and assignment.  You are familiar with the directory structure and the common files included in your assignment skeleton.",
            "title": "Prerequisites"
        },
        {
            "location": "/as08/index.html#learning-outcomes",
            "text": "Be comfortable writing C programs that involve arithmetic operations,  long ,  double ,  bool , and  char  types, conditional  if / else  statements, loops with  while / for / do-while  statements, arrays (including 2D arrays), strings, pointers, and dynamic memory allocation.  {++Be able to design and implement recursive search algorithms with correct pruning to prevent repetitive or redunant work.  Be comfortable breaking down a problem into smaller subproblems which can be resolved using functions, including reusing existing functions written for other programs (with a tweak), writing a function that calls itself, designing what should the inputs and return values/types of a function be.  Be able to analyze the problem and come up with solutions to problems that are efficient, through eliminating redundant and repetitive work.",
            "title": "Learning Outcomes"
        },
        {
            "location": "/as08/index.html#setup",
            "text": "Accept the assignment  Login to one of the hosts of  CS1010 programming environment  Run:   1 ~cs1010/get-as08    You should see the folder  as08-<github id>  in your home directory with the assignment skeleton inside.",
            "title": "Setup"
        },
        {
            "location": "/as08/index.html#solving-the-assignments",
            "text": "Edit the C files to solve the corresponding question as described below.  You should break down the problem into smaller subproblems, and write one function for each of the subproblem to solve the problem.    To compile and run tests with the sample inputs and outputs:   1 make    A minimal set of test cases are given in the  inputs  and  outputs  subdirectory.  You can use  cat  or  less  to look at the content of these test cases.  You should add more test cases or edit the given ones to extensively test your programs.",
            "title": "Solving The Assignments"
        },
        {
            "location": "/as08/index.html#submission",
            "text": "When you are ready, run the following command to submit:  1 ~cs1010/submit-as08   The C files given will be uploaded to GitHub.  You can submit multiple times, but only the last submission will be graded.   Editing Your Files in Multiple Locations  You should edit your code only on the CS1010 PE hosts.  If you choose to edit your code in other places, such as directly on Github or in a second location (such as your own laptop), you need to be comfortable with various  git  command to synchronize your code across the different locations, possibly needing to resolve synchronization conflicts.    Only the C files listed above will be submitted.  You can create additional C files for testing different solutions, but eventually, you must put your solution into the corresponding C file provided as the skeleton.",
            "title": "Submission"
        },
        {
            "location": "/as08/index.html#identifying-yourself",
            "text": "In every C file that you submit to CS1010, you need to identify yourself by writing your name and tutorial group. Marks will be deducted if you fail to do so. You need to edit the line:  1 @author XXXX (Group YYYY)   and change it to something like:  1 @author Fox Mulder",
            "title": "Identifying Yourself"
        },
        {
            "location": "/as08/index.html#grading",
            "text": "This assignment contributes towards 3% of your final grade.  The total mark for this assignment is 30 marks.  There are five marking criteria: design, efficiency, correctness, documentation, and style.     Design: 2 marks. You should break down your program into smaller functions, each one performs a single coherent task or solves a well-defined subproblem.  You should avoid repetitive code that can be factored out as a function.  Writing everything in a single long function  main  or cutting-and-pasting code would likely cause you to lose marks for this criteria.  Efficiency: See the question for the breakdown and marking criteria for efficiency.  Correctness: The rest of the marks are allocated to correctness.  Note that passing the tests does not guarantee that your code is correct.  Correctness here is defined in the broad sense of using the various programming constructs in C (type, function, variable, loops, arrays, pointers, conditionals, arithmetic expressions, logical expressions)  properly , not just producing the correct output and bug-free.    Style: Marks are no longer allocated for style, but we will deduct up to 2 marks if you have a serious violation of the style guideline.  Please refer to the  CS1010 C Style Guide  and follow the recommended guideline.  Documentation: Marks are no longer allocated for documentation, but we will deduct up to 2 marks if you do not document the functions in your code properly.  Please refer to the  documentation  and follow the recommended format.  We have added the compilation flag  -Wdocumentation  to help you identify documentation errors.  You need to explain the purpose of every file, function, and parameter.  Logic in your code that is not obvious should be explained as well.   We reserve the right to penalize students for using banned C syntax in the assignments.  In addition, each grader at his or her own discretion can penalize students for repeating mistakes / bad practices from the student's past assignments (even if it was just a warning with no marks deducted in the earlier assignments).",
            "title": "Grading"
        },
        {
            "location": "/as08/index.html#question-1-maze-15-marks",
            "text": "Agent Scully woke up and found herself in the dark.  She figured out that she is in a maze.  She has to find her way out, if there is one!  The maze can be simplified as a  m \\times n m \\times n  cells. Each cell can be of the following:   '#' denotes a segment of a wall.  Noone can pass through the walls.  '.' denotes an empty space  '@' denotes where Scully is at currently. It is also an empty space   Anytime Scully reaches a border cell (a cell in either the top-most or bottom-most row or left-most or right-most column), she escapes the maze and can go save her partner Agent Mulder.  She can only move from one empty space to another adjacent cell in one step.  Two cells are adjacent if they share a common edge.   Scully took CS1010, and she got a concrete plan to seek a way out by trial and error.\nShe follows  strictly  the following strategy to find a way through the maze starting from her initial position.  At each time step,    She looks for an empty adjacent cell that has never been visited yet, in the sequence of up/right/down/left to the current cell she is at.  If there is an empty adjacent cell, she moves to that cell.  The cell she moves to is now visited.  If no empty, unvisited, adjacent cell exists, she backtracks on the path that she comes from, moving one step back, and repeat 1 again.   In this way, Scully will explore the maze in a systematic manner, with no repetitive visit of any cell more than once except when she backtracks.  She will stop when successfully escaped the maze, or finds that there is no way out after backtracking all the way back to the original position.  She is completely trapped within the maze and now must wait for Agent Mulder to come and free her.  Write a program  maze.c , that reads from standard input. First, read two positive integers  m m  and  n n , followed by  m m  lines of  n n  characters in each line that represents the maze setup.  One and only one  @  will be present in the maze setup.  The program then prints, to standard output, an animation of  k k  iterations. The output should only contain  m m  rows with  n n  characters in each row, with an additional row at last.  Similarly, you must use  #  to represent a wall, a  .  to represents an empty space, and  @  to represent where Scully is at.  After printing the maze, your program prints the number of steps that Scully has made.  You should use recursion to explore the maze and look for a way out.   Here is an example.  The following is the starting position of Scully and the maze.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10 ###########\n#.#.....#.#\n#.#####.#.#\n#.#...#.#.#\n#.#.#.....#\n#.#.##.#.##\n#@#.#..#..#\n#...#.#.#..\n###########\n0   Scully firstly moves five steps up:  1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10 ###########\n#@#.....#.#\n#.#####.#.#\n#.#...#.#.#\n#.#.#.....#\n#.#.##.#.##\n#.#.#..#..#\n#...#.#.#..\n###########\n5   At this point, Scully is stuck since there is no more adjacent empty cell that has not been visited.\nScully then backtracks:  1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10 ###########\n#.#.....#.#\n#.#####.#.#\n#.#...#.#.#\n#.#.#.....#\n#.#.##.#.##\n#@#.#..#..#\n#...#.#.#..\n###########\n10   Scully then moves down:  1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10 ###########\n#.#.....#.#\n#.#####.#.#\n#.#...#.#.#\n#.#.#.....#\n#.#.##.#.##\n#.#.#..#..#\n#@..#.#.#..\n###########\n11   Then right:  1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10 ###########\n#.#.....#.#\n#.#####.#.#\n#.#...#.#.#\n#.#.#.....#\n#.#.##.#.##\n#.#.#..#..#\n#..@#.#.#..\n###########\n13   Then up:  1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10 ###########\n#.#.....#.#\n#.#####.#.#\n#.#@..#.#.#\n#.#.#.....#\n#.#.##.#.##\n#.#.#..#..#\n#...#.#.#..\n###########\n17   Then right (two steps) and then down (two steps) and then right (two step):   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10 ###########\n#.#.....#.#\n#.#####.#.#\n#.#...#.#.#\n#.#.#..@..#\n#.#.##.#.##\n#.#.#..#..#\n#...#.#.#..\n###########\n22   Then Scully moves up and left, and she is stuck again.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10 ###########\n#.#@....#.#\n#.#####.#.#\n#.#...#.#.#\n#.#.#.....#\n#.#.##.#.##\n#.#.#..#..#\n#...#.#.#..\n###########\n29   At this point she backtracks:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10 ###########\n#.#.....#.#\n#.#####.#.#\n#.#...#.#.#\n#.#.#..@..#\n#.#.##.#.##\n#.#.#..#..#\n#...#.#.#..\n###########\n36   Moves right, and up, and stuck again!   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10 ###########\n#.#.....#@#\n#.#####.#.#\n#.#...#.#.#\n#.#.#.....#\n#.#.##.#.##\n#.#.#..#..#\n#...#.#.#..\n###########\n41  \nShe backtracks again,   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10 ###########\n#.#.....#.#\n#.#####.#.#\n#.#...#.#.#\n#.#.#...@.#\n#.#.##.#.##\n#.#.#..#..#\n#...#.#.#..\n###########\n45   This time she found her way out!   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10 ###########\n#.#.....#.#\n#.#####.#.#\n#.#...#.#.#\n#.#.#.....#\n#.#.##.#.##\n#.#.#..#..#\n#...#.#.#.@\n###########\n50   It took her a total of 50 steps to exit the maze.",
            "title": "Question 1: Maze (15 marks)"
        },
        {
            "location": "/as08/index.html#animation-on-screen",
            "text": "We have provided a few lines of code in the skeleton file.  You should insert this at appropriate places:  1\n2\n3\n4\n5 char clear_screen[] = { 27, '[', '2', 'J',27, '[', ';', 'H', '\\0'};\n   :\ncs1010_print_string(clear_screen);\n\nusleep(250*1000); // you can change the interval here without affecting the correctness of the program.   Line 1 in the code above defines a special string that, when printed, will clear the screen and place the cursor on the top left corner of the terminal.   Line 5 calls the system function  usleep  that takes in the number of microseconds.  Calling  usleep  causes the program to pause for that amount of time.  Sleeping time in input file is set to to 250ms (250000) and you can freely change the value if you wish. During grading, sleeping time in all inputs are 0.  Hint: You need to strictly follow the described strategy and sequence of exploration. Do not forget to print the initial matrix, and final matrix Your solution must take no more than  O(mn) O(mn)  time.    The grading criteria for this question is:      Marks      Design  2    Correctness  5    Efficiency  8",
            "title": "Animation on Screen"
        },
        {
            "location": "/as08/index.html#sample-run",
            "text": "maze.1.in \n      maze.2.in \n      We also included a larger maze  maze.3.in  for you to play with but there is no corresponding output file for this.  This maze would take Scully 900 steps to find out that she is stuck in the maze!",
            "title": "Sample Run"
        },
        {
            "location": "/as08/index.html#question-2-fill-15-marks",
            "text": "Scully is attending a drawing class today. She has already completed her work, but the teacher is not satisfied with her choice of colors and wants her to re-color some parts. She asks you, a programming genius, to help.  Scully's drawing can be simplified as a 2D array of size  m \\times n m \\times n , with colors '0' to '9'. The drawing consists of several objects. Each object can be viewed as connected areas of cells of the same color. Two cells are connected if they share a common edge, i.e. a cell will have at most 4 connected cells.  Write a program,  fill.c , to help Scully re-color her drawing according to her teacher's requirement. It reads from standard input two positive integers  m m  and  n n  in the first line, followed by  m m  lines of strings. Each string is of length  n n , consisting of only characters '0' to '9'.  The next line is a positive integer  q q , which is the number of color changes the teacher requires.  Following this, there are  q q  lines with three integers on each line:  x_i x_i ,  y_i y_i , and  c_i c_i . It means to color the object containing pixel ( x_i x_i ,  y_i y_i ) to the color  c_i c_i .  We denote the top left pixel to be  (0,0) (0,0)  and the indices increases towards the right and down.  The program shall prints to standard output, the drawing after re-coloring the objects according to the teacher's commands according to the order of the input.  Note that one object can be re-colored multiple times.  You should use recursion to complete the coloring process.   Your solution must take no more than  O(mnq) O(mnq)  time.    The grading criteria for this question is:      Marks      Design  2    Correctness  5    Efficiency  8",
            "title": "Question 2: Fill (15 marks)"
        },
        {
            "location": "/as08/index.html#sample-run_1",
            "text": "1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32 ooiwt@pe119:~/as08-skeleton$ cat inputs/fill.1.in\n5 5\n00110\n00110\n00000\n11040\n01100\n2\n0 3 2\n4 1 3\nooiwt@pe119:~/as08-skeleton$ ./fill < inputs/fill.1.in\n00220\n00220\n00000\n33040\n03300\nooiwt@pe119:~/as08-skeleton$ cat inputs/fill.2.in\n5 5\n11111\n11111\n11111\n11111\n11111\n2\n0 3 2\n4 1 3\nooiwt@pe119:~/as08-skeleton$ ./fill < inputs/fill.2.in\n33333\n33333\n33333\n33333\n33333",
            "title": "Sample run"
        },
        {
            "location": "/as09/index.html",
            "text": "Assignment 9: Digits\n\n\nDeadline\n\n\n16 November 2018 (Friday), 23:59 pm\n\n\nPrerequisites\n\n\n\n\nYou survived CS1010 until Week 13!\n\n\n\n\nLearning Outcomes\n\n\n\n\nBe comfortable writing C programs that involve arithmetic operations, \nlong\n, \ndouble\n, \nbool\n, and \nchar\n types, conditional \nif\n/\nelse\n statements, loops with \nwhile\n/\nfor\n/\ndo-while\n statements, arrays (including 2D arrays), strings, pointers, dynamic memory allocation, and \n struct \n.\n\n\nBe comfortable breaking down a problem into smaller subproblems which can be resolved using functions, including reusing existing functions written for other programs (with a tweak), writing a function that calls itself, designing what should the inputs and return values/types of a function be.\n\n\nBe able to analyze the problem and come up with solutions to problems that are efficient, through eliminating redundant and repetitive work.\n\n\n\n\nSetup\n\n\n\n\nAccept the assignment\n\n\nLogin to one of the hosts of \nCS1010 programming environment\n\n\nRun:\n\n\n\n\n1\n~cs1010/get-as09\n\n\n\n\n\n\n\n\nYou should see the folder \nas09-<github id>\n in your home directory with the assignment skeleton inside.\n\n\n\n\nSolving The Assignments\n\n\n\n\nEdit the C files to solve the corresponding question as described below.\n\n\nYou should break down the problem into smaller subproblems, and write one function for each of the subproblem to solve the problem.  \n\n\nTo compile, run:\n\n\n\n\n1\nmake\n\n\n\n\n\n\nSubmission\n\n\nWhen you are ready, run the following command to submit:\n\n\n1\n~cs1010/submit-as09\n\n\n\n\n\n\nThe C file given will be uploaded to GitHub.  You can submit multiple times, but only the last submission will be graded.\n\n\n\n\nEditing Your Files in Multiple Locations\n\n\nYou should edit your code only on the CS1010 PE hosts.  If you choose to edit your code in other places, such as directly on Github or in a second location (such as your own laptop), you need to be comfortable with various \ngit\n command to synchronize your code across the different locations, possibly needing to resolve synchronization conflicts.  \n\n\nOnly the C files listed above will be submitted.  You can create additional C files for testing different solutions, but eventually, you must put your solution into the corresponding C file provided as the skeleton.\n\n\n\n\nIdentifying Yourself\n\n\nIn every C file that you submit to CS1010, you need to identify yourself by writing your name and tutorial group. Marks will be deducted if you fail to do so. You need to edit the line:\n\n\n1\n@author XXXX (Group YYYY)\n\n\n\n\n\n\nand change it to something like:\n\n\n1\n@author Ellen Ripley (Group 10)\n\n\n\n\n\n\nGrading\n\n\nThis assignment contributes towards 4% of your final grade.  The total mark for this assignment is 40 marks.  There are five marking criteria: design, efficiency, correctness, documentation, and style.  \n\n\n\n\nDesign (8 marks): You should break down your program into smaller functions, each one performs a single coherent task or solves a well-defined subproblem.  You should avoid repetitive code that can be factored out as a function.  Writing everything in a single long function \nmain\n or cutting-and-pasting code would likely cause you to lose marks for this criteria.\n\n\nEfficiency (8 marks): Your code should run within the efficiency bound (given in big-O notation) and avoid redundant work or repetitive work.\n\n\nCorrectness (8 marks): Correctness here is defined in the broad sense of using the various programming constructs in C (type, function, variable, loops, arrays, \n struct \n, pointers, conditionals, arithmetic expressions, logical expressions) \nproperly\n, not just producing the correct output and bug-free.  \n\n\nStyle (8 marks): 8 marks are given by default but we may deduct marks if you have a serious violation of the style guideline.  Please refer to the \nCS1010 C Style Guide\n and follow the recommended guideline.\n\n\nDocumentation (8 marks): 8 marks are given by default, but we will deduct marks if you do not document the functions in your code properly.  Please refer to the \ndocumentation\n and follow the recommended format.  We have added the compilation flag \n-Wdocumentation\n to help you identify documentation errors.  You need to explain the purpose of every file, function, and parameter.  Logic in your code that is not obvious should be explained as well.\n\n\n\n\nNote that the default marks on documentation and style are given on the condition that you have made a good attempt at solving the problem and your solution is reasonably close to correct.  This is to prevent students from submitting an arbitrary program to claim 16 marks :)\n\n\nWe reserve the right to penalize students for using banned C syntax in the assignments.  In addition, each grader at his or her own discretion can penalize students for repeating mistakes / bad practices from the student's past assignments (even if it was just a warning with no marks deducted in the earlier assignments).\n\n\nDigits (40 Marks)\n\n\nWe started CS1010 with an assignment question on digits, so it is fitting that we end with one.\n\n\nIn this assignment, your goal is to write a program that can recognize handwritten digits.  This is a classic problem in pattern recognition and machine learning.  The state of the art techniques can now achieve a recognition rate of over 99%.  We, however, will implement a simple algorithm called \nk\nk\n-nearest neighbor algorithm, which has lower accuracy but is simple enough to be a freshmen intro to programming assignment!\n\n\nHere is how it works.  \n\n\nRepresentation of a handwritten digit\n\n\nA handwritten digit is an image, represented as a 28x28 array of characters, consisting of \n.\n and \n#\n.  An example is:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n............................\n............................\n............................\n..........#######...........\n.........########...........\n........##########..........\n.......####....###..........\n.......###....####..........\n..............####..........\n.............####...........\n............#####...........\n............####............\n...........####.............\n...........###..............\n..........####..............\n.........####...............\n.........####...............\n........####................\n........###.................\n........###...........####..\n........###################.\n........###################.\n.........###########........\n............................\n............................\n............................\n............................\n............................\n\n\n\n\n\n\nThe image above contains the digit 2.\n\n\nTraining Data\n\n\nOur algorithm recognizes the patterns in a given image by comparing it against existing images where the digits contained within are known.  These existing images are known as the \ntraining samples\n.  They consist of a list of handwritten digits, together with the \nground truth\n label, i.e., the information of which digit is contained in each image.\n\n\nUsually, the more training data we have, the more accurate our recognition program will be.\n\n\nFor this assignment, we will use the data provided by the \nMNIST Handwritten Digit Database\n.  The original data has been \npost-procesed into CSV file\n by Joseph Redmon, then post-processed again by yours truly into the format above. \n\n\nThe dataset from above contains 60,000 training samples.  I have created two smaller subsets for you to test your code.\n\n\nThe first subset contains 10 samples for each digit -- this is given in the file \ntrain100.in\n.  \n\n\nThe second subset contains 6 samples for digits 0 and 1 -- this is given in the file \ntrain6.in\n. \n\n\nThe full training set from MNIST is too big to be included on GitHub.  You can read it from \n~cs1010/as09/train60000.in\n if you want to play with it. \n\n\nTesting Samples\n\n\nThe testing samples refer to the handwritten digits that we wish to recognize.  Each of these handwritten digits is also labeled with its ground truth.  We will use these ground truth to compare against the output from our algorithm so that we can check the accuracy of our algorithm.\n\n\nWe provide two sets of testing samples.  The first contains three testing samples per digit.  The second contains only a single digit corresponding to the example below.\n\n\nThe full training dataset from MNIST contains 10000 digits.  It takes a long time to test every handwritten digit in this file, so you should do this only after you have made sure that your code is fast and is correct.  Again, the file is too big to be posted on GitHub.  You can read it directly from \n~cs1010/as09/test10000.in\n.\n\n\nThe Algorithm\n\n\nLet's define the distance between the two handwritten digits \nd(x_1, x_2)\nd(x_1, x_2)\n as the number of pixels that are different between them, i.e., how many pixels are \n#\n in one image but is \n.\n in the image.\n\n\nGiven a test sample, \nq\nq\n, we find the distance between \nq\nq\n and all the available training samples and find the \nk\nk\n training samples with the smallest distance (i.e., \nk\nk\n nearest neighbors).  \nk\nk\n is usually small -- we use \nk = 5\nk = 5\n in this assignment.\n\n\nThe intuition is that \nq\nq\n must be \"close\" to the training data that has the same labels (i.e., the same digits).  So we look at the these \nk\nk\n nearest neighbors and find the most common digit \nd\nd\n among them.   We then recognize \nq\nq\n as containing the digit \nd\nd\n.  If there are \n more than one most common digits or more than k nearest neighbors \n, then we break ties by returning the smaller digit (we should do something smarter than this, by return the closer digit, but let's do this for simplicity).\n\n\nEfficiency\n\n\nSuppose we have \nn\nn\n training samples, recognizing a digit should take no more than \nO(kn)\nO(kn)\n time (or \nO(n)\nO(n)\n since \nk\nk\n is a constant).\n\n\nThere is also an opportunity to stop early the calculation of the distance between two handwritten digits if the distance is too large, pruning away redundant work. \n\n\nExample\n\n\nConsider the following simple example with six training samples and a test sample.\n\n  1\n  2\n  3\n  4\n  5\n  6\n  7\n  8\n  9\n 10\n 11\n 12\n 13\n 14\n 15\n 16\n 17\n 18\n 19\n 20\n 21\n 22\n 23\n 24\n 25\n 26\n 27\n 28\n 29\n 30\n 31\n 32\n 33\n 34\n 35\n 36\n 37\n 38\n 39\n 40\n 41\n 42\n 43\n 44\n 45\n 46\n 47\n 48\n 49\n 50\n 51\n 52\n 53\n 54\n 55\n 56\n 57\n 58\n 59\n 60\n 61\n 62\n 63\n 64\n 65\n 66\n 67\n 68\n 69\n 70\n 71\n 72\n 73\n 74\n 75\n 76\n 77\n 78\n 79\n 80\n 81\n 82\n 83\n 84\n 85\n 86\n 87\n 88\n 89\n 90\n 91\n 92\n 93\n 94\n 95\n 96\n 97\n 98\n 99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n6\n0\n............................\n............................\n............................\n............................\n...............#####........\n...............#####........\n.............########.......\n............##########......\n...........###########......\n..........########.###......\n..........####.##...###.....\n.........#####......###.....\n........####........###.....\n.......####.........###.....\n.......###..........###.....\n......####..........###.....\n......###..........###......\n......###.........####......\n......###........###........\n......###......####.........\n......####..#######.........\n......###########...........\n.......########.............\n........#####...............\n............................\n............................\n............................\n............................\n0\n............................\n............................\n............................\n............................\n.................####.......\n................######......\n...............#######......\n.............#########......\n...........###########......\n..........############......\n.........#############......\n........#####.####.###......\n.......#####..###...##......\n.......####.........##......\n.......##...........##......\n......###...........##......\n.....####..........###......\n.....####..........###......\n.....####.........###.......\n.....####.......####........\n.....##############.........\n......############..........\n........########............\n.........######.............\n............................\n............................\n............................\n............................\n0\n............................\n............................\n............................\n............................\n............................\n..............######........\n..............########......\n.............#########......\n.............#########......\n............##########......\n..........######..####......\n..........#####...####......\n..........#####...####......\n..........#####..#####......\n..........####...#####......\n.........####....####.......\n........#####...#####.......\n........#####...####........\n........#####..#####........\n........####..#####.........\n........##########..........\n........#########...........\n........#########...........\n.........######.............\n..........#####.............\n............................\n............................\n............................\n1\n............................\n............................\n............................\n............................\n............................\n..................####......\n.................#####......\n.................#####......\n................####........\n...............#####........\n...............####.........\n...............####.........\n..............####..........\n.............####...........\n............####............\n............####............\n...........####.............\n...........####.............\n..........####..............\n..........####..............\n.........####...............\n.........####...............\n........####................\n........####................\n.........###................\n............................\n............................\n............................\n1\n............................\n............................\n............................\n............................\n............###.............\n............####............\n............####............\n............####............\n............####............\n............####............\n............#####...........\n.............####...........\n.............####...........\n.............####...........\n.............####...........\n.............####...........\n.............####...........\n.............####...........\n.............#####..........\n.............#####..........\n..............####..........\n..............####..........\n..............####..........\n...............###..........\n............................\n............................\n............................\n............................\n1\n............................\n............................\n............................\n............................\n............................\n.............##.............\n.............##.............\n.............##.............\n.............##.............\n.............###............\n.............###............\n.............###............\n.............###............\n.............###............\n.............###............\n.............###............\n.............###............\n.............###............\n.............###............\n..............###...........\n..............##............\n..............##............\n..............###...........\n..............##............\n..............##............\n............................\n............................\n............................\n\n\n\n\n\nThe test sample is \n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n1\n0\n............................\n............................\n............................\n............................\n............................\n..............#####.........\n.............#######........\n...........##########.......\n..........####.##.####......\n.........####......####.....\n.........###........###.....\n........####.........##.....\n........###..........##.....\n.......###...........##.....\n.......###...........##.....\n.......###...........##.....\n......####...........##.....\n......####..........###.....\n.......###..........###.....\n.......###.........###......\n........###.......###.......\n........####....#####.......\n.........##########.........\n..........#########.........\n............#####...........\n............................\n............................\n............................\n\n\n\n\n\nThe distances between the test sample and each of the training sampes are 101, 120, 162, 174, 173, 162.  The \nk\nk\n nearest neighbors belong to digits 0, 0, 0, 1, and 1.  The most common digit among these neighbors is 0, so we conclude (correctly) that the test sample is digit 0.\n\n\nUsing \nstruct\n\n\nOne of the objectives of this assignment is to see if you know how to use \nstruct\n (refer to \nUnit 28\n.  Appropriate use of \nstruct\n is critical for the design and correctness marks for this assignment.\n\n\nInput/Output\n\n\nWrite a program \ndigits\n that reads, from the standard input, the following:\n\n\n\n\nA positive integer \nn\nn\n, corresponding to the number of training samples,\n\n\nthen repeatedly read \nn\nn\n handwritten digits, containing:\n\n\na label corresponding to the digit in the next image (a number between 0 - 9)\n\n\n28 lines of texts, consisting of '.' and '#' only, representing a handwritten digit\n\n\n\n\n\n\nfollowed by another positive integer \nm\nm\n, corresponding to the number testing samples,\n\n\nthen repeatedly read \nm\nm\n handwritten digits, containing:\n\n\na label corresponding to the digit in the next image (a number between 0 - 9)\n\n\n28 lines of texts, consisting of '.' and '#' only, representing a handwritten digit\n\n\n\n\n\n\n\n\nThen prints, to the standard output, the following:\n\n\nFor each testing sample, \n- print the digit it is labeled as, followed by a space, followed by the digit it is recognized as\n\n\nFinally, print a \ndouble\n value that corresponds to the accuracy, i.e, the percentage of \ntraining\n testing samples correctly recognized.\n\n\nWe separated the training samples and testing samples into two files, so the usual way of redirecting a file into your program does not work anymore (since you need two files). \n\n\nThe way to run your program is to do the following:\n\n\n1\ncat <training samples> <testing samples> | ./digits\n\n\n\n\n\n\nWe use \ncat\n which concatenate two files into one to pass both the training samples and testing samples into the program using the pipe \n|\n.  If this sounds familiar, you have seen pipe before in \nExercise 3\n.\n\n\nThe name convention for the output files is different for this assignment.  The name is formatted as X-Y.out where X refers to the training samples \ntrainX.in\n and Y refers to the testing samples \ntestY.in\n.\n\n\nSample Runs\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\nooiwt@pe121:~/cs1010/as09$ cat inputs/train6.in inputs/test1.in | ./digits\n0 0\n100.0000\nooiwt@pe121:~/cs1010/as09$ cat inputs/train100.in inputs/test30.in | ./digits\n0 0\n0 0\n0 6\n1 1\n1 1\n1 1\n2 2\n2 5\n2 2\n3 3\n3 3\n3 3\n4 9\n4 4\n4 9\n5 5\n5 3\n5 3\n6 2\n6 6\n6 6\n7 7\n7 7\n7 7\n8 8\n8 1\n8 8\n9 9\n9 9\n9 9\n73.3333\n\n\n\n\n\n\nWhen you use the file \n~cs1010/as09/train60000.in\n as the training samples, you should receive 100% accuracy with \ntest30.in\n and about 96.5\\% accuracy with \n~cs1010/as09/test10000.in",
            "title": "9. Digits"
        },
        {
            "location": "/as09/index.html#assignment-9-digits",
            "text": "",
            "title": "Assignment 9: Digits"
        },
        {
            "location": "/as09/index.html#deadline",
            "text": "16 November 2018 (Friday), 23:59 pm",
            "title": "Deadline"
        },
        {
            "location": "/as09/index.html#prerequisites",
            "text": "You survived CS1010 until Week 13!",
            "title": "Prerequisites"
        },
        {
            "location": "/as09/index.html#learning-outcomes",
            "text": "Be comfortable writing C programs that involve arithmetic operations,  long ,  double ,  bool , and  char  types, conditional  if / else  statements, loops with  while / for / do-while  statements, arrays (including 2D arrays), strings, pointers, dynamic memory allocation, and   struct  .  Be comfortable breaking down a problem into smaller subproblems which can be resolved using functions, including reusing existing functions written for other programs (with a tweak), writing a function that calls itself, designing what should the inputs and return values/types of a function be.  Be able to analyze the problem and come up with solutions to problems that are efficient, through eliminating redundant and repetitive work.",
            "title": "Learning Outcomes"
        },
        {
            "location": "/as09/index.html#setup",
            "text": "Accept the assignment  Login to one of the hosts of  CS1010 programming environment  Run:   1 ~cs1010/get-as09    You should see the folder  as09-<github id>  in your home directory with the assignment skeleton inside.",
            "title": "Setup"
        },
        {
            "location": "/as09/index.html#solving-the-assignments",
            "text": "Edit the C files to solve the corresponding question as described below.  You should break down the problem into smaller subproblems, and write one function for each of the subproblem to solve the problem.    To compile, run:   1 make",
            "title": "Solving The Assignments"
        },
        {
            "location": "/as09/index.html#submission",
            "text": "When you are ready, run the following command to submit:  1 ~cs1010/submit-as09   The C file given will be uploaded to GitHub.  You can submit multiple times, but only the last submission will be graded.   Editing Your Files in Multiple Locations  You should edit your code only on the CS1010 PE hosts.  If you choose to edit your code in other places, such as directly on Github or in a second location (such as your own laptop), you need to be comfortable with various  git  command to synchronize your code across the different locations, possibly needing to resolve synchronization conflicts.    Only the C files listed above will be submitted.  You can create additional C files for testing different solutions, but eventually, you must put your solution into the corresponding C file provided as the skeleton.",
            "title": "Submission"
        },
        {
            "location": "/as09/index.html#identifying-yourself",
            "text": "In every C file that you submit to CS1010, you need to identify yourself by writing your name and tutorial group. Marks will be deducted if you fail to do so. You need to edit the line:  1 @author XXXX (Group YYYY)   and change it to something like:  1 @author Ellen Ripley (Group 10)",
            "title": "Identifying Yourself"
        },
        {
            "location": "/as09/index.html#grading",
            "text": "This assignment contributes towards 4% of your final grade.  The total mark for this assignment is 40 marks.  There are five marking criteria: design, efficiency, correctness, documentation, and style.     Design (8 marks): You should break down your program into smaller functions, each one performs a single coherent task or solves a well-defined subproblem.  You should avoid repetitive code that can be factored out as a function.  Writing everything in a single long function  main  or cutting-and-pasting code would likely cause you to lose marks for this criteria.  Efficiency (8 marks): Your code should run within the efficiency bound (given in big-O notation) and avoid redundant work or repetitive work.  Correctness (8 marks): Correctness here is defined in the broad sense of using the various programming constructs in C (type, function, variable, loops, arrays,   struct  , pointers, conditionals, arithmetic expressions, logical expressions)  properly , not just producing the correct output and bug-free.    Style (8 marks): 8 marks are given by default but we may deduct marks if you have a serious violation of the style guideline.  Please refer to the  CS1010 C Style Guide  and follow the recommended guideline.  Documentation (8 marks): 8 marks are given by default, but we will deduct marks if you do not document the functions in your code properly.  Please refer to the  documentation  and follow the recommended format.  We have added the compilation flag  -Wdocumentation  to help you identify documentation errors.  You need to explain the purpose of every file, function, and parameter.  Logic in your code that is not obvious should be explained as well.   Note that the default marks on documentation and style are given on the condition that you have made a good attempt at solving the problem and your solution is reasonably close to correct.  This is to prevent students from submitting an arbitrary program to claim 16 marks :)  We reserve the right to penalize students for using banned C syntax in the assignments.  In addition, each grader at his or her own discretion can penalize students for repeating mistakes / bad practices from the student's past assignments (even if it was just a warning with no marks deducted in the earlier assignments).",
            "title": "Grading"
        },
        {
            "location": "/as09/index.html#digits-40-marks",
            "text": "We started CS1010 with an assignment question on digits, so it is fitting that we end with one.  In this assignment, your goal is to write a program that can recognize handwritten digits.  This is a classic problem in pattern recognition and machine learning.  The state of the art techniques can now achieve a recognition rate of over 99%.  We, however, will implement a simple algorithm called  k k -nearest neighbor algorithm, which has lower accuracy but is simple enough to be a freshmen intro to programming assignment!  Here is how it works.",
            "title": "Digits (40 Marks)"
        },
        {
            "location": "/as09/index.html#representation-of-a-handwritten-digit",
            "text": "A handwritten digit is an image, represented as a 28x28 array of characters, consisting of  .  and  # .  An example is:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28 ............................\n............................\n............................\n..........#######...........\n.........########...........\n........##########..........\n.......####....###..........\n.......###....####..........\n..............####..........\n.............####...........\n............#####...........\n............####............\n...........####.............\n...........###..............\n..........####..............\n.........####...............\n.........####...............\n........####................\n........###.................\n........###...........####..\n........###################.\n........###################.\n.........###########........\n............................\n............................\n............................\n............................\n............................   The image above contains the digit 2.",
            "title": "Representation of a handwritten digit"
        },
        {
            "location": "/as09/index.html#training-data",
            "text": "Our algorithm recognizes the patterns in a given image by comparing it against existing images where the digits contained within are known.  These existing images are known as the  training samples .  They consist of a list of handwritten digits, together with the  ground truth  label, i.e., the information of which digit is contained in each image.  Usually, the more training data we have, the more accurate our recognition program will be.  For this assignment, we will use the data provided by the  MNIST Handwritten Digit Database .  The original data has been  post-procesed into CSV file  by Joseph Redmon, then post-processed again by yours truly into the format above.   The dataset from above contains 60,000 training samples.  I have created two smaller subsets for you to test your code.  The first subset contains 10 samples for each digit -- this is given in the file  train100.in .    The second subset contains 6 samples for digits 0 and 1 -- this is given in the file  train6.in .   The full training set from MNIST is too big to be included on GitHub.  You can read it from  ~cs1010/as09/train60000.in  if you want to play with it.",
            "title": "Training Data"
        },
        {
            "location": "/as09/index.html#testing-samples",
            "text": "The testing samples refer to the handwritten digits that we wish to recognize.  Each of these handwritten digits is also labeled with its ground truth.  We will use these ground truth to compare against the output from our algorithm so that we can check the accuracy of our algorithm.  We provide two sets of testing samples.  The first contains three testing samples per digit.  The second contains only a single digit corresponding to the example below.  The full training dataset from MNIST contains 10000 digits.  It takes a long time to test every handwritten digit in this file, so you should do this only after you have made sure that your code is fast and is correct.  Again, the file is too big to be posted on GitHub.  You can read it directly from  ~cs1010/as09/test10000.in .",
            "title": "Testing Samples"
        },
        {
            "location": "/as09/index.html#the-algorithm",
            "text": "Let's define the distance between the two handwritten digits  d(x_1, x_2) d(x_1, x_2)  as the number of pixels that are different between them, i.e., how many pixels are  #  in one image but is  .  in the image.  Given a test sample,  q q , we find the distance between  q q  and all the available training samples and find the  k k  training samples with the smallest distance (i.e.,  k k  nearest neighbors).   k k  is usually small -- we use  k = 5 k = 5  in this assignment.  The intuition is that  q q  must be \"close\" to the training data that has the same labels (i.e., the same digits).  So we look at the these  k k  nearest neighbors and find the most common digit  d d  among them.   We then recognize  q q  as containing the digit  d d .  If there are   more than one most common digits or more than k nearest neighbors  , then we break ties by returning the smaller digit (we should do something smarter than this, by return the closer digit, but let's do this for simplicity).",
            "title": "The Algorithm"
        },
        {
            "location": "/as09/index.html#efficiency",
            "text": "Suppose we have  n n  training samples, recognizing a digit should take no more than  O(kn) O(kn)  time (or  O(n) O(n)  since  k k  is a constant).  There is also an opportunity to stop early the calculation of the distance between two handwritten digits if the distance is too large, pruning away redundant work.",
            "title": "Efficiency"
        },
        {
            "location": "/as09/index.html#example",
            "text": "Consider the following simple example with six training samples and a test sample.   1\n  2\n  3\n  4\n  5\n  6\n  7\n  8\n  9\n 10\n 11\n 12\n 13\n 14\n 15\n 16\n 17\n 18\n 19\n 20\n 21\n 22\n 23\n 24\n 25\n 26\n 27\n 28\n 29\n 30\n 31\n 32\n 33\n 34\n 35\n 36\n 37\n 38\n 39\n 40\n 41\n 42\n 43\n 44\n 45\n 46\n 47\n 48\n 49\n 50\n 51\n 52\n 53\n 54\n 55\n 56\n 57\n 58\n 59\n 60\n 61\n 62\n 63\n 64\n 65\n 66\n 67\n 68\n 69\n 70\n 71\n 72\n 73\n 74\n 75\n 76\n 77\n 78\n 79\n 80\n 81\n 82\n 83\n 84\n 85\n 86\n 87\n 88\n 89\n 90\n 91\n 92\n 93\n 94\n 95\n 96\n 97\n 98\n 99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175 6\n0\n............................\n............................\n............................\n............................\n...............#####........\n...............#####........\n.............########.......\n............##########......\n...........###########......\n..........########.###......\n..........####.##...###.....\n.........#####......###.....\n........####........###.....\n.......####.........###.....\n.......###..........###.....\n......####..........###.....\n......###..........###......\n......###.........####......\n......###........###........\n......###......####.........\n......####..#######.........\n......###########...........\n.......########.............\n........#####...............\n............................\n............................\n............................\n............................\n0\n............................\n............................\n............................\n............................\n.................####.......\n................######......\n...............#######......\n.............#########......\n...........###########......\n..........############......\n.........#############......\n........#####.####.###......\n.......#####..###...##......\n.......####.........##......\n.......##...........##......\n......###...........##......\n.....####..........###......\n.....####..........###......\n.....####.........###.......\n.....####.......####........\n.....##############.........\n......############..........\n........########............\n.........######.............\n............................\n............................\n............................\n............................\n0\n............................\n............................\n............................\n............................\n............................\n..............######........\n..............########......\n.............#########......\n.............#########......\n............##########......\n..........######..####......\n..........#####...####......\n..........#####...####......\n..........#####..#####......\n..........####...#####......\n.........####....####.......\n........#####...#####.......\n........#####...####........\n........#####..#####........\n........####..#####.........\n........##########..........\n........#########...........\n........#########...........\n.........######.............\n..........#####.............\n............................\n............................\n............................\n1\n............................\n............................\n............................\n............................\n............................\n..................####......\n.................#####......\n.................#####......\n................####........\n...............#####........\n...............####.........\n...............####.........\n..............####..........\n.............####...........\n............####............\n............####............\n...........####.............\n...........####.............\n..........####..............\n..........####..............\n.........####...............\n.........####...............\n........####................\n........####................\n.........###................\n............................\n............................\n............................\n1\n............................\n............................\n............................\n............................\n............###.............\n............####............\n............####............\n............####............\n............####............\n............####............\n............#####...........\n.............####...........\n.............####...........\n.............####...........\n.............####...........\n.............####...........\n.............####...........\n.............####...........\n.............#####..........\n.............#####..........\n..............####..........\n..............####..........\n..............####..........\n...............###..........\n............................\n............................\n............................\n............................\n1\n............................\n............................\n............................\n............................\n............................\n.............##.............\n.............##.............\n.............##.............\n.............##.............\n.............###............\n.............###............\n.............###............\n.............###............\n.............###............\n.............###............\n.............###............\n.............###............\n.............###............\n.............###............\n..............###...........\n..............##............\n..............##............\n..............###...........\n..............##............\n..............##............\n............................\n............................\n............................   The test sample is   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30 1\n0\n............................\n............................\n............................\n............................\n............................\n..............#####.........\n.............#######........\n...........##########.......\n..........####.##.####......\n.........####......####.....\n.........###........###.....\n........####.........##.....\n........###..........##.....\n.......###...........##.....\n.......###...........##.....\n.......###...........##.....\n......####...........##.....\n......####..........###.....\n.......###..........###.....\n.......###.........###......\n........###.......###.......\n........####....#####.......\n.........##########.........\n..........#########.........\n............#####...........\n............................\n............................\n............................   The distances between the test sample and each of the training sampes are 101, 120, 162, 174, 173, 162.  The  k k  nearest neighbors belong to digits 0, 0, 0, 1, and 1.  The most common digit among these neighbors is 0, so we conclude (correctly) that the test sample is digit 0.",
            "title": "Example"
        },
        {
            "location": "/as09/index.html#using-struct",
            "text": "One of the objectives of this assignment is to see if you know how to use  struct  (refer to  Unit 28 .  Appropriate use of  struct  is critical for the design and correctness marks for this assignment.",
            "title": "Using struct"
        },
        {
            "location": "/as09/index.html#inputoutput",
            "text": "Write a program  digits  that reads, from the standard input, the following:   A positive integer  n n , corresponding to the number of training samples,  then repeatedly read  n n  handwritten digits, containing:  a label corresponding to the digit in the next image (a number between 0 - 9)  28 lines of texts, consisting of '.' and '#' only, representing a handwritten digit    followed by another positive integer  m m , corresponding to the number testing samples,  then repeatedly read  m m  handwritten digits, containing:  a label corresponding to the digit in the next image (a number between 0 - 9)  28 lines of texts, consisting of '.' and '#' only, representing a handwritten digit     Then prints, to the standard output, the following:  For each testing sample, \n- print the digit it is labeled as, followed by a space, followed by the digit it is recognized as  Finally, print a  double  value that corresponds to the accuracy, i.e, the percentage of  training  testing samples correctly recognized.  We separated the training samples and testing samples into two files, so the usual way of redirecting a file into your program does not work anymore (since you need two files).   The way to run your program is to do the following:  1 cat <training samples> <testing samples> | ./digits   We use  cat  which concatenate two files into one to pass both the training samples and testing samples into the program using the pipe  | .  If this sounds familiar, you have seen pipe before in  Exercise 3 .  The name convention for the output files is different for this assignment.  The name is formatted as X-Y.out where X refers to the training samples  trainX.in  and Y refers to the testing samples  testY.in .",
            "title": "Input/Output"
        },
        {
            "location": "/as09/index.html#sample-runs",
            "text": "1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35 ooiwt@pe121:~/cs1010/as09$ cat inputs/train6.in inputs/test1.in | ./digits\n0 0\n100.0000\nooiwt@pe121:~/cs1010/as09$ cat inputs/train100.in inputs/test30.in | ./digits\n0 0\n0 0\n0 6\n1 1\n1 1\n1 1\n2 2\n2 5\n2 2\n3 3\n3 3\n3 3\n4 9\n4 4\n4 9\n5 5\n5 3\n5 3\n6 2\n6 6\n6 6\n7 7\n7 7\n7 7\n8 8\n8 1\n8 8\n9 9\n9 9\n9 9\n73.3333   When you use the file  ~cs1010/as09/train60000.in  as the training samples, you should receive 100% accuracy with  test30.in  and about 96.5\\% accuracy with  ~cs1010/as09/test10000.in",
            "title": "Sample Runs"
        },
        {
            "location": "/quiz/index.html",
            "text": "Quizzes\n\n\nWe have setup some quizzes to help you check for yourself how much you know about the topics we cover in CS1010.\n\n\nThere are two types of quizzes: (a) in-class Kahoot! quizzes, and (b) out-of-class Google Form quizzes.  The quizzes are linked here:\n\n\nKahoot! Quizzes\n\n\nWeek 4: Flow Charts\n (3 September 2018)\n\n\nGoogle Form Quizzes\n\n\nQuiz 1: Using PE and UNIX\n\n\nQuiz 2: Compiling Your Code\n\n\nQuiz 3: Basic C Syntax",
            "title": "Quizzes"
        },
        {
            "location": "/quiz/index.html#quizzes",
            "text": "We have setup some quizzes to help you check for yourself how much you know about the topics we cover in CS1010.  There are two types of quizzes: (a) in-class Kahoot! quizzes, and (b) out-of-class Google Form quizzes.  The quizzes are linked here:",
            "title": "Quizzes"
        },
        {
            "location": "/quiz/index.html#kahoot-quizzes",
            "text": "",
            "title": "Kahoot! Quizzes"
        },
        {
            "location": "/quiz/index.html#week-4-flow-charts-3-september-2018",
            "text": "",
            "title": "Week 4: Flow Charts (3 September 2018)"
        },
        {
            "location": "/quiz/index.html#google-form-quizzes",
            "text": "",
            "title": "Google Form Quizzes"
        },
        {
            "location": "/quiz/index.html#quiz-1-using-pe-and-unix",
            "text": "",
            "title": "Quiz 1: Using PE and UNIX"
        },
        {
            "location": "/quiz/index.html#quiz-2-compiling-your-code",
            "text": "",
            "title": "Quiz 2: Compiling Your Code"
        },
        {
            "location": "/quiz/index.html#quiz-3-basic-c-syntax",
            "text": "",
            "title": "Quiz 3: Basic C Syntax"
        },
        {
            "location": "/kahoot01/index.html",
            "text": "Kahoot Quiz 1\n\n\n3 September 2018 (Week 4)\n\n\nQuestion 1\n\n\nWhat is the output of the algorithm in the flowchart below if the input L is 10, 7, 1?\n\n\n\n\n\n\nA. 18\n\n\nB. 27\n\n\nC. 8\n\n\nD. 17\n\n\n\n\n(Answer: B)\n\n\nQuestion 2\n\n\nWhat is the output of the algorithm in the flowchart below if the input L is 5, 6, 10?\n\n\n\n\n\n\nA. 5\n\n\nB. 6\n\n\nC. 10\n\n\nD. No output\n\n\n\n\n(Answer: B)\n\n\nQuestion 3\n\n\nRefer to the flowchart in Question 2.  What is the output of the algorithm if L is 1, 2, 3, 4?\n\n\n\n\nA. 2\n\n\nB. 3\n\n\nC. 4\n\n\nD. No output\n\n\n\n\n(Answer: D)",
            "title": "Flow Charts"
        },
        {
            "location": "/kahoot01/index.html#kahoot-quiz-1",
            "text": "3 September 2018 (Week 4)",
            "title": "Kahoot Quiz 1"
        },
        {
            "location": "/kahoot01/index.html#question-1",
            "text": "What is the output of the algorithm in the flowchart below if the input L is 10, 7, 1?    A. 18  B. 27  C. 8  D. 17   (Answer: B)",
            "title": "Question 1"
        },
        {
            "location": "/kahoot01/index.html#question-2",
            "text": "What is the output of the algorithm in the flowchart below if the input L is 5, 6, 10?    A. 5  B. 6  C. 10  D. No output   (Answer: B)",
            "title": "Question 2"
        },
        {
            "location": "/kahoot01/index.html#question-3",
            "text": "Refer to the flowchart in Question 2.  What is the output of the algorithm if L is 1, 2, 3, 4?   A. 2  B. 3  C. 4  D. No output   (Answer: D)",
            "title": "Question 3"
        },
        {
            "location": "/c-in-cs1010/index.html",
            "text": "C in CS1010\n\n\nC is a simple and flexible language, providing programmers with many different ways to achieve the same thing.\n\n\nSome of these features that C provides, however, could be bug prone.  Wei Tsang has written enough buggy programs himself and seen enough buggy programs from students.  He feels that some of these features from C are not useful for beginners (or even seasoned programmers).\n\n\nFurthermore, some features in C simply encourages bad programming habits that are widely frowned upon.  Some would lead to insecure programs.  \n\n\nAs such, in CS1010, we \nban\n and \ndiscourage\n the use of certain operators, functions, constructs, and features in C.\n\n\nThis article summarizes this list.  This is a work in progress article. As we learn more about C, we will amend this list.\n\n\nBanned in CS1010\n\n\nThe banned items should not be used in CS1010.  Students should use the alternatives.  The teaching staff reserves the right to apply a penalty while grading the assignments and practical exams if these banned features are used.\n\n\n1. The \n++\n and \n--\n operators.\n\n\nWhy?\n\n\n\n\nThese operators lead to potential undefined behavior.  E.g., \ni = i++;\n\n\nThe potential confusion caused by the difference between \ni++\n and \n++i\n.\n\n\n\n\nWhat should be used instead?\n\n\n\n\nUse \ni += 1\n or \ni -= 1\n instead of \ni++\n or \ni--\n\n\n\n\n2. Skipping of curly braces for single statement conditional or loop body\n\n\nWhy?\n\n\n\n\nCould lead to dangling \nelse\n confusion\n\n\nEasy to forget to put back the \n{}\n pair if the body is modified beyond a single statements\n\n\n\n\nWhat should be used instead?\n\n\n\n\nAlways use \n{}\n even if the conditional or loop body contains only a single statement.\n\n\n\n\n3. Nested conditional operator \n?:\n\n\nWhy?\n\n\n\n\nCan get difficult to read, understand, and modify.  Example:\n\n\n\n\n1\na = (x > y) ? ((y > z) ? y : z) : ((x > z) ? x : z);\n\n\n\n\n\n\nWhat should be used\n\n\n\n\nUse nested \nif-else\n loop\n\n\n\n\n4. Global variables\n\n\nWhy?\n\n\n\n\nIt makes the code hard to reason about and trace, as you have no idea who will modify these variables.  For instance,  if \nx\n is not a global variable, we can safely assert that \nx\n is still 1 after calling \nf()\n.  If \nx\n is a global variable, we can no longer assert anything about \nx\n.\n\n\n\n\n1\n2\n3\nx\n \n=\n \n1\n;\n\n\nf\n();\n\n\n// { x == 1 }\n\n\n\n\n\n\n\nWhat should be used instead\n\n\n\n\nDeclare the variables as local, automatic variables, and pass them around.\n\n\n\n\n5. The type \nint\n and \nshort\n\n\nWhy?\n\n\n\n\nC standard guaratees that both \nshort\n and \nint\n are at least 16 bits, which limits its guaranteed range to only -32,768 to 32,767.  This is too small many purposes.\n\n\nWe are not concerned about memory usage in CS1010.  If we do want to have precise control over memory, we should be anyway using the types from \nstdint.h\n.\n\n\n\n\nWhat should be used instead\n\n\n\n\nlong\n, which is guaranteed to be at least 32 bits.\n\n\n\n\nException\n\n\n\n\nIf a function from C library calls for the use of \nint\n and offers no \nlong\n alternative, then we have to use \nint\n.\n\n\n\n\n6. The type \nfloat\n\n\nWhy?\n\n\n\n\nNot enough precision and will cause floating point errors.\n\n\n\n\nWhat should be used instead\n\n\n\n\ndouble\n\n\n\n\nException\n\n\n\n\nIf a function from C library calls for the use of \nfloat\n and offers no \ndouble\n alternative, then we have to use \nfloat\n.\n\n\n\n\n7. Using integer values for true / false\n\n\nWhy?\n\n\n\n\nConfusing and error prone\n\n\n\n\nWhat should be used instead\n\n\n\n\nUse the \nbool\n type, and the values \ntrue\n and \nfalse\n.\n\n\n\n\n8. \ngoto\n\n\nWhy?\n\n\n\n\nmakes the logical flow of the code hard to follow and trace\n\n\n\n\nWhat should be used instead\n\n\n\n\ncombinations of conditionals and loops\n\n\n\n\n\n\nDiscouraged in CS1010\n\n\nThese are things that are not strictly banned, but their usage is discouraged.  Students should really use them only if they know very well what they are doing.  Use at own perils.\n\n\n1. \nprintf\n and \nscanf\n Functions\n\n\nWhy?\n\n\n\n\nUsing the wrong format modifier for \nprintf\n could lead to strange results\n\n\nUsing the wrong format modifier for \nscanf\n could lead to memory corruption\n\n\nNeed to look up what is the right format modifier to use\n\n\nNeed to preallocate memory for \nscanf\n of strings\n\n\nscanf\n is not secure\n\n\nscanf\n is not a pure function.  Prefers students to learn about the concept of pure functions first.\n\n\netc. etc.\n\n\n\n\nWhat should be used instead\n\n\n\n\nThe CS1010 I/O library\n\n\n\n\n2. \nswitch\n Statements\n\n\nWhy?\n\n\n\n\nBug prone (missing \nbreak\n would cause the case to fall through)\n\n\nOnly works on ordinal types.\n\n\n\n\nWhat should be used instead\n\n\n\n\nif\n-\nelse\n statements\n\n\n\n\n3. \nbreak\n and \ncontinue\n Statements\n\n\nWhy?\n\n\n\n\nUsing \nbreak\n and \ncontinue\n complicates the flow of a loop, marks it harder to reason about the correctness of the loop, and is, therefore, bug-prone.  \n\n\n\n\nWhat should be used instead\n\n\n\n\nSimple loops with a single entry and a single exit point.  Use flag variables to indicate special conditions to exit or continue with the loop.\n\n\n\n\n4. Skipping parenthesis\n\n\nWhy?\n\n\n\n\nParenthesis makes it clear to the reader the order of evaluation of arithmetic operations / logical operations.  We should add parenthesis to make sure the intention of the code is clear.\n\n\n\n\nWhy should be used instead\n\n\n\n\nParenthesis",
            "title": "C in CS1010"
        },
        {
            "location": "/c-in-cs1010/index.html#c-in-cs1010",
            "text": "C is a simple and flexible language, providing programmers with many different ways to achieve the same thing.  Some of these features that C provides, however, could be bug prone.  Wei Tsang has written enough buggy programs himself and seen enough buggy programs from students.  He feels that some of these features from C are not useful for beginners (or even seasoned programmers).  Furthermore, some features in C simply encourages bad programming habits that are widely frowned upon.  Some would lead to insecure programs.    As such, in CS1010, we  ban  and  discourage  the use of certain operators, functions, constructs, and features in C.  This article summarizes this list.  This is a work in progress article. As we learn more about C, we will amend this list.",
            "title": "C in CS1010"
        },
        {
            "location": "/c-in-cs1010/index.html#banned-in-cs1010",
            "text": "The banned items should not be used in CS1010.  Students should use the alternatives.  The teaching staff reserves the right to apply a penalty while grading the assignments and practical exams if these banned features are used.",
            "title": "Banned in CS1010"
        },
        {
            "location": "/c-in-cs1010/index.html#1-the-and-operators",
            "text": "",
            "title": "1. The ++ and -- operators."
        },
        {
            "location": "/c-in-cs1010/index.html#why",
            "text": "These operators lead to potential undefined behavior.  E.g.,  i = i++;  The potential confusion caused by the difference between  i++  and  ++i .",
            "title": "Why?"
        },
        {
            "location": "/c-in-cs1010/index.html#what-should-be-used-instead",
            "text": "Use  i += 1  or  i -= 1  instead of  i++  or  i--",
            "title": "What should be used instead?"
        },
        {
            "location": "/c-in-cs1010/index.html#2-skipping-of-curly-braces-for-single-statement-conditional-or-loop-body",
            "text": "",
            "title": "2. Skipping of curly braces for single statement conditional or loop body"
        },
        {
            "location": "/c-in-cs1010/index.html#why_1",
            "text": "Could lead to dangling  else  confusion  Easy to forget to put back the  {}  pair if the body is modified beyond a single statements",
            "title": "Why?"
        },
        {
            "location": "/c-in-cs1010/index.html#what-should-be-used-instead_1",
            "text": "Always use  {}  even if the conditional or loop body contains only a single statement.",
            "title": "What should be used instead?"
        },
        {
            "location": "/c-in-cs1010/index.html#3-nested-conditional-operator",
            "text": "",
            "title": "3. Nested conditional operator ?:"
        },
        {
            "location": "/c-in-cs1010/index.html#why_2",
            "text": "Can get difficult to read, understand, and modify.  Example:   1 a = (x > y) ? ((y > z) ? y : z) : ((x > z) ? x : z);",
            "title": "Why?"
        },
        {
            "location": "/c-in-cs1010/index.html#what-should-be-used",
            "text": "Use nested  if-else  loop",
            "title": "What should be used"
        },
        {
            "location": "/c-in-cs1010/index.html#4-global-variables",
            "text": "",
            "title": "4. Global variables"
        },
        {
            "location": "/c-in-cs1010/index.html#why_3",
            "text": "It makes the code hard to reason about and trace, as you have no idea who will modify these variables.  For instance,  if  x  is not a global variable, we can safely assert that  x  is still 1 after calling  f() .  If  x  is a global variable, we can no longer assert anything about  x .   1\n2\n3 x   =   1 ;  f ();  // { x == 1 }",
            "title": "Why?"
        },
        {
            "location": "/c-in-cs1010/index.html#what-should-be-used-instead_2",
            "text": "Declare the variables as local, automatic variables, and pass them around.",
            "title": "What should be used instead"
        },
        {
            "location": "/c-in-cs1010/index.html#5-the-type-int-and-short",
            "text": "",
            "title": "5. The type int and short"
        },
        {
            "location": "/c-in-cs1010/index.html#why_4",
            "text": "C standard guaratees that both  short  and  int  are at least 16 bits, which limits its guaranteed range to only -32,768 to 32,767.  This is too small many purposes.  We are not concerned about memory usage in CS1010.  If we do want to have precise control over memory, we should be anyway using the types from  stdint.h .",
            "title": "Why?"
        },
        {
            "location": "/c-in-cs1010/index.html#what-should-be-used-instead_3",
            "text": "long , which is guaranteed to be at least 32 bits.",
            "title": "What should be used instead"
        },
        {
            "location": "/c-in-cs1010/index.html#exception",
            "text": "If a function from C library calls for the use of  int  and offers no  long  alternative, then we have to use  int .",
            "title": "Exception"
        },
        {
            "location": "/c-in-cs1010/index.html#6-the-type-float",
            "text": "",
            "title": "6. The type float"
        },
        {
            "location": "/c-in-cs1010/index.html#why_5",
            "text": "Not enough precision and will cause floating point errors.",
            "title": "Why?"
        },
        {
            "location": "/c-in-cs1010/index.html#what-should-be-used-instead_4",
            "text": "double",
            "title": "What should be used instead"
        },
        {
            "location": "/c-in-cs1010/index.html#exception_1",
            "text": "If a function from C library calls for the use of  float  and offers no  double  alternative, then we have to use  float .",
            "title": "Exception"
        },
        {
            "location": "/c-in-cs1010/index.html#7-using-integer-values-for-true-false",
            "text": "",
            "title": "7. Using integer values for true / false"
        },
        {
            "location": "/c-in-cs1010/index.html#why_6",
            "text": "Confusing and error prone",
            "title": "Why?"
        },
        {
            "location": "/c-in-cs1010/index.html#what-should-be-used-instead_5",
            "text": "Use the  bool  type, and the values  true  and  false .",
            "title": "What should be used instead"
        },
        {
            "location": "/c-in-cs1010/index.html#8-goto",
            "text": "",
            "title": "8. goto"
        },
        {
            "location": "/c-in-cs1010/index.html#why_7",
            "text": "makes the logical flow of the code hard to follow and trace",
            "title": "Why?"
        },
        {
            "location": "/c-in-cs1010/index.html#what-should-be-used-instead_6",
            "text": "combinations of conditionals and loops",
            "title": "What should be used instead"
        },
        {
            "location": "/c-in-cs1010/index.html#discouraged-in-cs1010",
            "text": "These are things that are not strictly banned, but their usage is discouraged.  Students should really use them only if they know very well what they are doing.  Use at own perils.",
            "title": "Discouraged in CS1010"
        },
        {
            "location": "/c-in-cs1010/index.html#1-printf-and-scanf-functions",
            "text": "",
            "title": "1. printf and scanf Functions"
        },
        {
            "location": "/c-in-cs1010/index.html#why_8",
            "text": "Using the wrong format modifier for  printf  could lead to strange results  Using the wrong format modifier for  scanf  could lead to memory corruption  Need to look up what is the right format modifier to use  Need to preallocate memory for  scanf  of strings  scanf  is not secure  scanf  is not a pure function.  Prefers students to learn about the concept of pure functions first.  etc. etc.",
            "title": "Why?"
        },
        {
            "location": "/c-in-cs1010/index.html#what-should-be-used-instead_7",
            "text": "The CS1010 I/O library",
            "title": "What should be used instead"
        },
        {
            "location": "/c-in-cs1010/index.html#2-switch-statements",
            "text": "",
            "title": "2. switch Statements"
        },
        {
            "location": "/c-in-cs1010/index.html#why_9",
            "text": "Bug prone (missing  break  would cause the case to fall through)  Only works on ordinal types.",
            "title": "Why?"
        },
        {
            "location": "/c-in-cs1010/index.html#what-should-be-used-instead_8",
            "text": "if - else  statements",
            "title": "What should be used instead"
        },
        {
            "location": "/c-in-cs1010/index.html#3-break-and-continue-statements",
            "text": "",
            "title": "3. break and continue Statements"
        },
        {
            "location": "/c-in-cs1010/index.html#why_10",
            "text": "Using  break  and  continue  complicates the flow of a loop, marks it harder to reason about the correctness of the loop, and is, therefore, bug-prone.",
            "title": "Why?"
        },
        {
            "location": "/c-in-cs1010/index.html#what-should-be-used-instead_9",
            "text": "Simple loops with a single entry and a single exit point.  Use flag variables to indicate special conditions to exit or continue with the loop.",
            "title": "What should be used instead"
        },
        {
            "location": "/c-in-cs1010/index.html#4-skipping-parenthesis",
            "text": "",
            "title": "4. Skipping parenthesis"
        },
        {
            "location": "/c-in-cs1010/index.html#why_11",
            "text": "Parenthesis makes it clear to the reader the order of evaluation of arithmetic operations / logical operations.  We should add parenthesis to make sure the intention of the code is clear.",
            "title": "Why?"
        },
        {
            "location": "/c-in-cs1010/index.html#why-should-be-used-instead",
            "text": "Parenthesis",
            "title": "Why should be used instead"
        },
        {
            "location": "/style/index.html",
            "text": "CS1010 C Style\n\n\nIn CS1010, you should following the following style guide when you write your code for your graded homework and practical exams.  We typically allocate a few marks for coding style (each assignment/exam may have different allocation).  You will lose marks for violation of style.\n\n\nThis guide is modified from past CS1010 style guide by Aaron Tan.\n\n\nWhy Coding Style is Important\n\n\nQuote\n\n\n\"It is not merely a matter of aesthetics that programs should be written in a particular style. Rather there is a psychological basis for writing programs in a conventional manner: programmers have strong expectations that other programmers will follow these discourse rules. If the rules are violated, then the utility afforded by the expectations that programmers have built up over time is effectively nullified. The results from the experiments with novice and advanced student programmers and with professional programmers described in this paper provide clear support for these claims.\"\n\n\nElliot Soloway and Kate Ehrlich. \"Empirical studies of programming knowledge.\" IEEE Transactions on Software Engineering 5 (1984): 595-609.\n\n\n1. Variable Declaration\n\n\nEach variable should be declared in its own line.\n\n\n1\n2\ndouble\n \nweight\n;\n  \n// The weight of the baby\n\n\ndouble\n \nheight\n;\n  \n// The height of the baby\n\n\n\n\n\n\n\nAvoid\n\n\n1\ndouble\n \nweight\n,\n \nheight\n;\n   \n// Weight and height of the baby\n\n\n\n\n\n\n\n2. Give Variables Descriptive Names\n\n\nThis is the most important rule to follow.  The name of a type, variable, function, constant should inform us of its purpose clearly without the readers having to guess or look up its meaning.\n\n\nFor example, \nint number_of_coins;\n is an appropriate variable but not \nint c;\n. Avoid using a single character for variable names.\n\n\nThere are some exceptions, however, as shown below:\n\n\n\n\nIf the variable is the problem size and it is given in the task statement. For example, a problem dealing with n values, hence the variable may be called n (preferably with a comment to explain).\n\n\nIf the variable is a transient/temporary variable whose purpose is clear.\n-If the variable is a loop variable whose purpose is clear.\n\n\n\n\n3. Shorten Variable Names with Naming Conventions\n\n\nDespite the recommendation for descriptive names, identifiers can be short yet descriptive by using abbreviations and/or common naming conventions. For example, \nMAX_LEN\n, \nnum_of_elems\n, \npcurr\n, \ntable_num\n.\n\n\nHowever, do not invent your own abbreviation. For instance, names like \nnm_elemnts\n should be avoided.\n\n\n4. Avoid Negated Variable or Function Names\n\n\nNegated variables often result in hard-to-read double-negatives in an expression like \n!is_not_err\n.\n\n\nSo, avoid \nis_not_error\n, \nis_not_found\n, \nis_not_valid\n, \ncannot_open_file\n.  Instead, we prefer \nis_error\n, \nis_found\n, \nis_valid\n, \ncan_open_file\n etc.\n\n\n5. Use \n#define\n to Define Constants for Magic Numbers\n\n\nAvoid direct use of magic numbers. Constant literals which have special meanings should be named and its named identifier should be used in its place. For example:\n\n\nAvoid:\n\n1\n2\n3\nfor\n \n(\ni\n \n=\n \n0\n;\n \ni\n \n<\n \n100\n;\n \ni\n \n+=\n \n1\n)\n \n{\n\n    \n:\n\n\n}\n\n\n\n\n\n\nPrefer:\n\n1\n2\n3\n4\n5\n#define MAX_LEN 100\n :\nfor (i = 0; i < MAX_LEN; i += 1) {\n    :\n}\n\n\n\n\n\n6. Naming Conventions\n\n\nConstants\n\n\nAll constant identifiers must be written in all caps and separated by an underscore \n_\n.  For instance \nMAX_ITERATIONS\n, \nMAX_LEN\n, \nGOLDEN_RATIO\n, \nCOLOR_DEFAULT\n, \nPI\n.\n\n\nVariables and Functions\n\n\nUse lower case letters for variable names and function names, with multiple words separated by underscore \n_\n.  Example, \ncs1010_read_long\n, \nis_prime\n. \n\n\n7. Use Consistent Indentation to Emphasize Block Structure\n\n\nThe code should be properly and neatly indented to emphasize the nested logical structure of the program. An indentation of 2 or 4 spaces is recommended (8 is too wide).\n\n\nEvery block that follows a \nfor\n, \nwhile\n, \nif-else\n, \ndo-while\n statement must be indented from its enclosing block.\n\n\nComments within a block should follow the indentation level of its enclosing block. For example,\n\n\n1\n2\n3\n4\n5\n6\n7\nfor\n \n(\ni\n \n=\n \n0\n;\n \ni\n \n<\n \n3\n;\n \ni\n \n+=\n \n1\n)\n \n{\n   \n    \n// Comments should be indented too\n\n    \nwhile\n \n(\nj\n \n!=\n \ni\n)\n \n{\n\n        \n// More indented comments\n\n        \nprintf\n(\n\"Hello\n\\n\n\"\n);\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nThe following are the wrong ways to indent the comments.\n\n\n1\n2\n3\n4\n5\n6\n7\nfor\n \n(\ni\n \n=\n \n0\n;\n \ni\n \n<\n \n3\n;\n \ni\n \n+=\n \n1\n)\n \n{\n\n\n// This comment should be indented and aligned with the while statement.\n\n    \nwhile\n \n(\nj\n \n!=\n \ni\n)\n \n{\n\n    \n// This comment should be aligned with the printf statement.\n\n        \nprintf\n(\n\"Hello\n\\n\n\"\n);\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\n8. Don't Mix Tabs and Spaces\n\n\nYou must use only spaces in your code.  Do not use tabs.\n\n\nYou can add the configuration \nset expandtab\n to automatically expand any tab that you enter into spaces.\n\n\n9. Spaces in \nif\n, \nelse\n, \nfor\n, \nwhile\n, \ndo\n-\nwhile\n Statements\n\n\nAdd a single space between the keywords \nif\n,\nelse\n, \nfor\n, \nwhile\n and the following parentheses and between the parentheses and next curly bracket.  For instance:\n\n\n1\n2\n3\nfor( ... ) { // not good\nfor( ... ){ // not good\nfor ( ... ) { // good\n\n\n\n\n\n\n10. Spaces in Assignments\n\n\nAdd a single space before and after \n=\n.\n\n\n1\n2\n3\n4\na=b; // no\na= b; // no\na =b; // no\na = b; // OK!\n\n\n\n\n\n\n11. Positions of Open and Close Braces\n\n\nThere are two camps on the position of open braces. The following shows the \"trailing open braces\":\n\n\n1\n2\n3\n4\n5\nfor\n \n(\ni\n \n=\n \n0\n;\n \ni\n \n<\n \n3\n;\n \ni\n \n+=\n \n1\n)\n \n{\n\n    \nwhile\n \n(\nj\n \n!=\n \ni\n)\n \n{\n\n        \nprintf\n(\n\"Hello\n\\n\n\"\n);\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nThe following shows the \"leading open braces\". The leading open brace must be aligned with the block of the construct it is in:\n\n\n1\n2\n3\n4\n5\n6\n7\nfor\n \n(\ni\n \n=\n \n0\n;\n \ni\n \n<\n \n3\n;\n \ni\n \n+=\n \n1\n)\n \n\n{\n\n    \nwhile\n \n(\nj\n \n!=\n \ni\n)\n \n    \n{\n\n        \nprintf\n(\n\"Hello\n\\n\n\"\n);\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nBoth styles are acceptable, but you should be consistent and should not mix both styles in a single program.\n\n\nFor close braces, they should be leading close braces aligned with the block of the construct. Close braces should NOT be trailing as that would make it hard to spot them.\n\n\n12. Comment Major Code Segments Adequately\n\n\nMajor segments of code should have explanatory comments. A major segment may be a loop block or a function block.\n\n\nYou should comment on complicated logic, expressions, or algorithms, explaining what you are doing in the code, including why and how.\n\n\nAn \"if\" block with a complex condition or an expression that is hard to understand should have explanatory comments.  For example,\n\n\n1\n2\n3\n4\n// Check and reject out-of-bounds indices\n\n\nif\n \n(\nk\n \n<\n \n0\n \n||\n \nk\n \n>=\n \nMAX_LEN\n)\n \n{\n\n    \nreturn\n \n-\n1\n;\n\n\n}\n\n\n\n\n\n\n\n13. Avoid Superfluous Comments\n\n\nA comment such as:\n\n\n1\ni\n \n+=\n \n1\n \n// add one to i\n\n\n\n\n\n\n\nserves no purpose, adds clutter to a program and does more harm than good.\n\n\n14. Blank Lines\n\n\nIt is good to add a blank line between two functions, or two long segments of code for readability.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n// This function ...\n\n\nint\n \nf\n(\nint\n \nx\n)\n \n{\n\n    \n// body\n\n\n}\n\n\n\n// This function ...\n\n\nint\n \ng\n(\ndouble\n \ny\n)\n \n{\n\n    \n// body\n\n\n}\n\n\n\n\n\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n// Statements 1 to 10 belong to a sub-task\n\n\nstatement1\n;\n\n\nstatement2\n;\n\n   \n:\n\n\nstatement10\n;\n\n\n\n// Leave a blank line for readability\n\n\nstatement11\n;\n\n\nstatement12\n;\n\n   \n:\n\n\n\n\n\n\n\nHowever, guard against the use of excessive blank lines. Double blank lines and triply blank lines, or more, should not be present.\n\n\n15. Long Lines\n\n\nIf a line (be it a statement or a comment) is too long (more than 80 characters), do not let it run through the screen and wrap around. Instead, split it into a few lines.\n\n\n1\nif\n \n((\nhas_cs2010\n \n||\n \nhas_cs2020\n \n||\n \nhas_cs2040\n \n||\n \nhas_cs2040C\n)\n \n&&\n \n(\nhas_st1232\n \n||\n \nhas_st2131\n \n||\n \nhas_st2132\n \n||\n \nhas_st2334\n)\n \n&&\n \n(\nhas_ma1102R\n \n||\n \nhas_ma1505\n \n||\n \n(\nhas_ma1511\n \n&&\n \nhas_ma1512\n)\n \n||\n \nhas_ma1521\n)\n \n&&\n \n(\nhas_ma1101R\n \n||\n \nhas_ma1311\n \n||\n \nhas_ma1506\n \n||\n \nhas_ma1508E\n))\n \n\n\n\n\nis bad\n\n\n1\n2\n3\n4\nif\n \n((\nhas_cs2010\n \n||\n \nhas_cs2020\n \n||\n \nhas_cs2040\n \n||\n \nhas_cs2040c\n)\n \n&&\n \n   \n(\nhas_st1232\n \n||\n \nhas_st2131\n \n||\n  \nhas_st2132\n \n||\n \nhas_st2334\n)\n \n&&\n \n   \n(\nhas_ma1102r\n \n||\n \nhas_ma1505\n \n||\n \n(\nhas_ma1511\n \n&&\n \nhas_ma1512\n)\n \n||\n \nhas_ma1521\n)\n \n&&\n    \n   \n(\nhas_ma1101r\n \n||\n \nhas_ma1311\n \n||\n \nhas_ma1506\n \n||\n \nhas_ma1508e\n))\n \n\n\n\n\nis better.",
            "title": "Style Guide"
        },
        {
            "location": "/style/index.html#cs1010-c-style",
            "text": "In CS1010, you should following the following style guide when you write your code for your graded homework and practical exams.  We typically allocate a few marks for coding style (each assignment/exam may have different allocation).  You will lose marks for violation of style.  This guide is modified from past CS1010 style guide by Aaron Tan.",
            "title": "CS1010 C Style"
        },
        {
            "location": "/style/index.html#why-coding-style-is-important",
            "text": "Quote  \"It is not merely a matter of aesthetics that programs should be written in a particular style. Rather there is a psychological basis for writing programs in a conventional manner: programmers have strong expectations that other programmers will follow these discourse rules. If the rules are violated, then the utility afforded by the expectations that programmers have built up over time is effectively nullified. The results from the experiments with novice and advanced student programmers and with professional programmers described in this paper provide clear support for these claims.\"  Elliot Soloway and Kate Ehrlich. \"Empirical studies of programming knowledge.\" IEEE Transactions on Software Engineering 5 (1984): 595-609.",
            "title": "Why Coding Style is Important"
        },
        {
            "location": "/style/index.html#1-variable-declaration",
            "text": "Each variable should be declared in its own line.  1\n2 double   weight ;    // The weight of the baby  double   height ;    // The height of the baby    Avoid  1 double   weight ,   height ;     // Weight and height of the baby",
            "title": "1. Variable Declaration"
        },
        {
            "location": "/style/index.html#2-give-variables-descriptive-names",
            "text": "This is the most important rule to follow.  The name of a type, variable, function, constant should inform us of its purpose clearly without the readers having to guess or look up its meaning.  For example,  int number_of_coins;  is an appropriate variable but not  int c; . Avoid using a single character for variable names.  There are some exceptions, however, as shown below:   If the variable is the problem size and it is given in the task statement. For example, a problem dealing with n values, hence the variable may be called n (preferably with a comment to explain).  If the variable is a transient/temporary variable whose purpose is clear.\n-If the variable is a loop variable whose purpose is clear.",
            "title": "2. Give Variables Descriptive Names"
        },
        {
            "location": "/style/index.html#3-shorten-variable-names-with-naming-conventions",
            "text": "Despite the recommendation for descriptive names, identifiers can be short yet descriptive by using abbreviations and/or common naming conventions. For example,  MAX_LEN ,  num_of_elems ,  pcurr ,  table_num .  However, do not invent your own abbreviation. For instance, names like  nm_elemnts  should be avoided.",
            "title": "3. Shorten Variable Names with Naming Conventions"
        },
        {
            "location": "/style/index.html#4-avoid-negated-variable-or-function-names",
            "text": "Negated variables often result in hard-to-read double-negatives in an expression like  !is_not_err .  So, avoid  is_not_error ,  is_not_found ,  is_not_valid ,  cannot_open_file .  Instead, we prefer  is_error ,  is_found ,  is_valid ,  can_open_file  etc.",
            "title": "4. Avoid Negated Variable or Function Names"
        },
        {
            "location": "/style/index.html#5-use-define-to-define-constants-for-magic-numbers",
            "text": "Avoid direct use of magic numbers. Constant literals which have special meanings should be named and its named identifier should be used in its place. For example:  Avoid: 1\n2\n3 for   ( i   =   0 ;   i   <   100 ;   i   +=   1 )   { \n     :  }    Prefer: 1\n2\n3\n4\n5 #define MAX_LEN 100\n :\nfor (i = 0; i < MAX_LEN; i += 1) {\n    :\n}",
            "title": "5. Use #define to Define Constants for Magic Numbers"
        },
        {
            "location": "/style/index.html#6-naming-conventions",
            "text": "",
            "title": "6. Naming Conventions"
        },
        {
            "location": "/style/index.html#constants",
            "text": "All constant identifiers must be written in all caps and separated by an underscore  _ .  For instance  MAX_ITERATIONS ,  MAX_LEN ,  GOLDEN_RATIO ,  COLOR_DEFAULT ,  PI .",
            "title": "Constants"
        },
        {
            "location": "/style/index.html#variables-and-functions",
            "text": "Use lower case letters for variable names and function names, with multiple words separated by underscore  _ .  Example,  cs1010_read_long ,  is_prime .",
            "title": "Variables and Functions"
        },
        {
            "location": "/style/index.html#7-use-consistent-indentation-to-emphasize-block-structure",
            "text": "The code should be properly and neatly indented to emphasize the nested logical structure of the program. An indentation of 2 or 4 spaces is recommended (8 is too wide).  Every block that follows a  for ,  while ,  if-else ,  do-while  statement must be indented from its enclosing block.  Comments within a block should follow the indentation level of its enclosing block. For example,  1\n2\n3\n4\n5\n6\n7 for   ( i   =   0 ;   i   <   3 ;   i   +=   1 )   {    \n     // Comments should be indented too \n     while   ( j   !=   i )   { \n         // More indented comments \n         printf ( \"Hello \\n \" ); \n     }  }    The following are the wrong ways to indent the comments.  1\n2\n3\n4\n5\n6\n7 for   ( i   =   0 ;   i   <   3 ;   i   +=   1 )   {  // This comment should be indented and aligned with the while statement. \n     while   ( j   !=   i )   { \n     // This comment should be aligned with the printf statement. \n         printf ( \"Hello \\n \" ); \n     }  }",
            "title": "7. Use Consistent Indentation to Emphasize Block Structure"
        },
        {
            "location": "/style/index.html#8-dont-mix-tabs-and-spaces",
            "text": "You must use only spaces in your code.  Do not use tabs.  You can add the configuration  set expandtab  to automatically expand any tab that you enter into spaces.",
            "title": "8. Don't Mix Tabs and Spaces"
        },
        {
            "location": "/style/index.html#9-spaces-in-if-else-for-while-do-while-statements",
            "text": "Add a single space between the keywords  if , else ,  for ,  while  and the following parentheses and between the parentheses and next curly bracket.  For instance:  1\n2\n3 for( ... ) { // not good\nfor( ... ){ // not good\nfor ( ... ) { // good",
            "title": "9. Spaces in if, else, for, while, do-while Statements"
        },
        {
            "location": "/style/index.html#10-spaces-in-assignments",
            "text": "Add a single space before and after  = .  1\n2\n3\n4 a=b; // no\na= b; // no\na =b; // no\na = b; // OK!",
            "title": "10. Spaces in Assignments"
        },
        {
            "location": "/style/index.html#11-positions-of-open-and-close-braces",
            "text": "There are two camps on the position of open braces. The following shows the \"trailing open braces\":  1\n2\n3\n4\n5 for   ( i   =   0 ;   i   <   3 ;   i   +=   1 )   { \n     while   ( j   !=   i )   { \n         printf ( \"Hello \\n \" ); \n     }  }    The following shows the \"leading open braces\". The leading open brace must be aligned with the block of the construct it is in:  1\n2\n3\n4\n5\n6\n7 for   ( i   =   0 ;   i   <   3 ;   i   +=   1 )   { \n     while   ( j   !=   i )  \n     { \n         printf ( \"Hello \\n \" ); \n     }  }    Both styles are acceptable, but you should be consistent and should not mix both styles in a single program.  For close braces, they should be leading close braces aligned with the block of the construct. Close braces should NOT be trailing as that would make it hard to spot them.",
            "title": "11. Positions of Open and Close Braces"
        },
        {
            "location": "/style/index.html#12-comment-major-code-segments-adequately",
            "text": "Major segments of code should have explanatory comments. A major segment may be a loop block or a function block.  You should comment on complicated logic, expressions, or algorithms, explaining what you are doing in the code, including why and how.  An \"if\" block with a complex condition or an expression that is hard to understand should have explanatory comments.  For example,  1\n2\n3\n4 // Check and reject out-of-bounds indices  if   ( k   <   0   ||   k   >=   MAX_LEN )   { \n     return   - 1 ;  }",
            "title": "12. Comment Major Code Segments Adequately"
        },
        {
            "location": "/style/index.html#13-avoid-superfluous-comments",
            "text": "A comment such as:  1 i   +=   1   // add one to i    serves no purpose, adds clutter to a program and does more harm than good.",
            "title": "13. Avoid Superfluous Comments"
        },
        {
            "location": "/style/index.html#14-blank-lines",
            "text": "It is good to add a blank line between two functions, or two long segments of code for readability.  1\n2\n3\n4\n5\n6\n7\n8\n9 // This function ...  int   f ( int   x )   { \n     // body  }  // This function ...  int   g ( double   y )   { \n     // body  }     1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10 // Statements 1 to 10 belong to a sub-task  statement1 ;  statement2 ; \n    :  statement10 ;  // Leave a blank line for readability  statement11 ;  statement12 ; \n    :    However, guard against the use of excessive blank lines. Double blank lines and triply blank lines, or more, should not be present.",
            "title": "14. Blank Lines"
        },
        {
            "location": "/style/index.html#15-long-lines",
            "text": "If a line (be it a statement or a comment) is too long (more than 80 characters), do not let it run through the screen and wrap around. Instead, split it into a few lines.  1 if   (( has_cs2010   ||   has_cs2020   ||   has_cs2040   ||   has_cs2040C )   &&   ( has_st1232   ||   has_st2131   ||   has_st2132   ||   has_st2334 )   &&   ( has_ma1102R   ||   has_ma1505   ||   ( has_ma1511   &&   has_ma1512 )   ||   has_ma1521 )   &&   ( has_ma1101R   ||   has_ma1311   ||   has_ma1506   ||   has_ma1508E ))    \nis bad  1\n2\n3\n4 if   (( has_cs2010   ||   has_cs2020   ||   has_cs2040   ||   has_cs2040c )   &&  \n    ( has_st1232   ||   has_st2131   ||    has_st2132   ||   has_st2334 )   &&  \n    ( has_ma1102r   ||   has_ma1505   ||   ( has_ma1511   &&   has_ma1512 )   ||   has_ma1521 )   &&     \n    ( has_ma1101r   ||   has_ma1311   ||   has_ma1506   ||   has_ma1508e ))    \nis better.",
            "title": "15. Long Lines"
        },
        {
            "location": "/documentation/index.html",
            "text": "Code Documentation\n\n\nCode documentation is as important as the code itself.  It helps readers of your code, including your future self, to understand\n\n\n\n\nthe purpose of a piece of code\n\n\nwhat assumptions are being made, and\n\n\nthe reasoning behind why certain things are done.\n\n\n\n\nC Syntax for Comments\n\n\nIn C, you can write comments in two ways:\n\n\n\n\nEither prefix a one-line comment with two slashes \n//\n , or\n\n\nWrite multiple-line comments between \n/*\n and \n*/\n\n\n\n\nFor example:\n\n\n1\n// assume the number of elements > 1\n\n\n\n\n\n\n\n1\n2\n3\n4\n5\n/*\n\n\n This function reads in the radius of a sphere and returns the\n\n\n volume of the sphere.  We assume the radius is normalized between\n\n\n 0.0 and 1.0.\n\n\n */\n\n\n\n\n\n\n\nThe Doxygen Format\n\n\nIn CS1010, we will adopt the Doxygen format for C comments.  Doxygen is a tool that automatically generates HTML documents from comments in C code and is widely used in the industry. \n\n\nWe write a Doxygen comment with an additional \n*\n after \n/*\n:\n\n\n1\n2\n3\n/**\n\n\n\n */\n\n\n\n\n\n\n\nThe comments can be free-form text.  However, to help with creating a more structured document, we can add what Doxygen calls special \"commands\".  I view these commands as keys to certain information.  Useful commands are:\n\n\n\n\n@author\n: the name the author\n\n\n@file\n: the name of a file\n\n\n@pre\n: the precondition of a function\n\n\n@post\n: the postcondition of a function\n\n\n@param[<dir>] <name>\n: describe a parameter of a function.  \n<name>\n is the name of the parameter, \n<dir>\n can be \nin\n, \nout\n, \nin,out\n corresponding to whether the parameter is used as input, output, or both.\n\n\n@return\n: describe the return value of a function\n\n\n\n\nThe comments should be placed before a file, a function, or a variable that you want the comment to apply to.\n\n\nExample\n\n\nHere is an example:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n/**\n\n\n * @file: cs1010.c\n\n\n * @author: Ooi Wei Tsang\n\n\n * \n\n\n * This file contains implementation of the CS1010 I/O library to \n\n\n * simplify the reading and writing of integer, real numbers, and text\n\n\n * from the standard input and output respectively.\n\n\n */\n\n\n\n/**\n\n\n * Raed k white-space-separated words from the standard input in an array.\n\n\n * The notion of \"word\" is the same to cs1010_read_word().  The caller is\n\n\n * responsible for freeing the memory allocated for the array by calling\n\n\n * free().\n\n\n *\n\n\n * @param[in] k The number of words to read.\n\n\n * @return Returns NULL if there is a memory allocation error, otherwise, \n\n\n * return an array of char* containing the words.\n\n\n */\n\n\nchar\n**\n \ncs1010_read_word_array\n(\nint\n \nk\n)\n \n\n{\n\n   \n:\n\n\n}\n\n\n\n\n\n\n\nYou can also see additional examples in the \nsolution posted for Assignment 1",
            "title": "Documentation Guide"
        },
        {
            "location": "/documentation/index.html#code-documentation",
            "text": "Code documentation is as important as the code itself.  It helps readers of your code, including your future self, to understand   the purpose of a piece of code  what assumptions are being made, and  the reasoning behind why certain things are done.",
            "title": "Code Documentation"
        },
        {
            "location": "/documentation/index.html#c-syntax-for-comments",
            "text": "In C, you can write comments in two ways:   Either prefix a one-line comment with two slashes  //  , or  Write multiple-line comments between  /*  and  */   For example:  1 // assume the number of elements > 1    1\n2\n3\n4\n5 /*   This function reads in the radius of a sphere and returns the   volume of the sphere.  We assume the radius is normalized between   0.0 and 1.0.   */",
            "title": "C Syntax for Comments"
        },
        {
            "location": "/documentation/index.html#the-doxygen-format",
            "text": "In CS1010, we will adopt the Doxygen format for C comments.  Doxygen is a tool that automatically generates HTML documents from comments in C code and is widely used in the industry.   We write a Doxygen comment with an additional  *  after  /* :  1\n2\n3 /**   */    The comments can be free-form text.  However, to help with creating a more structured document, we can add what Doxygen calls special \"commands\".  I view these commands as keys to certain information.  Useful commands are:   @author : the name the author  @file : the name of a file  @pre : the precondition of a function  @post : the postcondition of a function  @param[<dir>] <name> : describe a parameter of a function.   <name>  is the name of the parameter,  <dir>  can be  in ,  out ,  in,out  corresponding to whether the parameter is used as input, output, or both.  @return : describe the return value of a function   The comments should be placed before a file, a function, or a variable that you want the comment to apply to.",
            "title": "The Doxygen Format"
        },
        {
            "location": "/documentation/index.html#example",
            "text": "Here is an example:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23 /**   * @file: cs1010.c   * @author: Ooi Wei Tsang   *    * This file contains implementation of the CS1010 I/O library to    * simplify the reading and writing of integer, real numbers, and text   * from the standard input and output respectively.   */  /**   * Raed k white-space-separated words from the standard input in an array.   * The notion of \"word\" is the same to cs1010_read_word().  The caller is   * responsible for freeing the memory allocated for the array by calling   * free().   *   * @param[in] k The number of words to read.   * @return Returns NULL if there is a memory allocation error, otherwise,    * return an array of char* containing the words.   */  char **   cs1010_read_word_array ( int   k )   { \n    :  }    You can also see additional examples in the  solution posted for Assignment 1",
            "title": "Example"
        },
        {
            "location": "/readings/index.html",
            "text": "Readings\n\n\nMust Read\n\n\n\n\nHow NOT to Go About a Programming Assignment\n, by Agustin Cernuda del Rio. \nComputer programming students invariably fall into more than one bad habit. It can be extremely difficult to eradicate them (and many lecturers and professional programmers keep succumbing to them time and again)..\n\n\nBest Teacher I Ever Had\n, by David Owen.  \nMr. Whitson taught sixth-grade science. On the first day of class, he gave us a lecture about a creature called the cattywampus, ..\n\n\n\n\nWhy C?\n\n\n\n\nLearn C programming and the rest will come, by Marty Jacobs\n\n\nThe Resurgence of C Programming, by Mark Barlow\n\n\nYou Can't Dig Upwards, by Evan Miller\n\n\n\n\nVim\n\n\n\n\n\n\nTime to Drop Emacs and Vi?\n on StackOverflow.  \"\nProgrammers are notorious for using the tools that helps them get the job done in the most efficient way possible. These editors are ancient yet still being used because they are good, solid editors, proven by time. If they get the job done and get the job done well, why should we drop them in favor of something else?\n\"\n\n\n\n\n\n\nWhat are the benefits of learning Vim?\n on Stack Overflow.  \"\nUsually vim's killer features are considered: A) that it's available on pretty much every Unix you'll ever encounter and B) your fingers very rarely have to leave the home row, which means you'll be able to edit text very, very quickly. It's also usually very fast and lightweight even when editing huge files.\n\"\n\n\n\n\n\n\nLearn \nvim\n Progressively\n \"\nI suggest you teach yourself Vim in 4 steps: 1. Survive. 2.  Feel comfortable. 3.  Feel Better, Stronger, Faster. 4.  Use superpowers of vim\n\"\n\n\n\n\n\n\nWhere Vim Came From\n -- from TwoBitHistory.  \"\nPerhaps more importantly, while we\u2019re asking questions, why does exiting Vim involve typing :wq? Sure, it\u2019s a \u201cwrite\u201d operation followed by a \u201cquit\u201d operation, but that is not a particularly intuitive convention. Who decided that copying text should instead be called \u201cyanking\u201d? Why is :%s/foo/bar/gc short for \u201cfind and replace\u201d? Vim\u2019s idiosyncrasies seem too arbitrary to have been made up, but then where did they come from?\"\n\n\n\n\n\n\nVim's Big Idea\n - by Mike Kozlowski. \n\"This philosophy of minimalist commands that can be composed together is the fundamental originating philosophy of Unix, and Vim exemplifies it like no other editor.\"\n\n\n\n\n\n\nVIM Pays Excellent Dividends\n - by John Bjorn Nelson.  \n\"Being conservative, let\u2019s say it makes you 5% more productive. More specifically\u200a\u2014\u200aonce your brain maps the keystrokes to muscle memory\u200a\u2014\u200ait makes you 5% faster at completing the mundane tasks\u2026the ones which dominate programming. That added productivity snowballs. It\u2019s an extra twenty minutes a day to build or explore (or learn), that used to go to copy/paste-like operations.\"\n\n\n\n\n\n\nThe Powers of VIM\n - by Artem Dudarev\n\n\n\n\n\n\nThe 11 Steps to Learning Vim\n - by \ndamassi\n. \n\"Regardless of the initial confusion and difficulty in getting started, you're making your future developer self immensely more productive by diving in and taking the plunge. Seriously. I'm just a few weeks in right now and I can positively say that learning Vim has been the best work-related decision of my life. It's fun, and in the strangest of ways it makes you think better.\"\n\n\n\n\n\n\nVim for People Who Think Things like Vim and Weird and Hard\n - by \nHarry Roberts\n. \n\"the fact that, yes, people still use an editor that is over 20 years old (in turn based on a tool from the 70s), and those people number in the hundreds of thousands, perhaps they might be onto something.\"\n\n\n\n\n\n\nWhy I use Vim\n - Pascal Precht. \"_once I was able to do some basic operations in Vim and actually started working again, I made almost as twice as much progress at work in about half the time. I know that sounds kind of crazy but I\u2019m serious. And that convinced me that I made the right choice.\n\n\n\n\n\n\nSo, do yourself a favor and climb that mountain. Just remember that you can slide down afterwards._\"\n\n\nVim Video Tutorial (from Aaron Tan)\n\n\n\n\nLesson 1\n\n\nLesson 2\n\n\nLesson 3\n\n\nLesson 4",
            "title": "Readings"
        },
        {
            "location": "/readings/index.html#readings",
            "text": "",
            "title": "Readings"
        },
        {
            "location": "/readings/index.html#must-read",
            "text": "How NOT to Go About a Programming Assignment , by Agustin Cernuda del Rio.  Computer programming students invariably fall into more than one bad habit. It can be extremely difficult to eradicate them (and many lecturers and professional programmers keep succumbing to them time and again)..  Best Teacher I Ever Had , by David Owen.   Mr. Whitson taught sixth-grade science. On the first day of class, he gave us a lecture about a creature called the cattywampus, ..",
            "title": "Must Read"
        },
        {
            "location": "/readings/index.html#why-c",
            "text": "Learn C programming and the rest will come, by Marty Jacobs  The Resurgence of C Programming, by Mark Barlow  You Can't Dig Upwards, by Evan Miller",
            "title": "Why C?"
        },
        {
            "location": "/readings/index.html#vim",
            "text": "Time to Drop Emacs and Vi?  on StackOverflow.  \" Programmers are notorious for using the tools that helps them get the job done in the most efficient way possible. These editors are ancient yet still being used because they are good, solid editors, proven by time. If they get the job done and get the job done well, why should we drop them in favor of something else? \"    What are the benefits of learning Vim?  on Stack Overflow.  \" Usually vim's killer features are considered: A) that it's available on pretty much every Unix you'll ever encounter and B) your fingers very rarely have to leave the home row, which means you'll be able to edit text very, very quickly. It's also usually very fast and lightweight even when editing huge files. \"    Learn  vim  Progressively  \" I suggest you teach yourself Vim in 4 steps: 1. Survive. 2.  Feel comfortable. 3.  Feel Better, Stronger, Faster. 4.  Use superpowers of vim \"    Where Vim Came From  -- from TwoBitHistory.  \" Perhaps more importantly, while we\u2019re asking questions, why does exiting Vim involve typing :wq? Sure, it\u2019s a \u201cwrite\u201d operation followed by a \u201cquit\u201d operation, but that is not a particularly intuitive convention. Who decided that copying text should instead be called \u201cyanking\u201d? Why is :%s/foo/bar/gc short for \u201cfind and replace\u201d? Vim\u2019s idiosyncrasies seem too arbitrary to have been made up, but then where did they come from?\"    Vim's Big Idea  - by Mike Kozlowski.  \"This philosophy of minimalist commands that can be composed together is the fundamental originating philosophy of Unix, and Vim exemplifies it like no other editor.\"    VIM Pays Excellent Dividends  - by John Bjorn Nelson.   \"Being conservative, let\u2019s say it makes you 5% more productive. More specifically\u200a\u2014\u200aonce your brain maps the keystrokes to muscle memory\u200a\u2014\u200ait makes you 5% faster at completing the mundane tasks\u2026the ones which dominate programming. That added productivity snowballs. It\u2019s an extra twenty minutes a day to build or explore (or learn), that used to go to copy/paste-like operations.\"    The Powers of VIM  - by Artem Dudarev    The 11 Steps to Learning Vim  - by  damassi .  \"Regardless of the initial confusion and difficulty in getting started, you're making your future developer self immensely more productive by diving in and taking the plunge. Seriously. I'm just a few weeks in right now and I can positively say that learning Vim has been the best work-related decision of my life. It's fun, and in the strangest of ways it makes you think better.\"    Vim for People Who Think Things like Vim and Weird and Hard  - by  Harry Roberts .  \"the fact that, yes, people still use an editor that is over 20 years old (in turn based on a tool from the 70s), and those people number in the hundreds of thousands, perhaps they might be onto something.\"    Why I use Vim  - Pascal Precht. \"_once I was able to do some basic operations in Vim and actually started working again, I made almost as twice as much progress at work in about half the time. I know that sounds kind of crazy but I\u2019m serious. And that convinced me that I made the right choice.    So, do yourself a favor and climb that mountain. Just remember that you can slide down afterwards._\"",
            "title": "Vim"
        },
        {
            "location": "/readings/index.html#vim-video-tutorial-from-aaron-tan",
            "text": "Lesson 1  Lesson 2  Lesson 3  Lesson 4",
            "title": "Vim Video Tutorial (from Aaron Tan)"
        },
        {
            "location": "/environments/index.html",
            "text": "The CS1010 Programming Environment\n\n\nC is a common programming language and you can find different implementations of C compiler on many platforms.  Wikipedia \nlists more than 40 different C compilers\n.  These different compilers support different processor architecture, operating system, may behave slightly differently, and may support different features of C standards.  It is therefore important for CS1010 to stick to a single platform and single compiler.\n\n\nOur platform of choice is \nUbuntu 16.04 (or later)\n using the \nclang\n compiler (\nversion 3.4.2 or later\n).\n\n\nThe school has provided a list of computing servers for you to use.  You can access them remotely via \nssh\n, or secure shell.  The hosts are named \npe111\n, \npe112\n, ..., \npe120\n.  (\npe\n stands for \"programming environment\").\n\n\nYou can choose which of the 10 hosts to use.  You share the same home directory across all 10 hosts (this home directory, however, is different from that of \nsunfire\n).\n\n\nFor simplicity, the following guide uses \npe111\n in all examples.  Do keep in mind that you can use other hosts for CS1010 to spread out the load.\n\n\nWhile it is possible for you to complete the programming assignments on your own computers, the practical exams are done in a controlled environment using the desktop PCs in the programming labs.  It is therefore advisable for you to familiarize with accessing remote computing servers via \nssh\n and edit your program with either \nvim\n or \nmacro\n.\n\n\nBasic Requirements\n\n\n\n\n\n\nYou need to have an SoC UNIX account.  If you do not have one, you can \napply for one online\n.\n\n\n\n\n\n\nOnce you have an account, you need to [activate your access to the PE hosts] (\nhttps://mysoc.nus.edu.sg/~myacct/services.cgi\n), which is part of the SoC computer clusters.\n\n\n\n\n\n\nYou need an \nssh\n client.  MacOS and Linux users should already have it installed by default.  Windows 10 users should install \nthe Windows Subsystem for Linux\n and use Linux.\n\n\n\n\n\n\nFor older versions of Windows, such as those used in the SoC's programming labs, you can check out \nXShell 6\n (free for home/school use), or \nPuTTY\n.  These are GUI-based programs so the command lines instructions below do not apply.\n\n\nThe Command to SSH\n\n\nRun:\n\n1\nssh <username>@pe111.comp.nus.edu.sg\n\n\n\n\n\nReplace \n<username>\n with your SoC UNIX username, for instance, I would do:\n\n1\nssh ooiwt@pe111.comp.nus.edu.sg\n\n\n\n\n\nAfter the command above, following the instructions on the screen.  The first time you ever connect to \npe111.comp.nus.edu.sg\n, you will be warned that you are connecting to a previously unknown host.  Say \nyes\n, and you will be prompted with your SoC UNIX password.\n\n\nAccessing The PE Hosts from Outside SoC\n\n\nThe PE hosts can only be accessed from within the School of Computing networks.  If you want to access it from outside, there are two ways.\n\n\nUsing SoC VPN\n\n\nOne way is to set up a Virtual Private Network (VPN) (See \ninstruction here\n).  The staff at \nhelpdesk@comp.nus.edu.sg\n or the IT helpdesk in COM1, Level 1, will be able to help with you setting up if needed.\n\n\nTunneling through Sunfire\n\n\nThe alternative is to use ssh tunnels.\n\n\nSoC's Sunfire (\nsunfire.comp.nus.edu.sg\n) is configured to allow your connection if it's originating from a local telco. (See \nmore details here\n.)  Since \nsunfire\n is situated within the School of Computing network, \nsunfire\n is able to access the VM.  This opens the possibility of connecting from your device (using an Internet connection from a local telco) to \nsunfire\n, and then from \nsunfire\n to the VM.\n\n\nThere are two ways to achieve this, and in both ways it appears to the PE hosts that Sunfire is the client.\n\n\nSSH Using Sunfire's Terminal\n\n\nConnect to Sunfire at \nsunfire.comp.nus.edu.sg\n via your favorite SSH client.  After logging in, run the command \nssh pe111\n to connect to the programming environment.  This effectively starts an SSH session to the programming environment from within your existing SSH session to Sunfire.  Refer to instructions below on how to connect via SSH.\n\n\nSSH Port Forwarding\n\n\nSSH has built-in support for local and remote port forwarding, and local port forwarding can be used to connect to the programming environments.  Local port forwarding means that a port of the SSH client (your machine) is forwarded to the SSH server (\nsunfire\n), which opens a connection to a preset destination server (e.g., \npe111\n).  This method causes the host to seem as if it is hosted on a local port, e.g. \nlocalhost\n:\n1010\n, allowing you to use your favorite SCP program (e.g. \nFileZilla\n) to access the PE host.\n\n\nTo use local port forwarding (from local port \n1010\n), connect to \nsunfire\n using\n\n1\nssh -L 1010:pe111.comp.nus.edu.sg:22 <username>@sunfire.comp.nus.edu.sg\n\n\n\n\nThis command opens an SSH tunnel from port \n1010\n of your machine to port \n22\n (the default SSH port) of \npe111.comp.nus.edu.sg\n via \nsunfire\n.  After successful login, open a separate SSH (or SCP) connection from your machine to \nlocalhost\n at port \n1010\n to access the PE host:\n\n\n1\nssh <username>@localhost -p 1000\n\n\n\n\n\n\nPuTTY\n supports SSH port forwarding, so this setup can also be used on Windows.\n\n\nSetting up SSH Keys\n\n\nOnce you are comfortable with UNIX, you can set up a pair of public/private keys for authentication.  \n\n\nYou can use\n\n1\nssh-keygen -t rsa\n\n\n\n\n\nto generate a pair of keys on your local computer.  Keep the private key \nid_rsa\n on your local machine in the hidden \n~/.ssh\n directory, and copy the public key \nid_rsa.pub\n to your home directory on PE \npe111\n.  On \npe111\n, run\n\n1\ncat id_rsa.pub >> ~/.ssh/authorized_keys\n\n\n\n\n\nMake sure that the permission for \n.ssh\n both on local machine and on PE is set to \n700\n and the files \nid_rsa\n on local machine and \nauthorized_keys\n on remote machine is set to \n600\n.  Once setup, you need not enter your password every time you run \nssh\n or \nscp\n.",
            "title": "Programming Environments"
        },
        {
            "location": "/environments/index.html#the-cs1010-programming-environment",
            "text": "C is a common programming language and you can find different implementations of C compiler on many platforms.  Wikipedia  lists more than 40 different C compilers .  These different compilers support different processor architecture, operating system, may behave slightly differently, and may support different features of C standards.  It is therefore important for CS1010 to stick to a single platform and single compiler.  Our platform of choice is  Ubuntu 16.04 (or later)  using the  clang  compiler ( version 3.4.2 or later ).  The school has provided a list of computing servers for you to use.  You can access them remotely via  ssh , or secure shell.  The hosts are named  pe111 ,  pe112 , ...,  pe120 .  ( pe  stands for \"programming environment\").  You can choose which of the 10 hosts to use.  You share the same home directory across all 10 hosts (this home directory, however, is different from that of  sunfire ).  For simplicity, the following guide uses  pe111  in all examples.  Do keep in mind that you can use other hosts for CS1010 to spread out the load.  While it is possible for you to complete the programming assignments on your own computers, the practical exams are done in a controlled environment using the desktop PCs in the programming labs.  It is therefore advisable for you to familiarize with accessing remote computing servers via  ssh  and edit your program with either  vim  or  macro .",
            "title": "The CS1010 Programming Environment"
        },
        {
            "location": "/environments/index.html#basic-requirements",
            "text": "You need to have an SoC UNIX account.  If you do not have one, you can  apply for one online .    Once you have an account, you need to [activate your access to the PE hosts] ( https://mysoc.nus.edu.sg/~myacct/services.cgi ), which is part of the SoC computer clusters.    You need an  ssh  client.  MacOS and Linux users should already have it installed by default.  Windows 10 users should install  the Windows Subsystem for Linux  and use Linux.    For older versions of Windows, such as those used in the SoC's programming labs, you can check out  XShell 6  (free for home/school use), or  PuTTY .  These are GUI-based programs so the command lines instructions below do not apply.",
            "title": "Basic Requirements"
        },
        {
            "location": "/environments/index.html#the-command-to-ssh",
            "text": "Run: 1 ssh <username>@pe111.comp.nus.edu.sg   Replace  <username>  with your SoC UNIX username, for instance, I would do: 1 ssh ooiwt@pe111.comp.nus.edu.sg   After the command above, following the instructions on the screen.  The first time you ever connect to  pe111.comp.nus.edu.sg , you will be warned that you are connecting to a previously unknown host.  Say  yes , and you will be prompted with your SoC UNIX password.",
            "title": "The Command to SSH"
        },
        {
            "location": "/environments/index.html#accessing-the-pe-hosts-from-outside-soc",
            "text": "The PE hosts can only be accessed from within the School of Computing networks.  If you want to access it from outside, there are two ways.",
            "title": "Accessing The PE Hosts from Outside SoC"
        },
        {
            "location": "/environments/index.html#using-soc-vpn",
            "text": "One way is to set up a Virtual Private Network (VPN) (See  instruction here ).  The staff at  helpdesk@comp.nus.edu.sg  or the IT helpdesk in COM1, Level 1, will be able to help with you setting up if needed.",
            "title": "Using SoC VPN"
        },
        {
            "location": "/environments/index.html#tunneling-through-sunfire",
            "text": "The alternative is to use ssh tunnels.  SoC's Sunfire ( sunfire.comp.nus.edu.sg ) is configured to allow your connection if it's originating from a local telco. (See  more details here .)  Since  sunfire  is situated within the School of Computing network,  sunfire  is able to access the VM.  This opens the possibility of connecting from your device (using an Internet connection from a local telco) to  sunfire , and then from  sunfire  to the VM.  There are two ways to achieve this, and in both ways it appears to the PE hosts that Sunfire is the client.",
            "title": "Tunneling through Sunfire"
        },
        {
            "location": "/environments/index.html#ssh-using-sunfires-terminal",
            "text": "Connect to Sunfire at  sunfire.comp.nus.edu.sg  via your favorite SSH client.  After logging in, run the command  ssh pe111  to connect to the programming environment.  This effectively starts an SSH session to the programming environment from within your existing SSH session to Sunfire.  Refer to instructions below on how to connect via SSH.",
            "title": "SSH Using Sunfire's Terminal"
        },
        {
            "location": "/environments/index.html#ssh-port-forwarding",
            "text": "SSH has built-in support for local and remote port forwarding, and local port forwarding can be used to connect to the programming environments.  Local port forwarding means that a port of the SSH client (your machine) is forwarded to the SSH server ( sunfire ), which opens a connection to a preset destination server (e.g.,  pe111 ).  This method causes the host to seem as if it is hosted on a local port, e.g.  localhost : 1010 , allowing you to use your favorite SCP program (e.g.  FileZilla ) to access the PE host.  To use local port forwarding (from local port  1010 ), connect to  sunfire  using 1 ssh -L 1010:pe111.comp.nus.edu.sg:22 <username>@sunfire.comp.nus.edu.sg  \nThis command opens an SSH tunnel from port  1010  of your machine to port  22  (the default SSH port) of  pe111.comp.nus.edu.sg  via  sunfire .  After successful login, open a separate SSH (or SCP) connection from your machine to  localhost  at port  1010  to access the PE host:  1 ssh <username>@localhost -p 1000   PuTTY  supports SSH port forwarding, so this setup can also be used on Windows.",
            "title": "SSH Port Forwarding"
        },
        {
            "location": "/environments/index.html#setting-up-ssh-keys",
            "text": "Once you are comfortable with UNIX, you can set up a pair of public/private keys for authentication.    You can use 1 ssh-keygen -t rsa   to generate a pair of keys on your local computer.  Keep the private key  id_rsa  on your local machine in the hidden  ~/.ssh  directory, and copy the public key  id_rsa.pub  to your home directory on PE  pe111 .  On  pe111 , run 1 cat id_rsa.pub >> ~/.ssh/authorized_keys   Make sure that the permission for  .ssh  both on local machine and on PE is set to  700  and the files  id_rsa  on local machine and  authorized_keys  on remote machine is set to  600 .  Once setup, you need not enter your password every time you run  ssh  or  scp .",
            "title": "Setting up SSH Keys"
        },
        {
            "location": "/unix/index.html",
            "text": "Basic UNIX Commands\n\n\nUNIX-based operating systems provide a command line to interact with the system: to create directory, to manipulate files, to run certain applications.  While these tasks can be done through a GUI interface, a command line is still useful because (i) it provides a simple way to interacting with a remote system (only text are exchanged between the local and remote hosts instead of graphics); (ii) it is extremely flexible and provides many customization options; (iii) you can easily automate the sequence of commands to issue for repetitive tasks; and (iv) it is faster.  \n\n\nConnect to the Programming Environment (PE)\n\n\nIf you would like to follow the following examples, you should first \nssh\n into one of the PE hosts provided.  We will use \npe111\n in the following example.  But feel free to use \npe112\n up to \npe120\n for your practice.  You should read \nthis guide\n to see how to access and connect to the environment.\n\n\nOnce you are connected, you should see a prompt like this.\n\n\n1\nooiwt@pe111:~$\n\n\n\n\n\n\nThis interface is provided by a UNIX bash -- this shell sits in a loop and wait for users to enter a command, then it interprets and executes the command.  There are many versions of shells, the default shell for our PE is \nbash\n1\n.\n\n\nThe following is adapted for CS1010 from \nthe instructions created by Aaron Tan\n. Bugs are mine.\n  \n\n\nThe power of UNIX stems from the many commands it offers. The following are a few commonly used commands. This list is by no means exhaustive and you are urged to explore on your own. Note that UNIX commands are \ncase-sensitive\n.\n\n\nAll commands are to be entered after the UNIX prompt of the form\n\n\n1\nooiwt@pe111:~$\n\n\n\n\n\n\n~\n indicates that you are currently in your home directory.  The following examples assumes that user \nooiwt\n is logged into \npe111\n.\n\n\nIt might be good to understand the directory structure in UNIX, a multi-user system. The directory tree is shown below:\n\n\n\n\nEach user has his/her own home directory, which is where he/she will be automatically placed when he/she logs into the system. The above figure shows where the home directory of user \nooiwt\n resides in the directory tree. The user \nooiwt\n may create files or directories in his/her home directory, but not elsewhere unless permission is given.\n\n\npwd\n: Print Current Working directory\n\n\npwd\n shows you which directory you are currently in\n\n1\n2\nooiwt@pe111:~$ pwd\n/home/o/ooiwt\n\n\n\n\n\nUNIX uses forward slash \n/\n to deliminate different parts of the directory structure.  This is the same notation as URLs so you should already be familiar with it.\n\n\nls\n: LiSt files\n\n\nThe \nls\n list the files in the current working directory.\n\n\n1\n2\nooiwt@pe111:~$ ls\nooiwt@pe111:~$\n\n\n\n\n\n\nIf you do not have any regular files in your home directory, as you should when you first login, you should immediately return to the bash prompt.  \n\n\n\n\nRule of Silence\n\n\nUNIX follows the \nrule of silence\n: programs should not print unnecessary output, to allow other programs and users to easily parse the output from one program.  So, if \nls\n has nothing to list, it will list nothing (as oppose to, say, printing \"This is an empty directory.\")\n\n\n\n\nmkdir\n: MaKe a subDIRectory\n\n\nThe \nmkdir\n command creates a subdirectory with the given name in the current directory.\n\n\n1\n2\n3\n4\n5\nooiwt@pe111:~$ mkdir tut01\nooiwt@pe111:~$ ls\ntut01\nooiwt@pe111:~$ ls -F\ntut01/\n\n\n\n\n\n\nHere, you create a directory called \ntut01\n.  Now, when you \nls\n, you can see the directory listed.\n\n\nYou may also use \nls -F\n for more information (\n-F\n is one of the many \noptions\n/\nflags\n available for the \nls\n command. To see a complete list of the options, refer to the man pages, i.e., \nman ls\n.)\n\n\nThe slash \n/\n beside the filename tells you that the file is a directory (aka folder in Windows lingo). A normal file does not have a slash beside its name when \"ls -F\" is used.\n\n\nYou may also use the \nls -l\n command (hyphen el, not hyphen one) to display almost all the file information, include the size of the file and the date of modification.\n\n\n\n\nUse Up Arrow for Command History\n\n\nUNIX maintains a history of your previously executed UNIX commands, and you may use the up and down arrows to go through it. Press the up arrow until you find a previously executed UNIX command. You may then press Enter to execute it, or edit the command before executing it. This is handy when you need to repeatedly executed a long UNIX command.\n\n\n\n\ncd\n: Change Directory\n\n\nTo navigate in the directory tree, changing the current working directory from to another, we use the \ncd\n command.\n\n\n1\n2\nooiwt@pe111:~$ cd tut01\nooiwt@pe111:~/tut01$\n\n\n\n\nNote that the prompt changes to \n~/tut01\n to indicate that you are now in the \ntut01\n directory below your \nHOME\n directory.\n\n\nEntering \ncd\n alone brings you back to your \nHOME\n directory, i.e., the directory in which you started with when you first logged into the system.\n\n1\n2\nooiwt@pe111:~/tut01$ cd\nooiwt@pe111:~$\n\n\n\n\n\nTwo dots \n..\n refers to the parent directory.  So, alternatively, for the case above, since we are only one level down from the \nHOME\n, to return to home, we can alternatively use \ncd ..\n.\n\n\n1\n2\nooiwt@pe111:~/tut01$ cd ..\nooiwt@pe111:~$\n\n\n\n\n\n\nrmdir\n: ReMove a subDIRectory\n\n\nrmdir\n removes a subDIRectory in current directory -- note that a directory must be empty before it can be removed.\n\n\n1\n2\n3\n4\n5\nooiwt@pe111:~$ rmdir tut01\nooiwt@pe111:~$ ls -F\nooiwt@pe111:~$ mkdir tut01\nooiwt@pe111:~$ ls -F\ntut01/\n\n\n\n\n\n\ncp\n: CoPy files\n\n\n1\n2\n3\nooiwt@pe111:~/tut01$ cp ~cs1010/tut01/hello.c .\nooiwt@pe111:~/tut01$ ls\nhello.c\n\n\n\n\nThe command above copies the file \nhello.c\n from the HOME of user \ncs1010\n, under directory \ntut01\n, to the current directory.\n\n\nIf you want to copy the whole directory, use \n-r\n flag, where \nr\n stands for recursive copy.\n\n\n1\nooiwt@pe111:~/tut01$ cp -r ~cs1010/tut01 .\n\n\n\n\n\n\nIn the last command above, the single \n.\n refers to the current directory.  \n\n\nThe directory \ntut01\n and everything under it will be copied to the current directory.\n\n\nmv\n: MoVe or rename files\n\n\nmv\n can move files from one directory to another.\n\n\n1\n2\n3\n4\n5\n6\n7\nooiwt@pe111:~/tut01$ ls\nhello.c\nooiwt@pe111:~/tut01$ mv hello.c ..\nooiwt@pe111:~/tut01$ ls\nooiwt@pe111:~/tut01$ ls ..\nhello.c\nooiwt@pe111:~/tut01$ mv ../hello.c .\n\n\n\n\n\n\nHere, we tell \nmv\n to copy a file \nhello.c\n from the parent directory to the current directory.\n\n\nmv\n can also be used to rename files.\n\n\n1\n2\n3\nooiwt@pe111:~/tut01$ mv hello.c hello_world.c\nooiwt@pe111:~/tut01$ ls\nhello_world.c\n\n\n\n\n\n\n\n\nUse TAB for Name Completion\n\n\nIf you have a very long file name, you may use UNIX's filename completion feature to reduce typing. For instance, you may type:\n\n1\nooiwt@pe111:~/tut01$ mv h\n\n\n\n\nand press the tab key, and UNIX will complete the filename for you if there is only one filename with the prefix \"h\". Otherwise, it will fill up the filename up to point where you need to type in more characters for disambiguation.\nThe tab key can also complete the name of command.\n\n\n\n\nrm\n: ReMove files\n\n\nBe careful with this command -- files deleted cannot be restored.  There is no trash or recycled bin like in Mac or Windows.\n\n\n1\n2\n3\nooiwt@pe111:~/tut01$ rm hello.c\nooiwt@pe111:~/tut01$ ls\nooiwt@pe111:~/tut01$\n\n\n\n\n\n\n\n\nrm -rf *\n\n\nWhile UNIX command line provides lots of flexibility and power, with great power comes great responsibility.  Some of the commands are extremely dangerous.  \nrm -rf *\n is the most famous one.  The notation \n*\n refers to all files, and the flag \n-f\n means forceful deletion (no question asked!) and \n-r\n means remove recursively everything under the current directory tree.  Accidentally running this command has ruined many files.  \nRead more here\n\n\n\n\nrm\n comes with a \n-i\n flag that interactively ask you if you are sure if you want to delete a file.  It is a good idea to always run \nrm -i\n.  On \npe111\n, we have configured everyone's account so that \nrm\n is aliased to \nrm -i\n by default.  So when you run \nrm hello.c\n, it actually runs \nrm -i hello.c\n.  \n\n\n1\n2\nooiwt@pe111:~/tut01$ rm hello.c\nrm: remove regular file \n'hello.c'\n? \n\n\n\n\n\n\nType \ny\n or \nn\n to answer yes or no respectively.\n\n\nIf you setup your own UNIX OS, you should add this alias \n\n\n1\nalias\n \nrm\n=\n\"rm -i\"\n\n\n\n\n\n\n\nto your \n.bashrc\n (Google to find out how).  Other useful aliases to avoid accidentally overwriting existing files are:\n\n\n1\n2\nalias\n \nmv\n=\n\"mv -i\"\n\n\nalias\n \ncp\n=\n\"cp -i\"\n\n\n\n\n\n\n\ncat\n: CATenate file content to screen\n\n\n1\nooiwt@pe111:~/tut01$ cat hello.c\n\n\n\n\n\n\nless\n is variant of \ncat\n that includes features to read each page leisurely)\n\n1\nooiwt@pe111:~/tut01$ less hello.c\n\n\n\n\n\nIn \nless\n, use \n<space>\n to move down one page, \nb\n to move Back up one page, and \nq\n to Quit.\n\n\nman\n: Online MANual\n\n\nAn online help facility is available in UNIX via the \nman\n command (\nman\n stands for MANual). To look for more information about any UNIX command, for example, \nls\n, type \nman ls\n. Type \nman man\n and refer to Man Pages to find out more about the facility. To exit \nman\n, press \nq\n.\n\n\nNow that you are familiar with how the UNIX bash works, I won't show the command prompt any more in the rest of this article.\n\n\nchmod\n: Changing UNIX File Permission\n\n\nIt is important to guide our files properly on a multi-user system where users share the same file system.  UNIX has a simple mechanism to for ensuring that: every file and directory has nine bits of access permission, corresponds to three access operations, read (\nr\n), write (\nw\n), and execute (\nx\n), for four classes of users, the user who owns of the file (\nu\n), users in the same group as the owner (\ng\n), all other users (\no\n), and all users (\na\n) (union of all three classes before)\n\n\nWhen you run \nls -l\n, you will see the permission encoded as strings that look like \n-rw-------\n or \ndrwx--x--x\n besides other file information.   \n\n\n\n\nThe first character indicates if the file is a directory (\nd\n) or not (\n-\n).  \n\n\nThe next three characters are the permission for the owner.  \nrwx\n means that the owner can do all three: reading, writing, and executing, \nrw-\n means that the owner can read and write, but cannot execute.\n\n\nThe next three characters are the permission for the users in the same group.\n\n\nThe last three characters are the permission for the users in the other groups.\n\n\n\n\nTo change permission, we use the \nchmod\n command.  Let's say that we want to remove the read and write permission from all other users in the group.  You can run:\n\n\n1\nchmod g-rw <file>\n\n\n\n\n\n\nwhere \n<file>\n is the name of the file whose permission you want to change.  This would change the permission from \n-rw-rw-rw-\n to \n-rw----rw-\n, or from \n-rwxr--r--\n to \n-rwx---r--\n.\n\n\nTo add executable permission to everyone, you can run:\n\n\n1\nchmod a+x <file>\n\n\n\n\n\n\nThis would change the permission from \n-rw-rw-rw-\n to \n-rwx--xrwx\n \n-rwxrwxrwx\n, or from \n-rwxr--r--\n to \n-rwx--xr-x\n \n-rwxr-xr-x\n, and so on.  You get the idea.\n\n\nAnother way to change the permission is set the permission directly, instead of adding with \n+\n and removing with \n-\n.  To do this, one convenient way is to treat the permission for each class of user as a 3-bit binary number between 0 to 7.  So, \nrwx\n is 7, \nrw-\n is 6, \n-w-\n is 2, \n---\n is 0, etc.  \n\n\nTo set the permission of a file to \n-r--r--r--\n (readable by everyone), run:\n\n\n1\nchmod \n444\n <file>\n\n\n\n\n\n\nTo set the permission to \n-rw-------\n, run:\n\n\n1\nchmod \n600\n <file>\n\n\n\n\n\n\nand so on.\n\n\nIt is important to ensure that your code is not readable and writable by other students, especially for graded lab exercises.\n\n\nscp\n: Secure Copy\n\n\nSecure copy, or \nscp\n, is one way to transfer files from the programming environments to your local computer for archiving or storage.  Let's say you want to transfer a set of C files from the directory \na01\n to your local computer, then, on your local computer, run:\n\n\n1\nooiwt@macbook:~$ scp ooiwt@pe111:~/a01/*.c .\n\n\n\n\n\n\n\n\nWarning\n\n\nIf you have files with the same name in the remote directory, the files will be overwritten without warning.  I have lost my code a few times due to \nscp\n.  \n\n\n\n\nThe expression \n*.c\n is a \nregular expression\n that means all files with filename ending with \n.c\n.  You can copy specific files as well.  For instance,\n\n\n1\nooiwt@macbook:~$ scp ooiwt@pe111:~/a01/hello.c .\n\n\n\n\n\n\nscp\n supports \n-r\n (recursive copy) as well.\n\n\nSpecifying A Path in UNIX\n\n\nIn any command above, when we need to refer to a directory or a file, we need to specify an \nunambiguous location\n of the directory or the file.  The most precise way to specify the location is to use the full path, or the \nabsolute path\n.  For instance:\n\n\n1\ncp /home/o/ooiwt/tut01/hello.c /home/o/ooiwt/tut01/hello_world.c\n\n\n\n\n\n\nThat's a lot of characters to type.  We could shorten it in a few ways.  \n\n\n\n\nWe could specify the location with respect to the home directory using \n~\n.  \n~ooiwt\n refers to the home directory of user \nooiwt\n.  \n\n\n\n\n1\ncp ~ooiwt/tut01/hello.c ~ooiwt/tut01/hello_world.c\n\n\n\n\n\n\nIf you are \nooiwt\n, then you can omit \nooiwt\n, since \n~\n without any username refers to your home directory.\n\n\n1\ncp ~/tut01/hello.c ~/tut01/hello_world.c\n\n\n\n\n\n\n\n\nOr we could specify the location with respect to the current directory.  Suppose the current working directory is \n~/tut01\n (i.e., we have \ncd\n into \n~/tut01\n), then we could say this:\n\n\n\n\n1\ncp ./hello.c ./hello_world.c\n\n\n\n\n\n\nRecall that a single dot \n.\n refers to the current directory.\n\n\nThe \n./\n however is redundant unless you are executing a command.  Since, by specifying a file name or a directory without a path (i.e., not using any \n/\n), the bash looks for the file or directory in the current directory.  So, we could just do:\n\n\n1\ncp hello.c hello_world.c\n\n\n\n\n\n\nAnother important short form for relative location is \n..\n.  Recall that this refers to the parent directory.  Suppose that the current directory is in \n~/tut02\n.  Then, to copy the files in \n~/tut01\n, you can run:\n\n\n1\ncp ../tut01/hello.c ../tut01/hello_world.c\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nI run \nfish\n on my macOS, as you might have noticed during the in-class demos.  You can use any bash you like, if you know what you are doing.  Otherwise, \nbash\n is a popular one.\u00a0\n\u21a9",
            "title": "UNIX"
        },
        {
            "location": "/unix/index.html#basic-unix-commands",
            "text": "UNIX-based operating systems provide a command line to interact with the system: to create directory, to manipulate files, to run certain applications.  While these tasks can be done through a GUI interface, a command line is still useful because (i) it provides a simple way to interacting with a remote system (only text are exchanged between the local and remote hosts instead of graphics); (ii) it is extremely flexible and provides many customization options; (iii) you can easily automate the sequence of commands to issue for repetitive tasks; and (iv) it is faster.",
            "title": "Basic UNIX Commands"
        },
        {
            "location": "/unix/index.html#connect-to-the-programming-environment-pe",
            "text": "If you would like to follow the following examples, you should first  ssh  into one of the PE hosts provided.  We will use  pe111  in the following example.  But feel free to use  pe112  up to  pe120  for your practice.  You should read  this guide  to see how to access and connect to the environment.  Once you are connected, you should see a prompt like this.  1 ooiwt@pe111:~$   This interface is provided by a UNIX bash -- this shell sits in a loop and wait for users to enter a command, then it interprets and executes the command.  There are many versions of shells, the default shell for our PE is  bash 1 .  The following is adapted for CS1010 from  the instructions created by Aaron Tan . Bugs are mine.     The power of UNIX stems from the many commands it offers. The following are a few commonly used commands. This list is by no means exhaustive and you are urged to explore on your own. Note that UNIX commands are  case-sensitive .  All commands are to be entered after the UNIX prompt of the form  1 ooiwt@pe111:~$   ~  indicates that you are currently in your home directory.  The following examples assumes that user  ooiwt  is logged into  pe111 .  It might be good to understand the directory structure in UNIX, a multi-user system. The directory tree is shown below:   Each user has his/her own home directory, which is where he/she will be automatically placed when he/she logs into the system. The above figure shows where the home directory of user  ooiwt  resides in the directory tree. The user  ooiwt  may create files or directories in his/her home directory, but not elsewhere unless permission is given.",
            "title": "Connect to the Programming Environment (PE)"
        },
        {
            "location": "/unix/index.html#pwd-print-current-working-directory",
            "text": "pwd  shows you which directory you are currently in 1\n2 ooiwt@pe111:~$ pwd\n/home/o/ooiwt   UNIX uses forward slash  /  to deliminate different parts of the directory structure.  This is the same notation as URLs so you should already be familiar with it.",
            "title": "pwd: Print Current Working directory"
        },
        {
            "location": "/unix/index.html#ls-list-files",
            "text": "The  ls  list the files in the current working directory.  1\n2 ooiwt@pe111:~$ ls\nooiwt@pe111:~$   If you do not have any regular files in your home directory, as you should when you first login, you should immediately return to the bash prompt.     Rule of Silence  UNIX follows the  rule of silence : programs should not print unnecessary output, to allow other programs and users to easily parse the output from one program.  So, if  ls  has nothing to list, it will list nothing (as oppose to, say, printing \"This is an empty directory.\")",
            "title": "ls: LiSt files"
        },
        {
            "location": "/unix/index.html#mkdir-make-a-subdirectory",
            "text": "The  mkdir  command creates a subdirectory with the given name in the current directory.  1\n2\n3\n4\n5 ooiwt@pe111:~$ mkdir tut01\nooiwt@pe111:~$ ls\ntut01\nooiwt@pe111:~$ ls -F\ntut01/   Here, you create a directory called  tut01 .  Now, when you  ls , you can see the directory listed.  You may also use  ls -F  for more information ( -F  is one of the many  options / flags  available for the  ls  command. To see a complete list of the options, refer to the man pages, i.e.,  man ls .)  The slash  /  beside the filename tells you that the file is a directory (aka folder in Windows lingo). A normal file does not have a slash beside its name when \"ls -F\" is used.  You may also use the  ls -l  command (hyphen el, not hyphen one) to display almost all the file information, include the size of the file and the date of modification.   Use Up Arrow for Command History  UNIX maintains a history of your previously executed UNIX commands, and you may use the up and down arrows to go through it. Press the up arrow until you find a previously executed UNIX command. You may then press Enter to execute it, or edit the command before executing it. This is handy when you need to repeatedly executed a long UNIX command.",
            "title": "mkdir: MaKe a subDIRectory"
        },
        {
            "location": "/unix/index.html#cd-change-directory",
            "text": "To navigate in the directory tree, changing the current working directory from to another, we use the  cd  command.  1\n2 ooiwt@pe111:~$ cd tut01\nooiwt@pe111:~/tut01$  \nNote that the prompt changes to  ~/tut01  to indicate that you are now in the  tut01  directory below your  HOME  directory.  Entering  cd  alone brings you back to your  HOME  directory, i.e., the directory in which you started with when you first logged into the system. 1\n2 ooiwt@pe111:~/tut01$ cd\nooiwt@pe111:~$   Two dots  ..  refers to the parent directory.  So, alternatively, for the case above, since we are only one level down from the  HOME , to return to home, we can alternatively use  cd .. .  1\n2 ooiwt@pe111:~/tut01$ cd ..\nooiwt@pe111:~$",
            "title": "cd: Change Directory"
        },
        {
            "location": "/unix/index.html#rmdir-remove-a-subdirectory",
            "text": "rmdir  removes a subDIRectory in current directory -- note that a directory must be empty before it can be removed.  1\n2\n3\n4\n5 ooiwt@pe111:~$ rmdir tut01\nooiwt@pe111:~$ ls -F\nooiwt@pe111:~$ mkdir tut01\nooiwt@pe111:~$ ls -F\ntut01/",
            "title": "rmdir: ReMove a subDIRectory"
        },
        {
            "location": "/unix/index.html#cp-copy-files",
            "text": "1\n2\n3 ooiwt@pe111:~/tut01$ cp ~cs1010/tut01/hello.c .\nooiwt@pe111:~/tut01$ ls\nhello.c  \nThe command above copies the file  hello.c  from the HOME of user  cs1010 , under directory  tut01 , to the current directory.  If you want to copy the whole directory, use  -r  flag, where  r  stands for recursive copy.  1 ooiwt@pe111:~/tut01$ cp -r ~cs1010/tut01 .   In the last command above, the single  .  refers to the current directory.    The directory  tut01  and everything under it will be copied to the current directory.",
            "title": "cp: CoPy files"
        },
        {
            "location": "/unix/index.html#mv-move-or-rename-files",
            "text": "mv  can move files from one directory to another.  1\n2\n3\n4\n5\n6\n7 ooiwt@pe111:~/tut01$ ls\nhello.c\nooiwt@pe111:~/tut01$ mv hello.c ..\nooiwt@pe111:~/tut01$ ls\nooiwt@pe111:~/tut01$ ls ..\nhello.c\nooiwt@pe111:~/tut01$ mv ../hello.c .   Here, we tell  mv  to copy a file  hello.c  from the parent directory to the current directory.  mv  can also be used to rename files.  1\n2\n3 ooiwt@pe111:~/tut01$ mv hello.c hello_world.c\nooiwt@pe111:~/tut01$ ls\nhello_world.c    Use TAB for Name Completion  If you have a very long file name, you may use UNIX's filename completion feature to reduce typing. For instance, you may type: 1 ooiwt@pe111:~/tut01$ mv h  \nand press the tab key, and UNIX will complete the filename for you if there is only one filename with the prefix \"h\". Otherwise, it will fill up the filename up to point where you need to type in more characters for disambiguation.\nThe tab key can also complete the name of command.",
            "title": "mv: MoVe or rename files"
        },
        {
            "location": "/unix/index.html#rm-remove-files",
            "text": "Be careful with this command -- files deleted cannot be restored.  There is no trash or recycled bin like in Mac or Windows.  1\n2\n3 ooiwt@pe111:~/tut01$ rm hello.c\nooiwt@pe111:~/tut01$ ls\nooiwt@pe111:~/tut01$    rm -rf *  While UNIX command line provides lots of flexibility and power, with great power comes great responsibility.  Some of the commands are extremely dangerous.   rm -rf *  is the most famous one.  The notation  *  refers to all files, and the flag  -f  means forceful deletion (no question asked!) and  -r  means remove recursively everything under the current directory tree.  Accidentally running this command has ruined many files.   Read more here   rm  comes with a  -i  flag that interactively ask you if you are sure if you want to delete a file.  It is a good idea to always run  rm -i .  On  pe111 , we have configured everyone's account so that  rm  is aliased to  rm -i  by default.  So when you run  rm hello.c , it actually runs  rm -i hello.c .    1\n2 ooiwt@pe111:~/tut01$ rm hello.c\nrm: remove regular file  'hello.c' ?    Type  y  or  n  to answer yes or no respectively.  If you setup your own UNIX OS, you should add this alias   1 alias   rm = \"rm -i\"    to your  .bashrc  (Google to find out how).  Other useful aliases to avoid accidentally overwriting existing files are:  1\n2 alias   mv = \"mv -i\"  alias   cp = \"cp -i\"",
            "title": "rm: ReMove files"
        },
        {
            "location": "/unix/index.html#cat-catenate-file-content-to-screen",
            "text": "1 ooiwt@pe111:~/tut01$ cat hello.c   less  is variant of  cat  that includes features to read each page leisurely) 1 ooiwt@pe111:~/tut01$ less hello.c   In  less , use  <space>  to move down one page,  b  to move Back up one page, and  q  to Quit.",
            "title": "cat: CATenate file content to screen"
        },
        {
            "location": "/unix/index.html#man-online-manual",
            "text": "An online help facility is available in UNIX via the  man  command ( man  stands for MANual). To look for more information about any UNIX command, for example,  ls , type  man ls . Type  man man  and refer to Man Pages to find out more about the facility. To exit  man , press  q .  Now that you are familiar with how the UNIX bash works, I won't show the command prompt any more in the rest of this article.",
            "title": "man: Online MANual"
        },
        {
            "location": "/unix/index.html#chmod-changing-unix-file-permission",
            "text": "It is important to guide our files properly on a multi-user system where users share the same file system.  UNIX has a simple mechanism to for ensuring that: every file and directory has nine bits of access permission, corresponds to three access operations, read ( r ), write ( w ), and execute ( x ), for four classes of users, the user who owns of the file ( u ), users in the same group as the owner ( g ), all other users ( o ), and all users ( a ) (union of all three classes before)  When you run  ls -l , you will see the permission encoded as strings that look like  -rw-------  or  drwx--x--x  besides other file information.      The first character indicates if the file is a directory ( d ) or not ( - ).    The next three characters are the permission for the owner.   rwx  means that the owner can do all three: reading, writing, and executing,  rw-  means that the owner can read and write, but cannot execute.  The next three characters are the permission for the users in the same group.  The last three characters are the permission for the users in the other groups.   To change permission, we use the  chmod  command.  Let's say that we want to remove the read and write permission from all other users in the group.  You can run:  1 chmod g-rw <file>   where  <file>  is the name of the file whose permission you want to change.  This would change the permission from  -rw-rw-rw-  to  -rw----rw- , or from  -rwxr--r--  to  -rwx---r-- .  To add executable permission to everyone, you can run:  1 chmod a+x <file>   This would change the permission from  -rw-rw-rw-  to  -rwx--xrwx   -rwxrwxrwx , or from  -rwxr--r--  to  -rwx--xr-x   -rwxr-xr-x , and so on.  You get the idea.  Another way to change the permission is set the permission directly, instead of adding with  +  and removing with  - .  To do this, one convenient way is to treat the permission for each class of user as a 3-bit binary number between 0 to 7.  So,  rwx  is 7,  rw-  is 6,  -w-  is 2,  ---  is 0, etc.    To set the permission of a file to  -r--r--r--  (readable by everyone), run:  1 chmod  444  <file>   To set the permission to  -rw------- , run:  1 chmod  600  <file>   and so on.  It is important to ensure that your code is not readable and writable by other students, especially for graded lab exercises.",
            "title": "chmod: Changing UNIX File Permission"
        },
        {
            "location": "/unix/index.html#scp-secure-copy",
            "text": "Secure copy, or  scp , is one way to transfer files from the programming environments to your local computer for archiving or storage.  Let's say you want to transfer a set of C files from the directory  a01  to your local computer, then, on your local computer, run:  1 ooiwt@macbook:~$ scp ooiwt@pe111:~/a01/*.c .    Warning  If you have files with the same name in the remote directory, the files will be overwritten without warning.  I have lost my code a few times due to  scp .     The expression  *.c  is a  regular expression  that means all files with filename ending with  .c .  You can copy specific files as well.  For instance,  1 ooiwt@macbook:~$ scp ooiwt@pe111:~/a01/hello.c .   scp  supports  -r  (recursive copy) as well.",
            "title": "scp: Secure Copy"
        },
        {
            "location": "/unix/index.html#specifying-a-path-in-unix",
            "text": "In any command above, when we need to refer to a directory or a file, we need to specify an  unambiguous location  of the directory or the file.  The most precise way to specify the location is to use the full path, or the  absolute path .  For instance:  1 cp /home/o/ooiwt/tut01/hello.c /home/o/ooiwt/tut01/hello_world.c   That's a lot of characters to type.  We could shorten it in a few ways.     We could specify the location with respect to the home directory using  ~ .   ~ooiwt  refers to the home directory of user  ooiwt .     1 cp ~ooiwt/tut01/hello.c ~ooiwt/tut01/hello_world.c   If you are  ooiwt , then you can omit  ooiwt , since  ~  without any username refers to your home directory.  1 cp ~/tut01/hello.c ~/tut01/hello_world.c    Or we could specify the location with respect to the current directory.  Suppose the current working directory is  ~/tut01  (i.e., we have  cd  into  ~/tut01 ), then we could say this:   1 cp ./hello.c ./hello_world.c   Recall that a single dot  .  refers to the current directory.  The  ./  however is redundant unless you are executing a command.  Since, by specifying a file name or a directory without a path (i.e., not using any  / ), the bash looks for the file or directory in the current directory.  So, we could just do:  1 cp hello.c hello_world.c   Another important short form for relative location is  .. .  Recall that this refers to the parent directory.  Suppose that the current directory is in  ~/tut02 .  Then, to copy the files in  ~/tut01 , you can run:  1 cp ../tut01/hello.c ../tut01/hello_world.c       I run  fish  on my macOS, as you might have noticed during the in-class demos.  You can use any bash you like, if you know what you are doing.  Otherwise,  bash  is a popular one.\u00a0 \u21a9",
            "title": "Specifying A Path in UNIX"
        },
        {
            "location": "/clang/index.html",
            "text": "CS1010 Compilation Guide\n\n\n1. Compile a standalone C program\n\n\nSuppose we have a standalone C program \nteh.c\n that does not use any external libraries.  We can compile the program using the command\n\n\n1\nooiwt@pe118:~$ clang teh.c\n\n\n\n\n\n\nThis command should create an executable called \na.out\n in the current directory, which you can then run with:\n\n\n1\nooiwt@pe118:~$ ./a.out\n\n\n\n\n\n\n2. Renaming executable file\n\n\nThe name \na.out\n is an abbreviation for \nassembler output\n, a name that many compilers kept as the default output name since the 60s.  We should, however, give our executable more descriptive name, by using the \n-o\n flag.  (\no\n is the mnemonic for output).\n\n\n1\nooiwt@pe118:~$ clang teh.c -o teh\n\n\n\n\n\n\nor\n\n\n1\nooiwt@pe118:~$ clang -o teh teh.c\n\n\n\n\n\n\nThe command above would create an executable called \nteh\n.\n\n\n\n\nBeware of the order\n\n\nIf you are not careful and run the following command instead:\n\n1\nooiwt@pe118:~$ clang -o teh.c teh\n\n\n\n\n\nclang\n would overwrite your code \nteh.c\n -- all your hard work will be gone!!\n\n\n\n\n3. Warning for possible bugs.\n\n\nThe \nclang\n checks for syntax errors in your C files -- i.e., things that violate the C syntax rules.  The compiler, however, is smart enough to identify possible bugs -- errors that will cause your program to behave incorrectly, even if the syntax follows C's rules.  You can ask \nclang\n to warn you about this, using the \n-W\n flag (\nW\n is the mnemonic for warning -- note the capital W).  The manual for \nclang\n lists different types of warnings that \nclang\n can warn you about.  For simplicity, we will ask \nclang\n to warn us about everything, by enabling \nall\n warnings.  The command to do so is:\n\n\n1\nooiwt@pe118:~$ clang -Wall teh.c -o teh\n\n\n\n\n\n\nFor beginners, it is \nhighly recommended\n that you \nalways\n compile with \n-Wall\n flag.\n\n\n4. Generating additional information for debugging.\n\n\nIn order to use the debugger \nlldb\n to trace through and debug your program, \nclang\n needs to generate additional information and store them in the executable file.  We can instruct \nclang\n to generate them with the flag \n-g\n (\ng\n for generate).  \n\n\n1\nooiwt@pe118:~$ clang -Wall -g teh.c -o teh\n\n\n\n\n\n\nIt is recommended that you always compile with \n-g\n flags during development phase.  If you need to measure the performance (e.g., how fast it runs) of your program or when you are releasing the program to the public, you can remove the \n-g\n flag and compile with the optimization flags (e.g., \n-O\n) instead.  \n\n\n5. Linking with standard library.\n\n\nTo link with a standard library, we use the \n-l\n flag to specify the name of the library to link.  For instance, to link with the C standard math library (abbreviated \nm\n), you issue the command:\n\n\n1\nooiwt@pe118:~$ clang -Wall -g teh.c -o teh -lm\n\n\n\n\n\n\n6. Linking with 3\nrd\n party library\n\n\nBy default, \nclang\n looks for headers and libraries in the systems directories (\n/usr/include\n, \n/usr/lib\n, etc) and the current working directory.  \n\n\nIf you use a third party library, you usually need to tell \nclang\n where to look for the corresponding headers and libraries.  You can use the \n-I\n flag and the \n-L\n flag for these purposes. For instance, if you have a library installed under your home called \ncitadel\n, and the file \ncitadel.h\n can be found under \n~/citadel/include\n and the file \nlibcitadel.a\n can be found under \n~/citadel/lib\n, to tell \nclang\n where to find these files, you can compile with:\n\n\n1\nooiwt@pe118:~$ clang -Wall -g -I ~/citadel/include -L ~/citadel/lib teh.c -o teh -lm -lcitadel",
            "title": "CLang"
        },
        {
            "location": "/clang/index.html#cs1010-compilation-guide",
            "text": "",
            "title": "CS1010 Compilation Guide"
        },
        {
            "location": "/clang/index.html#1-compile-a-standalone-c-program",
            "text": "Suppose we have a standalone C program  teh.c  that does not use any external libraries.  We can compile the program using the command  1 ooiwt@pe118:~$ clang teh.c   This command should create an executable called  a.out  in the current directory, which you can then run with:  1 ooiwt@pe118:~$ ./a.out",
            "title": "1. Compile a standalone C program"
        },
        {
            "location": "/clang/index.html#2-renaming-executable-file",
            "text": "The name  a.out  is an abbreviation for  assembler output , a name that many compilers kept as the default output name since the 60s.  We should, however, give our executable more descriptive name, by using the  -o  flag.  ( o  is the mnemonic for output).  1 ooiwt@pe118:~$ clang teh.c -o teh   or  1 ooiwt@pe118:~$ clang -o teh teh.c   The command above would create an executable called  teh .   Beware of the order  If you are not careful and run the following command instead: 1 ooiwt@pe118:~$ clang -o teh.c teh   clang  would overwrite your code  teh.c  -- all your hard work will be gone!!",
            "title": "2. Renaming executable file"
        },
        {
            "location": "/clang/index.html#3-warning-for-possible-bugs",
            "text": "The  clang  checks for syntax errors in your C files -- i.e., things that violate the C syntax rules.  The compiler, however, is smart enough to identify possible bugs -- errors that will cause your program to behave incorrectly, even if the syntax follows C's rules.  You can ask  clang  to warn you about this, using the  -W  flag ( W  is the mnemonic for warning -- note the capital W).  The manual for  clang  lists different types of warnings that  clang  can warn you about.  For simplicity, we will ask  clang  to warn us about everything, by enabling  all  warnings.  The command to do so is:  1 ooiwt@pe118:~$ clang -Wall teh.c -o teh   For beginners, it is  highly recommended  that you  always  compile with  -Wall  flag.",
            "title": "3. Warning for possible bugs."
        },
        {
            "location": "/clang/index.html#4-generating-additional-information-for-debugging",
            "text": "In order to use the debugger  lldb  to trace through and debug your program,  clang  needs to generate additional information and store them in the executable file.  We can instruct  clang  to generate them with the flag  -g  ( g  for generate).    1 ooiwt@pe118:~$ clang -Wall -g teh.c -o teh   It is recommended that you always compile with  -g  flags during development phase.  If you need to measure the performance (e.g., how fast it runs) of your program or when you are releasing the program to the public, you can remove the  -g  flag and compile with the optimization flags (e.g.,  -O ) instead.",
            "title": "4. Generating additional information for debugging."
        },
        {
            "location": "/clang/index.html#5-linking-with-standard-library",
            "text": "To link with a standard library, we use the  -l  flag to specify the name of the library to link.  For instance, to link with the C standard math library (abbreviated  m ), you issue the command:  1 ooiwt@pe118:~$ clang -Wall -g teh.c -o teh -lm",
            "title": "5. Linking with standard library."
        },
        {
            "location": "/clang/index.html#6-linking-with-3rd-party-library",
            "text": "By default,  clang  looks for headers and libraries in the systems directories ( /usr/include ,  /usr/lib , etc) and the current working directory.    If you use a third party library, you usually need to tell  clang  where to look for the corresponding headers and libraries.  You can use the  -I  flag and the  -L  flag for these purposes. For instance, if you have a library installed under your home called  citadel , and the file  citadel.h  can be found under  ~/citadel/include  and the file  libcitadel.a  can be found under  ~/citadel/lib , to tell  clang  where to find these files, you can compile with:  1 ooiwt@pe118:~$ clang -Wall -g -I ~/citadel/include -L ~/citadel/lib teh.c -o teh -lm -lcitadel",
            "title": "6. Linking with 3rd party library"
        },
        {
            "location": "/vim/index.html",
            "text": "Vim Tips\n\n\nI collected below some tips on \nvim\n that I find helpful.  If you are new to \nvim\n, please try out the command \nvimtutor\n on any machine where \nvim\n is installed, and check out the nice article \nLearn vim Progressively\n.  \n\n\n1. Useful Configuration\n\n\nYou can configure your \nvim\n by putting your configuration options and scripts in the \n~/.vimrc\n file (a hidden file named \n.vimrc\n in your home directory).  This file will be loaded whenever you starts \nvim\n.\n\n\nYou can copy a sample \n.vimrc\n file from \n~cs1010/.vimrc\n to your home directory. \nYou can edit this file \n~/.vimrc\n just like any other file, using \nvim\n.\n\n\nHelp\n\n\nIn \nvim,\n the command \n:help <topic>\n shows help about a particular topic in \nvim\n.  Example, \n:help backup\n.\n\n\nBackup Files\n\n\nYou can ask \nvim\n to automatically backup files that you edit.  This has been a life saver for me in multiple  occasions.\n\n\nIn your \n~/.vimrc\n file, \n\n\n1\nset backup\n\n\n\n\n\n\nwill cause a copy of your file to be save with suffix \n~\n appended to its name everytime you save.\n\n\nI prefer not to clutter my working directory, so I set\n\n\n1\nset backupdir=~/.backup\n\n\n\n\n\n\nand create a directory named \n~/.backup\n to store my backup files.\n\n\nSo if you made changes to a file that you regreted, or if you accidentally deleted a file, you can check under \n~/.backup\n to see if the backup can save you.\n\n\nSyntax Highlighting\n\n\nIf for some reasons, syntax highlighting is not on by default, add this to your \n~/.vimrc\n:\n\n\n1\nsyntax on\n\n\n\n\n\n\nRuler and Numbers\n\n\nIf you prefer to show the line number you are on and the column number you are on, adding the commands to \n~/.vimrc\n\n\n1\nset ruler\n\n\n\n\n\n\nwill display the line number and the column number on the lower right corner.  \n\n\nYou can also add\n\n1\nset number\n\n\n\n\n\nto label each line with a line number.\n\n\nAuto Indentation \n(new)\n\n\nProper indentation is important to make your code readable (to yourself and others).  You should enable this in \nvim\n with:\n\n\n1\n2\nset autoindent \nset smartindent\n\n\n\n\n\n\nAutoindent will cause the next line to have the same indentation as the previous line; while smartindent has some understanding of C-like syntax (such as recognizing \n{\n and \n}\n) and indent your code accordingly.  The size of the indentation is based on the setting \nshiftwidth\n.  For CS1010, please set it to either \n2\n or \n4\n:\n\n\n1\nset shiftwidth=2\n\n\n\n\n\n\n2. Navigation\n\n\nBasic Navigation\n\n\nUse \nk\n and \nj\n keys to move up and down (just like Gmail and Facebook!).  \nh\n and \nl\n to move left and right.\n\n\nOther shortcuts (no need to memorize them now, just refer back when you feel like you are typing too many \nhjkl\n to see how you can navigate faster).\n\n\n\n\nw\n   jump to the beginning of the next word\n\n\nb\n   jump to the beginning of the previous word (reverse of \nw\n)\n\n\ne\n   jump to the end of the word (or next word when pressed again)\n\n\nf\n + char: search forward in the line and sit on the next matching char\n\n\nt\n + char:  search forward in the line and sit on one space before the matching char\n\n\n$\n jump to end of line\n\n\n0\n jump to the beginning of the line\n\n\n^\n jump to the first non-blank character of the line\n\n\n%\n jump between matching parentheses\n\n\nCTRL-\nd\n jump forward (Down) half page\n\n\nCTRL-\nf\n jump Forward one page\n\n\nCTRL-\nu\n jump backward (Up) half page\n\n\nCTRL-\nb\n jump Backward half page\n\n\n\n\nJumping to a Line\n\n\nIf the compiler tells you there is an error on Line \nx\nx\n, you can issue \n:<x>\n to jump to Line \nx\nx\n.  For instance, \n:40\n will go to Line 40.\n\n\n3. Editing Operations\n\n\nUndo\n\n\nSince we are on the topic of correcting mistakes, \nu\n in command mode undo your changes.  Prefix it with a number \nn\nn\n to undo \nn\nn\n times.  If you want to undo your undo, \n<CTRL-R>\n will redo.\n\n\nNavigation + Editing\n\n\nvim\n is powerful because you can combine \noperations\n with \nnavigation\n.  For instance \nc\n to change, \nd\n to delete, \ny\n to yank (copy).  Since \nw\n is the navigation command to move over the current word, combining them we get:\n\n\n\n\ncw\n change the current word (delete the current word and enter insert mode)\n\n\ndw\n delete the current word\n\n\nyw\n yank the current word (copy word into buffer)\n\n\n\n\nCan you guess what \ndf)\n, \ndt)\n, \nc$\n, \ny0\n do?\n\n\nIf you repeat the operation \nc\n, \nd\n, and \ny\n, it applies to the whole line, so:\n\n\n\n\ncc\n change the whole line\n\n\ndd\n delete the whole line\n\n\nyy\n yank the whole line\n\n\n\n\nYou can add a number before an operation to specify how many times you want to repeat an operation.  So \n5dd\n deletes 5 lines, \n5dw\n deletes 5 words, etc.\n\n\nSee the article \nOperator, the True Power of \nVim\n for more details.\n\n\nSwapping Lines\n\n\nSometimes you want to swap the order of two lines of code, in command mode, \nddp\n will do the trick.  \ndd\n deletes the current line, \np\n paste it after the current line, in effect swapping the order of the two lines.\n\n\nCommenting blocks of code\n\n\nSometimes we need to comment out a whole block of code in C for testing purposes. There are several ways to do it in \nvim\n:\n\n\n\n\nPlace the cursor on the first line of the block of code you want to comment.\n\n\n0\n to jump to the beginning of the line\n\n\nV\n enter visual mode\n\n\nUse arrow key to select the block of code you want to comment. \n\n\nI\n to insert at the beginning of the line (here, since we already selected the block, we will insert at the beginning of every selected)\n\n\n//\n to insert the Java comment character (you will see it inserted in the current line, but don't worry)\n\n\n to escape from the visual code.\n\n\n\n\nTo uncomment, \n\n\n\n\nPlace the cursor on the first line of the block of code you want to comment.\n\n\n0\n to jump to the beginning of the line\n\n\n<CTRL-v>\n enter block visual mode\n\n\nUse arrow key to select the columns of text containing \n//\n\n\nx\n to delete them\n\n\n\n\n4. Other Advanced Features\n\n\nSearch and Replace in \nvim\n\n\n1\n:%s/oldWord/newWord/gc \n\n\n\n\n\n\n:\n enters the command mode.  \n%\n means apply to the whole document, \ns\n means substitute, \ng\n means global (otherwise, only the first occurance of each line is replaced). \nc\n is optional -- adding it cause \nvim\n to confirm with you before each replacement  \n\n\nShell Command\n\n\nIf you need to issue a shell command quickly, you don't have to exit \nvim\n, run the command, and launch \nvim\n again.  You can use \n!\n, \n\n\n1\n:!<command>\n\n\n\n\n\n\nwill issue the command to shell.  E.g.,\n\n\n1\n:!ls\n\n\n\n\n\n\nYou can use this to compile your current file, without exiting \nvim\n.\n\n\n1\n:!make\n\n\n\n\n\n\nmake\n is actually a builtin command for \nvim\n so you can also simply run\n\n\n1\n:make\n\n\n\n\n\n\nAbbreviation\n\n\nYou can use the command \nab\n to abbreviate frequently typed commands.  E.g., in your \n~/.vimrc\n, \n\n\n1\nab pl cs1010_print_long(\n\n\n\n\n\n\nNow, when you type \npl\n, it will be expanded into \ncs1010_print_long(\n\n\nAuto-Completion\n\n\nYou can \n<CTRL-P>\n to auto-complete.  By default, the auto-complete dictionary is based on text in your current editing buffers.  This is a very useful keystroke saver for long function and variable names.\n\n\nAuto-Indent the Whole File\n\n\nYou can \ngg=G\n in command mode to auto-indent the whole file.  \ngg\n is the command to go to the beginning of the file.  \n=\n is the command to indent.  \nG\n is the command to go to the end of the file.  \n\n\nSplitting \nvim\n's Viewport\n\n\n\n\n:sp file.c\n splits the \nvim\n window horizontally\n\n\n:vsp file.c\n splits the \nvim\n window vertically\n\n\nCtrl-w Ctrl-w\n moves between the different \nvim\n viewports\n\n\n\n\n5. Plugins\n\n\nSyntax and Style Checker\n\n\nI use \nsyntastic\n to check for style and syntax whenever I save a file.  \nsyntastic\n is a \nvim\n plugin. \n\n\nMy \n.vimrc\n configuration file contains the following:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\"For syntastic\nset laststatus=2\nset statusline+=%#warningmsg#\nset statusline+=%{SyntasticStatuslineFlag()}\nset statusline+=%*\n\nlet g:syntastic_error_symbol = '\u2717'\nlet g:syntastic_warning_symbol = '\u26a0'\nlet g:syntastic_always_populate_loc_list = 1\nlet g:syntastic_auto_loc_list = 1\nlet g:syntastic_check_on_open = 1\nlet g:syntastic_check_on_wq = 0\n\nlet g:syntastic_c_checkers = [ 'clang_tidy', 'clang' ]\nlet g:syntastic_c_compiler = 'clang'\nlet g:syntastic_c_clang_args = '-Wall -Werror -Wextra -Iinclude'\nlet g:syntastic_c_clang_tidy_args = '-checks=*'\nlet g:syntastic_c_compiler_options = '-Wall -Iinclude'\nlet g:syntastic_c_include_dirs = [ '../include', 'include' ]\nlet g:syntastic_c_clang_tidy_post_args = \"\"\n\n\n\n\n\n\nNew Addition:\n By default, \nclang-tidy\n does not know where to find the header files.  So if you include non-standard C headers, it will complain that it cannot find headers.  To resolve this, we need to tell \nclang-tidy\n the compilation flags that we use when compiling our program.  \n\n\nWe can do this by creating a file named \ncompile_flags.txt\n in your working directory (where your C files are located), containing one compilation flag per line.  For instance, if the header files are located in \n/home/course/cs1010/include\n, your \ncompile_flags.txt\n should contain the following two lines:\n\n\n1\n2\n-Wall\n-I/home/course/cs1010/include",
            "title": "Vim"
        },
        {
            "location": "/vim/index.html#vim-tips",
            "text": "I collected below some tips on  vim  that I find helpful.  If you are new to  vim , please try out the command  vimtutor  on any machine where  vim  is installed, and check out the nice article  Learn vim Progressively .",
            "title": "Vim Tips"
        },
        {
            "location": "/vim/index.html#1-useful-configuration",
            "text": "You can configure your  vim  by putting your configuration options and scripts in the  ~/.vimrc  file (a hidden file named  .vimrc  in your home directory).  This file will be loaded whenever you starts  vim .  You can copy a sample  .vimrc  file from  ~cs1010/.vimrc  to your home directory. \nYou can edit this file  ~/.vimrc  just like any other file, using  vim .",
            "title": "1. Useful Configuration"
        },
        {
            "location": "/vim/index.html#help",
            "text": "In  vim,  the command  :help <topic>  shows help about a particular topic in  vim .  Example,  :help backup .",
            "title": "Help"
        },
        {
            "location": "/vim/index.html#backup-files",
            "text": "You can ask  vim  to automatically backup files that you edit.  This has been a life saver for me in multiple  occasions.  In your  ~/.vimrc  file,   1 set backup   will cause a copy of your file to be save with suffix  ~  appended to its name everytime you save.  I prefer not to clutter my working directory, so I set  1 set backupdir=~/.backup   and create a directory named  ~/.backup  to store my backup files.  So if you made changes to a file that you regreted, or if you accidentally deleted a file, you can check under  ~/.backup  to see if the backup can save you.",
            "title": "Backup Files"
        },
        {
            "location": "/vim/index.html#syntax-highlighting",
            "text": "If for some reasons, syntax highlighting is not on by default, add this to your  ~/.vimrc :  1 syntax on",
            "title": "Syntax Highlighting"
        },
        {
            "location": "/vim/index.html#ruler-and-numbers",
            "text": "If you prefer to show the line number you are on and the column number you are on, adding the commands to  ~/.vimrc  1 set ruler   will display the line number and the column number on the lower right corner.    You can also add 1 set number   to label each line with a line number.",
            "title": "Ruler and Numbers"
        },
        {
            "location": "/vim/index.html#auto-indentation-czjqqkd0newczjqqkd1",
            "text": "Proper indentation is important to make your code readable (to yourself and others).  You should enable this in  vim  with:  1\n2 set autoindent \nset smartindent   Autoindent will cause the next line to have the same indentation as the previous line; while smartindent has some understanding of C-like syntax (such as recognizing  {  and  } ) and indent your code accordingly.  The size of the indentation is based on the setting  shiftwidth .  For CS1010, please set it to either  2  or  4 :  1 set shiftwidth=2",
            "title": "Auto Indentation (new)"
        },
        {
            "location": "/vim/index.html#2-navigation",
            "text": "",
            "title": "2. Navigation"
        },
        {
            "location": "/vim/index.html#basic-navigation",
            "text": "Use  k  and  j  keys to move up and down (just like Gmail and Facebook!).   h  and  l  to move left and right.  Other shortcuts (no need to memorize them now, just refer back when you feel like you are typing too many  hjkl  to see how you can navigate faster).   w    jump to the beginning of the next word  b    jump to the beginning of the previous word (reverse of  w )  e    jump to the end of the word (or next word when pressed again)  f  + char: search forward in the line and sit on the next matching char  t  + char:  search forward in the line and sit on one space before the matching char  $  jump to end of line  0  jump to the beginning of the line  ^  jump to the first non-blank character of the line  %  jump between matching parentheses  CTRL- d  jump forward (Down) half page  CTRL- f  jump Forward one page  CTRL- u  jump backward (Up) half page  CTRL- b  jump Backward half page",
            "title": "Basic Navigation"
        },
        {
            "location": "/vim/index.html#jumping-to-a-line",
            "text": "If the compiler tells you there is an error on Line  x x , you can issue  :<x>  to jump to Line  x x .  For instance,  :40  will go to Line 40.",
            "title": "Jumping to a Line"
        },
        {
            "location": "/vim/index.html#3-editing-operations",
            "text": "",
            "title": "3. Editing Operations"
        },
        {
            "location": "/vim/index.html#undo",
            "text": "Since we are on the topic of correcting mistakes,  u  in command mode undo your changes.  Prefix it with a number  n n  to undo  n n  times.  If you want to undo your undo,  <CTRL-R>  will redo.",
            "title": "Undo"
        },
        {
            "location": "/vim/index.html#navigation-editing",
            "text": "vim  is powerful because you can combine  operations  with  navigation .  For instance  c  to change,  d  to delete,  y  to yank (copy).  Since  w  is the navigation command to move over the current word, combining them we get:   cw  change the current word (delete the current word and enter insert mode)  dw  delete the current word  yw  yank the current word (copy word into buffer)   Can you guess what  df) ,  dt) ,  c$ ,  y0  do?  If you repeat the operation  c ,  d , and  y , it applies to the whole line, so:   cc  change the whole line  dd  delete the whole line  yy  yank the whole line   You can add a number before an operation to specify how many times you want to repeat an operation.  So  5dd  deletes 5 lines,  5dw  deletes 5 words, etc.  See the article  Operator, the True Power of  Vim  for more details.",
            "title": "Navigation + Editing"
        },
        {
            "location": "/vim/index.html#swapping-lines",
            "text": "Sometimes you want to swap the order of two lines of code, in command mode,  ddp  will do the trick.   dd  deletes the current line,  p  paste it after the current line, in effect swapping the order of the two lines.",
            "title": "Swapping Lines"
        },
        {
            "location": "/vim/index.html#commenting-blocks-of-code",
            "text": "Sometimes we need to comment out a whole block of code in C for testing purposes. There are several ways to do it in  vim :   Place the cursor on the first line of the block of code you want to comment.  0  to jump to the beginning of the line  V  enter visual mode  Use arrow key to select the block of code you want to comment.   I  to insert at the beginning of the line (here, since we already selected the block, we will insert at the beginning of every selected)  //  to insert the Java comment character (you will see it inserted in the current line, but don't worry)   to escape from the visual code.   To uncomment,    Place the cursor on the first line of the block of code you want to comment.  0  to jump to the beginning of the line  <CTRL-v>  enter block visual mode  Use arrow key to select the columns of text containing  //  x  to delete them",
            "title": "Commenting blocks of code"
        },
        {
            "location": "/vim/index.html#4-other-advanced-features",
            "text": "",
            "title": "4. Other Advanced Features"
        },
        {
            "location": "/vim/index.html#search-and-replace-in-vim",
            "text": "1 :%s/oldWord/newWord/gc    :  enters the command mode.   %  means apply to the whole document,  s  means substitute,  g  means global (otherwise, only the first occurance of each line is replaced).  c  is optional -- adding it cause  vim  to confirm with you before each replacement",
            "title": "Search and Replace in vim"
        },
        {
            "location": "/vim/index.html#shell-command",
            "text": "If you need to issue a shell command quickly, you don't have to exit  vim , run the command, and launch  vim  again.  You can use  ! ,   1 :!<command>   will issue the command to shell.  E.g.,  1 :!ls   You can use this to compile your current file, without exiting  vim .  1 :!make   make  is actually a builtin command for  vim  so you can also simply run  1 :make",
            "title": "Shell Command"
        },
        {
            "location": "/vim/index.html#abbreviation",
            "text": "You can use the command  ab  to abbreviate frequently typed commands.  E.g., in your  ~/.vimrc ,   1 ab pl cs1010_print_long(   Now, when you type  pl , it will be expanded into  cs1010_print_long(",
            "title": "Abbreviation"
        },
        {
            "location": "/vim/index.html#auto-completion",
            "text": "You can  <CTRL-P>  to auto-complete.  By default, the auto-complete dictionary is based on text in your current editing buffers.  This is a very useful keystroke saver for long function and variable names.",
            "title": "Auto-Completion"
        },
        {
            "location": "/vim/index.html#auto-indent-the-whole-file",
            "text": "You can  gg=G  in command mode to auto-indent the whole file.   gg  is the command to go to the beginning of the file.   =  is the command to indent.   G  is the command to go to the end of the file.",
            "title": "Auto-Indent the Whole File"
        },
        {
            "location": "/vim/index.html#splitting-vims-viewport",
            "text": ":sp file.c  splits the  vim  window horizontally  :vsp file.c  splits the  vim  window vertically  Ctrl-w Ctrl-w  moves between the different  vim  viewports",
            "title": "Splitting vim's Viewport"
        },
        {
            "location": "/vim/index.html#5-plugins",
            "text": "",
            "title": "5. Plugins"
        },
        {
            "location": "/vim/index.html#syntax-and-style-checker",
            "text": "I use  syntastic  to check for style and syntax whenever I save a file.   syntastic  is a  vim  plugin.   My  .vimrc  configuration file contains the following:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20 \"For syntastic\nset laststatus=2\nset statusline+=%#warningmsg#\nset statusline+=%{SyntasticStatuslineFlag()}\nset statusline+=%*\n\nlet g:syntastic_error_symbol = '\u2717'\nlet g:syntastic_warning_symbol = '\u26a0'\nlet g:syntastic_always_populate_loc_list = 1\nlet g:syntastic_auto_loc_list = 1\nlet g:syntastic_check_on_open = 1\nlet g:syntastic_check_on_wq = 0\n\nlet g:syntastic_c_checkers = [ 'clang_tidy', 'clang' ]\nlet g:syntastic_c_compiler = 'clang'\nlet g:syntastic_c_clang_args = '-Wall -Werror -Wextra -Iinclude'\nlet g:syntastic_c_clang_tidy_args = '-checks=*'\nlet g:syntastic_c_compiler_options = '-Wall -Iinclude'\nlet g:syntastic_c_include_dirs = [ '../include', 'include' ]\nlet g:syntastic_c_clang_tidy_post_args = \"\"   New Addition:  By default,  clang-tidy  does not know where to find the header files.  So if you include non-standard C headers, it will complain that it cannot find headers.  To resolve this, we need to tell  clang-tidy  the compilation flags that we use when compiling our program.    We can do this by creating a file named  compile_flags.txt  in your working directory (where your C files are located), containing one compilation flag per line.  For instance, if the header files are located in  /home/course/cs1010/include , your  compile_flags.txt  should contain the following two lines:  1\n2 -Wall\n-I/home/course/cs1010/include",
            "title": "Syntax and Style Checker"
        },
        {
            "location": "/lldb/index.html",
            "text": "Using LLDB Debugger\n\n\nWhat is a debugger?\n\n\nA debugger is a tool that allows a programmer to examine the states of the execution of the program, while the program is executing.  It allows a programmer to trace through the program step-by-step, examine the flow of the execution and the values of the variables.  It is a tremendously valuable and powerful tool to help us trace through our code to understand the behavior and find bugs.\n\n\nIn CS1010, we will use \nlldb\n, a debugger that comes from the same project as \nclang\n.  \n\n\nStarting Up LLDB\n\n\nTo use \nlldb\n, you first make sure that your code is compiled with \nclang\n using the flag \n-g\n.  This should be done for you already if you use the \nMakefile\n that we provide you for the assignments and exercises.  \n\n\nThen, you invoke \nlldb\n with the name of your executable as an argument.  For instance,\n\n1\n2\n3\n4\nooiwt@pe113:~$ lldb social\n(lldb) target create \"social\"\nCurrent executable set to 'social' (x86_64).\n(lldb)\n\n\n\n\n\nYou should see the following message, showing the \nsocial\n is loaded as the current executable, and you will be brought to a prompt that says \n(lldb)\n.\n\n\nAt any time, you can type \nhelp\n on the prompt to see the list of commands, or type \nhelp <command-name>\n to get help for a particular command.\n\n\nAs we use \nlldb\n, we are going to be bombarded with a lot of information about the internals of the program, so things might seem scary and you might be overwhelmed.  But, not too worry.  We only need to look for information that is useful to help you debug your program.  We can ignore other unnecessary details that \nlldb\n provide us.\n\n\nRunning the Executable\n\n\nTo run the executable, you need to launch the process\n1\n\n\n1\n(lldb) process launch\n\n\n\n\n\n\n\n\nSave on Typing\n\n\nThis is too long to type.  There are multiple ways to save typing.  Using \n to repeat previous commands is one.  The other is to use \n to autocomplete.  You can also just type the prefix -- if it is unique enough, \nlldb\n can figure out what you want to do.  For instance, the following is the same as \nprocess launch\n since no other commands have the same prefix.\n\n1\n(lldb) pr la\n\n\n\n\n\n\n\nLaunching the process is the same as running the executable on the command line.  If the program is reading from standard inputs, you should type in your inputs, after that the executable will run as per normal.\n\n\nIf you want to redirect the input from a file (like \n./social < inputs/social.1.in\n), you will need to pass in the \n-i\n flag to \nprocess launch\n:\n\n\n1\n(lldb) process launch -i inputs/social.1.in\n\n\n\n\n\n\nThis will cause the executable to read directly from the given input file.  An example output is as follows:\n\n\n1\n2\n3\n4\n5\n6\n7\n(lldb) process launch -i inputs/social.1.in\nProcess 29181 launched: '/home/o/ooiwt/as05-weitsang/social' (x86_64)\n1\n11\n011\nNO\nProcess 29181 exited with status = 0 (0x00000000)\n\n\n\n\n\n\nSo far, nothing interesting happens.  Running the executable from \nlldb\n is the same as running it from \nbash\n command line.\n\n\nSetting Breakpoint and Examining States\n\n\nLet's do something more interesting.  Suppose that my program is giving us the wrong answer, and I suspect that there is a bug in the function \nis_friend\n.  I can set a \nbreakpoint\n.  A breakpoint is a particular point in the code where you want to execution to pause.  Once the program pauses, you can then examine the state of the program.  You can set a breakpoint by specifying the line number or by the function name.  \n\n\nTo set a breakpoint a function \nis_friend\n, I can do the following:\n\n\n1\n2\n(\nlldb\n)\n \nbreakpoint\n \nset\n \n-\nn\n \nis_friend\n\n\nBreakpoint\n \n1\n:\n \nwhere\n \n=\n \nsocial\n`\nis_friend\n \n+\n \n14\n \nat\n \nsocial\n.\nc\n:\n13\n,\n \naddress\n \n=\n \n0x0000000000400a6e\n\n\n\n\n\n\n\nA short form is \nb is_friend\n:\n\n1\n2\n(\nlldb\n)\n \nb\n \nis_friend\n\n\nBreakpoint\n \n1\n:\n \nwhere\n \n=\n \nsocial\n`\nis_friend\n \n+\n \n14\n \nat\n \nsocial\n.\nc\n:\n13\n,\n \naddress\n \n=\n \n0x0000000000400a6e\n\n\n\n\n\n\nAfter setting the breakpoint, if I run the program again, I get\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n(lldb) b is_friend\nBreakpoint 1: where = social`is_friend + 14 at social.c:13, address = 0x0000000000400a6e\n(lldb) process launch -i inputs/social.2.in\nProcess 29596 launched: '/home/vagrant/cs1010/as05-solution/social' (x86_64)\nProcess 29596 stopped\n* thread #1: tid = 29596, 0x0000000000400a6e social`is_friend(socnet=0x0000000000605070, i=0, j=0) + 14 at social.c:13, name = 'social', stop reason = breakpoint 1.1\n    frame #0: 0x0000000000400a6e social`is_friend(socnet=0x0000000000605070, i=0, j=0) + 14 at social.c:13\n   10      }\n   11\n   12      bool is_friend(char **socnet, int i, int j) {\n-> 13        if (i >= j) {\n   14          return socnet[i][j] == '1';\n   15        }\n   16        return socnet[j][i] == '1';\n\n\n\n\n\nAt this point, the execution has paused, on Line 13 above.  We can now examine the state of the program.\nThe line\n\n1\n    frame #0: 0x0000000000400a6e social`is_friend(socnet=0x0000000000605070, i=0, j=0) + 14 at social.c:13\n\n\n\n\n\nshows the value of the parameters passed into \nis_friend\n.  \nsocnet\n is a pointer to a memory location (shown in hexadecimal format).  \ni\n and \nj\n are both zeros.\n\n\nChecking the Value of A Variable\n\n\n1\n2\n3\n4\n5\n6\n(lldb) print i\n(int) $0 = 0\n(lldb) print j\n(int) $1 = 0\n(lldb) print socnet\n(char **) $2 = 0x0000000000605070\n\n\n\n\n\n\nWe can use the \nprint\n (or \np\n) command to display the value of a variable.  In the examples above, I print out the value for \ni\n, \nj\n, \nsocnet\n.   The type, a temp variable name (\n$0\n, \n$1\n, etc), and the value of the variable are shown as output.\n\n\nIn my program, \nsocnet\n is the social network.  Suppose I want to know what is the value stored in different locations of this matrix, I can do the following:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n(lldb) p socnet[0][0]\n(char) $3 = '1'\n(lldb) p socnet[0][1]\n(char) $4 = '\\0'\n(lldb) p socnet[1][1]\n(char) $5 = '1'\n(lldb) p socnet[1]\n(char *) $8 = 0x0000000000605150 \"01\"\n(lldb) p socnet[3]\n(char *) $10 = 0x0000000000605210 \"1011\"\n\n\n\n\n\n\nChecking the Content of the Stack\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n(lldb) bt\n(lldb) bt\n* thread #1: tid = 29596, 0x0000000000400a6e social`is_friend(socnet=0x0000000000605070, i=0, j=0) + 14 at social.c:13, name = 'social', stop reason = breakpoint 1.1\n  * frame #0: 0x0000000000400a6e social`is_friend(socnet=0x0000000000605070, i=0, j=0) + 14 at social.c:13\n    frame #1: 0x0000000000400b1f social`expand(n=4, socnet=0x0000000000605040, degree_k=0x0000000000605070, result=0x00000000006050a0) + 79 at social.c:22\n    frame #2: 0x0000000000400e7d social`main + 301 at social.c:79\n    frame #3: 0x00007ffff7724830 libc.so.6`__libc_start_main(main=(social`main at social.c:60), argc=1, argv=0x00007fffffffe578, init=<unavailable>, fini=<unavailable>, rtld_fini=<unavailable>, stack_end=0x00007fffffffe568) + 240 at libc-start.c:291\n    frame #4: 0x0000000000400949 social`_start + 41\n\n\n\n\n\n\nThe \nbt\n, or \nbacktrace\n command shows all the call frames on the call stack.  \nframe #0\n is the current frame, where the breakpoint is.  \nframe #1\n is the function that calls \nis_friend\n.  You can ignore \nframe #3\n and \nframe #4\n in the example above, as they are relevant to how the OS invokes your executable.   So you can see the calls above: \nmain\n calls \nexpand, which then calls\nis_friend`.  \n\n\nIn the example above, we can see that the function \nexpand\n takes in four parameters.  What if I want to example what are these four parameters?  Now, I am at the frame \nis_friend\n.  If I try to print \nk\n or \ndegree_k\n, I will get an error:\n\n\n1\n2\n3\n(lldb) p degree_k\nerror: use of undeclared identifier 'degree_k'\nerror: 1 errors parsing expression\n\n\n\n\n\n\nTo examine the variables of another frame, we can use the \nup\n command, to move up the call frame (but, actually, we are moving down the stack).\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n(lldb) up\nframe #1: 0x0000000000400b1f social`expand(n=4, socnet=0x0000000000605040, degree_k=0x0000000000605070, result=0x00000000006050a0) + 79 at social.c:22\n   19      void expand(long n, char **socnet, char **degree_k, char **result) {\n   20        for (int i = 0; i < n; i += 1) {\n   21          for (int j = 0; j <= i; j += 1) {\n-> 22            if (is_friend(degree_k, i, j)) {\n   23              result[i][j] = '1';\n   24            } else {\n   25              bool find_connection = false;\n\n\n\n\n\n\nThis shows us where exactly is \nis_friend\n called. And now we can examine the content of \nsocnet\n in this frame.\n\n\n1\n2\n(lldb) p socnet[0][0]\n(char) $11 = '1'\n\n\n\n\n\n\nTo easily see what are the variables in the current frame, you can also run the commend\n\n1\n2\n3\n4\n5\n6\n7\n(lldb) frame variable\n(long) n = 4\n(char **) socnet = 0x0000000000605040\n(char **) degree_k = 0x0000000000605070\n(char **) result = 0x00000000006050a0\n(int) i = 0\n(int) j = 0\n\n\n\n\n\nTo move back to the earlier call frame, you can run \ndown\n:\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n(lldb) down\nframe #0: 0x0000000000400a6e social`is_friend(socnet=0x0000000000605070, i=0, j=0) + 14 at social.c:13\n   10      }\n   11\n   12      bool is_friend(char **socnet, int i, int j) {\n-> 13        if (i >= j) {\n   14          return socnet[i][j] == '1';\n   15        }\n   16        return socnet[j][i] == '1';\n\n\n\n\n\nAnd now we are back in \nis_friend\n.\n\n\nExecuting the Program Line-by-Line\n\n\nTo continue the execution of the program, we can run \nnext\n (or \nn\n), which cause the execution to continue, in one line:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n(lldb) n\nProcess 29596 stopped\n* thread #1: tid = 29596, 0x0000000000400a7a social`is_friend(socnet=0x0000000000605070, i=0, j=0) + 26 at social.c:14, name = 'social', stop reason = step over\n    frame #0: 0x0000000000400a7a social`is_friend(socnet=0x0000000000605070, i=0, j=0) + 26 at social.c:14\n   11\n   12      bool is_friend(char **socnet, int i, int j) {\n   13        if (i >= j) {\n-> 14          return socnet[i][j] == '1';\n   15        }\n   16        return socnet[j][i] == '1';\n   17      }\n\n\n\n\n\n\nSo now we see that the control flow actually cause the execution of Line 14 -- that is, it enters the true-block of the \nif\n statement.  We can keep typing \nn\n to continue to trace through the code, line-by-line.\n\n\nIf the \nnext\n command, encounters a function, it will go into the function.  Suppose you are not interested in tracing through the code in a particular function, line-by-line, you can use the \nstep\n command (or \ns\n) to step over a function.  \n\n\nThe \ncontinue\n command, or \nc\n, would cause lldb to continue (unpause) the execution.  The execution continues until the next breakpoint is encountered.\n\n\nPausing with Conditions\n\n\nConditional Breakpoint\n\n\nSuppose that I now suspect there is a problem with \nis_friend\n with j is 2.  Setting the breakpoint at \nis_friend\n is not going to help much, as it pauses the program \nevery time\n \nis_friend\n is called.  Since this is inside a double for loop, it is going to take multiple stops at this breakpoint before I read that state that I am interested in.  \n\n\nTo get around this, we can set a conditional breakpoint -- a breakpoint that will pause the program, only if the condition is true.  The command to do so is as follows:\n\n\n1\n2\n(lldb) b -n is_friend -c 'j == 2'\nBreakpoint 15: where = social`is_friend + 14 at social.c:13, address = 0x0000000000400a6e\n\n\n\n\n\n\nThis command sets a breakpoint at the function \nis_friend\n, but only when the condition \nj == 2\n is true.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n(lldb) process launch -i inputs/social.2.in\nProcess 30796 launched: '/home/vagrant/cs1010/as05-solution/social' (x86_64)\nProcess 30796 stopped\n* thread #1: tid = 30796, 0x0000000000400a6e social`is_friend(socnet=0x0000000000605040, i=1, j=2) + 14 at social.c:13, name = 'social', stop reason = breakpoint 15.1\n    frame #0: 0x0000000000400a6e social`is_friend(socnet=0x0000000000605040, i=1, j=2) + 14 at social.c:13\n   10      }\n   11\n   12      bool is_friend(char **socnet, int i, int j) {\n-> 13        if (i >= j) {\n   14          return socnet[i][j] == '1';\n   15        }\n   16        return socnet[j][i] == '1';\n\n\n\n\n\n\nNow, when we run the program, the breakpoint \nis_friend\n is triggered only when the value of j is 2.\n\n\n\n\n\n\n\n\n\n\nA \nprocess\n is the technical term for a running application -- it is more complicated than this, but this intuition will do for now.  You will learn what a process is in your OS module.\u00a0\n\u21a9",
            "title": "LLDB"
        },
        {
            "location": "/lldb/index.html#using-lldb-debugger",
            "text": "",
            "title": "Using LLDB Debugger"
        },
        {
            "location": "/lldb/index.html#what-is-a-debugger",
            "text": "A debugger is a tool that allows a programmer to examine the states of the execution of the program, while the program is executing.  It allows a programmer to trace through the program step-by-step, examine the flow of the execution and the values of the variables.  It is a tremendously valuable and powerful tool to help us trace through our code to understand the behavior and find bugs.  In CS1010, we will use  lldb , a debugger that comes from the same project as  clang .",
            "title": "What is a debugger?"
        },
        {
            "location": "/lldb/index.html#starting-up-lldb",
            "text": "To use  lldb , you first make sure that your code is compiled with  clang  using the flag  -g .  This should be done for you already if you use the  Makefile  that we provide you for the assignments and exercises.    Then, you invoke  lldb  with the name of your executable as an argument.  For instance, 1\n2\n3\n4 ooiwt@pe113:~$ lldb social\n(lldb) target create \"social\"\nCurrent executable set to 'social' (x86_64).\n(lldb)   You should see the following message, showing the  social  is loaded as the current executable, and you will be brought to a prompt that says  (lldb) .  At any time, you can type  help  on the prompt to see the list of commands, or type  help <command-name>  to get help for a particular command.  As we use  lldb , we are going to be bombarded with a lot of information about the internals of the program, so things might seem scary and you might be overwhelmed.  But, not too worry.  We only need to look for information that is useful to help you debug your program.  We can ignore other unnecessary details that  lldb  provide us.",
            "title": "Starting Up LLDB"
        },
        {
            "location": "/lldb/index.html#running-the-executable",
            "text": "To run the executable, you need to launch the process 1  1 (lldb) process launch    Save on Typing  This is too long to type.  There are multiple ways to save typing.  Using   to repeat previous commands is one.  The other is to use   to autocomplete.  You can also just type the prefix -- if it is unique enough,  lldb  can figure out what you want to do.  For instance, the following is the same as  process launch  since no other commands have the same prefix. 1 (lldb) pr la    Launching the process is the same as running the executable on the command line.  If the program is reading from standard inputs, you should type in your inputs, after that the executable will run as per normal.  If you want to redirect the input from a file (like  ./social < inputs/social.1.in ), you will need to pass in the  -i  flag to  process launch :  1 (lldb) process launch -i inputs/social.1.in   This will cause the executable to read directly from the given input file.  An example output is as follows:  1\n2\n3\n4\n5\n6\n7 (lldb) process launch -i inputs/social.1.in\nProcess 29181 launched: '/home/o/ooiwt/as05-weitsang/social' (x86_64)\n1\n11\n011\nNO\nProcess 29181 exited with status = 0 (0x00000000)   So far, nothing interesting happens.  Running the executable from  lldb  is the same as running it from  bash  command line.",
            "title": "Running the Executable"
        },
        {
            "location": "/lldb/index.html#setting-breakpoint-and-examining-states",
            "text": "Let's do something more interesting.  Suppose that my program is giving us the wrong answer, and I suspect that there is a bug in the function  is_friend .  I can set a  breakpoint .  A breakpoint is a particular point in the code where you want to execution to pause.  Once the program pauses, you can then examine the state of the program.  You can set a breakpoint by specifying the line number or by the function name.    To set a breakpoint a function  is_friend , I can do the following:  1\n2 ( lldb )   breakpoint   set   - n   is_friend  Breakpoint   1 :   where   =   social ` is_friend   +   14   at   social . c : 13 ,   address   =   0x0000000000400a6e    A short form is  b is_friend : 1\n2 ( lldb )   b   is_friend  Breakpoint   1 :   where   =   social ` is_friend   +   14   at   social . c : 13 ,   address   =   0x0000000000400a6e    After setting the breakpoint, if I run the program again, I get  1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14 (lldb) b is_friend\nBreakpoint 1: where = social`is_friend + 14 at social.c:13, address = 0x0000000000400a6e\n(lldb) process launch -i inputs/social.2.in\nProcess 29596 launched: '/home/vagrant/cs1010/as05-solution/social' (x86_64)\nProcess 29596 stopped\n* thread #1: tid = 29596, 0x0000000000400a6e social`is_friend(socnet=0x0000000000605070, i=0, j=0) + 14 at social.c:13, name = 'social', stop reason = breakpoint 1.1\n    frame #0: 0x0000000000400a6e social`is_friend(socnet=0x0000000000605070, i=0, j=0) + 14 at social.c:13\n   10      }\n   11\n   12      bool is_friend(char **socnet, int i, int j) {\n-> 13        if (i >= j) {\n   14          return socnet[i][j] == '1';\n   15        }\n   16        return socnet[j][i] == '1';   At this point, the execution has paused, on Line 13 above.  We can now examine the state of the program.\nThe line 1     frame #0: 0x0000000000400a6e social`is_friend(socnet=0x0000000000605070, i=0, j=0) + 14 at social.c:13   shows the value of the parameters passed into  is_friend .   socnet  is a pointer to a memory location (shown in hexadecimal format).   i  and  j  are both zeros.",
            "title": "Setting Breakpoint and Examining States"
        },
        {
            "location": "/lldb/index.html#checking-the-value-of-a-variable",
            "text": "1\n2\n3\n4\n5\n6 (lldb) print i\n(int) $0 = 0\n(lldb) print j\n(int) $1 = 0\n(lldb) print socnet\n(char **) $2 = 0x0000000000605070   We can use the  print  (or  p ) command to display the value of a variable.  In the examples above, I print out the value for  i ,  j ,  socnet .   The type, a temp variable name ( $0 ,  $1 , etc), and the value of the variable are shown as output.  In my program,  socnet  is the social network.  Suppose I want to know what is the value stored in different locations of this matrix, I can do the following:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10 (lldb) p socnet[0][0]\n(char) $3 = '1'\n(lldb) p socnet[0][1]\n(char) $4 = '\\0'\n(lldb) p socnet[1][1]\n(char) $5 = '1'\n(lldb) p socnet[1]\n(char *) $8 = 0x0000000000605150 \"01\"\n(lldb) p socnet[3]\n(char *) $10 = 0x0000000000605210 \"1011\"",
            "title": "Checking the Value of A Variable"
        },
        {
            "location": "/lldb/index.html#checking-the-content-of-the-stack",
            "text": "1\n2\n3\n4\n5\n6\n7\n8 (lldb) bt\n(lldb) bt\n* thread #1: tid = 29596, 0x0000000000400a6e social`is_friend(socnet=0x0000000000605070, i=0, j=0) + 14 at social.c:13, name = 'social', stop reason = breakpoint 1.1\n  * frame #0: 0x0000000000400a6e social`is_friend(socnet=0x0000000000605070, i=0, j=0) + 14 at social.c:13\n    frame #1: 0x0000000000400b1f social`expand(n=4, socnet=0x0000000000605040, degree_k=0x0000000000605070, result=0x00000000006050a0) + 79 at social.c:22\n    frame #2: 0x0000000000400e7d social`main + 301 at social.c:79\n    frame #3: 0x00007ffff7724830 libc.so.6`__libc_start_main(main=(social`main at social.c:60), argc=1, argv=0x00007fffffffe578, init=<unavailable>, fini=<unavailable>, rtld_fini=<unavailable>, stack_end=0x00007fffffffe568) + 240 at libc-start.c:291\n    frame #4: 0x0000000000400949 social`_start + 41   The  bt , or  backtrace  command shows all the call frames on the call stack.   frame #0  is the current frame, where the breakpoint is.   frame #1  is the function that calls  is_friend .  You can ignore  frame #3  and  frame #4  in the example above, as they are relevant to how the OS invokes your executable.   So you can see the calls above:  main  calls  expand, which then calls is_friend`.    In the example above, we can see that the function  expand  takes in four parameters.  What if I want to example what are these four parameters?  Now, I am at the frame  is_friend .  If I try to print  k  or  degree_k , I will get an error:  1\n2\n3 (lldb) p degree_k\nerror: use of undeclared identifier 'degree_k'\nerror: 1 errors parsing expression   To examine the variables of another frame, we can use the  up  command, to move up the call frame (but, actually, we are moving down the stack).  1\n2\n3\n4\n5\n6\n7\n8\n9 (lldb) up\nframe #1: 0x0000000000400b1f social`expand(n=4, socnet=0x0000000000605040, degree_k=0x0000000000605070, result=0x00000000006050a0) + 79 at social.c:22\n   19      void expand(long n, char **socnet, char **degree_k, char **result) {\n   20        for (int i = 0; i < n; i += 1) {\n   21          for (int j = 0; j <= i; j += 1) {\n-> 22            if (is_friend(degree_k, i, j)) {\n   23              result[i][j] = '1';\n   24            } else {\n   25              bool find_connection = false;   This shows us where exactly is  is_friend  called. And now we can examine the content of  socnet  in this frame.  1\n2 (lldb) p socnet[0][0]\n(char) $11 = '1'   To easily see what are the variables in the current frame, you can also run the commend 1\n2\n3\n4\n5\n6\n7 (lldb) frame variable\n(long) n = 4\n(char **) socnet = 0x0000000000605040\n(char **) degree_k = 0x0000000000605070\n(char **) result = 0x00000000006050a0\n(int) i = 0\n(int) j = 0   To move back to the earlier call frame, you can run  down : 1\n2\n3\n4\n5\n6\n7\n8\n9 (lldb) down\nframe #0: 0x0000000000400a6e social`is_friend(socnet=0x0000000000605070, i=0, j=0) + 14 at social.c:13\n   10      }\n   11\n   12      bool is_friend(char **socnet, int i, int j) {\n-> 13        if (i >= j) {\n   14          return socnet[i][j] == '1';\n   15        }\n   16        return socnet[j][i] == '1';   And now we are back in  is_friend .",
            "title": "Checking the Content of the Stack"
        },
        {
            "location": "/lldb/index.html#executing-the-program-line-by-line",
            "text": "To continue the execution of the program, we can run  next  (or  n ), which cause the execution to continue, in one line:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11 (lldb) n\nProcess 29596 stopped\n* thread #1: tid = 29596, 0x0000000000400a7a social`is_friend(socnet=0x0000000000605070, i=0, j=0) + 26 at social.c:14, name = 'social', stop reason = step over\n    frame #0: 0x0000000000400a7a social`is_friend(socnet=0x0000000000605070, i=0, j=0) + 26 at social.c:14\n   11\n   12      bool is_friend(char **socnet, int i, int j) {\n   13        if (i >= j) {\n-> 14          return socnet[i][j] == '1';\n   15        }\n   16        return socnet[j][i] == '1';\n   17      }   So now we see that the control flow actually cause the execution of Line 14 -- that is, it enters the true-block of the  if  statement.  We can keep typing  n  to continue to trace through the code, line-by-line.  If the  next  command, encounters a function, it will go into the function.  Suppose you are not interested in tracing through the code in a particular function, line-by-line, you can use the  step  command (or  s ) to step over a function.    The  continue  command, or  c , would cause lldb to continue (unpause) the execution.  The execution continues until the next breakpoint is encountered.",
            "title": "Executing the Program Line-by-Line"
        },
        {
            "location": "/lldb/index.html#pausing-with-conditions",
            "text": "",
            "title": "Pausing with Conditions"
        },
        {
            "location": "/lldb/index.html#conditional-breakpoint",
            "text": "Suppose that I now suspect there is a problem with  is_friend  with j is 2.  Setting the breakpoint at  is_friend  is not going to help much, as it pauses the program  every time   is_friend  is called.  Since this is inside a double for loop, it is going to take multiple stops at this breakpoint before I read that state that I am interested in.    To get around this, we can set a conditional breakpoint -- a breakpoint that will pause the program, only if the condition is true.  The command to do so is as follows:  1\n2 (lldb) b -n is_friend -c 'j == 2'\nBreakpoint 15: where = social`is_friend + 14 at social.c:13, address = 0x0000000000400a6e   This command sets a breakpoint at the function  is_friend , but only when the condition  j == 2  is true.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12 (lldb) process launch -i inputs/social.2.in\nProcess 30796 launched: '/home/vagrant/cs1010/as05-solution/social' (x86_64)\nProcess 30796 stopped\n* thread #1: tid = 30796, 0x0000000000400a6e social`is_friend(socnet=0x0000000000605040, i=1, j=2) + 14 at social.c:13, name = 'social', stop reason = breakpoint 15.1\n    frame #0: 0x0000000000400a6e social`is_friend(socnet=0x0000000000605040, i=1, j=2) + 14 at social.c:13\n   10      }\n   11\n   12      bool is_friend(char **socnet, int i, int j) {\n-> 13        if (i >= j) {\n   14          return socnet[i][j] == '1';\n   15        }\n   16        return socnet[j][i] == '1';   Now, when we run the program, the breakpoint  is_friend  is triggered only when the value of j is 2.      A  process  is the technical term for a running application -- it is more complicated than this, but this intuition will do for now.  You will learn what a process is in your OS module.\u00a0 \u21a9",
            "title": "Conditional Breakpoint"
        },
        {
            "location": "/library/index.html",
            "text": "The CS1010 I/O Library\n\n\nTo help students get started with C programming without worrying too much about the details and pitfalls of using \nprintf\n and \nscanf\n, we provide a simple-to-use library to read and write integers, floating point numbers, and strings.  \n\n\nThe libraries are pre-installed in \nCS1010 programming environments\n, with \ncs1010.h\n located under \n~cs1010/include\n and \nlibcs1010.a\n located under \n~cs1010/lib\n.\n\n\nInstalling the Library\n\n\nIf you want to install the libraries on your own version of Ubuntu, do the following:\n\n\n\n\nTo get an updated copy of the library, clone it from its git repo on GitHub with the command:\n\n\n\n\n1\ngit clone https://github.com/nus-cs1010-1819-s1/libcs1010.git\n\n\n\n\n\n\nIt is recommended you do this in your home directory.\n\n\nYou should see an output similar to:\n\n1\n2\n3\n4\n5\nCloning into 'libcs1010'...\nremote: Counting objects: 6, done.\nremote: Compressing objects: 100% (3/3), done.\nremote: Total 6 (delta 0), reused 0 (delta 0), pack-reused 0\nUnpacking objects: 100% (6/6), done.\n\n\n\n\n\nAfter that, you should see a subdirectory \nlibcs1010\n created in your current directory.  Inside, there should be a file called \nMakefile\n, and two subdirectories called \ninclude\n and \nsrc\n.  \n\n\n\n\nTo compile the library, run\n\n\n\n\n1\nmake\n\n\n\n\n\n\nThis should compile the file \nsrc/cs1010.c\n and create a static C library named \nlibcs1010.a\n under the \nlib\n directory.\n\n\nUsing the Library\n\n\nHeader\n\n\nTo use the CS1010 I/O library, you should \n#include\n the file \ncs1010.h\n, like this:\n\n\n1\n#include\n \n\"cs1010.h\"\n\n\n\n\n\n\n\nat the top of your C program.\n\n\nLinking\n\n\nThe CS1010 I/O library is provided as the file \nlibcs1010.a\n.  To link to the library, you need to compile with \n-lcs1010\n.  Usually, you need to specify where you can find \ncs1010.h\n with the \n-I\n flag, and \nlibcs1010.a\n with the \n-L\n flag.  Assuming that you are compiling in another subdirectory under your home and \nlibcs1010\n are located under your home directory, the header file and the library file are in \n../libcs1010/include\n and \n../libcs1010/lib\n respectively.\n\n\nSo you compile using the command line:\n\n\n1\nclang -I../libcs1010/include -L../libcs1010/lib hello.c -lcs1010\n\n\n\n\n\n\n\nOf course if your header and library files are located in another directory that is not \n../libcs1010/include\n and \n../libcs1010/lib\n, you should change the command above accordingly.\n\n\nAlthough it is a long string to type, you should type it once and use up arrow in bash to go back to this command over-and-over again.   For advanced students, we suggest that you put this in a shell script so that you just need to run the shell script to compile the program.  We have also automate this for you for your assignments and exercises using the \nmake\n command.\n\n\n\nReading of a Single Value\n\n\nThe CS1010 library supports reading of \nlong\n value, \ndouble\n value, and strings (both space-separated words and newline-separated lines) from the standard input.  For \nlong\n and \ndouble\n. The relevant methods are:\n\n\n\n\n\n\nlong cs1010_read_long()\n\nReturns a \nlong\n value from the standard input.  An error message will be printed (to \nstderr\n) if the input sequence is not a valid \nlong\n value -- in which case the value \nLONG_MAX\n will be returned.  Example:\n\n1\nlong\n \nyear\n \n=\n \ncs1010_read_long\n();\n\n\n\n\n\n\n\n\n\n\ndouble cs1010_read_double()\n\nReturns a \ndouble\n value from the standard input.  An error message will be printed (to \nstderr\n) if the input sequence is not a valid \ndouble\n value -- in which case the value \nDBL_MAX\n will be returned. Example:\n\n1\ndouble\n \ncap\n \n=\n \ncs1010_read_double\n();\n\n\n\n\n\n\n\n\n\n\nchar* cs1010_read_word()\n\nReturns a \nchar *\n pointing to the next white-space-separated string from the standard input.  A white-space character is defined based on the standard C function \nisspace()\n and includes the space \n, tab \n\\t\n, and newline \n\\n\n character.  Returns NULL if there is an error.  If the returned value is non-NULL, the caller is responsible for freeing the memory allocated by calling \nfree\n.\n\n\n1\n2\n3\n4\n5\nchar\n*\n \nword\n \n=\n \ncs1010_read_word\n();\n\n\n// use word to do something\n\n \n:\n\n \n:\n\n\nfree\n(\nword\n);\n\n\n\n\n\n\n\n\n\n\nchar* cs1010_read_line()\n\nReturns a \nchar *\n pointing to the next new-line-separated string from the standard input.   The string returns from \ncs1010_read_line()\n includes the newline character (if one is found).\nReturns NULL if there is an error.  If the returned value is non-NULL, the caller is responsible for freeing the memory allocated by calling \nfree\n.\n\n1\n2\n3\n4\n5\nchar\n*\n \nline\n \n=\n \ncs1010_read_line\n();\n\n\n// use line to do something\n\n \n:\n\n \n:\n\n\nfree\n(\nline\n);\n\n\n\n\n\n\n\n\n\n\nReading of Multiple Values\n\n\nThe CS1010 library also supports reading of multiple values.  \n\n\n\n\n\n\nlong* cs1010_read_long_array(int k)\n\nReturns \nk\n numbers of \nlong\n values read from the standard input stored in an array.  An error message will be printed (to \nstderr\n) for each input that is not a valid \nlong\n value -- in which case the value \nLONG_MAX\n will be populated in the corresponding array element.  Returns NULL if there is a memory allocation error.  If the returned value is non-NULL, the caller is responsible for freeing the memory allocated by calling \nfree\n.\n\n1\n2\n3\n4\n5\n6\n7\nlong\n*\n \nvalues\n \n=\n \ncs1010_read_long_array\n(\n10\n);\n\n\nif\n \n(\nvalues\n \n!=\n \nNULL\n)\n \n{\n\n  \n// Do something with array values\n\n   \n:\n\n   \n:\n\n  \nfree\n(\nvalues\n);\n\n\n}\n\n\n\n\n\n\n\n\n\n\ndouble* cs1010_read_double_array(int k)\n\nReturns \nk\n numbers of \ndouble\n values read from the standard input stored in an array.  An error message will be printed (to \nstderr\n) for each input that is not a valid \ndouble\n value -- in which case the value \nDBL_MAX\n will be populated in the corresponding array element.\n\nReturns NULL if there is a memory allocation error.  If the returned value is non-NULL, the caller is responsible for freeing the memory allocated by calling \nfree\n.\n\n1\n2\n3\n4\n5\n6\n7\ndouble\n*\n \nvalues\n \n=\n \ncs1010_read_double_array\n(\n10\n);\n\n\nif\n \n(\nvalues\n \n!=\n \nNULL\n)\n \n{\n\n  \n// Do something with array values\n\n   \n:\n\n   \n:\n\n  \nfree\n(\nvalues\n);\n\n\n}\n\n\n\n\n\n\n\n\n\n\nchar** cs1010_read_word_array(int k)\n\nReturns \nk\n white-space-separated words read from the standard input stored in an array.  The notion of \"word\" is the same to \ncs1010_read_word()\n.\n\nReturns NULL if there is a memory allocation error.  If the returned value is non-NULL, the caller is responsible for freeing the memory allocated for each word and for the whole array by calling \nfree\n.\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\nchar\n**\n \nwords\n \n=\n \ncs1010_read_word_array\n(\n10\n);\n\n\nif\n \n(\nwords\n \n!=\n \nNULL\n)\n \n{\n\n  \n// Do something with array words\n\n   \n:\n\n   \n:\n\n  \nfor\n \n(\nlong\n \ni\n \n=\n \n0\n;\n \ni\n \n<\n \n10\n;\n \ni\n \n+=\n \n1\n)\n \n{\n\n    \nfree\n(\nwords\n[\ni\n]);\n\n  \n}\n\n  \nfree\n(\nwords\n);\n\n\n}\n\n\n\n\n\n\n\n\n\n\nchar** cs1010_read_line_array(int k)\n\nReturns \nk\n new-line-separated words read from the standard input stored in an array.  The notion of line is the same to \ncs1010_read_line()\n.\n\nReturns NULL if there is a memory allocation error.  If the returned value is non-NULL, the caller is responsible for freeing the memory allocated for each line and for the whole array by calling \nfree\n.\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\nchar\n**\n \nlines\n \n=\n \ncs1010_read_line_array\n(\n10\n);\n\n\nif\n \n(\nlines\n \n!=\n \nNULL\n)\n \n{\n\n  \n// Do something with array lines\n\n   \n:\n\n   \n:\n\n  \nfor\n \n(\nlong\n \ni\n \n=\n \n0\n;\n \ni\n \n<\n \n10\n;\n \ni\n \n+=\n \n1\n)\n \n{\n\n    \nfree\n(\nlines\n[\ni\n]);\n\n  \n}\n\n  \nfree\n(\nlines\n);\n\n\n}\n\n\n\n\n\n\n\n\n\n\nPrinting of a Single Value\n\n\nThe CS1010 library provides a few convenince functions to format and print \nlong\n and \ndouble\n values to the standard output.\n\n\n\n\n\n\nvoid cs1010_print_long(long value)\n and \nvoid cs1010_println_long(long value)\n\nPrint \nvalue\n to the standard output (with printf format \n%ld\n).\n\nThe \ncs1010_println_long\n version prints a newline after the value.\n\n1\n2\n3\n  \nlong\n \nx\n;\n\n    \n:\n\n  \ncs1010_print_long\n(\nx\n);\n\n\n\n\n\n\n\n\n\n\nvoid cs1010_print_double(double value)\n and \nvoid cs1010_println_double(double value)\n\nPrint \nvalue\n to the standard output (with printf format \n%.4f\n).\nThe \ncs1010_println_double\n version prints a newline after the value.\n\n1\n2\n3\n  \ndouble\n \nx\n;\n\n    \n:\n\n  \ncs1010_println_double\n(\nx\n);\n\n\n\n\n\n\n\n\n\n\nvoid cs1010_print_string(char *str)\n and \nvoid cs1010_println_string(char *str)\n\nPrint a given string \nstr\n to the standard output.  These functions are provided for completeness and is a simple wrapper around \nprintf(str)\n and \nprintf(\"%s\\n\", str)\n repsectively.\n\n1\n  \ncs1010_println_string\n(\n\"hello world!\"\n);",
            "title": "CS1010 I/O"
        },
        {
            "location": "/library/index.html#the-cs1010-io-library",
            "text": "To help students get started with C programming without worrying too much about the details and pitfalls of using  printf  and  scanf , we provide a simple-to-use library to read and write integers, floating point numbers, and strings.    The libraries are pre-installed in  CS1010 programming environments , with  cs1010.h  located under  ~cs1010/include  and  libcs1010.a  located under  ~cs1010/lib .",
            "title": "The CS1010 I/O Library"
        },
        {
            "location": "/library/index.html#installing-the-library",
            "text": "If you want to install the libraries on your own version of Ubuntu, do the following:   To get an updated copy of the library, clone it from its git repo on GitHub with the command:   1 git clone https://github.com/nus-cs1010-1819-s1/libcs1010.git   It is recommended you do this in your home directory.  You should see an output similar to: 1\n2\n3\n4\n5 Cloning into 'libcs1010'...\nremote: Counting objects: 6, done.\nremote: Compressing objects: 100% (3/3), done.\nremote: Total 6 (delta 0), reused 0 (delta 0), pack-reused 0\nUnpacking objects: 100% (6/6), done.   After that, you should see a subdirectory  libcs1010  created in your current directory.  Inside, there should be a file called  Makefile , and two subdirectories called  include  and  src .     To compile the library, run   1 make   This should compile the file  src/cs1010.c  and create a static C library named  libcs1010.a  under the  lib  directory.",
            "title": "Installing the Library"
        },
        {
            "location": "/library/index.html#using-the-library",
            "text": "",
            "title": "Using the Library"
        },
        {
            "location": "/library/index.html#header",
            "text": "To use the CS1010 I/O library, you should  #include  the file  cs1010.h , like this:  1 #include   \"cs1010.h\"    at the top of your C program.",
            "title": "Header"
        },
        {
            "location": "/library/index.html#linking",
            "text": "The CS1010 I/O library is provided as the file  libcs1010.a .  To link to the library, you need to compile with  -lcs1010 .  Usually, you need to specify where you can find  cs1010.h  with the  -I  flag, and  libcs1010.a  with the  -L  flag.  Assuming that you are compiling in another subdirectory under your home and  libcs1010  are located under your home directory, the header file and the library file are in  ../libcs1010/include  and  ../libcs1010/lib  respectively.  So you compile using the command line:  1 clang -I../libcs1010/include -L../libcs1010/lib hello.c -lcs1010   \nOf course if your header and library files are located in another directory that is not  ../libcs1010/include  and  ../libcs1010/lib , you should change the command above accordingly.  Although it is a long string to type, you should type it once and use up arrow in bash to go back to this command over-and-over again.   For advanced students, we suggest that you put this in a shell script so that you just need to run the shell script to compile the program.  We have also automate this for you for your assignments and exercises using the  make  command.",
            "title": "Linking"
        },
        {
            "location": "/library/index.html#reading-of-a-single-value",
            "text": "The CS1010 library supports reading of  long  value,  double  value, and strings (both space-separated words and newline-separated lines) from the standard input.  For  long  and  double . The relevant methods are:    long cs1010_read_long() \nReturns a  long  value from the standard input.  An error message will be printed (to  stderr ) if the input sequence is not a valid  long  value -- in which case the value  LONG_MAX  will be returned.  Example: 1 long   year   =   cs1010_read_long ();      double cs1010_read_double() \nReturns a  double  value from the standard input.  An error message will be printed (to  stderr ) if the input sequence is not a valid  double  value -- in which case the value  DBL_MAX  will be returned. Example: 1 double   cap   =   cs1010_read_double ();      char* cs1010_read_word() \nReturns a  char *  pointing to the next white-space-separated string from the standard input.  A white-space character is defined based on the standard C function  isspace()  and includes the space  , tab  \\t , and newline  \\n  character.  Returns NULL if there is an error.  If the returned value is non-NULL, the caller is responsible for freeing the memory allocated by calling  free .  1\n2\n3\n4\n5 char *   word   =   cs1010_read_word ();  // use word to do something \n  : \n  :  free ( word );      char* cs1010_read_line() \nReturns a  char *  pointing to the next new-line-separated string from the standard input.   The string returns from  cs1010_read_line()  includes the newline character (if one is found).\nReturns NULL if there is an error.  If the returned value is non-NULL, the caller is responsible for freeing the memory allocated by calling  free . 1\n2\n3\n4\n5 char *   line   =   cs1010_read_line ();  // use line to do something \n  : \n  :  free ( line );",
            "title": "Reading of a Single Value"
        },
        {
            "location": "/library/index.html#reading-of-multiple-values",
            "text": "The CS1010 library also supports reading of multiple values.      long* cs1010_read_long_array(int k) \nReturns  k  numbers of  long  values read from the standard input stored in an array.  An error message will be printed (to  stderr ) for each input that is not a valid  long  value -- in which case the value  LONG_MAX  will be populated in the corresponding array element.  Returns NULL if there is a memory allocation error.  If the returned value is non-NULL, the caller is responsible for freeing the memory allocated by calling  free . 1\n2\n3\n4\n5\n6\n7 long *   values   =   cs1010_read_long_array ( 10 );  if   ( values   !=   NULL )   { \n   // Do something with array values \n    : \n    : \n   free ( values );  }      double* cs1010_read_double_array(int k) \nReturns  k  numbers of  double  values read from the standard input stored in an array.  An error message will be printed (to  stderr ) for each input that is not a valid  double  value -- in which case the value  DBL_MAX  will be populated in the corresponding array element. \nReturns NULL if there is a memory allocation error.  If the returned value is non-NULL, the caller is responsible for freeing the memory allocated by calling  free . 1\n2\n3\n4\n5\n6\n7 double *   values   =   cs1010_read_double_array ( 10 );  if   ( values   !=   NULL )   { \n   // Do something with array values \n    : \n    : \n   free ( values );  }      char** cs1010_read_word_array(int k) \nReturns  k  white-space-separated words read from the standard input stored in an array.  The notion of \"word\" is the same to  cs1010_read_word() . \nReturns NULL if there is a memory allocation error.  If the returned value is non-NULL, the caller is responsible for freeing the memory allocated for each word and for the whole array by calling  free .  1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10 char **   words   =   cs1010_read_word_array ( 10 );  if   ( words   !=   NULL )   { \n   // Do something with array words \n    : \n    : \n   for   ( long   i   =   0 ;   i   <   10 ;   i   +=   1 )   { \n     free ( words [ i ]); \n   } \n   free ( words );  }      char** cs1010_read_line_array(int k) \nReturns  k  new-line-separated words read from the standard input stored in an array.  The notion of line is the same to  cs1010_read_line() . \nReturns NULL if there is a memory allocation error.  If the returned value is non-NULL, the caller is responsible for freeing the memory allocated for each line and for the whole array by calling  free .  1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10 char **   lines   =   cs1010_read_line_array ( 10 );  if   ( lines   !=   NULL )   { \n   // Do something with array lines \n    : \n    : \n   for   ( long   i   =   0 ;   i   <   10 ;   i   +=   1 )   { \n     free ( lines [ i ]); \n   } \n   free ( lines );  }",
            "title": "Reading of Multiple Values"
        },
        {
            "location": "/library/index.html#printing-of-a-single-value",
            "text": "The CS1010 library provides a few convenince functions to format and print  long  and  double  values to the standard output.    void cs1010_print_long(long value)  and  void cs1010_println_long(long value) \nPrint  value  to the standard output (with printf format  %ld ). \nThe  cs1010_println_long  version prints a newline after the value. 1\n2\n3    long   x ; \n     : \n   cs1010_print_long ( x );      void cs1010_print_double(double value)  and  void cs1010_println_double(double value) \nPrint  value  to the standard output (with printf format  %.4f ).\nThe  cs1010_println_double  version prints a newline after the value. 1\n2\n3    double   x ; \n     : \n   cs1010_println_double ( x );      void cs1010_print_string(char *str)  and  void cs1010_println_string(char *str) \nPrint a given string  str  to the standard output.  These functions are provided for completeness and is a simple wrapper around  printf(str)  and  printf(\"%s\\n\", str)  repsectively. 1    cs1010_println_string ( \"hello world!\" );",
            "title": "Printing of a Single Value"
        }
    ]
}