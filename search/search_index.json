{
    "docs": [
        {
            "location": "/index.html",
            "text": "CS1010\n\n\nWhat's New\n\n\nAssignment 3: Kendall, Histogram, CountingSort\n\n\nReleased 21 September 2018, Due 5 October 2018, 6pm.\n\n\nExercise 4: ID, Grade, Index, Max\n\n\nReleased 20 September 2018\n\n\nInfo on \nMidterm\n and \nPractical Exam 1\n\n\nSummary of CS1010's Rules on C\n\n\nAssignment 1: Comments and Answer Keys\n\n\nLecture 6\n\n\nIn this lecture, we will discuss how call stack works, giving more insights about how a C program is executed, particularly when we call a function and when a function returns.  We then discuss about pointers and arrays, ending with a brief introduction to strings as an array of \nchar\n.\n\n\nUnits covered are Units 13 - 16: \nUnit 13: Call Stack\n, \nUnit 14: Pointers\n, \nUnit 15: Arrays\n and \nUnit 16: Strings\n.\n\n\n\n\nPiazza Q&A\n \n\n\nPiazza is the Q&A site for students and instructors to ask questions and discuss among each other on all matters related to CS1010.\n\n\n\n\nProgramming Exercises\n\n\nExercises are ungraded programming questions for practicing on your own.\n\n\nExercise 3: Binary, Rectangle, Fibonacci, Prime\n\n\nReleased 13 September 2018\n\n\nExercise 2: Leap, Suffix, Days\n\n\nReleased 6 September 2018\n\n\nExercise 1: Freezer\n\n\nReleased 3 September 2018\n\n\n\n\nProgramming Assignments\n\n\nAssignment 2: Collatz, Weekday, Circle, Pattern\n\n\nReleased 14 September 2018, Due 21 September 2018, 6pm.\n\n\nAssignment 1: Invest, Box, Digits, and Taxi\n\n\nReleased 7 September 2018, Due 14 September 2018, 6pm.\n\n\n\n\nNotes and Lectures \n\n\nLecture 6\n\n\nIn this lecture, we will discuss how call stack works, giving more insights about how a C program is executed, particularly when we call a function and when a function returns.  We then discuss about pointers and arrays, ending with a brief introduction to strings as an array of \nchar\n.\n\n\nUnits covered are Units 13 - 16: \nUnit 13: Call Stack\n, \nUnit 14: Pointers\n, \nUnit 15: Arrays\n and \nUnit 16: Strings\n.\n\n\nLecture 5\n\n\n\n\nSlides\n | \nScreencast\n\n\n\n\nIn this lecture, we talked about how to write loops, followed by using assertions to reason about the behavior and logic of our programs.\n\n\nUnits covered are Units \n10 Assertions\n, \n11 Loops\n, and \n12 Reasoning About Loops\n.\n\n\nLecture 4\n\n\n\n\nSlides\n | \nScreencast\n | \nKahoot Quiz\n\n\n\n\nIn this lecture, we learned how to write programs that involve branching execution paths, using \nif\n-\nelse\n statements and logical expressions.  \nUnit 8 If-Else\n, \nUnit 9 Logical Expression\n were covered.\n\n\nLecture 3\n\n\n\n\nSlides\n | \nScreencast\n\n\n\n\nWe covered \nUnit 5: First C Program\n, \nUnit 6: CS1010 I/O Library\n and \nUnit 7: Arithmetic Operations\n.\n\n\nIn this lecture, we got started with writing simple C programs that read inputs, perform some calculations, and display the result.\n\n\nLecture 2\n\n\n\n\nSlides\n | \nScreencast\n\n\n\n\nWe covered \nUnit 3: functions\n and \nUnit 4: types\n.\n\n\nIn this lecture, we learned the concepts of functions, with which we can build up a more complex algorithm from smaller building blocks, such as finding the maximum.  We also learned about the concept of types.\n\n\nLecture 1\n\n\n\n\nSlides\n | \nScreencast\n (password posted on Piazza)\n\n\n\n\nAfter some admin matters, we introduced what is a program, what is meant by programming, and what is computational problem solving.\n\n\nWe covered \nUnit 1: What is a Program?\n and \nUnit 2: Computational Problems and Algorithms\n in the first lecture.",
            "title": "Home"
        },
        {
            "location": "/index.html#cs1010",
            "text": "",
            "title": "CS1010"
        },
        {
            "location": "/index.html#whats-new",
            "text": "",
            "title": "What's New"
        },
        {
            "location": "/index.html#assignment-3-kendall-histogram-countingsort",
            "text": "Released 21 September 2018, Due 5 October 2018, 6pm.",
            "title": "Assignment 3: Kendall, Histogram, CountingSort"
        },
        {
            "location": "/index.html#exercise-4-id-grade-index-max",
            "text": "Released 20 September 2018",
            "title": "Exercise 4: ID, Grade, Index, Max"
        },
        {
            "location": "/index.html#info-on-midterm-and-practical-exam-1",
            "text": "",
            "title": "Info on Midterm and Practical Exam 1"
        },
        {
            "location": "/index.html#summary-of-cs1010s-rules-on-c",
            "text": "",
            "title": "Summary of CS1010's Rules on C"
        },
        {
            "location": "/index.html#assignment-1-comments-and-answer-keys",
            "text": "",
            "title": "Assignment 1: Comments and Answer Keys"
        },
        {
            "location": "/index.html#lecture-6",
            "text": "In this lecture, we will discuss how call stack works, giving more insights about how a C program is executed, particularly when we call a function and when a function returns.  We then discuss about pointers and arrays, ending with a brief introduction to strings as an array of  char .  Units covered are Units 13 - 16:  Unit 13: Call Stack ,  Unit 14: Pointers ,  Unit 15: Arrays  and  Unit 16: Strings .",
            "title": "Lecture 6"
        },
        {
            "location": "/index.html#piazza-qa",
            "text": "Piazza is the Q&A site for students and instructors to ask questions and discuss among each other on all matters related to CS1010.",
            "title": "Piazza Q&amp;A"
        },
        {
            "location": "/index.html#programming-exercises",
            "text": "Exercises are ungraded programming questions for practicing on your own.",
            "title": "Programming Exercises"
        },
        {
            "location": "/index.html#exercise-3-binary-rectangle-fibonacci-prime",
            "text": "Released 13 September 2018",
            "title": "Exercise 3: Binary, Rectangle, Fibonacci, Prime"
        },
        {
            "location": "/index.html#exercise-2-leap-suffix-days",
            "text": "Released 6 September 2018",
            "title": "Exercise 2: Leap, Suffix, Days"
        },
        {
            "location": "/index.html#exercise-1-freezer",
            "text": "Released 3 September 2018",
            "title": "Exercise 1: Freezer"
        },
        {
            "location": "/index.html#programming-assignments",
            "text": "",
            "title": "Programming Assignments"
        },
        {
            "location": "/index.html#assignment-2-collatz-weekday-circle-pattern",
            "text": "Released 14 September 2018, Due 21 September 2018, 6pm.",
            "title": "Assignment 2: Collatz, Weekday, Circle, Pattern"
        },
        {
            "location": "/index.html#assignment-1-invest-box-digits-and-taxi",
            "text": "Released 7 September 2018, Due 14 September 2018, 6pm.",
            "title": "Assignment 1: Invest, Box, Digits, and Taxi"
        },
        {
            "location": "/index.html#notes-and-lectures",
            "text": "",
            "title": "Notes and Lectures"
        },
        {
            "location": "/index.html#lecture-6_1",
            "text": "In this lecture, we will discuss how call stack works, giving more insights about how a C program is executed, particularly when we call a function and when a function returns.  We then discuss about pointers and arrays, ending with a brief introduction to strings as an array of  char .  Units covered are Units 13 - 16:  Unit 13: Call Stack ,  Unit 14: Pointers ,  Unit 15: Arrays  and  Unit 16: Strings .",
            "title": "Lecture 6"
        },
        {
            "location": "/index.html#lecture-5",
            "text": "Slides  |  Screencast   In this lecture, we talked about how to write loops, followed by using assertions to reason about the behavior and logic of our programs.  Units covered are Units  10 Assertions ,  11 Loops , and  12 Reasoning About Loops .",
            "title": "Lecture 5"
        },
        {
            "location": "/index.html#lecture-4",
            "text": "Slides  |  Screencast  |  Kahoot Quiz   In this lecture, we learned how to write programs that involve branching execution paths, using  if - else  statements and logical expressions.   Unit 8 If-Else ,  Unit 9 Logical Expression  were covered.",
            "title": "Lecture 4"
        },
        {
            "location": "/index.html#lecture-3",
            "text": "Slides  |  Screencast   We covered  Unit 5: First C Program ,  Unit 6: CS1010 I/O Library  and  Unit 7: Arithmetic Operations .  In this lecture, we got started with writing simple C programs that read inputs, perform some calculations, and display the result.",
            "title": "Lecture 3"
        },
        {
            "location": "/index.html#lecture-2",
            "text": "Slides  |  Screencast   We covered  Unit 3: functions  and  Unit 4: types .  In this lecture, we learned the concepts of functions, with which we can build up a more complex algorithm from smaller building blocks, such as finding the maximum.  We also learned about the concept of types.",
            "title": "Lecture 2"
        },
        {
            "location": "/index.html#lecture-1",
            "text": "Slides  |  Screencast  (password posted on Piazza)   After some admin matters, we introduced what is a program, what is meant by programming, and what is computational problem solving.  We covered  Unit 1: What is a Program?  and  Unit 2: Computational Problems and Algorithms  in the first lecture.",
            "title": "Lecture 1"
        },
        {
            "location": "/midterm/index.html",
            "text": "Midterm\n\n\nImportant Information\n\n\n\n\nDate: 2 October, 2018 (Tuesday)\n\n\nTime: 4pm to 6pm\n\n\nVenue: MPSH 1 (Section B)\n\n\nScope: Units 1-12, Assignments 1-2, Tutorials 1-4\n\n\nMCQs and Short Structured Questions\n\n\nDuration: 90 minutes\n\n\nOpen Book (You can bring analog references)",
            "title": "Midterm"
        },
        {
            "location": "/midterm/index.html#midterm",
            "text": "",
            "title": "Midterm"
        },
        {
            "location": "/midterm/index.html#important-information",
            "text": "Date: 2 October, 2018 (Tuesday)  Time: 4pm to 6pm  Venue: MPSH 1 (Section B)  Scope: Units 1-12, Assignments 1-2, Tutorials 1-4  MCQs and Short Structured Questions  Duration: 90 minutes  Open Book (You can bring analog references)",
            "title": "Important Information"
        },
        {
            "location": "/pe1/index.html",
            "text": "Practice Exam 1\n\n\n\n\nDate: 6 October, 2018 (Saturday)\n\n\nTime: 9am to 12noon\n\n\nVenue: Various programming labs\n\n\nScope: Units 1-12, Assignments 1-2, Tutorials 1-4\n\n\n4-5 programming questions, very easy to hard\n\n\nDuration: 2 hours and 30 minutes\n\n\nOpen Book (You can bring analog references)\n\n\n\n\nLab Allocation\n\n\n\n\nEvery student is assigned to a programming lab.  \n\n\nPlease see the allocation below.\n\n\nYou should acclimatize yourself to the use of the PC desktops in the lab assigned to you.\n\n\nSpecial access has been given to students assigned to ES Lab 1 and 2 (Embedded System Teaching Lab 1 and 2)\n\n\nHere are the \nlocatons for the respective labs\n\n\n\n\nSpecial Restrictions\n\n\n\n\n\n\nYou will be issued a special account on the PE day to solve the exam questions.  \n\n\n\n\n\n\nThere will be no Internet access.\n\n\n\n\n\n\nVim Configuration\n\n\nYour default account will have the same \n.vimrc\n as \n~cs1010/.vimrc\n on the CS1010 PE hosts.  \n\n\nYou are free to edit this during the practical exams.  \n\n\nYou, however, will not be able to download nor install \nvim\n plugins.\n\n\nLab Allocation\n\n\n\n\n\n\n\n\nNAME\n\n\nPE1 Venue\n\n\n\n\n\n\n\n\n\n\nAARUSHI SINGH\n\n\nPL1\n\n\n\n\n\n\nADELYN KOH JING YING\n\n\nPL1\n\n\n\n\n\n\nAHMAD MUDAAFI' B ZAINUDDIN\n\n\nPL1\n\n\n\n\n\n\nAI ZHENGWEI\n\n\nPL1\n\n\n\n\n\n\nALEX TEO KANG JIE\n\n\nPL1\n\n\n\n\n\n\nAMIR AZHAR B AZIZAN\n\n\nPL1\n\n\n\n\n\n\nANDREW LAU JIA JUN\n\n\nPL1\n\n\n\n\n\n\nANG KENG SIANG\n\n\nPL1\n\n\n\n\n\n\nANG KIANG YANG\n\n\nPL1\n\n\n\n\n\n\nAW CHIAN HAO\n\n\nPL1\n\n\n\n\n\n\nBALAM SAI ROHIT REDDY\n\n\nPL1\n\n\n\n\n\n\nBEATRICE CHAN TONG\n\n\nPL1\n\n\n\n\n\n\nBENEDICT YU CHENG EN\n\n\nPL1\n\n\n\n\n\n\nBENJAMIN CHIA SHAN HONG\n\n\nPL1\n\n\n\n\n\n\nBRANSON LEE JUN XIAN\n\n\nPL1\n\n\n\n\n\n\nCAI RONG\n\n\nPL1\n\n\n\n\n\n\nCHAN EE ZHENG, BENJAMIN\n\n\nPL1\n\n\n\n\n\n\nCHAN HIN, SEAN\n\n\nPL1\n\n\n\n\n\n\nCHAN WEI FONG, MAX\n\n\nPL1\n\n\n\n\n\n\nCHAN YEE CHONG PHILIP\n\n\nPL1\n\n\n\n\n\n\nCHAN YEW CHUN DANIEL\n\n\nPL1\n\n\n\n\n\n\nCHAN ZHI ZHENG, AMOS\n\n\nPL1\n\n\n\n\n\n\nCHANG HUI ZHEN\n\n\nPL1\n\n\n\n\n\n\nCHANG ZHONG KAI\n\n\nPL1\n\n\n\n\n\n\nCHEN CHAO\n\n\nPL1\n\n\n\n\n\n\nCHEN TONG\n\n\nPL1\n\n\n\n\n\n\nCHENG LE DA, CLEMENT\n\n\nPL1\n\n\n\n\n\n\nCHENG WANYIN\n\n\nPL1\n\n\n\n\n\n\nCHENG WEIXUAN\n\n\nPL1\n\n\n\n\n\n\nCHERYL NG YUN LIN\n\n\nPL1\n\n\n\n\n\n\nCHEW JUN KONG\n\n\nPL1\n\n\n\n\n\n\nCHIA BIING HANN\n\n\nPL1\n\n\n\n\n\n\nCHNG XIAN YI\n\n\nPL1\n\n\n\n\n\n\nCHOI WONJAE\n\n\nPL1\n\n\n\n\n\n\nCHU JUI HUNG @JEFFERSON CHU\n\n\nPL1\n\n\n\n\n\n\nCHUA MAI FENG, CARL\n\n\nPL1\n\n\n\n\n\n\nCHUA WEN XUAN\n\n\nPL1\n\n\n\n\n\n\nCHUA ZONG WEI\n\n\nPL1\n\n\n\n\n\n\nCLAIRE CHAN YEN HWA\n\n\nPL1\n\n\n\n\n\n\nCYNTHIA LEE WENG YAN\n\n\nPL1\n\n\n\n\n\n\nDANIEL TAN WEE LIANG\n\n\nPL2\n\n\n\n\n\n\nDANISH B EDDIE\n\n\nPL2\n\n\n\n\n\n\nDARREN ONG\n\n\nPL2\n\n\n\n\n\n\nDEBBIE TAN JIA MIN\n\n\nPL2\n\n\n\n\n\n\nDING NING\n\n\nPL2\n\n\n\n\n\n\nDIVAKARAN HARITHA\n\n\nPL2\n\n\n\n\n\n\nEDMUND TEO WEI XIN\n\n\nPL2\n\n\n\n\n\n\nEU JING SEN\n\n\nPL2\n\n\n\n\n\n\nEVELYN YI-WEN CHEN\n\n\nPL2\n\n\n\n\n\n\nFATIN NABILAH BTE SUHAIMI\n\n\nPL2\n\n\n\n\n\n\nFOO CHI HEN\n\n\nPL2\n\n\n\n\n\n\nGINA QUAH JIE XI\n\n\nPL2\n\n\n\n\n\n\nGLEN WONG SHU ZE\n\n\nPL2\n\n\n\n\n\n\nGOH RUI PING SAMANTHA\n\n\nPL2\n\n\n\n\n\n\nGOH ZHEN HAO JOEY\n\n\nPL2\n\n\n\n\n\n\nGONDHALEKAR SUKRUT YOGESH\n\n\nPL2\n\n\n\n\n\n\nGREGORY TAN WEI YUAN\n\n\nPL2\n\n\n\n\n\n\nGUI XIXIAN\n\n\nPL2\n\n\n\n\n\n\nGUO HAOREN\n\n\nPL2\n\n\n\n\n\n\nHANS KURNIA WIDJAJA\n\n\nPL2\n\n\n\n\n\n\nHAO YUN\n\n\nPL2\n\n\n\n\n\n\nHASHIR ZAHIR\n\n\nPL2\n\n\n\n\n\n\nHENG HONG CHUAN\n\n\nPL2\n\n\n\n\n\n\nHO JING YANG DANIEL\n\n\nPL2\n\n\n\n\n\n\nHO SI SHI ANNETTE\n\n\nPL2\n\n\n\n\n\n\nHO WEI BIN, JERRY\n\n\nPL2\n\n\n\n\n\n\nHU XINYING\n\n\nPL2\n\n\n\n\n\n\nHUANG XUANKUN\n\n\nPL2\n\n\n\n\n\n\nIAN CHUA\n\n\nPL2\n\n\n\n\n\n\nISABELLA CHEONG XIAO XUAN\n\n\nPL2\n\n\n\n\n\n\nIVAN ANDIKA LIE\n\n\nPL2\n\n\n\n\n\n\nJANEL ANG YEE HUEY\n\n\nPL2\n\n\n\n\n\n\nJASON SATHYA CITRO\n\n\nPL2\n\n\n\n\n\n\nJASPER ONG SHAO YONG\n\n\nPL2\n\n\n\n\n\n\nJAZHTEN LOW YONGSHEN\n\n\nPL2\n\n\n\n\n\n\nJERRY ZHANG ZHUORAN\n\n\nPL2\n\n\n\n\n\n\nJESS TEO XI ZHI\n\n\nPL2\n\n\n\n\n\n\nJOEL CHANG ZHI KAI\n\n\nPL2\n\n\n\n\n\n\nJOHN CUTHBERT KHOO TENG FONG\n\n\nPL2\n\n\n\n\n\n\nJOSEPH WONG YEFENG\n\n\nPL2\n\n\n\n\n\n\nJUSTIN CHIA JIA JIN\n\n\nPL3\n\n\n\n\n\n\nK ALAGES\n\n\nPL3\n\n\n\n\n\n\nKARAN SARAT\n\n\nPL3\n\n\n\n\n\n\nKARNATI SAI ABHISHEK\n\n\nPL3\n\n\n\n\n\n\nKEE KAH LOK\n\n\nPL3\n\n\n\n\n\n\nKEITH CHAN JUN KAI\n\n\nPL3\n\n\n\n\n\n\nKELVIN HARRIS\n\n\nPL3\n\n\n\n\n\n\nKEVIN PUTERA\n\n\nPL3\n\n\n\n\n\n\nKEZIA KEW KAI YUN\n\n\nPL3\n\n\n\n\n\n\nKHAIRUL IMAN NASRI B AZHARIE\n\n\nPL3\n\n\n\n\n\n\nKHOO TZE YANG RAYSON\n\n\nPL3\n\n\n\n\n\n\nKISHORE R\n\n\nPL3\n\n\n\n\n\n\nKWOK KUIN EK JEREMY\n\n\nPL3\n\n\n\n\n\n\nKYAWT KYAWT SAN\n\n\nPL3\n\n\n\n\n\n\nLAI WEN XUAN JEREMY\n\n\nPL3\n\n\n\n\n\n\nLAM TIAN WEI JUSTIN\n\n\nPL3\n\n\n\n\n\n\nLE HONG LONG\n\n\nPL3\n\n\n\n\n\n\nLEE HONG CHIEN, KENNETH\n\n\nPL3\n\n\n\n\n\n\nLEE LI XIN\n\n\nPL3\n\n\n\n\n\n\nLEE RAIYAN BIN ZULKIFLI\n\n\nPL3\n\n\n\n\n\n\nLEE WEI HERN, JASON\n\n\nPL3\n\n\n\n\n\n\nLEE YUEYU\n\n\nPL3\n\n\n\n\n\n\nLEE ZHEN YU\n\n\nPL4\n\n\n\n\n\n\nLEOW YONG HENG\n\n\nPL4\n\n\n\n\n\n\nLEOW YONG KANG ANDREW\n\n\nPL4\n\n\n\n\n\n\nLI JIAYU\n\n\nPL4\n\n\n\n\n\n\nLI ZIHAN\n\n\nPL4\n\n\n\n\n\n\nLIAO LIXIN\n\n\nPL4\n\n\n\n\n\n\nLIAO TIANCHANG\n\n\nPL4\n\n\n\n\n\n\nLIM CHEE SENG BRIAN\n\n\nPL4\n\n\n\n\n\n\nLIM CHEK JUN\n\n\nPL4\n\n\n\n\n\n\nLIM CHENG YIN, RYAN\n\n\nPL4\n\n\n\n\n\n\nLIM HAO XIANG, SEAN\n\n\nPL4\n\n\n\n\n\n\nLIM JIA WEI\n\n\nPL4\n\n\n\n\n\n\nLIM JIAYI, TAMELLY\n\n\nPL4\n\n\n\n\n\n\nLIM JUN KUANG, LIONEL\n\n\nPL4\n\n\n\n\n\n\nLIM LI LINCOLN\n\n\nPL4\n\n\n\n\n\n\nLIM SI YING\n\n\nPL4\n\n\n\n\n\n\nLIM TING WEI\n\n\nPL4\n\n\n\n\n\n\nLIM WEN HAN, EUGENE\n\n\nPL4\n\n\n\n\n\n\nLIM YAN TING\n\n\nPL4\n\n\n\n\n\n\nLIN JIAYUE\n\n\nPL4\n\n\n\n\n\n\nLING WEN JIAN\n\n\nPL4\n\n\n\n\n\n\nLIU JINGXUAN\n\n\nPL4\n\n\n\n\n\n\nLIU PEIZE\n\n\nPL5\n\n\n\n\n\n\nLIU SHIRU\n\n\nPL5\n\n\n\n\n\n\nLIU SONGTAO\n\n\nPL5\n\n\n\n\n\n\nLIU WEI JIE NICHOLAS\n\n\nPL5\n\n\n\n\n\n\nLOH CHING WEI, JOSHUA\n\n\nPL5\n\n\n\n\n\n\nLOH YONG ZEE\n\n\nPL5\n\n\n\n\n\n\nLOW EE TER\n\n\nPL5\n\n\n\n\n\n\nLOW JIA YEE\n\n\nPL5\n\n\n\n\n\n\nLOW QIRAN\n\n\nPL5\n\n\n\n\n\n\nLOW SIU YUAN, FRANCIS\n\n\nPL5\n\n\n\n\n\n\nLUCAS FOO SOO QUAN\n\n\nPL5\n\n\n\n\n\n\nLYE JUN WEI ANANDA\n\n\nPL5\n\n\n\n\n\n\nMARC PHUA HSIAO MENG\n\n\nPL5\n\n\n\n\n\n\nMATTHEW NATHANAEL SUGIRI\n\n\nPL5\n\n\n\n\n\n\nMERVIN WEE MINGWEN\n\n\nPL5\n\n\n\n\n\n\nMICHELLE TOH HUI PING\n\n\nPL5\n\n\n\n\n\n\nMODAK SHANTANU BHARAT\n\n\nPL5\n\n\n\n\n\n\nMOHAMED RIYAS\n\n\nPL5\n\n\n\n\n\n\nMOHAMMAD YOUSUF MINHAJ ZIA\n\n\nPL5\n\n\n\n\n\n\nMUHAMMAD FAIRUZ B AMIRHAMZAH\n\n\nPL5\n\n\n\n\n\n\nMUHAMMAD HOZEFA ZUMKHAWALA\n\n\nPL6\n\n\n\n\n\n\nMUHAMMAD SHOLIHIN BIN KAMARUDIN\n\n\nPL6\n\n\n\n\n\n\nMUHHAMMAD NUR HAFIDZ BIN HUSSAIN\n\n\nPL6\n\n\n\n\n\n\nNATHAN YEO KEE HERN\n\n\nPL6\n\n\n\n\n\n\nNEO WEN HUI\n\n\nPL6\n\n\n\n\n\n\nNG JIE WU\n\n\nPL6\n\n\n\n\n\n\nNG JING KANG\n\n\nPL6\n\n\n\n\n\n\nNG JING KIAT\n\n\nPL6\n\n\n\n\n\n\nNG SHI QI, CARRIE\n\n\nPL6\n\n\n\n\n\n\nNG SIU HIAN\n\n\nPL6\n\n\n\n\n\n\nNG WEE KIAT\n\n\nPL6\n\n\n\n\n\n\nNG WEI JIE, BRANDON\n\n\nPL6\n\n\n\n\n\n\nNG ZI HUI\n\n\nPL6\n\n\n\n\n\n\nNGAN JI CHENG\n\n\nPL6\n\n\n\n\n\n\nNGUYEN THANH DUC\n\n\nPL6\n\n\n\n\n\n\nNGUYEN TIEN DAT\n\n\nPL6\n\n\n\n\n\n\nNIGEL TAN\n\n\nPL6\n\n\n\n\n\n\nNIGELLE LEO YUWEN\n\n\nPL6\n\n\n\n\n\n\nNISHANTH ELANGO\n\n\nPL6\n\n\n\n\n\n\nNYAN WUN PAING\n\n\nPL6\n\n\n\n\n\n\nOEI CHIU YAN REBECCA\n\n\nPL6\n\n\n\n\n\n\nONG YU XUAN\n\n\nPL6\n\n\n\n\n\n\nOUNG YONG SHENG KENNEDY\n\n\nPL6\n\n\n\n\n\n\nOW ZHENG KUAN\n\n\nPL6\n\n\n\n\n\n\nP PRADEEP\n\n\nPL6\n\n\n\n\n\n\nPANG JIA JUN VERNON\n\n\nPL6\n\n\n\n\n\n\nPARK SO HYUN\n\n\nPL6\n\n\n\n\n\n\nPARMAR VARUN SAMIR\n\n\nPL6\n\n\n\n\n\n\nPARVATHI RANJITH MENON\n\n\nESLab 1\n\n\n\n\n\n\nPATWARI RISHAB\n\n\nESLab 1\n\n\n\n\n\n\nPEI YAN BO\n\n\nESLab 1\n\n\n\n\n\n\nPHOON JIA JUIN\n\n\nESLab 1\n\n\n\n\n\n\nPOH CHOO LEONG, LINSTON\n\n\nESLab 1\n\n\n\n\n\n\nPONG LOONG BOB\n\n\nESLab 1\n\n\n\n\n\n\nPOON KAH ONN, BENJAMIN\n\n\nESLab 1\n\n\n\n\n\n\nPOW JING YONG\n\n\nESLab 1\n\n\n\n\n\n\nQIAN JIE\n\n\nESLab 1\n\n\n\n\n\n\nQUAH YOU JING KANE\n\n\nESLab 1\n\n\n\n\n\n\nQUEK AIK PENG\n\n\nESLab 1\n\n\n\n\n\n\nRAGHAV BHARDWAJ\n\n\nESLab 1\n\n\n\n\n\n\nRAJAMOHAN B PRIYAN\n\n\nESLab 1\n\n\n\n\n\n\nRAVEENDRAN AJEY ASHOK\n\n\nESLab 1\n\n\n\n\n\n\nRISHI MAHADEVAN\n\n\nESLab 1\n\n\n\n\n\n\nRUSDI HAIZIM B RAHIM\n\n\nESLab 1\n\n\n\n\n\n\nRYAN TAN YU\n\n\nESLab 1\n\n\n\n\n\n\nSAI GANESH SURESH\n\n\nESLab 1\n\n\n\n\n\n\nSCOTT FLOYD ZHEN-YAN SMAHON\n\n\nESLab 1\n\n\n\n\n\n\nSEE SHENG CHAO\n\n\nESLab 1\n\n\n\n\n\n\nSENTHIL ARAAVIND\n\n\nESLab 2\n\n\n\n\n\n\nSHA LONG\n\n\nESLab 2\n\n\n\n\n\n\nSHANNON LEE\n\n\nESLab 2\n\n\n\n\n\n\nSHAWN WONG JUN KIT\n\n\nESLab 2\n\n\n\n\n\n\nSHRIYA SAXENA\n\n\nESLab 2\n\n\n\n\n\n\nSIM YU JIE\n\n\nESLab 2\n\n\n\n\n\n\nSITI NADIAH BINTE MOHAMED RAMLI\n\n\nESLab 2\n\n\n\n\n\n\nSUTHER DAVID SAMUEL\n\n\nESLab 2\n\n\n\n\n\n\nTALAGADADIVI DURGA RUKMINI MANASWINI\n\n\nESLab 2\n\n\n\n\n\n\nTAM WEI IAN JOSHUA\n\n\nESLab 2\n\n\n\n\n\n\nTAN GUAN YEW\n\n\nESLab 2\n\n\n\n\n\n\nTAN KAI LI CATHERINE\n\n\nESLab 2\n\n\n\n\n\n\nTAN KOK JOON\n\n\nESLab 2\n\n\n\n\n\n\nTAN LI ANN PETER\n\n\nESLab 2\n\n\n\n\n\n\nTAN YEH HAN, JOHN\n\n\nESLab 2\n\n\n\n\n\n\nTAN YI XIANG\n\n\nESLab 2\n\n\n\n\n\n\nTAN ZHENG FU JUSTIN\n\n\nESLab 2\n\n\n\n\n\n\nTAN ZHENG WEN\n\n\nESLab 2\n\n\n\n\n\n\nTAY JIN WEN\n\n\nESLab 2\n\n\n\n\n\n\nTAY JING XUAN\n\n\nESLab 2\n\n\n\n\n\n\nTAY TZE-WEI, CALEB\n\n\nWSLab 1\n\n\n\n\n\n\nTAY YEE EN, RYAN\n\n\nWSLab 1\n\n\n\n\n\n\nTEH ZI HUAI\n\n\nWSLab 1\n\n\n\n\n\n\nTEO WEI JIE, SHAUN\n\n\nWSLab 1\n\n\n\n\n\n\nTOH YING YING JANICE\n\n\nWSLab 1\n\n\n\n\n\n\nTONG QI WEI\n\n\nWSLab 1\n\n\n\n\n\n\nTRAN MINH DUONG\n\n\nWSLab 1\n\n\n\n\n\n\nTRAN QUANG THANH\n\n\nWSLab 1\n\n\n\n\n\n\nTSHIN QI REN\n\n\nWSLab 1\n\n\n\n\n\n\nUMAR BIN MOIZ\n\n\nWSLab 1\n\n\n\n\n\n\nVASAVADA TEJAS SUDHIR\n\n\nWSLab 1\n\n\n\n\n\n\nVIDHYABHARATHI SOMASUNDARAM\n\n\nWSLab 1\n\n\n\n\n\n\nVIVIAN LEE BOON GEOK\n\n\nWSLab 1\n\n\n\n\n\n\nWANG ZICONG\n\n\nWSLab 1\n\n\n\n\n\n\nWEI FENG\n\n\nWSLab 1\n\n\n\n\n\n\nWENG KEXIN\n\n\nWSLab 1\n\n\n\n\n\n\nWONG JIN EN, SHANNON\n\n\nWSLab 1\n\n\n\n\n\n\nWONG REN-WEI, RYAN\n\n\nWSLab 1\n\n\n\n\n\n\nXUE ZHENGQING\n\n\nWSLab 1\n\n\n\n\n\n\nYANG AN QI\n\n\nWSLab 1\n\n\n\n\n\n\nYANG CHENGLONG\n\n\nWSLab 1\n\n\n\n\n\n\nYANG KAI ZE\n\n\nWSLab 3\n\n\n\n\n\n\nYANG ZI YUN\n\n\nWSLab 3\n\n\n\n\n\n\nYAP JIN FA\n\n\nWSLab 3\n\n\n\n\n\n\nYAP KESIN\n\n\nWSLab 3\n\n\n\n\n\n\nYE GUOQUAN\n\n\nWSLab 3\n\n\n\n\n\n\nYE TONG\n\n\nWSLab 3\n\n\n\n\n\n\nYEN PEI CHIH\n\n\nWSLab 3\n\n\n\n\n\n\nYEW JING HUI\n\n\nWSLab 3\n\n\n\n\n\n\nYU XIAOXUE\n\n\nWSLab 3\n\n\n\n\n\n\nYUAN JIAYI\n\n\nWSLab 3\n\n\n\n\n\n\nYUE JUN YI\n\n\nWSLab 3\n\n\n\n\n\n\nZHANG SHIYU\n\n\nWSLab 3\n\n\n\n\n\n\nZHANG YIHAN\n\n\nWSLab 3\n\n\n\n\n\n\nZHANG YIPING\n\n\nWSLab 3\n\n\n\n\n\n\nZHANG YUE HAN\n\n\nWSLab 3\n\n\n\n\n\n\nZHAO PENGFEI\n\n\nWSLab 3\n\n\n\n\n\n\nZHAO TIANQI\n\n\nWSLab 3\n\n\n\n\n\n\nZHENG KAINING\n\n\nWSLab 3\n\n\n\n\n\n\nZHU BO\n\n\nWSLab 3\n\n\n\n\n\n\nZHU YIJIE\n\n\nWSLab 3\n\n\n\n\n\n\nZOE WONG XIN LEI\n\n\nWSLab 3",
            "title": "Practical Exam"
        },
        {
            "location": "/pe1/index.html#practice-exam-1",
            "text": "Date: 6 October, 2018 (Saturday)  Time: 9am to 12noon  Venue: Various programming labs  Scope: Units 1-12, Assignments 1-2, Tutorials 1-4  4-5 programming questions, very easy to hard  Duration: 2 hours and 30 minutes  Open Book (You can bring analog references)",
            "title": "Practice Exam 1"
        },
        {
            "location": "/pe1/index.html#lab-allocation",
            "text": "Every student is assigned to a programming lab.    Please see the allocation below.  You should acclimatize yourself to the use of the PC desktops in the lab assigned to you.  Special access has been given to students assigned to ES Lab 1 and 2 (Embedded System Teaching Lab 1 and 2)  Here are the  locatons for the respective labs",
            "title": "Lab Allocation"
        },
        {
            "location": "/pe1/index.html#special-restrictions",
            "text": "You will be issued a special account on the PE day to solve the exam questions.      There will be no Internet access.",
            "title": "Special Restrictions"
        },
        {
            "location": "/pe1/index.html#vim-configuration",
            "text": "Your default account will have the same  .vimrc  as  ~cs1010/.vimrc  on the CS1010 PE hosts.    You are free to edit this during the practical exams.    You, however, will not be able to download nor install  vim  plugins.",
            "title": "Vim Configuration"
        },
        {
            "location": "/pe1/index.html#lab-allocation_1",
            "text": "NAME  PE1 Venue      AARUSHI SINGH  PL1    ADELYN KOH JING YING  PL1    AHMAD MUDAAFI' B ZAINUDDIN  PL1    AI ZHENGWEI  PL1    ALEX TEO KANG JIE  PL1    AMIR AZHAR B AZIZAN  PL1    ANDREW LAU JIA JUN  PL1    ANG KENG SIANG  PL1    ANG KIANG YANG  PL1    AW CHIAN HAO  PL1    BALAM SAI ROHIT REDDY  PL1    BEATRICE CHAN TONG  PL1    BENEDICT YU CHENG EN  PL1    BENJAMIN CHIA SHAN HONG  PL1    BRANSON LEE JUN XIAN  PL1    CAI RONG  PL1    CHAN EE ZHENG, BENJAMIN  PL1    CHAN HIN, SEAN  PL1    CHAN WEI FONG, MAX  PL1    CHAN YEE CHONG PHILIP  PL1    CHAN YEW CHUN DANIEL  PL1    CHAN ZHI ZHENG, AMOS  PL1    CHANG HUI ZHEN  PL1    CHANG ZHONG KAI  PL1    CHEN CHAO  PL1    CHEN TONG  PL1    CHENG LE DA, CLEMENT  PL1    CHENG WANYIN  PL1    CHENG WEIXUAN  PL1    CHERYL NG YUN LIN  PL1    CHEW JUN KONG  PL1    CHIA BIING HANN  PL1    CHNG XIAN YI  PL1    CHOI WONJAE  PL1    CHU JUI HUNG @JEFFERSON CHU  PL1    CHUA MAI FENG, CARL  PL1    CHUA WEN XUAN  PL1    CHUA ZONG WEI  PL1    CLAIRE CHAN YEN HWA  PL1    CYNTHIA LEE WENG YAN  PL1    DANIEL TAN WEE LIANG  PL2    DANISH B EDDIE  PL2    DARREN ONG  PL2    DEBBIE TAN JIA MIN  PL2    DING NING  PL2    DIVAKARAN HARITHA  PL2    EDMUND TEO WEI XIN  PL2    EU JING SEN  PL2    EVELYN YI-WEN CHEN  PL2    FATIN NABILAH BTE SUHAIMI  PL2    FOO CHI HEN  PL2    GINA QUAH JIE XI  PL2    GLEN WONG SHU ZE  PL2    GOH RUI PING SAMANTHA  PL2    GOH ZHEN HAO JOEY  PL2    GONDHALEKAR SUKRUT YOGESH  PL2    GREGORY TAN WEI YUAN  PL2    GUI XIXIAN  PL2    GUO HAOREN  PL2    HANS KURNIA WIDJAJA  PL2    HAO YUN  PL2    HASHIR ZAHIR  PL2    HENG HONG CHUAN  PL2    HO JING YANG DANIEL  PL2    HO SI SHI ANNETTE  PL2    HO WEI BIN, JERRY  PL2    HU XINYING  PL2    HUANG XUANKUN  PL2    IAN CHUA  PL2    ISABELLA CHEONG XIAO XUAN  PL2    IVAN ANDIKA LIE  PL2    JANEL ANG YEE HUEY  PL2    JASON SATHYA CITRO  PL2    JASPER ONG SHAO YONG  PL2    JAZHTEN LOW YONGSHEN  PL2    JERRY ZHANG ZHUORAN  PL2    JESS TEO XI ZHI  PL2    JOEL CHANG ZHI KAI  PL2    JOHN CUTHBERT KHOO TENG FONG  PL2    JOSEPH WONG YEFENG  PL2    JUSTIN CHIA JIA JIN  PL3    K ALAGES  PL3    KARAN SARAT  PL3    KARNATI SAI ABHISHEK  PL3    KEE KAH LOK  PL3    KEITH CHAN JUN KAI  PL3    KELVIN HARRIS  PL3    KEVIN PUTERA  PL3    KEZIA KEW KAI YUN  PL3    KHAIRUL IMAN NASRI B AZHARIE  PL3    KHOO TZE YANG RAYSON  PL3    KISHORE R  PL3    KWOK KUIN EK JEREMY  PL3    KYAWT KYAWT SAN  PL3    LAI WEN XUAN JEREMY  PL3    LAM TIAN WEI JUSTIN  PL3    LE HONG LONG  PL3    LEE HONG CHIEN, KENNETH  PL3    LEE LI XIN  PL3    LEE RAIYAN BIN ZULKIFLI  PL3    LEE WEI HERN, JASON  PL3    LEE YUEYU  PL3    LEE ZHEN YU  PL4    LEOW YONG HENG  PL4    LEOW YONG KANG ANDREW  PL4    LI JIAYU  PL4    LI ZIHAN  PL4    LIAO LIXIN  PL4    LIAO TIANCHANG  PL4    LIM CHEE SENG BRIAN  PL4    LIM CHEK JUN  PL4    LIM CHENG YIN, RYAN  PL4    LIM HAO XIANG, SEAN  PL4    LIM JIA WEI  PL4    LIM JIAYI, TAMELLY  PL4    LIM JUN KUANG, LIONEL  PL4    LIM LI LINCOLN  PL4    LIM SI YING  PL4    LIM TING WEI  PL4    LIM WEN HAN, EUGENE  PL4    LIM YAN TING  PL4    LIN JIAYUE  PL4    LING WEN JIAN  PL4    LIU JINGXUAN  PL4    LIU PEIZE  PL5    LIU SHIRU  PL5    LIU SONGTAO  PL5    LIU WEI JIE NICHOLAS  PL5    LOH CHING WEI, JOSHUA  PL5    LOH YONG ZEE  PL5    LOW EE TER  PL5    LOW JIA YEE  PL5    LOW QIRAN  PL5    LOW SIU YUAN, FRANCIS  PL5    LUCAS FOO SOO QUAN  PL5    LYE JUN WEI ANANDA  PL5    MARC PHUA HSIAO MENG  PL5    MATTHEW NATHANAEL SUGIRI  PL5    MERVIN WEE MINGWEN  PL5    MICHELLE TOH HUI PING  PL5    MODAK SHANTANU BHARAT  PL5    MOHAMED RIYAS  PL5    MOHAMMAD YOUSUF MINHAJ ZIA  PL5    MUHAMMAD FAIRUZ B AMIRHAMZAH  PL5    MUHAMMAD HOZEFA ZUMKHAWALA  PL6    MUHAMMAD SHOLIHIN BIN KAMARUDIN  PL6    MUHHAMMAD NUR HAFIDZ BIN HUSSAIN  PL6    NATHAN YEO KEE HERN  PL6    NEO WEN HUI  PL6    NG JIE WU  PL6    NG JING KANG  PL6    NG JING KIAT  PL6    NG SHI QI, CARRIE  PL6    NG SIU HIAN  PL6    NG WEE KIAT  PL6    NG WEI JIE, BRANDON  PL6    NG ZI HUI  PL6    NGAN JI CHENG  PL6    NGUYEN THANH DUC  PL6    NGUYEN TIEN DAT  PL6    NIGEL TAN  PL6    NIGELLE LEO YUWEN  PL6    NISHANTH ELANGO  PL6    NYAN WUN PAING  PL6    OEI CHIU YAN REBECCA  PL6    ONG YU XUAN  PL6    OUNG YONG SHENG KENNEDY  PL6    OW ZHENG KUAN  PL6    P PRADEEP  PL6    PANG JIA JUN VERNON  PL6    PARK SO HYUN  PL6    PARMAR VARUN SAMIR  PL6    PARVATHI RANJITH MENON  ESLab 1    PATWARI RISHAB  ESLab 1    PEI YAN BO  ESLab 1    PHOON JIA JUIN  ESLab 1    POH CHOO LEONG, LINSTON  ESLab 1    PONG LOONG BOB  ESLab 1    POON KAH ONN, BENJAMIN  ESLab 1    POW JING YONG  ESLab 1    QIAN JIE  ESLab 1    QUAH YOU JING KANE  ESLab 1    QUEK AIK PENG  ESLab 1    RAGHAV BHARDWAJ  ESLab 1    RAJAMOHAN B PRIYAN  ESLab 1    RAVEENDRAN AJEY ASHOK  ESLab 1    RISHI MAHADEVAN  ESLab 1    RUSDI HAIZIM B RAHIM  ESLab 1    RYAN TAN YU  ESLab 1    SAI GANESH SURESH  ESLab 1    SCOTT FLOYD ZHEN-YAN SMAHON  ESLab 1    SEE SHENG CHAO  ESLab 1    SENTHIL ARAAVIND  ESLab 2    SHA LONG  ESLab 2    SHANNON LEE  ESLab 2    SHAWN WONG JUN KIT  ESLab 2    SHRIYA SAXENA  ESLab 2    SIM YU JIE  ESLab 2    SITI NADIAH BINTE MOHAMED RAMLI  ESLab 2    SUTHER DAVID SAMUEL  ESLab 2    TALAGADADIVI DURGA RUKMINI MANASWINI  ESLab 2    TAM WEI IAN JOSHUA  ESLab 2    TAN GUAN YEW  ESLab 2    TAN KAI LI CATHERINE  ESLab 2    TAN KOK JOON  ESLab 2    TAN LI ANN PETER  ESLab 2    TAN YEH HAN, JOHN  ESLab 2    TAN YI XIANG  ESLab 2    TAN ZHENG FU JUSTIN  ESLab 2    TAN ZHENG WEN  ESLab 2    TAY JIN WEN  ESLab 2    TAY JING XUAN  ESLab 2    TAY TZE-WEI, CALEB  WSLab 1    TAY YEE EN, RYAN  WSLab 1    TEH ZI HUAI  WSLab 1    TEO WEI JIE, SHAUN  WSLab 1    TOH YING YING JANICE  WSLab 1    TONG QI WEI  WSLab 1    TRAN MINH DUONG  WSLab 1    TRAN QUANG THANH  WSLab 1    TSHIN QI REN  WSLab 1    UMAR BIN MOIZ  WSLab 1    VASAVADA TEJAS SUDHIR  WSLab 1    VIDHYABHARATHI SOMASUNDARAM  WSLab 1    VIVIAN LEE BOON GEOK  WSLab 1    WANG ZICONG  WSLab 1    WEI FENG  WSLab 1    WENG KEXIN  WSLab 1    WONG JIN EN, SHANNON  WSLab 1    WONG REN-WEI, RYAN  WSLab 1    XUE ZHENGQING  WSLab 1    YANG AN QI  WSLab 1    YANG CHENGLONG  WSLab 1    YANG KAI ZE  WSLab 3    YANG ZI YUN  WSLab 3    YAP JIN FA  WSLab 3    YAP KESIN  WSLab 3    YE GUOQUAN  WSLab 3    YE TONG  WSLab 3    YEN PEI CHIH  WSLab 3    YEW JING HUI  WSLab 3    YU XIAOXUE  WSLab 3    YUAN JIAYI  WSLab 3    YUE JUN YI  WSLab 3    ZHANG SHIYU  WSLab 3    ZHANG YIHAN  WSLab 3    ZHANG YIPING  WSLab 3    ZHANG YUE HAN  WSLab 3    ZHAO PENGFEI  WSLab 3    ZHAO TIANQI  WSLab 3    ZHENG KAINING  WSLab 3    ZHU BO  WSLab 3    ZHU YIJIE  WSLab 3    ZOE WONG XIN LEI  WSLab 3",
            "title": "Lab Allocation"
        },
        {
            "location": "/about/index.html",
            "text": "About CS1010\n\n\nModule Description\n\n\nThis module introduces the fundamental concepts of problem solving by computing and programming using an imperative programming language. It is the first and foremost introductory course to computing. It is also the first part of a three-part series on introductory programming and problem solving by computing, which also includes CS2030 and CS2040. Topics covered include problem solving by computing, writing pseudo-codes, basic problem formulation and problem solving, program development, coding, testing and debugging, fundamental programming constructs (variables, types, expressions, assignments, functions, control structures, etc.), fundamental data structures: arrays, strings and structures, simple file processing, and basic recursion. This module is appropriate for SoC students.\n\n\nWho/Where/When\n\n\n\n\nInstructor\n: Ooi Wei Tsang\n\n\nLecture Venue\n: \nI^3\nI^3\n Auditorium\n\n\nLecture Time\n: Every Tuesday, 4pm - 6pm\n\n\nOffice Hour\n: Every Wednesday, 4pm - 5pm\n\n\n\n\nTeaching Assistants\n:\n\n\n\n\nWu Biao\n\n\nYu Xiao Liang\n\n\nDou Rengan\n\n\n\n\n\n\n\n\nUndergraduate Discussion Leaders\n:\n\n\n\n\nArchana Pradeep\n\n\nAu Liang Jun\n\n\nChai Jie Feng (Jack)\n\n\nChua Jun Hui\n\n\nD David Livingston\n\n\nEvan Tay\n\n\nGu Wangfan\n\n\nHo Boon Wee Addison\n\n\nJeffery Kwoh Ji Hui\n\n\nJiang Qinhua\n\n\nJoanne Ong Cui FanG\n\n\nKerryn Eer\n\n\nKyle Timothy Ng Chu\n\n\nLim Heng Guang\n\n\nLin Si Jie\n\n\nNguyen Trong Truong Thanh\n\n\nOng Shu Peng (Metta)\n\n\nOng You Sheng Aaron\n\n\nQuek Shui Herng\n\n\nZhang Tianyang\n\n\n\n\n\n\n\n\nImportant Dates\n\n\n\n\nMidterm Assessment\n: Tuesday, 2 October, 2018 (4pm - 6pm), \nMPSH 1B\n\n\nFinal Assessment\n: Tuesday, 27 Nov, 2018 (9am - 11am)\n\n\nPractical Exam 1\n: Saturday, 6 October, 2018 (9am - 12noon)\n\n\nPractical Exam 2\n: Saturday, 10 November, 2018 \n(9am - 12noon)\n (1pm - 4pm)\n\n\n\n\nAssessment Weightage\n\n\n\n\nProgramming Assignments\n: 30%\n\n\nFinal Assessment\n: 30%\n\n\nMidterm Assessment\n: 15%\n\n\nPractical Exam 1\n: 10%\n\n\nPractical Exam 2\n: 15%",
            "title": "About CS1010"
        },
        {
            "location": "/about/index.html#about-cs1010",
            "text": "",
            "title": "About CS1010"
        },
        {
            "location": "/about/index.html#module-description",
            "text": "This module introduces the fundamental concepts of problem solving by computing and programming using an imperative programming language. It is the first and foremost introductory course to computing. It is also the first part of a three-part series on introductory programming and problem solving by computing, which also includes CS2030 and CS2040. Topics covered include problem solving by computing, writing pseudo-codes, basic problem formulation and problem solving, program development, coding, testing and debugging, fundamental programming constructs (variables, types, expressions, assignments, functions, control structures, etc.), fundamental data structures: arrays, strings and structures, simple file processing, and basic recursion. This module is appropriate for SoC students.",
            "title": "Module Description"
        },
        {
            "location": "/about/index.html#whowherewhen",
            "text": "Instructor : Ooi Wei Tsang  Lecture Venue :  I^3 I^3  Auditorium  Lecture Time : Every Tuesday, 4pm - 6pm  Office Hour : Every Wednesday, 4pm - 5pm   Teaching Assistants :   Wu Biao  Yu Xiao Liang  Dou Rengan     Undergraduate Discussion Leaders :   Archana Pradeep  Au Liang Jun  Chai Jie Feng (Jack)  Chua Jun Hui  D David Livingston  Evan Tay  Gu Wangfan  Ho Boon Wee Addison  Jeffery Kwoh Ji Hui  Jiang Qinhua  Joanne Ong Cui FanG  Kerryn Eer  Kyle Timothy Ng Chu  Lim Heng Guang  Lin Si Jie  Nguyen Trong Truong Thanh  Ong Shu Peng (Metta)  Ong You Sheng Aaron  Quek Shui Herng  Zhang Tianyang",
            "title": "Who/Where/When"
        },
        {
            "location": "/about/index.html#important-dates",
            "text": "Midterm Assessment : Tuesday, 2 October, 2018 (4pm - 6pm),  MPSH 1B  Final Assessment : Tuesday, 27 Nov, 2018 (9am - 11am)  Practical Exam 1 : Saturday, 6 October, 2018 (9am - 12noon)  Practical Exam 2 : Saturday, 10 November, 2018  (9am - 12noon)  (1pm - 4pm)",
            "title": "Important Dates"
        },
        {
            "location": "/about/index.html#assessment-weightage",
            "text": "Programming Assignments : 30%  Final Assessment : 30%  Midterm Assessment : 15%  Practical Exam 1 : 10%  Practical Exam 2 : 15%",
            "title": "Assessment Weightage"
        },
        {
            "location": "/outcomes/index.html",
            "text": "After taking CS1010, students should\n\n\n\n\nbe familiar with fundamental  programming concepts and methodology (variables, assignments, conditions, branches, loops, functions, recursions, structures);\n\n\nbe familiar with and appreciate good programming practice, and apply it to follow-up courses;\n\n\nbe able to apply problem-solving knowledge and skills to write small, well-documented, effective C programs;\n\n\nbe able to appreciate the use of simple data structure such as array, know their limitations to pave way for more complex data structures in the next course;\n\n\nknow the responsibilities of an ethical programmer;\n\n\nbe able to write simple programs in the corresponding programming language to solve a task, given the constraints on the inputs;\n\n\nbe able to manually trace through a program to identify logical errors;\n\n\nbe able to differentiate between logical errors, syntax errors, and run-time errors;\n\n\nbe exposed informally to the concept of code specification in the form of comments in the code, explaining what are the expected inputs and outputs and what are the assumptions;\n\n\nknow about what are some insecure functions to avoid;\n\n\nbe able to generate test cases on their own, with a focus on boundary/special cases;\n\n\nbe able to debug with printf or equivalent functions;\n\n\nbe aware of common strategies and good practices of debugging with printf or equivalent functions;\n\n\nbe able to identify opportunities to, and write, modularized code;\n\n\nbe exposed to a debugger;\n\n\nbe able to write code following good programming style (clear comments, naming convention, indentation, etc.);\n\n\nunderstand the different data types and that there exists a representation of each in the memory, as well as the limitation of the representations due to the limited number of bits;\n\n\ndevelop a simple mental model of how a program is executed (CPU runs the code on data that is stored in memory, function call leads to the creation of call frames, which can explain recursion and variable scoping, etc).  For interpreted language, understand the role of virtual machine/interpreter;\n\n\nbe able to understand at a high level the compilation process (from pre-processing to compiling to linking), where applicable;\n\n\nunderstand the concept of reusability and how a software application can be built on top of software libraries/packages (standard or third parties);\n\n\nbe able to implement bubble sort and insertion sort;\n\n\nbe able to implement linear search and binary search (both iterative and recursive versions);",
            "title": "Learning Outcomes"
        },
        {
            "location": "/schedule/index.html",
            "text": "Schedule\n\n\nThis is a tentative schedule for CS1010.\n\n\nLecture Schedule (Tentative)\n\n\n\n\n\n\n\n\nWeek\n\n\nStarting..\n\n\nTopics\n\n\nTutorial\n\n\nAssignment\n\n\n\n\n\n\n\n\n\n\n1\n\n\n2018-08-13\n\n\nUnits 1-2: Computational Problem Solving\n\n\n\n\n\n\n\n\n\n\n2\n\n\n2018-08-20\n\n\nUnits 3-4: Functions & Types\n\n\n\n\n\n\n\n\n\n\n3\n\n\n2018-08-27\n\n\nUnits 5-7: Basic C programs\n\n\nPS 1; Unix\n\n\n\n\n\n\n\n\n4\n\n\n2018-09-03\n\n\nUnits 8-9: Conditionals\n\n\nPS 3-5; Vim; ex01\n\n\nas01 Released\n\n\n\n\n\n\n5\n\n\n2018-09-10\n\n\nUnits 10-12 Loops\n\n\nPS 8-9\n\n\nas02 Released\n\n\n\n\n\n\n6\n\n\n2018-09-17\n\n\nUnits 13-16 Memory, Array, Strings\n\n\nPS 10-12\n\n\nas03 Released\n\n\n\n\n\n\n-\n\n\n2018-09-24\n\n\nBreak\n\n\n\n\n\n\n\n\n\n\n7\n\n\n2018-10-01\n\n\nMidterm & Practical Exam 1\n\n\n\n\nas04 Released\n\n\n\n\n\n\n8\n\n\n2018-10-08\n\n\nMacro, Call-by-Referece, nD-Array\n\n\n\n\nas05 Released\n\n\n\n\n\n\n9\n\n\n2018-10-15\n\n\nSearching, Sorting\n\n\n\n\nas06 Released\n\n\n\n\n\n\n10\n\n\n2018-10-22\n\n\nStruct, I/O\n\n\n\n\nas07 Released\n\n\n\n\n\n\n11\n\n\n2018-10-29\n\n\n\n\n\n\nas08 Released\n\n\n\n\n\n\n12\n\n\n2018-11-05\n\n\n\n\nPractical Exam 2\n\n\nas09 Released\n\n\n\n\n\n\n13\n\n\n2018-11-12\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTutorial Time / Venue\n\n\n(scroll horizontally to see the full table)\n\n\n\n\n\n\n\n\nDay/Time\n\n\nCOM1\nB108\n\n\nCOM1\nB109\n\n\nCOM1\nB111\n\n\nCOM1\nB112\n\n\nCOM1\n0120\n\n\nI3\n0336\n\n\nI3\n0338\n\n\nAS6\n0421\n\n\n\n\n\n\n\n\n\n\nMon\n1000\n\n\nC10\nJoanne\n\n\n\n\n\n\n\n\nC09\nEvan\n\n\n\n\n\n\n\n\n\n\n\n\nMon\n1400\n\n\n\n\n\n\n\n\nC1A\nXiao Liang\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTue\n1200\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n03\nAddison\n\n\n\n\n\n\n\n\nTue\n1400\n\n\n\n\n\n\n\n\n\n\n\n\nC03\nKyle\n\n\nC02\nThanh\n\n\n\n\n\n\n\n\nWed\n1000\n\n\nC07\nJun Hui\n\n\n\n\nC08\nShui Herng\n\n\n\n\n\n\n\n\nC06\nShu Peng\n\n\n11\nRengan\n\n\n\n\n\n\nWed\n1200\n\n\n\n\n\n\n\n\n\n\n\n\n10\nDavid\n\n\n07\nAaron\n\n\n\n\n\n\n\n\nWed\n1400\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n08\nTian Yang\n\n\n\n\n\n\n\n\nThu\n1000\n\n\n\n\n\n\n\n\n05\nJeffrey\n\n\n\n\n01\nSi Jie\n\n\n\n\n\n\n\n\n\n\nThu\n1200\n\n\n\n\n\n\nC11\nKerryn\n\n\nC04\nJiefeng\n\n\nC05\nQinhua\n\n\n\n\n\n\n12\nHeng Guang\n\n\n\n\n\n\nThu\n1400\n\n\n\n\n\n\n\n\n06\nArchana\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFri\n1200\n\n\n\n\n\n\n\n\n02\nLiang Jun\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFri\n1400\n\n\n\n\n\n\n\n\n04\nWangfan",
            "title": "Schedule"
        },
        {
            "location": "/schedule/index.html#schedule",
            "text": "This is a tentative schedule for CS1010.",
            "title": "Schedule"
        },
        {
            "location": "/schedule/index.html#lecture-schedule-tentative",
            "text": "Week  Starting..  Topics  Tutorial  Assignment      1  2018-08-13  Units 1-2: Computational Problem Solving      2  2018-08-20  Units 3-4: Functions & Types      3  2018-08-27  Units 5-7: Basic C programs  PS 1; Unix     4  2018-09-03  Units 8-9: Conditionals  PS 3-5; Vim; ex01  as01 Released    5  2018-09-10  Units 10-12 Loops  PS 8-9  as02 Released    6  2018-09-17  Units 13-16 Memory, Array, Strings  PS 10-12  as03 Released    -  2018-09-24  Break      7  2018-10-01  Midterm & Practical Exam 1   as04 Released    8  2018-10-08  Macro, Call-by-Referece, nD-Array   as05 Released    9  2018-10-15  Searching, Sorting   as06 Released    10  2018-10-22  Struct, I/O   as07 Released    11  2018-10-29    as08 Released    12  2018-11-05   Practical Exam 2  as09 Released    13  2018-11-12",
            "title": "Lecture Schedule (Tentative)"
        },
        {
            "location": "/schedule/index.html#tutorial-time-venue",
            "text": "(scroll horizontally to see the full table)     Day/Time  COM1 B108  COM1 B109  COM1 B111  COM1 B112  COM1 0120  I3 0336  I3 0338  AS6 0421      Mon 1000  C10 Joanne     C09 Evan       Mon 1400     C1A Xiao Liang        Tue 1200        03 Addison     Tue 1400       C03 Kyle  C02 Thanh     Wed 1000  C07 Jun Hui   C08 Shui Herng     C06 Shu Peng  11 Rengan    Wed 1200       10 David  07 Aaron     Wed 1400        08 Tian Yang     Thu 1000     05 Jeffrey   01 Si Jie      Thu 1200    C11 Kerryn  C04 Jiefeng  C05 Qinhua    12 Heng Guang    Thu 1400     06 Archana        Fri 1200     02 Liang Jun        Fri 1400     04 Wangfan",
            "title": "Tutorial Time / Venue"
        },
        {
            "location": "/accounts/index.html",
            "text": "CS1010 Accounts\n\n\nWe will be using a variety of services for CS1010.  To take CS1010, please make sure you have the following accounts:\n\n\nSoC UNIX Account\n\n\nYou can get one here: \nhttps://mysoc.nus.edu.sg/~newacct/\n\n\nThis account allows you to access SoC UNIX resources, including the main computing host running Solaris, \nsunfire\n, and computer clusters running Ubuntu / CentOS.  We will be using the compute clusters for CS1010 (details coming soon).\n\n\nGitHub Account\n\n\nCS1010 uses GitHub Classroom for programming assignment submissions and grading.  You should \nregister for a GitHub account\n if you do not have one. \n\n\nPiazza Account\n\n\nCS1010 uses Piazza for Q&A and discussion.  You should receive an email to register for Piazza.",
            "title": "Accounts"
        },
        {
            "location": "/accounts/index.html#cs1010-accounts",
            "text": "We will be using a variety of services for CS1010.  To take CS1010, please make sure you have the following accounts:",
            "title": "CS1010 Accounts"
        },
        {
            "location": "/accounts/index.html#soc-unix-account",
            "text": "You can get one here:  https://mysoc.nus.edu.sg/~newacct/  This account allows you to access SoC UNIX resources, including the main computing host running Solaris,  sunfire , and computer clusters running Ubuntu / CentOS.  We will be using the compute clusters for CS1010 (details coming soon).",
            "title": "SoC UNIX Account"
        },
        {
            "location": "/accounts/index.html#github-account",
            "text": "CS1010 uses GitHub Classroom for programming assignment submissions and grading.  You should  register for a GitHub account  if you do not have one.",
            "title": "GitHub Account"
        },
        {
            "location": "/accounts/index.html#piazza-account",
            "text": "CS1010 uses Piazza for Q&A and discussion.  You should receive an email to register for Piazza.",
            "title": "Piazza Account"
        },
        {
            "location": "/policies/index.html",
            "text": "Policies\n\n\nEmail Communication\n\n\n\n\n\n\nPlease use only your official NUS email for communication with the teaching staffs -- either the one with \n@u.nus.edu\n or \n@comp.nus.edu.sg\n.  \n\n\n\n\n\n\nPlease use email only for private matters.  Prefix your email subject with \n[CS1010]\n.\n\n\n\n\n\n\nPlease use \nPiazza\n for other matters related to the module.  If you email us privately and we feel that your questions/answers are useful to the rest of the class, we will publish it on Piazza, with anonymization when appropriate.\n\n\n\n\n\n\nLab Sessions\n\n\n\n\n\n\nAttendance is not compulsory at NUS, but we do take attendance during the tutorial sessions.\n\n\n\n\n\n\nYou should stick to your allocated time slot for tutorials.  If there is a strong reason for your to attend another tutorial session, please inform your undergraduate discussion leaders (UDLs).\n\n\n\n\n\n\nLate Submissions\n\n\n\n\n\n\nAll programming assignments must be submitted on time.  If you need an extension, please ask for one and provide a justification for approval.  Only academic reasons and compassionate reasons can be considered (e.g., representing NUS for a sports event is OK; Attending a wedding is not).\n\n\n\n\n\n\nFor late submission, there is a 1% penalty (of the total assessment grade) for every 5-minutes after the deadline, capped at 80%.  For example, if an assessment which was given 40 marks was submitted 100 minutes after the deadline, the student will get 32 marks instead (20% penalty).  If it is submitted 10 hours after the deadline, the student will get 8 marks (as the cap of 80% penalty has been reached).\n\n\n\n\n\n\nDiscussions and Plagiarism\n\n\n\n\n\n\nWe encourage discussions among students for programming assignments, but each student should be responsible for writing his/her own code and should give credits to others when appropriate.  \n\n\n\n\n\n\nNUS and School of Computing have a high standard on academic honesty and take any violation seriously.  In the context of computing modules, source code plagiarism -- copying code from another source and attributing it as one's own code -- is a serious violation.   Please read the page \nPreventing Plagiarism\n from the school's website to familiarize yourself with the policy.\n\n\n\n\n\n\nI adopt a \"no mercy\" policy when it comes to disciplinary action on plagiarism.  Both parties, the student who copied, and the student who allowed others to copy, will be penalized equally.\n\n\n\n\n\n\nScreencast\n\n\n\n\n\n\nScreencast will be recorded and posted online 3-4 days after the lecture.\nThis will be done on a 'best effort' basis and screencast will not be guaranteed to be available on time or at all.  \n\n\n\n\n\n\nPosting of screencast is meant to help students who attended the lecture to recap the content, or to help those who are not able to attend the lecture due to unexpected circumstances.  It does not mean that you should skip lecture.  \nResearch\n has shown that the effect of over-reliance on screencast is negative.\n\n\n\n\n\n\nModel Solutions and Slides\n\n\n\n\n\n\nSlides will be posted \nafter\n the class.  Note that slides are used as a \nvisual aid\n to assist me during lecture. It is not meant as summary of lectures nor a replacement of lecture notes.\n\n\n\n\n\n\nIn a module like CS1010, there is often not a single correct answer.  Hence, there is no model solution for this module.  Sample solutions may be posted (both good and bad ones) for discussion.  I strongly encourage students to discuss your solution with the teaching team, instead of just comparing your solution with the sample solution.\n\n\n\n\n\n\nGrading\n\n\n\n\nStudents will received the grades they deserve irrespective of how the other students in the class perform (i.e., no bell curve).\n\n\n\n\nOpen Book Assessment\n\n\n\n\n\n\nAll assessment, including practical exams, midterm test, and final assessment, are open book assessment -- you can bring in your notes or other \nanalog\n reference materials.\n\n\n\n\n\n\nThere is \nnothing to memorize\n for this class.",
            "title": "Policies"
        },
        {
            "location": "/policies/index.html#policies",
            "text": "",
            "title": "Policies"
        },
        {
            "location": "/policies/index.html#email-communication",
            "text": "Please use only your official NUS email for communication with the teaching staffs -- either the one with  @u.nus.edu  or  @comp.nus.edu.sg .      Please use email only for private matters.  Prefix your email subject with  [CS1010] .    Please use  Piazza  for other matters related to the module.  If you email us privately and we feel that your questions/answers are useful to the rest of the class, we will publish it on Piazza, with anonymization when appropriate.",
            "title": "Email Communication"
        },
        {
            "location": "/policies/index.html#lab-sessions",
            "text": "Attendance is not compulsory at NUS, but we do take attendance during the tutorial sessions.    You should stick to your allocated time slot for tutorials.  If there is a strong reason for your to attend another tutorial session, please inform your undergraduate discussion leaders (UDLs).",
            "title": "Lab Sessions"
        },
        {
            "location": "/policies/index.html#late-submissions",
            "text": "All programming assignments must be submitted on time.  If you need an extension, please ask for one and provide a justification for approval.  Only academic reasons and compassionate reasons can be considered (e.g., representing NUS for a sports event is OK; Attending a wedding is not).    For late submission, there is a 1% penalty (of the total assessment grade) for every 5-minutes after the deadline, capped at 80%.  For example, if an assessment which was given 40 marks was submitted 100 minutes after the deadline, the student will get 32 marks instead (20% penalty).  If it is submitted 10 hours after the deadline, the student will get 8 marks (as the cap of 80% penalty has been reached).",
            "title": "Late Submissions"
        },
        {
            "location": "/policies/index.html#discussions-and-plagiarism",
            "text": "We encourage discussions among students for programming assignments, but each student should be responsible for writing his/her own code and should give credits to others when appropriate.      NUS and School of Computing have a high standard on academic honesty and take any violation seriously.  In the context of computing modules, source code plagiarism -- copying code from another source and attributing it as one's own code -- is a serious violation.   Please read the page  Preventing Plagiarism  from the school's website to familiarize yourself with the policy.    I adopt a \"no mercy\" policy when it comes to disciplinary action on plagiarism.  Both parties, the student who copied, and the student who allowed others to copy, will be penalized equally.",
            "title": "Discussions and Plagiarism"
        },
        {
            "location": "/policies/index.html#screencast",
            "text": "Screencast will be recorded and posted online 3-4 days after the lecture.\nThis will be done on a 'best effort' basis and screencast will not be guaranteed to be available on time or at all.      Posting of screencast is meant to help students who attended the lecture to recap the content, or to help those who are not able to attend the lecture due to unexpected circumstances.  It does not mean that you should skip lecture.   Research  has shown that the effect of over-reliance on screencast is negative.",
            "title": "Screencast"
        },
        {
            "location": "/policies/index.html#model-solutions-and-slides",
            "text": "Slides will be posted  after  the class.  Note that slides are used as a  visual aid  to assist me during lecture. It is not meant as summary of lectures nor a replacement of lecture notes.    In a module like CS1010, there is often not a single correct answer.  Hence, there is no model solution for this module.  Sample solutions may be posted (both good and bad ones) for discussion.  I strongly encourage students to discuss your solution with the teaching team, instead of just comparing your solution with the sample solution.",
            "title": "Model Solutions and Slides"
        },
        {
            "location": "/policies/index.html#grading",
            "text": "Students will received the grades they deserve irrespective of how the other students in the class perform (i.e., no bell curve).",
            "title": "Grading"
        },
        {
            "location": "/policies/index.html#open-book-assessment",
            "text": "All assessment, including practical exams, midterm test, and final assessment, are open book assessment -- you can bring in your notes or other  analog  reference materials.    There is  nothing to memorize  for this class.",
            "title": "Open Book Assessment"
        },
        {
            "location": "/01-program/index.html",
            "text": "Unit 1: What is a Program?\n\n\nLearning Outcomes\n\n\nAfter this unit, students should:\n\n\n\n\nhave an idea of what is a program and how a program is executed by a computer\n\n\nunderstand the basic terminologies: machine code, assembly language, and higher-level programming languages\n\n\n\n\nWhat is a (computer) program?\n\n\nDespite all the wonderful and amazing things that computers can do, computers are not very smart. In fact, they are pretty dumb. Computers can only follow the instructions given by a human. A computer program is a sequence of step-by-step instructions given to computers to manipulate data in order to perform a certain task.\n\n\nProgramming is the art and science of writing a computer program, and that is what you will learn to do in CS1010.\n\n\nHow computer executes a program\n\n\nIn order to learn how to write a program, it is important to have an overview of how a computer executes a program.  You will learn in details how this is done in CS2100/CS2106 or EE2024/CG2271, but for CS1010, we will take a very simplistic and high-level view of this process.\n\n\nThe two important components of a computer we will discuss for CS1010 is the CPU, or \ncentral processing unit\n and the memory, which is a generalized term for where we store the data to be processed or manipulated by the CPU, as well as the instructions to do so.  A memory location is addressable using a \nmemory address\n.  \n\n\nThe instructions to the CPU comes in the form of \nmachine code\n, a sequence of bits (1s and 0s) that is interpreted and then followed by the CPU to do certain things.  These machine code could instruct the CPU, for instance, to compare if a particular number at a certain memory location is more than 0, to add one number to another, or to execute another instruction at another memory location.  The data stored in the memory is also stored as a sequence of 1s and 0s.\n\n\nFrom Machine Code to High-level Programming Language\n\n\nWhile it is possible for us, human, to write machine code directly, few actually do since it is challenging to do so. Different CPUs understand different sets of machine code; it is tedious to figure out where each piece of data is located in the memory (this is actually determined by the operating system).  The resulting code, even when it is correct and easy to read and understand by the machine, are often hard to decipher for a human.\nSimple operations such as comparing which number is bigger might require several instructions to perform.\n\n\nTo get around the readability problem, programmers can code in \nassembly language\n -- a human-readable form of machine code, where each instruction, instead of represented by 0s and 1s, is represented by a mnemonic (such as \ndecr\n, \nincr\n, \nstore\n, \nadd\n, etc.)\n\n\nWriting assembly code does not address the issues of machine-dependent code and the tediousness of programming.  Early programmers (in the fifties) understood this and designed \nhigh-level programming languages\n, where programmers can describe the operations that they wish to do in a language closer to their intention that is machine independent.  A program written in one of these programming languages is then \ncompiled\n into machine code for a specific CPU for execution using a compiler.\n\n\n\n\nThe first commercially available language is FORTRAN from IBM in the 1950s.  Among many early programming languages, C (birth year 1972) is the only one that is still popular and widely used today,  \nFor many reasons\n, C is the language of choice for CS1010.  \n\n\nThe Goals of CS1010\n\n\nThis brings us to the goals of CS1010.  First, you will learn the most important syntax element of the C programming language.  Second, you will learn how a C program behaves, in relation to how a program is executed and how data are stored and manipulated in memory.  Third, you will learn the various tools and techniques that will help you produce good and correct C programs.\n\n\nThe last, and the most important and challenging goal of CS1010, however, is that you will learn how to write programs to solve computational problems.  Learning to write a program that does what you want it to do is actually not difficult.  \nKnowing what you want your program to do is the more challenging part!",
            "title": "1. What is a Program?"
        },
        {
            "location": "/01-program/index.html#unit-1-what-is-a-program",
            "text": "",
            "title": "Unit 1: What is a Program?"
        },
        {
            "location": "/01-program/index.html#learning-outcomes",
            "text": "After this unit, students should:   have an idea of what is a program and how a program is executed by a computer  understand the basic terminologies: machine code, assembly language, and higher-level programming languages",
            "title": "Learning Outcomes"
        },
        {
            "location": "/01-program/index.html#what-is-a-computer-program",
            "text": "Despite all the wonderful and amazing things that computers can do, computers are not very smart. In fact, they are pretty dumb. Computers can only follow the instructions given by a human. A computer program is a sequence of step-by-step instructions given to computers to manipulate data in order to perform a certain task.  Programming is the art and science of writing a computer program, and that is what you will learn to do in CS1010.",
            "title": "What is a (computer) program?"
        },
        {
            "location": "/01-program/index.html#how-computer-executes-a-program",
            "text": "In order to learn how to write a program, it is important to have an overview of how a computer executes a program.  You will learn in details how this is done in CS2100/CS2106 or EE2024/CG2271, but for CS1010, we will take a very simplistic and high-level view of this process.  The two important components of a computer we will discuss for CS1010 is the CPU, or  central processing unit  and the memory, which is a generalized term for where we store the data to be processed or manipulated by the CPU, as well as the instructions to do so.  A memory location is addressable using a  memory address .    The instructions to the CPU comes in the form of  machine code , a sequence of bits (1s and 0s) that is interpreted and then followed by the CPU to do certain things.  These machine code could instruct the CPU, for instance, to compare if a particular number at a certain memory location is more than 0, to add one number to another, or to execute another instruction at another memory location.  The data stored in the memory is also stored as a sequence of 1s and 0s.",
            "title": "How computer executes a program"
        },
        {
            "location": "/01-program/index.html#from-machine-code-to-high-level-programming-language",
            "text": "While it is possible for us, human, to write machine code directly, few actually do since it is challenging to do so. Different CPUs understand different sets of machine code; it is tedious to figure out where each piece of data is located in the memory (this is actually determined by the operating system).  The resulting code, even when it is correct and easy to read and understand by the machine, are often hard to decipher for a human.\nSimple operations such as comparing which number is bigger might require several instructions to perform.  To get around the readability problem, programmers can code in  assembly language  -- a human-readable form of machine code, where each instruction, instead of represented by 0s and 1s, is represented by a mnemonic (such as  decr ,  incr ,  store ,  add , etc.)  Writing assembly code does not address the issues of machine-dependent code and the tediousness of programming.  Early programmers (in the fifties) understood this and designed  high-level programming languages , where programmers can describe the operations that they wish to do in a language closer to their intention that is machine independent.  A program written in one of these programming languages is then  compiled  into machine code for a specific CPU for execution using a compiler.   The first commercially available language is FORTRAN from IBM in the 1950s.  Among many early programming languages, C (birth year 1972) is the only one that is still popular and widely used today,   For many reasons , C is the language of choice for CS1010.",
            "title": "From Machine Code to High-level Programming Language"
        },
        {
            "location": "/01-program/index.html#the-goals-of-cs1010",
            "text": "This brings us to the goals of CS1010.  First, you will learn the most important syntax element of the C programming language.  Second, you will learn how a C program behaves, in relation to how a program is executed and how data are stored and manipulated in memory.  Third, you will learn the various tools and techniques that will help you produce good and correct C programs.  The last, and the most important and challenging goal of CS1010, however, is that you will learn how to write programs to solve computational problems.  Learning to write a program that does what you want it to do is actually not difficult.   Knowing what you want your program to do is the more challenging part!",
            "title": "The Goals of CS1010"
        },
        {
            "location": "/02-algo/index.html",
            "text": "Unit 2: Computational Problems and Algorithms\n\n\nLearning Outcomes:\n\n\nAfter this unit, students should:\n\n\n\n\nunderstand the basic terminologies: computational problem solving, algorithm, flowchart, debugging, testing, variables, value, assignment\n\n\nbe familiar with the algorithm to find the maximum among a list of numbers\n\n\nbe able to trace through flowcharts and updates of variables, and argue if a given algorithm is correct or incorrect\n\n\n\n\nComputational Problems\n\n\nSo, what is computational problem solving?  Let's start with the question, what is a \ncomputational problem\n?  \n\n\nA computational problem is a problem that can be solved step-by-step with a computer.  These problems usually have a well-defined input, constraints, and conditions that the output must satisfied.  Here are some types of computational problems:\n\n\n\n\n\n\nA \ndecision problem\n is one where the answer is yes or no.  For instance, \"given a number \nn\n, is \nn\n even?\" is a decision problem.  Some decision problems take more steps to solve than others.  For instance, \"given a number \nn\n, is \nn\n prime?\" takes more steps than just checking the parity of a number.\n\n\n\n\n\n\nA \nsearch problem\n is one where the solution consists of one or more values that satisfies a given condition.  For instance, we may want to compute a path from one geographical location to another on a map.\n\n\n\n\n\n\nA \ncounting problem\n is one where the answer is the number of solutions to a search problem.\n\n\n\n\n\n\nAn \noptimization problem\n is one where the solution is the \"best\" possible solution, where the \"best\" can be defined in a different way.  For instance, we may want to compute the fastest route from one location to another.\n\n\n\n\n\n\nQuestions such as \"what is the meaning of life?\" \"do I look good in this outfit?\"\n1\n are not computational problems, because they do not have well-defined input, constraints, and conditions that the output must satisfy.\n\n\nIn CS1010 (followed by CS2040C and CS3230), you will learn how to solve computational problems \ncomputationally\n -- this means that you learn to come up with step-by-step instructions meant for computers that you can translate into computer programs, to solve a given problem. \n\n\nExample: Finding the maximum\n\n\nLet's start with a simple problem.  Given a finite list \nL\nL\n of \nk\nk\n integers (\nk\nk\n > 0), find the integer with the maximum value from the list.\n\n\nFirst, let's consider if this is a computational problem.  The input is very well defined.  We know what an integer is.  We are told we have at least one, and we have a finite number of them\n2\n.\n\n\nSecond, let's consider the output.  What conditions must the output satisfy?  First, it has to be equal or larger than every other integer on the list.  Second, it must be an integer \nin\n the list.  This is well defined by the problem statement, so we can say that it is a computational problem.\n\n\nHere is an example.  Suppose the input consists of:\n\n\n4 1 -4 0 9 9 3 5 8\n\n\nThe output should be \n9\n.\n\n\nNow, you should pause reading and think about how you would solve this step-by-step.  \n\n\nAlgorithm\n\n\nOne way to solve this problem is to check through the integers in the list, one-by-one, and keep track of the maximum value so far.  When you reach the end of the list, your \"maximum value so far\" will also be the maximum for the whole list.  \n\n\nLet's look at an example:\n\n\n\n\n\n\n\n\nIntegers Scanned\n\n\nMaximum So Far\n\n\n\n\n\n\n\n\n\n\n4\n\n\n4\n\n\n\n\n\n\n4 1\n\n\n4\n\n\n\n\n\n\n4 1 -4\n\n\n4\n\n\n\n\n\n\n4 1 -4 0\n\n\n4\n\n\n\n\n\n\n4 1 -4 0 9\n\n\n9\n\n\n\n\n\n\n4 1 -4 0 9 9\n\n\n9\n\n\n\n\n\n\n4 1 -4 0 9 9 3\n\n\n9\n\n\n\n\n\n\n4 1 -4 0 9 9 3 5\n\n\n9\n\n\n\n\n\n\n4 1 -4 0 9 9 3 5 8\n\n\n9\n\n\n\n\n\n\n\n\nThe English description above, however, is not detailed enough for computers to understand.  What is the meaning of \"check one-by-one\"? \"keep track of maximum so far\"?  how to tell if we have reached \"the end of the list\"?\n\n\nLet's work out all the details.\n\n\nFirst, we need a concise way of representing the integers in the list.  Borrowing from mathematical notation, let's say that the list \nL\nL\n contains the integers \n\nl_0, l_1, ..., l_{k-1}\nl_0, l_1, ..., l_{k-1}\n. To \"check one-by-one,\" we introduce another notation \nl_i\nl_i\n, which is the integer currently being \"checked\".  We begin with \ni = 0\ni = 0\n, then \ni = 1\ni = 1\n, then \ni = 2\ni = 2\n, etc, until \ni = k-1\ni = k-1\n.  At every step, we increase \ni\ni\n by 1.\n\n\nSecond, we need a concise way of keeping track of the maximum so far.  We introduce another notation, \nm\nm\n, to represent the maximum value so far.  When \ni = 0\ni = 0\n, \nm = l_0\nm = l_0\n.  Since we only scan a single integer, it has to be the maximum.  When we check another integer \nl_i (i > 0)\nl_i (i > 0)\n, only two things can happen:\n\n\n\n\nif this \nl_i\nl_i\n is larger than \nm\nm\n, then \nl_i\nl_i\n has to be the maximum so far, so we update \nm\nm\n to be \nl_i\nl_i\n.\n\n\nif \nl_i\nl_i\n is equal to or smaller than \nm\nm\n, then \nm\nm\n is still the maximum value so far.\n\n\n\n\nWe keep doing the above and increase \ni\ni\n, until we reach the end of the list when (after increasing \ni\ni\n) we find that \ni\ni\n is \nk\nk\n.\n\n\nNow, we have enough details to describe step-by-step, how to find the maximum value from a list of integers.  Such steps, which the computer can take to solve a problem, is called an \nalgorithm\n.  \n\n\nFlowchart\n\n\nThere are different ways one can describe an algorithm.  The easiest way I find is to use a diagram called a \nflowchart\n.  The flowchart for the algorithm above looks like this.  A diamond box represents a \"question\" that can be true or false (yes or no), and we trace through the \"flow\" step by step, following the corresponding path depending on the answer. \n\n\n\n\nPlease spend some time to trace through the walkthrough above.  The snapshot of the values of the \ni\ni\n, \nl_i\nl_i\n, \nk\nk\n, and \nm\nm\n, at the point after \"is \ni\ni\n equals \nk\nk\n\" is shown in the table below \n(except for the first row, which shows the value just before entering \"is \ni\ni\n equals \nk\nk\n\")\n.\n\n\n\n\n\n\n\n\nIntegers Scanned\n\n\ni\ni\n\n\nl_i\nl_i\n\n\nk\nk\n\n\nMaximum So Far (\nm\nm\n)\n\n\n\n\n\n\n\n\n\n\n4\n\n\n1\n\n\n4\n \n1\n\n\n9\n\n\n4\n\n\n\n\n\n\n4 1\n\n\n1\n\n\n1\n\n\n9\n\n\n4\n\n\n\n\n\n\n4 1 -4\n\n\n2\n\n\n-4\n\n\n9\n\n\n4\n\n\n\n\n\n\n4 1 -4 0\n\n\n3\n\n\n0\n\n\n9\n\n\n4\n\n\n\n\n\n\n4 1 -4 0 9\n\n\n4\n\n\n9\n\n\n9\n\n\n4\n\n\n\n\n\n\n4 1 -4 0 9 9\n\n\n5\n\n\n9\n\n\n9\n\n\n9\n\n\n\n\n\n\n4 1 -4 0 9 9 3\n\n\n6\n\n\n3\n\n\n9\n\n\n9\n\n\n\n\n\n\n4 1 -4 0 9 9 3 5\n\n\n7\n\n\n5\n\n\n9\n\n\n9\n\n\n\n\n\n\n4 1 -4 0 9 9 3 5 8\n\n\n8\n\n\n8\n\n\n9\n\n\n9\n\n\n\n\n\n\n4 1 -4 0 9 9 3 5 8\n\n\n9\n\n\n``\n\n\n9\n\n\n9\n\n\n\n\n\n\n\n\nVariables\n\n\nThere are a few important things to take note here.  \nm\nm\n, \ni\ni\n, \nk\nk\n, and the list \nL\nL\n are what we called \nstates\n or \nvariables\n.  While in the above, we can think of them as mathematical variables which we can assign \nvalues\n to, in a computer program, a variable is a location in the memory which holds a value.  \n\n\nWe can perform two very basic operations on the variables: reading and writing.  In other words, we can set their values and we can retrieve their values. \n\n\nWe can \nassign\n the value of one variable to a constant (e.g., set \ni\ni\n to 1) or to the value of another variable (e.g., set \nm\nm\n to \nl_i\nl_i\n).  In the latter example, we first read the value of \nl_i\nl_i\n, from \nl_i\nl_i\n's memory location and then we write that value to the memory location of \nm\nm\n.  Once written, the value of \nm\nm\n will not change until the next time we update the value of \nm\nm\n.\n\n\nIt is important to note that, when \ni\ni\n changes, \nm\nm\n \ndoes not change automatically\n to the new \nl_i\nl_i\n  This behavior is different from that which you may be familiar with in spreadsheet software -- if you set the value of a cell, say \nA1\n to be \n=B1\n, when the value in cell \nB1\n changes, the value \nA1\n also changes automatically.\n\n\nWe can also compare the values of two variables.  We see two examples above: \"\ni\ni\n equals \nk\nk\n?\"  \"\nl_i > m\nl_i > m\n?\"  When we compare, we read the values of the variables from their memory location and checks their relations.\n\n\nWe can perform arithmetic operations on the variables: addition, subtraction, etc.  We see one example above: \"increment \ni\ni\n\".  This operation is actually an assignment operation in disguise.  We can write it as \"set \ni\ni\n to \ni\ni\n + 1\".  Here, you see that \ni\ni\n is referred to twice.  This operation reads the value from the memory location of \ni\ni\n, adds 1 to it, and then writes the resulting value back to the location of \ni\ni\n.\n\n\nBugs\n\n\nIf you follow the execution of the algorithm above, step-by-step, using the example input \n4 1 -4 0 9 9 3 5\n above, you will obtain the correct maximum value \nm\nm\n of \n9\n.  But does that mean that the algorithm is correct?  The answer is NO.  \n\n\nFor an algorithm to correctly solve the given problem, it has to produce the correct result for all valid inputs to the problem.  If we can find one counterexample, one input where the algorithm does not produce the correct output, then the algorithm is incorrect.  Note that I say \ndoes not produce the correct output\n, which means that either the algorithm  \nproduces the wrong output\n or \ndoes not produce any output at all\n.  \n\n\nIn this case, we say that the algorithm or the program has a \nbug\n.  A bug is a defect that causes the algorithm to behave incorrectly.  As a software developer, you will spend some time finding bugs in your code, a process known as \ndebugging\n.  A \ndebugger\n is a tool that helps programmers find bugs in their code.\n\n\nBefore we even start the process of debugging, we first have to know if our algorithm is correct.  Remember that an algorithm is correct only if it produces the correct output only all possible valid inputs.  So, one way to check if an algorithm is correct is to try it with all possible valid inputs.  For the problem we are solving above, however, even though the list is finite, there are infinitely many possible inputs, and so, it is impossible to try all possible valid inputs.  In practice, we \ncraft\n a smaller set of test inputs to check if the algorithm behaves correctly for these test inputs, and \nhope\n that it is correct for all possible inputs.  With experience, you will choose the right set of test inputs to maximize that chances that you will find a bug in your code.  There are also systematic ways of deriving test cases so that the test cases \ncover\n different paths of execution of the algorithm, but we won't be covering it in CS1010\n3\n.\n\n\nAnother way of checking if an algorithm is correct, is to reason about the behavior of the algorithm.  We will do this rather informally in CS1010, starting in 1-2 lectures from now.  You get to rigorously prove that an algorithm is correct in a higher level module (CS3230 Design and Analysis of Algorithms).\n\n\nFinally, even if an algorithm is correct, the corresponding program might not be.  Recall that an algorithm is a step-by-step process to solve a problem.  It is what you want your program to do.  You still have to write a program (in C, or other languages) to actually have the computer do what you want it to do (in other words, to \nimplement the algorithm\n). This process of translating the algorithm to a computer program, called \ncoding\n may introduce bugs as well.  But we will worry about this later when we learn to program.\n\n\nIn the problem set at the end of this lecture, you will see slight variations of the algorithm above.  You should check through them to see whether they are correct or not.\n\n\nProblem Set\n\n\nProblem 1.1\n\n\nThe following algorithms are slight variations of the one in the notes above.  The differences are highlighted in red.  Do they correctly find the maximum integer from a finite list of \nk\nk\n integers (\nk > 0\nk > 0\n)?  \n\n\nIf an algorithm is buggy, give a counter-example where the output is incorrect.  In addition, give an example input where the algorithm still produces the correct output, where possible.  \n\n\n(a). \n\n\n\n(b). \n\n\n\n\u00a9. \n\n\n\n(d). \n\n\n\n(e). \n\n\n\nProblem 1.2\n\n\nChange the algorithm above to find the minimum value instead of the maximum value from the given list \nL = \\{l_0, ..., l_{k-1}\\}\nL = \\{l_0, ..., l_{k-1}\\}\n. \nYou can also assume that the list \nL\nL\n is finite and \nk > 0\nk > 0\n for this question\n.\n\n\nProblem 1.3\n\n\nDraw the flowchart for an algorithm, that takes in a list of integers \nL = \\{l_0, ..., l_{k-1}\\}, k \\ge 0\nL = \\{l_0, ..., l_{k-1}\\}, k \\ge 0\n, and compute the \nsum\n of all the integers.  Think about what variable(s) do you need.\n\n\n\n\n\n\n\n\n\n\nThe answer is, by the way, always \"Yes.\"\u00a0\n\u21a9\n\n\n\n\n\n\nThink about why it is important to have a finite number of integers in the input.\u00a0\n\u21a9\n\n\n\n\n\n\nSoftware testing is a body of knowledge worthy of an advanced module by itself -- we offer one in CS4218.\u00a0\n\u21a9",
            "title": "2. Computational Problem &amp; Algorithms"
        },
        {
            "location": "/02-algo/index.html#unit-2-computational-problems-and-algorithms",
            "text": "",
            "title": "Unit 2: Computational Problems and Algorithms"
        },
        {
            "location": "/02-algo/index.html#learning-outcomes",
            "text": "After this unit, students should:   understand the basic terminologies: computational problem solving, algorithm, flowchart, debugging, testing, variables, value, assignment  be familiar with the algorithm to find the maximum among a list of numbers  be able to trace through flowcharts and updates of variables, and argue if a given algorithm is correct or incorrect",
            "title": "Learning Outcomes:"
        },
        {
            "location": "/02-algo/index.html#computational-problems",
            "text": "So, what is computational problem solving?  Let's start with the question, what is a  computational problem ?    A computational problem is a problem that can be solved step-by-step with a computer.  These problems usually have a well-defined input, constraints, and conditions that the output must satisfied.  Here are some types of computational problems:    A  decision problem  is one where the answer is yes or no.  For instance, \"given a number  n , is  n  even?\" is a decision problem.  Some decision problems take more steps to solve than others.  For instance, \"given a number  n , is  n  prime?\" takes more steps than just checking the parity of a number.    A  search problem  is one where the solution consists of one or more values that satisfies a given condition.  For instance, we may want to compute a path from one geographical location to another on a map.    A  counting problem  is one where the answer is the number of solutions to a search problem.    An  optimization problem  is one where the solution is the \"best\" possible solution, where the \"best\" can be defined in a different way.  For instance, we may want to compute the fastest route from one location to another.    Questions such as \"what is the meaning of life?\" \"do I look good in this outfit?\" 1  are not computational problems, because they do not have well-defined input, constraints, and conditions that the output must satisfy.  In CS1010 (followed by CS2040C and CS3230), you will learn how to solve computational problems  computationally  -- this means that you learn to come up with step-by-step instructions meant for computers that you can translate into computer programs, to solve a given problem.",
            "title": "Computational Problems"
        },
        {
            "location": "/02-algo/index.html#example-finding-the-maximum",
            "text": "Let's start with a simple problem.  Given a finite list  L L  of  k k  integers ( k k  > 0), find the integer with the maximum value from the list.  First, let's consider if this is a computational problem.  The input is very well defined.  We know what an integer is.  We are told we have at least one, and we have a finite number of them 2 .  Second, let's consider the output.  What conditions must the output satisfy?  First, it has to be equal or larger than every other integer on the list.  Second, it must be an integer  in  the list.  This is well defined by the problem statement, so we can say that it is a computational problem.  Here is an example.  Suppose the input consists of:  4 1 -4 0 9 9 3 5 8  The output should be  9 .  Now, you should pause reading and think about how you would solve this step-by-step.",
            "title": "Example: Finding the maximum"
        },
        {
            "location": "/02-algo/index.html#algorithm",
            "text": "One way to solve this problem is to check through the integers in the list, one-by-one, and keep track of the maximum value so far.  When you reach the end of the list, your \"maximum value so far\" will also be the maximum for the whole list.    Let's look at an example:     Integers Scanned  Maximum So Far      4  4    4 1  4    4 1 -4  4    4 1 -4 0  4    4 1 -4 0 9  9    4 1 -4 0 9 9  9    4 1 -4 0 9 9 3  9    4 1 -4 0 9 9 3 5  9    4 1 -4 0 9 9 3 5 8  9     The English description above, however, is not detailed enough for computers to understand.  What is the meaning of \"check one-by-one\"? \"keep track of maximum so far\"?  how to tell if we have reached \"the end of the list\"?  Let's work out all the details.  First, we need a concise way of representing the integers in the list.  Borrowing from mathematical notation, let's say that the list  L L  contains the integers  l_0, l_1, ..., l_{k-1} l_0, l_1, ..., l_{k-1} . To \"check one-by-one,\" we introduce another notation  l_i l_i , which is the integer currently being \"checked\".  We begin with  i = 0 i = 0 , then  i = 1 i = 1 , then  i = 2 i = 2 , etc, until  i = k-1 i = k-1 .  At every step, we increase  i i  by 1.  Second, we need a concise way of keeping track of the maximum so far.  We introduce another notation,  m m , to represent the maximum value so far.  When  i = 0 i = 0 ,  m = l_0 m = l_0 .  Since we only scan a single integer, it has to be the maximum.  When we check another integer  l_i (i > 0) l_i (i > 0) , only two things can happen:   if this  l_i l_i  is larger than  m m , then  l_i l_i  has to be the maximum so far, so we update  m m  to be  l_i l_i .  if  l_i l_i  is equal to or smaller than  m m , then  m m  is still the maximum value so far.   We keep doing the above and increase  i i , until we reach the end of the list when (after increasing  i i ) we find that  i i  is  k k .  Now, we have enough details to describe step-by-step, how to find the maximum value from a list of integers.  Such steps, which the computer can take to solve a problem, is called an  algorithm .",
            "title": "Algorithm"
        },
        {
            "location": "/02-algo/index.html#flowchart",
            "text": "There are different ways one can describe an algorithm.  The easiest way I find is to use a diagram called a  flowchart .  The flowchart for the algorithm above looks like this.  A diamond box represents a \"question\" that can be true or false (yes or no), and we trace through the \"flow\" step by step, following the corresponding path depending on the answer.    Please spend some time to trace through the walkthrough above.  The snapshot of the values of the  i i ,  l_i l_i ,  k k , and  m m , at the point after \"is  i i  equals  k k \" is shown in the table below  (except for the first row, which shows the value just before entering \"is  i i  equals  k k \") .     Integers Scanned  i i  l_i l_i  k k  Maximum So Far ( m m )      4  1  4   1  9  4    4 1  1  1  9  4    4 1 -4  2  -4  9  4    4 1 -4 0  3  0  9  4    4 1 -4 0 9  4  9  9  4    4 1 -4 0 9 9  5  9  9  9    4 1 -4 0 9 9 3  6  3  9  9    4 1 -4 0 9 9 3 5  7  5  9  9    4 1 -4 0 9 9 3 5 8  8  8  9  9    4 1 -4 0 9 9 3 5 8  9  ``  9  9",
            "title": "Flowchart"
        },
        {
            "location": "/02-algo/index.html#variables",
            "text": "There are a few important things to take note here.   m m ,  i i ,  k k , and the list  L L  are what we called  states  or  variables .  While in the above, we can think of them as mathematical variables which we can assign  values  to, in a computer program, a variable is a location in the memory which holds a value.    We can perform two very basic operations on the variables: reading and writing.  In other words, we can set their values and we can retrieve their values.   We can  assign  the value of one variable to a constant (e.g., set  i i  to 1) or to the value of another variable (e.g., set  m m  to  l_i l_i ).  In the latter example, we first read the value of  l_i l_i , from  l_i l_i 's memory location and then we write that value to the memory location of  m m .  Once written, the value of  m m  will not change until the next time we update the value of  m m .  It is important to note that, when  i i  changes,  m m   does not change automatically  to the new  l_i l_i   This behavior is different from that which you may be familiar with in spreadsheet software -- if you set the value of a cell, say  A1  to be  =B1 , when the value in cell  B1  changes, the value  A1  also changes automatically.  We can also compare the values of two variables.  We see two examples above: \" i i  equals  k k ?\"  \" l_i > m l_i > m ?\"  When we compare, we read the values of the variables from their memory location and checks their relations.  We can perform arithmetic operations on the variables: addition, subtraction, etc.  We see one example above: \"increment  i i \".  This operation is actually an assignment operation in disguise.  We can write it as \"set  i i  to  i i  + 1\".  Here, you see that  i i  is referred to twice.  This operation reads the value from the memory location of  i i , adds 1 to it, and then writes the resulting value back to the location of  i i .",
            "title": "Variables"
        },
        {
            "location": "/02-algo/index.html#bugs",
            "text": "If you follow the execution of the algorithm above, step-by-step, using the example input  4 1 -4 0 9 9 3 5  above, you will obtain the correct maximum value  m m  of  9 .  But does that mean that the algorithm is correct?  The answer is NO.    For an algorithm to correctly solve the given problem, it has to produce the correct result for all valid inputs to the problem.  If we can find one counterexample, one input where the algorithm does not produce the correct output, then the algorithm is incorrect.  Note that I say  does not produce the correct output , which means that either the algorithm   produces the wrong output  or  does not produce any output at all .    In this case, we say that the algorithm or the program has a  bug .  A bug is a defect that causes the algorithm to behave incorrectly.  As a software developer, you will spend some time finding bugs in your code, a process known as  debugging .  A  debugger  is a tool that helps programmers find bugs in their code.  Before we even start the process of debugging, we first have to know if our algorithm is correct.  Remember that an algorithm is correct only if it produces the correct output only all possible valid inputs.  So, one way to check if an algorithm is correct is to try it with all possible valid inputs.  For the problem we are solving above, however, even though the list is finite, there are infinitely many possible inputs, and so, it is impossible to try all possible valid inputs.  In practice, we  craft  a smaller set of test inputs to check if the algorithm behaves correctly for these test inputs, and  hope  that it is correct for all possible inputs.  With experience, you will choose the right set of test inputs to maximize that chances that you will find a bug in your code.  There are also systematic ways of deriving test cases so that the test cases  cover  different paths of execution of the algorithm, but we won't be covering it in CS1010 3 .  Another way of checking if an algorithm is correct, is to reason about the behavior of the algorithm.  We will do this rather informally in CS1010, starting in 1-2 lectures from now.  You get to rigorously prove that an algorithm is correct in a higher level module (CS3230 Design and Analysis of Algorithms).  Finally, even if an algorithm is correct, the corresponding program might not be.  Recall that an algorithm is a step-by-step process to solve a problem.  It is what you want your program to do.  You still have to write a program (in C, or other languages) to actually have the computer do what you want it to do (in other words, to  implement the algorithm ). This process of translating the algorithm to a computer program, called  coding  may introduce bugs as well.  But we will worry about this later when we learn to program.  In the problem set at the end of this lecture, you will see slight variations of the algorithm above.  You should check through them to see whether they are correct or not.",
            "title": "Bugs"
        },
        {
            "location": "/02-algo/index.html#problem-set",
            "text": "",
            "title": "Problem Set"
        },
        {
            "location": "/02-algo/index.html#problem-11",
            "text": "The following algorithms are slight variations of the one in the notes above.  The differences are highlighted in red.  Do they correctly find the maximum integer from a finite list of  k k  integers ( k > 0 k > 0 )?    If an algorithm is buggy, give a counter-example where the output is incorrect.  In addition, give an example input where the algorithm still produces the correct output, where possible.    (a).   (b).   \u00a9.   (d).   (e).",
            "title": "Problem 1.1"
        },
        {
            "location": "/02-algo/index.html#problem-12",
            "text": "Change the algorithm above to find the minimum value instead of the maximum value from the given list  L = \\{l_0, ..., l_{k-1}\\} L = \\{l_0, ..., l_{k-1}\\} .  You can also assume that the list  L L  is finite and  k > 0 k > 0  for this question .",
            "title": "Problem 1.2"
        },
        {
            "location": "/02-algo/index.html#problem-13",
            "text": "Draw the flowchart for an algorithm, that takes in a list of integers  L = \\{l_0, ..., l_{k-1}\\}, k \\ge 0 L = \\{l_0, ..., l_{k-1}\\}, k \\ge 0 , and compute the  sum  of all the integers.  Think about what variable(s) do you need.      The answer is, by the way, always \"Yes.\"\u00a0 \u21a9    Think about why it is important to have a finite number of integers in the input.\u00a0 \u21a9    Software testing is a body of knowledge worthy of an advanced module by itself -- we offer one in CS4218.\u00a0 \u21a9",
            "title": "Problem 1.3"
        },
        {
            "location": "/03-func/index.html",
            "text": "Unit 3: Functions\n\n\nLet's start with another problem.\n\n\nProblem: Finding the Range\n\n\nThe \nrange\n of a finite list of at least one integers \nL\nL\n is defined as the difference between the maximum and the minimum.  For example, the range for \n4 1 -4 0 9 9 3 5 8\n is \n13\n.  How do we find the range of a given list? \n\n\nTo find the range of a list, we can break the solution down into three subtasks: first find the maximum, then find the minimum, and finally, find the difference between the two.  \n\n\nFrom the previous lecture, you already know how to find the maximum and the minimum (from Problem 1.2)!  So, in expressing the algorithm to find the range, \nwe can refer to a previous solution to a sub-problem, which we assume we already know how to solve\n.  \n\n\nLet's call our solution to find the maximum value from a given list \nL\nL\n as \nmax\nmax\n.  \nmax\nmax\n takes as input (i) a list \nL\nL\n and (ii) \nk\nk\n, the number of integers in \nL\nL\n.  It produces, or \nreturns\n, the maximum value among the integers in \nL\nL\n.  Borrowing from mathematical notation, we use the notation \nmax(L, k)\nmax(L, k)\n to represent the maximum value of \nL\nL\n.  \n\n\nSuppose that \nmin(L,k)\nmin(L,k)\n returns the minimum value among the integers in \nL\nL\n, then, the algorithm to find the range of \nL\nL\n can be written in a single line: \n\n\n\n\nmax(L, k) - min(L, k)\n\n\nmax(L, k) - min(L, k)\n\n\n\n\nFunctions\n\n\nmax\nmax\n and \nmin\nmin\n are examples of a powerful and important concept with many names: \nfunction\n, \nprocedure\n, \nsubroutine\n, \nmethod\n, \nsubprogram\n.  In the context of CS1010, we will use the term \nfunction\n.  Functions allow us to solve a problem by thinking about the solution at a higher level.  For instance, in the example above, we no longer have to think about checking through the items in the list one-by-one and maintaining the maximum so far, or the minimum so far.  We just have to think about how to compute the range, assuming that we already know how to compute the maximum and the minimum value.\n\n\nSuch an assumption, that we already know how to solve a subproblem, is known as \nwishful thinking\n.  Sometimes, it is useful to solve a problem assuming that you know how to solve the subproblem first, then worry about solving the subproblem later.  \n\n\nFor instance, consider the following problem: Given a finite list of \nk\nk\n integers (\nk > 0\nk > 0\n), find the mean.  \n\n\nThe algorithm again, can be written in one line:\n\n\n\n\nsum(L, k) / k\n\n\nsum(L, k) / k\n\n\n\n\nif we assume that we have a function \nsum\nsum\n that can help us find the total of all \nk\nk\n integers.  It turns out, in this case, that you should also know how to solve the subproblem \nsum\nsum\n, since it is Problem 1.3 from last week.\n\n\nWe can then make this into a function itself, \nmean(L, k)\nmean(L, k)\n, which we can now use to solve other more complex problems.\n\n\nThinking in terms of functions also have another advantage: given a function, we only need to worry about \nwhat\n it does, but not \nhow\n it is done.   We can treat a function as a black box -- given an input, it will produce an output satisfying certain conditions.  Many programming languages, including C which we will be using in CS1010, come with a rich set of predefined functions that we can use to help us solve computational problems.  In CS1010, we will also provide you with some functions to help you with your lab assignments.  You will also define your own functions when solving problems with C.  In fact, a C program is just a collection of functions calling each other.\n\n\nProblem: Finding Standard Deviation\n\n\nLet's look at another problem: Given \nL\nL\n, a finite list of at least one integers, find the standard deviation of the integers in \nL\nL\n.  \n\n\nFirst, recall that the (population) standard deviation is given by \n\n\n\n\n\\sqrt{\\frac{\\sum_{i=0}^{k-1} (l_i - \\mu)^2}{k}}\n\n\n\\sqrt{\\frac{\\sum_{i=0}^{k-1} (l_i - \\mu)^2}{k}}\n\n\n\n\nwhere \n\\mu\n\\mu\n is the mean of the integers in \nL\nL\n.\n\n\nTo compute the standard deviation, we first need to compute \n\\mu\n\\mu\n, the mean.   We already know how to do that: \nmean(L, k)\nmean(L, k)\n.  Then, we need to compute \n\\sum_{i=0}^{k-1} (l_i - \\mu)^2\n\\sum_{i=0}^{k-1} (l_i - \\mu)^2\n.  We can break it down into two subproblems:\n\n\n\n\nGiven a list \nL\nL\n and a constant value \nx\nx\n, subtract \nx\nx\n from every number in \nL\nL\n, giving us a new list.\n\n\nGiven a list, square every number in the list, giving us a new list.\n\n\n\n\nFor now, let's apply wishful thinking and assume that we know how to compute the above two steps with functions \nsubstract(L, k, x)\nsubstract(L, k, x)\n and \nsquare(L, k)\nsquare(L, k)\n, then, the formula \n\\sum_{i=0}^{k-1} (l_i - \\mu)^2\n\\sum_{i=0}^{k-1} (l_i - \\mu)^2\n can be computed by the following steps:\n\n\n\n\nset \n\\mu\n\\mu\n to \nmean(L, k)\nmean(L, k)\n\n\nset \nL'\nL'\n to \nsubstract(L, k, \\mu)\nsubstract(L, k, \\mu)\n\n\nset \nL''\nL''\n to \nsquare(L', k)\nsquare(L', k)\n\n\nset \ntotal\ntotal\n to \nsum(L'', k)\nsum(L'', k)\n.\n\n\n\n\nWe can also write it in one line:\n\n\n\n\nset \ntotal\ntotal\n to \nsum(square(substract(L, k, mean(L, k)), k), k)\nsum(square(substract(L, k, mean(L, k)), k), k)\n\n\n\n\nNow, to compute the standard deviation, we need to divide \ntotal\ntotal\n by \nk\nk\n and find the square root.  But, finding \ntotal\ntotal\n and dividing the result by \nk\nk\n is just \nmean\nmean\n.  To compute square root, we again apply wishful thinking and assume that there is a function \nsqrt\nsqrt\n to do so.\n\n\nWe can now compute the standard deviation with one line: \n\n\n\n\nsqrt(mean(square(substract(L, k, mean(L, k)), k), k))\n\n\nsqrt(mean(square(substract(L, k, mean(L, k)), k), k))\n\n\n\n\nUsing functions, we can easily pass the output from one function as input to another, essentially chain the functions together, like Lego blocks, to solve problems.  We also see an example of \nreuse\n here -- \nmean\nmean\n is used twice with different inputs.\n\n\n\n\nReturning a list\n\n\nWhile the above one-liner is an elegant solution, when we actually implement this in C later, it will not so simple and elegant.  Let's worry about that later.\n\n\n\n\nNow that we have seen how to compute standard deviation by breaking it down the four subproblems, \nsqrt\nsqrt\n, \nmean\nmean\n, \nsquare\nsquare\n, and \nsubstract\nsubstract\n, we have to make sure that things we wish can be done can actually be done.  The C library, and many programming languages, provide a pre-defined method to compute \nsqrt\nsqrt\n.  We already know how to compute \nmean\nmean\n.  Computing \nsquare\nsquare\n can be done as follows:\n\n\n\n\nThe implementation for \nsubstract\nsubstract\n is similar.\n\n\nAnother Solution for Finding Maximum\n\n\nIn the previous lecture, you have seen an algorithm to find the maximum value from a list of integers, which involves checking the elements one-by-one and keeping track of the maximum value so far.\n\n\nNow that we have seen what a function is, we can use the concept of wishful thinking to help us solve this problem in a different way and more elegant way.\n\n\nLet's suppose that we have a function \nmax'(L, i, j)\nmax'(L, i, j)\n, that finds the maximum integer among the elements \nl_i, l_{i+1}, ... l_j\nl_i, l_{i+1}, ... l_j\n.  The function \nmax(L, k)\nmax(L, k)\n, which finds the maximum among all elements of \nL\nL\n, is therefore the same as \nmax'(L, 0, k-1)\nmax'(L, 0, k-1)\n.\n\n\nDo we know how to solve \nmax'(L, i, j)\nmax'(L, i, j)\n without checking the integers in \nL\nL\n one-by-one?  Well, if \ni\ni\n equals to \nj\nj\n, i.e., there is only one element in the range of \nl_i, ..., l_j\nl_i, ..., l_j\n, then yes, the function should return the value of \nl_i\nl_i\n.  But, what if there are multiple elements in the range? (i.e., \ni < j\ni < j\n)?  By wishful thinking, we assume that we already know how to solve smaller (as in a shorter list) problem -- \nmax'(L, i+1, j)\nmax'(L, i+1, j)\n, so the maximum value for the range of \nl_i, ..., l_j\nl_i, ..., l_j\n is the larger of the two: either \nl_i\nl_i\n, or \nmax'(L, i+1, j)\nmax'(L, i+1, j)\n.  We can express this algorithm as follows:\n\n\n\n\nLet's trace through the algorithm above, using our previous example: \n4 1 -4 0 9 9 3 5 8\n.  Given this list, we compare the first element, \n4\n, with the maximum of the rest of the list \n1 -4 0 9 9 3 5 8\n.  Since with wishful thinking, we know how to solve this already, we get \n9\n as maximum value of \n1 -4 0 9 9 3 5 8\n.  Comparing \n4\n and \n9\n, \n9\n is larger. Thus, the maximum value for the whole list is \n9\n.\n\n\nExample: Finding a Factorial\n\n\nLet us look at another example of a function before we move on to another topic.  Suppose we want to write a function \nfactorial(n)\nfactorial(n)\n for an integer \nn\nn\n (\nn \\ge 0\nn \\ge 0\n) that computes \nn!\nn!\n. Recall that \nn! = n \\times n - 1 \\times n - 2 \\times ... 2 \\times 1 = n \\times (n-1)!\nn! = n \\times n - 1 \\times n - 2 \\times ... 2 \\times 1 = n \\times (n-1)!\n.  As a special case, \n0!\n0!\n is defined to be \n1\n1\n.\n\n\nThe algorithm to do this can be expressed by the following diagram:\n\n\n\n\nLet's look at an example.  Let's say we want to compute \nfactorial(4)\nfactorial(4)\n.  We assume we know how to solve this for a smaller problem --  \nfactorial(3)\nfactorial(3)\n, which is 6.  \nfactorial(4)\nfactorial(4)\n is thus 4 \n\\times\n\\times\n 6, i.e., 24.\n\n\nRecursion: Function Calling Itself\n\n\nmax'\nmax'\n and \nfactorial\nfactorial\n are examples of functions which calls itself to solve a simpler version of the problem.  This is known as \nrecursion\n.  We will revisit this concept in much greater detail in the later part of CS1010.\n\n\nProblem Set\n\n\nProblem 3.1 : Getting MAD\n\n\nThe mean absolute deviation, or MAD, of a set of integers measures how spread out a set of data is.  The \nabsolute deviation\n is the absolute difference between an element in the list with the mean of values of the list.  The mean absolute deviation is the mean of all the absolute difference.  In other words, given \nL = \\{l_0, ... l_{k-1}\\}\nL = \\{l_0, ... l_{k-1}\\}\n, the MAD of \nL\nL\n is:\n\n\n\n\n\\frac{\\sum_{i=0}^{k-1} |l_i - \\mu|}{k}\n\n\n\\frac{\\sum_{i=0}^{k-1} |l_i - \\mu|}{k}\n\n\n\n\nHow do you find MAD by composing various functions we have seen?  Do you need a new function?\n\n\nProblem 3.2 : Ownself calls ownself\n\n\n(a) Give an algorithm for finding the sum of all the integers in the list \nL\nL\n with \nk\nk\n integers (\nk > 0\nk > 0\n) that is recursive.\n\n\n(b) The function \npow(i, j)\npow(i, j)\n computes \ni^j\ni^j\n.  Give an algorithm to compute \npow(i, j)\npow(i, j)\n recursively.",
            "title": "3. Functions"
        },
        {
            "location": "/03-func/index.html#unit-3-functions",
            "text": "Let's start with another problem.",
            "title": "Unit 3: Functions"
        },
        {
            "location": "/03-func/index.html#problem-finding-the-range",
            "text": "The  range  of a finite list of at least one integers  L L  is defined as the difference between the maximum and the minimum.  For example, the range for  4 1 -4 0 9 9 3 5 8  is  13 .  How do we find the range of a given list?   To find the range of a list, we can break the solution down into three subtasks: first find the maximum, then find the minimum, and finally, find the difference between the two.    From the previous lecture, you already know how to find the maximum and the minimum (from Problem 1.2)!  So, in expressing the algorithm to find the range,  we can refer to a previous solution to a sub-problem, which we assume we already know how to solve .    Let's call our solution to find the maximum value from a given list  L L  as  max max .   max max  takes as input (i) a list  L L  and (ii)  k k , the number of integers in  L L .  It produces, or  returns , the maximum value among the integers in  L L .  Borrowing from mathematical notation, we use the notation  max(L, k) max(L, k)  to represent the maximum value of  L L .    Suppose that  min(L,k) min(L,k)  returns the minimum value among the integers in  L L , then, the algorithm to find the range of  L L  can be written in a single line:    max(L, k) - min(L, k)  max(L, k) - min(L, k)",
            "title": "Problem: Finding the Range"
        },
        {
            "location": "/03-func/index.html#functions",
            "text": "max max  and  min min  are examples of a powerful and important concept with many names:  function ,  procedure ,  subroutine ,  method ,  subprogram .  In the context of CS1010, we will use the term  function .  Functions allow us to solve a problem by thinking about the solution at a higher level.  For instance, in the example above, we no longer have to think about checking through the items in the list one-by-one and maintaining the maximum so far, or the minimum so far.  We just have to think about how to compute the range, assuming that we already know how to compute the maximum and the minimum value.  Such an assumption, that we already know how to solve a subproblem, is known as  wishful thinking .  Sometimes, it is useful to solve a problem assuming that you know how to solve the subproblem first, then worry about solving the subproblem later.    For instance, consider the following problem: Given a finite list of  k k  integers ( k > 0 k > 0 ), find the mean.    The algorithm again, can be written in one line:   sum(L, k) / k  sum(L, k) / k   if we assume that we have a function  sum sum  that can help us find the total of all  k k  integers.  It turns out, in this case, that you should also know how to solve the subproblem  sum sum , since it is Problem 1.3 from last week.  We can then make this into a function itself,  mean(L, k) mean(L, k) , which we can now use to solve other more complex problems.  Thinking in terms of functions also have another advantage: given a function, we only need to worry about  what  it does, but not  how  it is done.   We can treat a function as a black box -- given an input, it will produce an output satisfying certain conditions.  Many programming languages, including C which we will be using in CS1010, come with a rich set of predefined functions that we can use to help us solve computational problems.  In CS1010, we will also provide you with some functions to help you with your lab assignments.  You will also define your own functions when solving problems with C.  In fact, a C program is just a collection of functions calling each other.",
            "title": "Functions"
        },
        {
            "location": "/03-func/index.html#problem-finding-standard-deviation",
            "text": "Let's look at another problem: Given  L L , a finite list of at least one integers, find the standard deviation of the integers in  L L .    First, recall that the (population) standard deviation is given by    \\sqrt{\\frac{\\sum_{i=0}^{k-1} (l_i - \\mu)^2}{k}}  \\sqrt{\\frac{\\sum_{i=0}^{k-1} (l_i - \\mu)^2}{k}}   where  \\mu \\mu  is the mean of the integers in  L L .  To compute the standard deviation, we first need to compute  \\mu \\mu , the mean.   We already know how to do that:  mean(L, k) mean(L, k) .  Then, we need to compute  \\sum_{i=0}^{k-1} (l_i - \\mu)^2 \\sum_{i=0}^{k-1} (l_i - \\mu)^2 .  We can break it down into two subproblems:   Given a list  L L  and a constant value  x x , subtract  x x  from every number in  L L , giving us a new list.  Given a list, square every number in the list, giving us a new list.   For now, let's apply wishful thinking and assume that we know how to compute the above two steps with functions  substract(L, k, x) substract(L, k, x)  and  square(L, k) square(L, k) , then, the formula  \\sum_{i=0}^{k-1} (l_i - \\mu)^2 \\sum_{i=0}^{k-1} (l_i - \\mu)^2  can be computed by the following steps:   set  \\mu \\mu  to  mean(L, k) mean(L, k)  set  L' L'  to  substract(L, k, \\mu) substract(L, k, \\mu)  set  L'' L''  to  square(L', k) square(L', k)  set  total total  to  sum(L'', k) sum(L'', k) .   We can also write it in one line:   set  total total  to  sum(square(substract(L, k, mean(L, k)), k), k) sum(square(substract(L, k, mean(L, k)), k), k)   Now, to compute the standard deviation, we need to divide  total total  by  k k  and find the square root.  But, finding  total total  and dividing the result by  k k  is just  mean mean .  To compute square root, we again apply wishful thinking and assume that there is a function  sqrt sqrt  to do so.  We can now compute the standard deviation with one line:    sqrt(mean(square(substract(L, k, mean(L, k)), k), k))  sqrt(mean(square(substract(L, k, mean(L, k)), k), k))   Using functions, we can easily pass the output from one function as input to another, essentially chain the functions together, like Lego blocks, to solve problems.  We also see an example of  reuse  here --  mean mean  is used twice with different inputs.   Returning a list  While the above one-liner is an elegant solution, when we actually implement this in C later, it will not so simple and elegant.  Let's worry about that later.   Now that we have seen how to compute standard deviation by breaking it down the four subproblems,  sqrt sqrt ,  mean mean ,  square square , and  substract substract , we have to make sure that things we wish can be done can actually be done.  The C library, and many programming languages, provide a pre-defined method to compute  sqrt sqrt .  We already know how to compute  mean mean .  Computing  square square  can be done as follows:   The implementation for  substract substract  is similar.",
            "title": "Problem: Finding Standard Deviation"
        },
        {
            "location": "/03-func/index.html#another-solution-for-finding-maximum",
            "text": "In the previous lecture, you have seen an algorithm to find the maximum value from a list of integers, which involves checking the elements one-by-one and keeping track of the maximum value so far.  Now that we have seen what a function is, we can use the concept of wishful thinking to help us solve this problem in a different way and more elegant way.  Let's suppose that we have a function  max'(L, i, j) max'(L, i, j) , that finds the maximum integer among the elements  l_i, l_{i+1}, ... l_j l_i, l_{i+1}, ... l_j .  The function  max(L, k) max(L, k) , which finds the maximum among all elements of  L L , is therefore the same as  max'(L, 0, k-1) max'(L, 0, k-1) .  Do we know how to solve  max'(L, i, j) max'(L, i, j)  without checking the integers in  L L  one-by-one?  Well, if  i i  equals to  j j , i.e., there is only one element in the range of  l_i, ..., l_j l_i, ..., l_j , then yes, the function should return the value of  l_i l_i .  But, what if there are multiple elements in the range? (i.e.,  i < j i < j )?  By wishful thinking, we assume that we already know how to solve smaller (as in a shorter list) problem --  max'(L, i+1, j) max'(L, i+1, j) , so the maximum value for the range of  l_i, ..., l_j l_i, ..., l_j  is the larger of the two: either  l_i l_i , or  max'(L, i+1, j) max'(L, i+1, j) .  We can express this algorithm as follows:   Let's trace through the algorithm above, using our previous example:  4 1 -4 0 9 9 3 5 8 .  Given this list, we compare the first element,  4 , with the maximum of the rest of the list  1 -4 0 9 9 3 5 8 .  Since with wishful thinking, we know how to solve this already, we get  9  as maximum value of  1 -4 0 9 9 3 5 8 .  Comparing  4  and  9 ,  9  is larger. Thus, the maximum value for the whole list is  9 .",
            "title": "Another Solution for Finding Maximum"
        },
        {
            "location": "/03-func/index.html#example-finding-a-factorial",
            "text": "Let us look at another example of a function before we move on to another topic.  Suppose we want to write a function  factorial(n) factorial(n)  for an integer  n n  ( n \\ge 0 n \\ge 0 ) that computes  n! n! . Recall that  n! = n \\times n - 1 \\times n - 2 \\times ... 2 \\times 1 = n \\times (n-1)! n! = n \\times n - 1 \\times n - 2 \\times ... 2 \\times 1 = n \\times (n-1)! .  As a special case,  0! 0!  is defined to be  1 1 .  The algorithm to do this can be expressed by the following diagram:   Let's look at an example.  Let's say we want to compute  factorial(4) factorial(4) .  We assume we know how to solve this for a smaller problem --   factorial(3) factorial(3) , which is 6.   factorial(4) factorial(4)  is thus 4  \\times \\times  6, i.e., 24.",
            "title": "Example: Finding a Factorial"
        },
        {
            "location": "/03-func/index.html#recursion-function-calling-itself",
            "text": "max' max'  and  factorial factorial  are examples of functions which calls itself to solve a simpler version of the problem.  This is known as  recursion .  We will revisit this concept in much greater detail in the later part of CS1010.",
            "title": "Recursion: Function Calling Itself"
        },
        {
            "location": "/03-func/index.html#problem-set",
            "text": "",
            "title": "Problem Set"
        },
        {
            "location": "/03-func/index.html#problem-31-getting-mad",
            "text": "The mean absolute deviation, or MAD, of a set of integers measures how spread out a set of data is.  The  absolute deviation  is the absolute difference between an element in the list with the mean of values of the list.  The mean absolute deviation is the mean of all the absolute difference.  In other words, given  L = \\{l_0, ... l_{k-1}\\} L = \\{l_0, ... l_{k-1}\\} , the MAD of  L L  is:   \\frac{\\sum_{i=0}^{k-1} |l_i - \\mu|}{k}  \\frac{\\sum_{i=0}^{k-1} |l_i - \\mu|}{k}   How do you find MAD by composing various functions we have seen?  Do you need a new function?",
            "title": "Problem 3.1 : Getting MAD"
        },
        {
            "location": "/03-func/index.html#problem-32-ownself-calls-ownself",
            "text": "(a) Give an algorithm for finding the sum of all the integers in the list  L L  with  k k  integers ( k > 0 k > 0 ) that is recursive.  (b) The function  pow(i, j) pow(i, j)  computes  i^j i^j .  Give an algorithm to compute  pow(i, j) pow(i, j)  recursively.",
            "title": "Problem 3.2 : Ownself calls ownself"
        },
        {
            "location": "/04-type/index.html",
            "text": "Unit 4: Types\n\n\nRecall from Unit 1 that machine code and data manipulated by machine code are all stored as a sequence of 1s and 0s in the memory.  Each unit of either 1 or 0 is known as a \nbit\n.  8 bits form a \nbyte\n.\n\n\nRemember from Unit 2 that a variable is a memory location that stores a value, as a sequence of bits.  The bits stored in the memory has no meaning by itself.  It has to be interpreted by the machine code.  Does a sequence of 1s and 0s represent an integer?  A pixel of an image?  A sound sample in an audio clip?  A month?   As a programmer, we have to tag the variable with its \ntype\n, so that the machine code knows how to interpret the sequence of bits.  In addition, the type also tells the machine code, how many bits \"belong\" to this variable.  The number of bits of a type is also known as the \nsize\n of a type.\n\n\nThe size of a type determines how many different values a variable of that type can hold.  For instance, a type of one bit can only hold two possible values (e.g., \n0\n or \n1\n, \ntrue\n or \nfalse\n, \nblack\n or \nwhite\n).  A type of two bits can hold four values, represented as \n00\n, \n01\n, \n10\n, \n11\n.  In general, a type of \nk\nk\n bits can hold \n2^k\n2^k\n values.\n\n\nIntegers\n\n\nTo represent integers, a type of 8 bits can represent 256 different values.  If the type only represents non-negative integers (called \nunsigned\n), then it can hold any value between 0 to 255.  If it represents both positive and negative integers (called \nsigned\n), it can hold any value between -128 to 127.  Depending on the needs (how much memory we have, how big is the number we need to represent), programmers have to decide on the size of the type used for a variable in their programs.  With 64 bits, a signed integer can store any value between -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807.  This might look big enough for you -- but we can't even fit the results from \nfactorial(21)\nfactorial(21)\n here!\n\nWe have to go to 128 bits to represent larger integers.\n\n\nCharacters\n\n\nTo represent a character (i.e., a symbol representing a letter, number, punctuation, etc), we use 8 bits for English characters.  The ASCII standard maps 127 binary sequences to common characters you can type on your keyboard (including 0-9, A-Z, a-z, all sorts of punctuations: <>?:\"{}!@#$%^&*()_+-=[]\\';/., and special characters like return and escape).  The unicode standard uses up to 32 bits per character, allowing many non-English letter characters (e.g., \nEmoticons\n, \nBraille\n, \nMahjong Tiles\n) to be represented.\n\n\nReal Numbers\n\n\nFor real numbers, because we need to represent a huge number of possible values, we normally use 32 bits or 64 bits.  In CS1231, you will learn that there are uncountably many possible real numbers.  But, no matter how many bits we use, we can only represent a finite number of possible values for real numbers.  Here, we run into a limit of digitizing information into 0s and 1s -- we can never represent all possible real numbers in a computer!  Because of this, programs that manipulate real numbers leads to weird answers (such as 0.1 + 0.2 is not exactly the same as 0.3) and so, we have to take special care when dealing with real numbers when writing programs (not just in C, but in many other languages as well).  Hence, if we only expect a variable to hold an integer, we should not choose a type that represents real numbers.\n\n\nThe details of how a sequence of bits can represent integers and real numbers (both positive and negative numbers) are covered in CS2100. \n\n\nYou should have also noticed that in the discussion above, we talk about types that are 8, 16, 32, 64, 128 bits -- all power of twos.  We do not have a type of size, say, 41 bits.  The reason for this has to do with how memory location is addressed.  This will again be explained in CS2100.\n\n\nType Declaration\n\n\nIn C, which we will use in CS1010, we have to associate \nevery\n variable with a type, and once a variable is \ndeclared\n with a type, the type cannot be changed\n1\n.\n\n\nWhen we write a function, we have to declare the types of each of the parameters and the return value as well.  \n\n\nTake the function \nmean(L, k)\nmean(L, k)\n as an example.  We have said that \nL\nL\n is a list\n2\n of integers.  So each element in \nL\nL\n should have an integer type (how many bits to use will depend on the range of numbers we want the program to possibly handle and how frugal we are about memory usage).  What about \nk\nk\n?  \nk\nk\n refers to the number of elements in \nL\nL\n, so it has to be an integer.  As for the value returned by \nmean(L, k)\nmean(L, k)\n, even when the inputs are all integers (and thus, the sum is an integer), the mean value can be a real number.  So we should choose a type that represents a real number for the return value.  \n\n\n\n\nImportance of Type\n\n\nChoosing a wrong type to represent a variable can lead to buggy code.  Suppose we say that \nmean(L, k)\nmean(L, k)\n returns an integer, then when we call \nmean\nmean\n on the input \n1 2 3 4\n, we will get \n2\n as the answer, instead of \n2.5\n as it should.\n\n\n\n\n\n\n\n\n\n\n\n\nThis behavior is known as static typing.  Some programming languages, such as Javascript and Python, are dynamically typed.  The type of a variable may change depending on the value the variable is assigned to.\u00a0\n\u21a9\n\n\n\n\n\n\nWe have not talked about how to represent a list yet.  I will do that in a later unit.\u00a0\n\u21a9",
            "title": "4. Types"
        },
        {
            "location": "/04-type/index.html#unit-4-types",
            "text": "Recall from Unit 1 that machine code and data manipulated by machine code are all stored as a sequence of 1s and 0s in the memory.  Each unit of either 1 or 0 is known as a  bit .  8 bits form a  byte .  Remember from Unit 2 that a variable is a memory location that stores a value, as a sequence of bits.  The bits stored in the memory has no meaning by itself.  It has to be interpreted by the machine code.  Does a sequence of 1s and 0s represent an integer?  A pixel of an image?  A sound sample in an audio clip?  A month?   As a programmer, we have to tag the variable with its  type , so that the machine code knows how to interpret the sequence of bits.  In addition, the type also tells the machine code, how many bits \"belong\" to this variable.  The number of bits of a type is also known as the  size  of a type.  The size of a type determines how many different values a variable of that type can hold.  For instance, a type of one bit can only hold two possible values (e.g.,  0  or  1 ,  true  or  false ,  black  or  white ).  A type of two bits can hold four values, represented as  00 ,  01 ,  10 ,  11 .  In general, a type of  k k  bits can hold  2^k 2^k  values.",
            "title": "Unit 4: Types"
        },
        {
            "location": "/04-type/index.html#integers",
            "text": "To represent integers, a type of 8 bits can represent 256 different values.  If the type only represents non-negative integers (called  unsigned ), then it can hold any value between 0 to 255.  If it represents both positive and negative integers (called  signed ), it can hold any value between -128 to 127.  Depending on the needs (how much memory we have, how big is the number we need to represent), programmers have to decide on the size of the type used for a variable in their programs.  With 64 bits, a signed integer can store any value between -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807.  This might look big enough for you -- but we can't even fit the results from  factorial(21) factorial(21)  here! \nWe have to go to 128 bits to represent larger integers.",
            "title": "Integers"
        },
        {
            "location": "/04-type/index.html#characters",
            "text": "To represent a character (i.e., a symbol representing a letter, number, punctuation, etc), we use 8 bits for English characters.  The ASCII standard maps 127 binary sequences to common characters you can type on your keyboard (including 0-9, A-Z, a-z, all sorts of punctuations: <>?:\"{}!@#$%^&*()_+-=[]\\';/., and special characters like return and escape).  The unicode standard uses up to 32 bits per character, allowing many non-English letter characters (e.g.,  Emoticons ,  Braille ,  Mahjong Tiles ) to be represented.",
            "title": "Characters"
        },
        {
            "location": "/04-type/index.html#real-numbers",
            "text": "For real numbers, because we need to represent a huge number of possible values, we normally use 32 bits or 64 bits.  In CS1231, you will learn that there are uncountably many possible real numbers.  But, no matter how many bits we use, we can only represent a finite number of possible values for real numbers.  Here, we run into a limit of digitizing information into 0s and 1s -- we can never represent all possible real numbers in a computer!  Because of this, programs that manipulate real numbers leads to weird answers (such as 0.1 + 0.2 is not exactly the same as 0.3) and so, we have to take special care when dealing with real numbers when writing programs (not just in C, but in many other languages as well).  Hence, if we only expect a variable to hold an integer, we should not choose a type that represents real numbers.  The details of how a sequence of bits can represent integers and real numbers (both positive and negative numbers) are covered in CS2100.   You should have also noticed that in the discussion above, we talk about types that are 8, 16, 32, 64, 128 bits -- all power of twos.  We do not have a type of size, say, 41 bits.  The reason for this has to do with how memory location is addressed.  This will again be explained in CS2100.",
            "title": "Real Numbers"
        },
        {
            "location": "/04-type/index.html#type-declaration",
            "text": "In C, which we will use in CS1010, we have to associate  every  variable with a type, and once a variable is  declared  with a type, the type cannot be changed 1 .  When we write a function, we have to declare the types of each of the parameters and the return value as well.    Take the function  mean(L, k) mean(L, k)  as an example.  We have said that  L L  is a list 2  of integers.  So each element in  L L  should have an integer type (how many bits to use will depend on the range of numbers we want the program to possibly handle and how frugal we are about memory usage).  What about  k k ?   k k  refers to the number of elements in  L L , so it has to be an integer.  As for the value returned by  mean(L, k) mean(L, k) , even when the inputs are all integers (and thus, the sum is an integer), the mean value can be a real number.  So we should choose a type that represents a real number for the return value.     Importance of Type  Choosing a wrong type to represent a variable can lead to buggy code.  Suppose we say that  mean(L, k) mean(L, k)  returns an integer, then when we call  mean mean  on the input  1 2 3 4 , we will get  2  as the answer, instead of  2.5  as it should.       This behavior is known as static typing.  Some programming languages, such as Javascript and Python, are dynamically typed.  The type of a variable may change depending on the value the variable is assigned to.\u00a0 \u21a9    We have not talked about how to represent a list yet.  I will do that in a later unit.\u00a0 \u21a9",
            "title": "Type Declaration"
        },
        {
            "location": "/05-first-c/index.html",
            "text": "Unit 5: First C Program\n\n\nIn this unit, we will write and compile your first C program.  You have already learned, conceptually, what is a variable, what is a type and what is a function.  Let's see how we apply these concepts to C.\n\n\nTo start, let's look at a simple snippet of C code:\n\n\n1\n2\n3\n4\nint\n \nsquare\n(\nint\n \nx\n)\n \n\n{\n\n  \nreturn\n \nx\n*\nx\n;\n\n\n}\n\n\n\n\n\n\n\nThe code above defines a function named \nsquare\n.  The word \nint\n appears \nbefore\n the name \nsquare\n.  \nint\n is used to signify an integer type.  Appearing before the name \nsquare\n tells the compiler that \nsquare\n is returning a value of type \nint\n.\n\n\nAfter the word \nsquare\n, we write the parameters to the function in parenthesis \n(\n and \n)\n.  In between \n(\n and \n)\n is \nint x\n: \nx\n is the name of the parameter, \nint\n is the type of that parameter.  \n\n\nTo summarize, in Line 1, \nint square(int x)\n defines a function named \nsquare\n that takes in an integer parameter \nx\n and is returning a value which is also an integer.\n\n\nThe next three lines are written in between curly brackets \n{\n and \n}\n.  You will see these used a lot in C and other programming languages with C-like syntaxes, such as Javascript, C++, and Java.  These curly brackets group a \nblock\n of \nstatements\n together.  In this example, this block defines how the function \nsquare\n computes the square of \nx\n, and what it returns.  This is sometimes called the \nbody of a function\n.\n\n\nIn this function body, there is only one statement \nreturn x*x;\n  within the block.  A \nstatement\n is a unit in a programming language that expresses either a command to be executed or declares a new variable or function.  The word \nreturn\n says that this function \nsquare\n should return the following value, computed as \nx*x\n (\nx\n multiply by \nx\n).  This statement is terminated by a semicolon \n;\n.\n\n\nYou also see that the line that starts with \nreturn\n is indented.  We use indentation extensively to indicate the body of a block.  Since we can have nested blocks, indentation makes our code easier to read and understand.\n\n\nThe words \nint\n and \nreturn\n that appear above are \nkeywords\n defined in the C programming language, and they are reserved for the special meaning that they represent (a type and a command to return a value from a function).  We cannot repurpose keywords in C.  For instance, we cannot introduce a variable called \nint\n.\n\n\nWe are now ready to write our first C program.  The first program computes the square of the hypotenuse of a right-angled triangle with a base of 4 and height of 3.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\nint\n \nsquare\n(\nint\n \nx\n)\n \n\n{\n\n  \nreturn\n \nx\n*\nx\n;\n\n\n}\n\n\n\nint\n \nmain\n()\n \n\n{\n\n  \nint\n \nhypotenuse_square\n;\n\n\n  \nhypotenuse_square\n \n=\n \nsquare\n(\n3\n)\n \n+\n \nsquare\n(\n4\n);\n\n  \nreturn\n \n0\n;\n\n\n}\n\n\n\n\n\n\n\nRemember that a C program consists of a bunch of functions, calling each other.  The most important function is called \nmain\n, and it is the \nentry point\n to the program.  It is where the operating system will begin to execute the program.  Every program must define \nexactly one function\n called \nmain\n.\n\n\n1\n2\n3\n4\nint\n \nmain\n()\n \n\n{\n\n  \n:\n\n\n}\n\n\n\n\n\n\n\nmain\n returns an integer to the operating system, to signal to the operating system whether the program exits successfully or not.  In this case, we always return \n0\n (success) assuming that nothing goes wrong for simplicity.  This is the second example where you see the keyword \nreturn\n in action.\n\n\nIn modern C, the main always return 0 when it exits.  So, we will skip this statement \nreturn 0;\n from now on.\n\n\nVariable Declaration\n\n\nIn the example above, you also see the lines\n\n\n1\nint\n \nhypotenuse_square\n;\n\n\n\n\n\n\n\nThis is declaration statement (terminated with a semicolon, again).  Each statement declares a variable with its corresponding type (\nint\n here).  We gave each variable a name, here we call the variable \nhypotenuse_square\n.\n\n\nRemember that \nall variables must be declared with its corresponding type before used in C\n.\n\n\nIn C, a function must be either defined or declared before used as well.  In the example above, we define \nsquare\n before \nmain\n.  If we switch the order of the two, the compiler will complain.  Unless we declare the function first.  Declaring a function means that we simply state the return type, the name, and the parameters, \nwithout\n the body.  Here is an example:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\nint\n \nsquare\n(\nint\n \nx\n);\n \n// declaring the function square\n\n\n\nint\n \nmain\n()\n \n\n{\n\n  \nint\n \nhypotenuse_square\n;\n\n\n  \nhypotenuse_square\n \n=\n \nsquare\n(\n3\n)\n \n+\n \nsquare\n(\n4\n);\n\n  \nreturn\n \n0\n;\n\n\n}\n\n\n\nint\n \nsquare\n(\nint\n \nx\n)\n  \n// defining the function square\n\n\n{\n\n  \nreturn\n \nx\n*\nx\n;\n\n\n}\n\n\n\n\n\n\n\nAssignment Statement\n\n\nThe next line of the code shows an example of an assignment statement.  \n\n\n1\n  \nhypotenuse_square\n \n=\n \nsquare\n(\n3\n)\n \n+\n \nsquare\n(\n4\n);\n\n\n\n\n\n\n\nAn assignment operator takes the form of:\n\n\n1\n  \nleft_hand_side\n \n=\n \nright_hand_side\n;\n\n\n\n\n\n\n\nThe \nleft_hand_side\n must be the name of a variable.  We first evaluate the \nright_hand_side\n of the assignment statement, find its value, then put the value into the variable named on the \nleft_hand_side\n.\n\n\nHere, on the right-hand side, we call the function \nsquare\n, which we defined earlier.  We call \nsquare\n with \narguments\n \n3\n and \n4\n respectively.   We use the operator \n+\n to add the two results together.  The right-hand side should give the value 25, which we then assign to the variable \nhypotenuse_square\n.\n\n\nNote that we use \n=\n equal sign for assignment, NOT for checking equality.  The C notation for checking for equality is \n==\n (we will come back to this later).\n\n\nRecap\n\n\nBefore we move on, let's recap some concepts:\n\n\n\n\nA C program consists of functions, invoking each other.\n\n\nEach function is defined by its returned type, followed by its name, its parameter(s) (within a pair of parenthesis) and its body (within a pair of curly brackets).  \n\n\nEach function must be defined or declared before it is used.  \n\n\nThe function body consists of one or more statements.  We have seen assignment statements (using the \n=\n operator) and return statements, using \nreturn\n as the keyword.\n\n\nEach variable must be declared before it is used.  A declaration starts with its type followed by its name.\n\n\n\n\nExample 2\n\n\nLet's change the program slightly, so that instead of computing the square of the hypotenuse, we compute the hypotenuse itself.  Recall that we said C provides a bunch of predefined functions, include \nsqrt\n, which computes the square root of a given number.  Since a square root of a number is not necessarily an integer, we need to use a variable with a type that can store a real number.  \n\n\nTo represent real numbers, we commonly use the type \nfloat\n (which is short for a floating point number -- named so due to how a real number is represented in bits).  A \nfloat\n type can store 32 bits.  To double the precision (64 bits), we can use the type \ndouble\n.  A \nlong double\n type can store either 80-bits or 128-bits, depending on the implementation.\n\n\nBut which one does \nsqrt\n returns?  To find out the exact \nspecification\n of a pre-defined function, we can consult the manual (or \nman\n for short) pages for the function.  \n\n\nIf you type \nman sqrt\n on the command line (or place the cursor on \nsqrt\n in \nvim\n and type \nK\n in command mode), you will see that the \nsqrt\n method has the following specification:\n\n\n1\ndouble\n \nsqrt\n(\ndouble\n \nx\n);\n\n\n\n\n\n\n\nThe \nsqrt\n function returns a \ndouble\n precision real number.  We can now modify the program above to the following:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\ndouble\n \nsqrt\n(\ndouble\n \nx\n);\n \n// not recommended\n\n\n\nlong\n \nsquare\n(\nlong\n \nx\n)\n \n\n{\n\n  \nreturn\n \nx\n*\nx\n;\n\n\n}\n\n\n\ndouble\n \nhypotenuse_of\n(\nlong\n \nbase\n,\n \nlong\n \nheight\n)\n \n\n{\n\n  \nreturn\n \nsqrt\n(\nsquare\n(\nbase\n)\n \n+\n \nsquare\n(\nheight\n));\n\n\n}\n\n\n\nint\n \nmain\n()\n \n\n{\n\n  \nhypotenuse_of\n(\n3\n,\n \n4\n);\n\n\n}\n\n\n\n\n\n\n\nNote that the first line declares the function \nsqrt\n, because we need to declare a function before it is used.  Since \nsqrt\n is pre-defined elsewhere, we do not have to supply the function body here.  Such practice of declaring a predefined function ourselves, however, is not recommended.  Different platform, compilers, libraries, may provide a different specification for the same function.  As such, it is better to use the declaration from the library that provides the predefined function itself.  A library usually provides one or more \nheader files\n, a set of files that contain function declarations, type definitions, and constant definitions.  In the case of \nsqrt\n, its declaration is contained in a header file called \nmath.h\n (which we found out through consulting the \nman\n pages).  To include this file, you add the line \n#include\n \n<math.h>\n at the top of the program.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n#include\n \n<math.h>\n\n\n\nlong\n \nsquare\n(\nlong\n \nx\n)\n \n\n{\n\n  \nreturn\n \nx\n*\nx\n;\n\n\n}\n\n\n\ndouble\n \nhypotenuse_of\n(\nlong\n \nbase\n,\n \nlong\n \nheight\n)\n \n\n{\n\n  \nreturn\n \nsqrt\n(\nsquare\n(\nbase\n)\n \n+\n \nsquare\n(\nheight\n));\n\n\n}\n\n\n\nint\n \nmain\n()\n \n\n{\n\n  \nhypotenuse_of\n(\n3\n,\n \n4\n);\n\n\n}\n\n\n\n\n\n\n\nYou might notice the same line appear in the man page for \nsqrt\n.  Thus, the man pages tell us which header file to include if you want to use a certain function.\n\n\n\n\nFile Extension\n\n\nThe convention for file extension for a C program is \n.c\n and for a C header file is \n.h\n.  Even though you are allowed to name the files with any extension you like, you should stick to the convention so that it is clear to other tools/programmers what is the purpose of each file.\n\n\n\n\nOther Types in C\n\n\nAn \nint\n variable is usually 32-bits long.  If we only need 16 bits, we use the type \nshort int\n, or just \nshort\n.  If we only need 8-bits, we use the type \nchar\n (short for character).\n\n\nNote that in the above, I said an \nint\n is \nusually\n 32 bits.  Remember (from \nUnit 1\n that a C program gets compiled into machine code for a specific CPU architecture.  The C standard only guarantees that an \nint\n is at least 16 bits.  Although most C compilers compile \nint\n to 32 bits, there is no guarantee!    \n\n\nIf we need something more than an \nint\n, we can use \nlong int\n, or just \nlong\n.  The C standard guarantees that a \nlong\n is at least 32 bits.  Depending on the implementation, it sometimes compiled to 32-bits, sometimes 64-bits.  To get even longer, we can use the type \nlong long int\n, or just \nlong long\n, which is guaranteed to be at least 64 bits\n1\n.\n\n\nSigned vs. Unsigned\n\n\nWe have seen earlier that the same sequence of bits, if interpreted as signed or unsigned, would result in a different value.  By default, all types in C refer to signed types.  If you want a variable that holds only non-negative integers, you can add the keyword \nunsigned\n to the front of the type.  Doing so would mean that the range of values you can store in the variable is doubled, without adding more bits (since the bit used to present the + or - sign is no longer needed).  \n\n\nFor instance, since we know that \nsquare\n can only return a non-zero integer, we can actually declare it as:\n\n\n1\n2\n3\n4\nunsigned\n \nlong\n \nsquare\n(\nlong\n \nx\n)\n \n\n{\n\n  \nreturn\n \nx\n*\nx\n;\n\n\n}\n\n\n\n\n\n\n\nFor most practical purposes in CS1010, a (signed) \nlong\n suffices.  We introduce the notion of \nsigned\n vs. \nunsigned\n for your information so that you know what they are when you come across them in others source code.  Mixing \nsigned\n and \nunsigned\n can lead to subtle bugs in your code.  As such, \nwe will only use signed \nlong\n for CS1010\n.  You may choose to use them appropriately in another context, especially for embedded system or low-level programming.\n\n\n\n\nUnsigned Real Numbers?\n\n\nThere are no \nunsigned\n versions of \nfloat\n and \ndouble\n.  To understand the reason, we have to go further into how floating points numbers are represented in bits.  That is a topic for another module.\n\n\n\n\nstdint.h\n\n\nSince the number of bits for \nint\n, \nlong\n, and \nlong long\n could differ, in order to write a C program that is portable (i.e., works on different platforms, architecture, operating systems), we have two options:\n\n\n\n\nDo not write a program that assumes a specific number of bits is used for a certain type, or\n\n\nUse the type defined in the header file \nstdint.h\n: \nint8_t\n, \nuint8_t\n, \nint16_t\n, \nuint16_t\n, \nint32_t\n, \nuint32_t\n, \nint64_t\n, \nuint64_t\n.  The suffix \n_t\n is a convention to indicate that this is a customized type (more on this in later units).  The prefix \nu\n indicates that the type is an unsigned type.  The numbers \n8\n, \n16\n, \n32\n, and \n64\n indicate the number of bits for each type.  Thus, \nuint32_t\n is guaranteed to be of size 32 bits, and can hold unsigned integer values from \n0\n0\n to \n2^{32}-1\n2^{32}-1\n.\n\n\n\n\nProblem Set 5\n\n\nProblem 5.1\n\n\nIn the example above, \nsqrt\n is declared to take in a parameter of type \ndouble\n .  But the argument that we pass in is the sum of two \nint\n, which is also an \nint\n.   Would this result in an error?  \n\n\nProblem 5.2\n\n\nConsider the following alternative definition of \nsquare\n\n\n1\n2\n3\n???\n \nsquare\n(\nuint16_t\n \nx\n)\n \n{\n\n    \nreturn\n \nx\n*\nx\n;\n\n\n}\n\n\n\n\n\n\n\nWhat should the return type of this \nsquare\n be, in order for the return type to be big enough to store all possible value for \nx*x\n?\n\n\n\n\n\n\n\n\n\n\nAdding more \nlong\n does not make the integer longer, i.e., there is no \nlong long long int\n.\u00a0\n\u21a9",
            "title": "5. First C Program"
        },
        {
            "location": "/05-first-c/index.html#unit-5-first-c-program",
            "text": "In this unit, we will write and compile your first C program.  You have already learned, conceptually, what is a variable, what is a type and what is a function.  Let's see how we apply these concepts to C.  To start, let's look at a simple snippet of C code:  1\n2\n3\n4 int   square ( int   x )   { \n   return   x * x ;  }    The code above defines a function named  square .  The word  int  appears  before  the name  square .   int  is used to signify an integer type.  Appearing before the name  square  tells the compiler that  square  is returning a value of type  int .  After the word  square , we write the parameters to the function in parenthesis  (  and  ) .  In between  (  and  )  is  int x :  x  is the name of the parameter,  int  is the type of that parameter.    To summarize, in Line 1,  int square(int x)  defines a function named  square  that takes in an integer parameter  x  and is returning a value which is also an integer.  The next three lines are written in between curly brackets  {  and  } .  You will see these used a lot in C and other programming languages with C-like syntaxes, such as Javascript, C++, and Java.  These curly brackets group a  block  of  statements  together.  In this example, this block defines how the function  square  computes the square of  x , and what it returns.  This is sometimes called the  body of a function .  In this function body, there is only one statement  return x*x;   within the block.  A  statement  is a unit in a programming language that expresses either a command to be executed or declares a new variable or function.  The word  return  says that this function  square  should return the following value, computed as  x*x  ( x  multiply by  x ).  This statement is terminated by a semicolon  ; .  You also see that the line that starts with  return  is indented.  We use indentation extensively to indicate the body of a block.  Since we can have nested blocks, indentation makes our code easier to read and understand.  The words  int  and  return  that appear above are  keywords  defined in the C programming language, and they are reserved for the special meaning that they represent (a type and a command to return a value from a function).  We cannot repurpose keywords in C.  For instance, we cannot introduce a variable called  int .  We are now ready to write our first C program.  The first program computes the square of the hypotenuse of a right-angled triangle with a base of 4 and height of 3.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12 int   square ( int   x )   { \n   return   x * x ;  }  int   main ()   { \n   int   hypotenuse_square ; \n\n   hypotenuse_square   =   square ( 3 )   +   square ( 4 ); \n   return   0 ;  }    Remember that a C program consists of a bunch of functions, calling each other.  The most important function is called  main , and it is the  entry point  to the program.  It is where the operating system will begin to execute the program.  Every program must define  exactly one function  called  main .  1\n2\n3\n4 int   main ()   { \n   :  }    main  returns an integer to the operating system, to signal to the operating system whether the program exits successfully or not.  In this case, we always return  0  (success) assuming that nothing goes wrong for simplicity.  This is the second example where you see the keyword  return  in action.  In modern C, the main always return 0 when it exits.  So, we will skip this statement  return 0;  from now on.",
            "title": "Unit 5: First C Program"
        },
        {
            "location": "/05-first-c/index.html#variable-declaration",
            "text": "In the example above, you also see the lines  1 int   hypotenuse_square ;    This is declaration statement (terminated with a semicolon, again).  Each statement declares a variable with its corresponding type ( int  here).  We gave each variable a name, here we call the variable  hypotenuse_square .  Remember that  all variables must be declared with its corresponding type before used in C .  In C, a function must be either defined or declared before used as well.  In the example above, we define  square  before  main .  If we switch the order of the two, the compiler will complain.  Unless we declare the function first.  Declaring a function means that we simply state the return type, the name, and the parameters,  without  the body.  Here is an example:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14 int   square ( int   x );   // declaring the function square  int   main ()   { \n   int   hypotenuse_square ; \n\n   hypotenuse_square   =   square ( 3 )   +   square ( 4 ); \n   return   0 ;  }  int   square ( int   x )    // defining the function square  { \n   return   x * x ;  }",
            "title": "Variable Declaration"
        },
        {
            "location": "/05-first-c/index.html#assignment-statement",
            "text": "The next line of the code shows an example of an assignment statement.    1    hypotenuse_square   =   square ( 3 )   +   square ( 4 );    An assignment operator takes the form of:  1    left_hand_side   =   right_hand_side ;    The  left_hand_side  must be the name of a variable.  We first evaluate the  right_hand_side  of the assignment statement, find its value, then put the value into the variable named on the  left_hand_side .  Here, on the right-hand side, we call the function  square , which we defined earlier.  We call  square  with  arguments   3  and  4  respectively.   We use the operator  +  to add the two results together.  The right-hand side should give the value 25, which we then assign to the variable  hypotenuse_square .  Note that we use  =  equal sign for assignment, NOT for checking equality.  The C notation for checking for equality is  ==  (we will come back to this later).",
            "title": "Assignment Statement"
        },
        {
            "location": "/05-first-c/index.html#recap",
            "text": "Before we move on, let's recap some concepts:   A C program consists of functions, invoking each other.  Each function is defined by its returned type, followed by its name, its parameter(s) (within a pair of parenthesis) and its body (within a pair of curly brackets).    Each function must be defined or declared before it is used.    The function body consists of one or more statements.  We have seen assignment statements (using the  =  operator) and return statements, using  return  as the keyword.  Each variable must be declared before it is used.  A declaration starts with its type followed by its name.",
            "title": "Recap"
        },
        {
            "location": "/05-first-c/index.html#example-2",
            "text": "Let's change the program slightly, so that instead of computing the square of the hypotenuse, we compute the hypotenuse itself.  Recall that we said C provides a bunch of predefined functions, include  sqrt , which computes the square root of a given number.  Since a square root of a number is not necessarily an integer, we need to use a variable with a type that can store a real number.    To represent real numbers, we commonly use the type  float  (which is short for a floating point number -- named so due to how a real number is represented in bits).  A  float  type can store 32 bits.  To double the precision (64 bits), we can use the type  double .  A  long double  type can store either 80-bits or 128-bits, depending on the implementation.  But which one does  sqrt  returns?  To find out the exact  specification  of a pre-defined function, we can consult the manual (or  man  for short) pages for the function.    If you type  man sqrt  on the command line (or place the cursor on  sqrt  in  vim  and type  K  in command mode), you will see that the  sqrt  method has the following specification:  1 double   sqrt ( double   x );    The  sqrt  function returns a  double  precision real number.  We can now modify the program above to the following:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16 double   sqrt ( double   x );   // not recommended  long   square ( long   x )   { \n   return   x * x ;  }  double   hypotenuse_of ( long   base ,   long   height )   { \n   return   sqrt ( square ( base )   +   square ( height ));  }  int   main ()   { \n   hypotenuse_of ( 3 ,   4 );  }    Note that the first line declares the function  sqrt , because we need to declare a function before it is used.  Since  sqrt  is pre-defined elsewhere, we do not have to supply the function body here.  Such practice of declaring a predefined function ourselves, however, is not recommended.  Different platform, compilers, libraries, may provide a different specification for the same function.  As such, it is better to use the declaration from the library that provides the predefined function itself.  A library usually provides one or more  header files , a set of files that contain function declarations, type definitions, and constant definitions.  In the case of  sqrt , its declaration is contained in a header file called  math.h  (which we found out through consulting the  man  pages).  To include this file, you add the line  #include   <math.h>  at the top of the program.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16 #include   <math.h>  long   square ( long   x )   { \n   return   x * x ;  }  double   hypotenuse_of ( long   base ,   long   height )   { \n   return   sqrt ( square ( base )   +   square ( height ));  }  int   main ()   { \n   hypotenuse_of ( 3 ,   4 );  }    You might notice the same line appear in the man page for  sqrt .  Thus, the man pages tell us which header file to include if you want to use a certain function.   File Extension  The convention for file extension for a C program is  .c  and for a C header file is  .h .  Even though you are allowed to name the files with any extension you like, you should stick to the convention so that it is clear to other tools/programmers what is the purpose of each file.",
            "title": "Example 2"
        },
        {
            "location": "/05-first-c/index.html#other-types-in-c",
            "text": "An  int  variable is usually 32-bits long.  If we only need 16 bits, we use the type  short int , or just  short .  If we only need 8-bits, we use the type  char  (short for character).  Note that in the above, I said an  int  is  usually  32 bits.  Remember (from  Unit 1  that a C program gets compiled into machine code for a specific CPU architecture.  The C standard only guarantees that an  int  is at least 16 bits.  Although most C compilers compile  int  to 32 bits, there is no guarantee!      If we need something more than an  int , we can use  long int , or just  long .  The C standard guarantees that a  long  is at least 32 bits.  Depending on the implementation, it sometimes compiled to 32-bits, sometimes 64-bits.  To get even longer, we can use the type  long long int , or just  long long , which is guaranteed to be at least 64 bits 1 .",
            "title": "Other Types in C"
        },
        {
            "location": "/05-first-c/index.html#signed-vs-unsigned",
            "text": "We have seen earlier that the same sequence of bits, if interpreted as signed or unsigned, would result in a different value.  By default, all types in C refer to signed types.  If you want a variable that holds only non-negative integers, you can add the keyword  unsigned  to the front of the type.  Doing so would mean that the range of values you can store in the variable is doubled, without adding more bits (since the bit used to present the + or - sign is no longer needed).    For instance, since we know that  square  can only return a non-zero integer, we can actually declare it as:  1\n2\n3\n4 unsigned   long   square ( long   x )   { \n   return   x * x ;  }    For most practical purposes in CS1010, a (signed)  long  suffices.  We introduce the notion of  signed  vs.  unsigned  for your information so that you know what they are when you come across them in others source code.  Mixing  signed  and  unsigned  can lead to subtle bugs in your code.  As such,  we will only use signed  long  for CS1010 .  You may choose to use them appropriately in another context, especially for embedded system or low-level programming.   Unsigned Real Numbers?  There are no  unsigned  versions of  float  and  double .  To understand the reason, we have to go further into how floating points numbers are represented in bits.  That is a topic for another module.",
            "title": "Signed vs. Unsigned"
        },
        {
            "location": "/05-first-c/index.html#stdinth",
            "text": "Since the number of bits for  int ,  long , and  long long  could differ, in order to write a C program that is portable (i.e., works on different platforms, architecture, operating systems), we have two options:   Do not write a program that assumes a specific number of bits is used for a certain type, or  Use the type defined in the header file  stdint.h :  int8_t ,  uint8_t ,  int16_t ,  uint16_t ,  int32_t ,  uint32_t ,  int64_t ,  uint64_t .  The suffix  _t  is a convention to indicate that this is a customized type (more on this in later units).  The prefix  u  indicates that the type is an unsigned type.  The numbers  8 ,  16 ,  32 , and  64  indicate the number of bits for each type.  Thus,  uint32_t  is guaranteed to be of size 32 bits, and can hold unsigned integer values from  0 0  to  2^{32}-1 2^{32}-1 .",
            "title": "stdint.h"
        },
        {
            "location": "/05-first-c/index.html#problem-set-5",
            "text": "",
            "title": "Problem Set 5"
        },
        {
            "location": "/05-first-c/index.html#problem-51",
            "text": "In the example above,  sqrt  is declared to take in a parameter of type  double  .  But the argument that we pass in is the sum of two  int , which is also an  int .   Would this result in an error?",
            "title": "Problem 5.1"
        },
        {
            "location": "/05-first-c/index.html#problem-52",
            "text": "Consider the following alternative definition of  square  1\n2\n3 ???   square ( uint16_t   x )   { \n     return   x * x ;  }    What should the return type of this  square  be, in order for the return type to be big enough to store all possible value for  x*x ?      Adding more  long  does not make the integer longer, i.e., there is no  long long long int .\u00a0 \u21a9",
            "title": "Problem 5.2"
        },
        {
            "location": "/06-cs1010-io/index.html",
            "text": "Unit 6: The CS1010 I/O Library\n\n\nOur first C program that computes the hypotenuse doesn't do much -- it simply computes \n\\sqrt(3^2 + 4^2)\n\\sqrt(3^2 + 4^2)\n.  The value to be computed is hard-coded, and the result computed is not displayed.\n\n\nTo make this program more general and useful, first, we need to compute the hypotenuse for any length of the base and the height of a right-angled triangle.  We cannot hardcode the length in the program.   We should read these values from the users.  Second, we need to output the result of the computation to the users.  In other words, to make the program more general and useful, we need to add input and output, or I/O, functions.\n\n\nStandard Input and Standard Output\n\n\nBefore we talk about how to read the input values and display the output values, we have to first talk about where an input comes from and where an output goes to.\n\n\nIn UNIX-flavored operating systems, an input is read from an abstract channel called the \nstandard input\n, or \nstdin\n for short, and an output is sent to an abstract channel called the \nstandard output\n, or \nstdout\n for short.  \n\n\nThe fact that these channels are abstract is a powerful concept -- when we write our code, we do not have to worry about where the inputs come from and where the outputs go to.  It will depend on how the user runs our program.  Thus, it allows the users of our program the flexibility to control where the data comes from or goes to.\n\n\nFor instance, the standard input, by default, reads from the keyboard.  But the user can choose to read from a file, using the redirection \n<\n operator \nfrom the command line\n or from the output of another process, using the pipe \n|\n operator \nfrom the command line\n.  Similarly, the standard output, by default, writes to the terminal.  But the user can choose to write to a file using the redirection \n>\n operator \non the command line\n or to the input of another process, using the pipe \n|\n operator, again, on the command line when invoking the program.  You will see how cool these are later.  But for the purpose of C programming, it suffices to know for now that we only need to read from \nstdin\n and write to \nstdout\n in our code, and we let the users decide where they come from / go to.\n\n\nNo \nprintf\n and \nscanf\n (yet)\n\n\nIn almost all articles and textbooks on C that I have seen, the \nscanf\n and \nprintf\n functions are taught as the standard C library functions to perform the input and output respectively.  The function \nscanf\n, however, is tricky to use correctly and securely.  The function \nprintf\n comes with many nuances, such as remembering the different conversion specifiers and modifiers.  I would rather not teach you \nscanf\n and \nprintf\n at this stage.  As such, CS1010 is providing you a library to perform I/O -- the library provides a small set of essential functions to read and write \nlong\n values, \ndouble\n values, space-separated words, and lines of text. \n\n\nYou can find the \ndocumentation for the CS1010 I/O Library here\n.  We will see how to use the library to improve our hypotenuse computation program here.\n\n\nUsing the CS1010 I/O Library\n\n\nLet's modify our earlier program to now read the base and height from \nstdin\n, compute the hypotenuse, and print the results out to \nstdout\n.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n#include\n \n<math.h>\n\n\n#include\n \n\"cs1010.h\"\n\n\n\nlong\n \nsquare\n(\nlong\n \nx\n)\n \n\n{\n\n  \nreturn\n \nx\n*\nx\n;\n\n\n}\n\n\n\ndouble\n \nhypotenuse_of\n(\nlong\n \nbase\n,\n \nlong\n \nheight\n)\n \n\n{\n\n  \nreturn\n \nsqrt\n(\nsquare\n(\nbase\n)\n \n+\n \nsquare\n(\nheight\n));\n\n\n}\n\n\n\nint\n \nmain\n()\n \n\n{\n\n  \ndouble\n \nhypotenuse\n;\n\n  \nlong\n \nbase\n \n=\n \ncs1010_read_long\n();\n\n  \nlong\n \nheight\n \n=\n \ncs1010_read_long\n();\n\n  \nhypotenuse\n \n=\n \nhypotenuse_of\n(\nbase\n,\n \nheight\n);\n\n  \ncs1010_println_double\n(\nhypotenuse\n);\n\n\n}\n\n\n\n\n\n\n\nThe first change you see (on Line 2) is to include the file \ncs1010.h\n, which includes the declaration of functions provided by the library.  On Lines 17 and 18, we introduce two new \nlong\n variables named \nbase\n and \nheight\n, which we initialized with the returned value from \ncs1010_read_long()\n.  The function \ncs1010_read_long\n reads a \nlong\n value from \nstdin\n and returns the value.  For now, we assume that the inputs are correctly passed to the program.\n\n\nFinally, on Line 20, we print the resulting hypotenuse to \nstdout\n using the library function \ncs1010_println_double\n.  Note that there are two versions of functions to print a \ndouble\n value: \ncs1010_println_double\n and \ncs1010_print_double\n.  The one with \nprintln\n prints a new line character so that the text that got printed after appears in the next line.\n\n\nRefer to \nCS1010 Compilation Guide\n on how to compile a program that uses the CS1010 I/O library.\n\n\nNote that the \nmain\n function above can be written as a single statement without any state and assignment.  The resulting code, however, is not necessarily easier to understand.\n\n1\n2\n3\n4\nint\n \nmain\n()\n \n\n{\n\n  \ncs1010_println_double\n(\nhypotenuse_of\n(\ncs1010_read_long\n(),\n \ncs1010_read_long\n()));\n\n\n}",
            "title": "6. CS1010 I/O Library"
        },
        {
            "location": "/06-cs1010-io/index.html#unit-6-the-cs1010-io-library",
            "text": "Our first C program that computes the hypotenuse doesn't do much -- it simply computes  \\sqrt(3^2 + 4^2) \\sqrt(3^2 + 4^2) .  The value to be computed is hard-coded, and the result computed is not displayed.  To make this program more general and useful, first, we need to compute the hypotenuse for any length of the base and the height of a right-angled triangle.  We cannot hardcode the length in the program.   We should read these values from the users.  Second, we need to output the result of the computation to the users.  In other words, to make the program more general and useful, we need to add input and output, or I/O, functions.",
            "title": "Unit 6: The CS1010 I/O Library"
        },
        {
            "location": "/06-cs1010-io/index.html#standard-input-and-standard-output",
            "text": "Before we talk about how to read the input values and display the output values, we have to first talk about where an input comes from and where an output goes to.  In UNIX-flavored operating systems, an input is read from an abstract channel called the  standard input , or  stdin  for short, and an output is sent to an abstract channel called the  standard output , or  stdout  for short.    The fact that these channels are abstract is a powerful concept -- when we write our code, we do not have to worry about where the inputs come from and where the outputs go to.  It will depend on how the user runs our program.  Thus, it allows the users of our program the flexibility to control where the data comes from or goes to.  For instance, the standard input, by default, reads from the keyboard.  But the user can choose to read from a file, using the redirection  <  operator  from the command line  or from the output of another process, using the pipe  |  operator  from the command line .  Similarly, the standard output, by default, writes to the terminal.  But the user can choose to write to a file using the redirection  >  operator  on the command line  or to the input of another process, using the pipe  |  operator, again, on the command line when invoking the program.  You will see how cool these are later.  But for the purpose of C programming, it suffices to know for now that we only need to read from  stdin  and write to  stdout  in our code, and we let the users decide where they come from / go to.",
            "title": "Standard Input and Standard Output"
        },
        {
            "location": "/06-cs1010-io/index.html#no-printf-and-scanf-yet",
            "text": "In almost all articles and textbooks on C that I have seen, the  scanf  and  printf  functions are taught as the standard C library functions to perform the input and output respectively.  The function  scanf , however, is tricky to use correctly and securely.  The function  printf  comes with many nuances, such as remembering the different conversion specifiers and modifiers.  I would rather not teach you  scanf  and  printf  at this stage.  As such, CS1010 is providing you a library to perform I/O -- the library provides a small set of essential functions to read and write  long  values,  double  values, space-separated words, and lines of text.   You can find the  documentation for the CS1010 I/O Library here .  We will see how to use the library to improve our hypotenuse computation program here.",
            "title": "No printf and scanf (yet)"
        },
        {
            "location": "/06-cs1010-io/index.html#using-the-cs1010-io-library",
            "text": "Let's modify our earlier program to now read the base and height from  stdin , compute the hypotenuse, and print the results out to  stdout .   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21 #include   <math.h>  #include   \"cs1010.h\"  long   square ( long   x )   { \n   return   x * x ;  }  double   hypotenuse_of ( long   base ,   long   height )   { \n   return   sqrt ( square ( base )   +   square ( height ));  }  int   main ()   { \n   double   hypotenuse ; \n   long   base   =   cs1010_read_long (); \n   long   height   =   cs1010_read_long (); \n   hypotenuse   =   hypotenuse_of ( base ,   height ); \n   cs1010_println_double ( hypotenuse );  }    The first change you see (on Line 2) is to include the file  cs1010.h , which includes the declaration of functions provided by the library.  On Lines 17 and 18, we introduce two new  long  variables named  base  and  height , which we initialized with the returned value from  cs1010_read_long() .  The function  cs1010_read_long  reads a  long  value from  stdin  and returns the value.  For now, we assume that the inputs are correctly passed to the program.  Finally, on Line 20, we print the resulting hypotenuse to  stdout  using the library function  cs1010_println_double .  Note that there are two versions of functions to print a  double  value:  cs1010_println_double  and  cs1010_print_double .  The one with  println  prints a new line character so that the text that got printed after appears in the next line.  Refer to  CS1010 Compilation Guide  on how to compile a program that uses the CS1010 I/O library.  Note that the  main  function above can be written as a single statement without any state and assignment.  The resulting code, however, is not necessarily easier to understand. 1\n2\n3\n4 int   main ()   { \n   cs1010_println_double ( hypotenuse_of ( cs1010_read_long (),   cs1010_read_long ()));  }",
            "title": "Using the CS1010 I/O Library"
        },
        {
            "location": "/07-arithmetic-ops/index.html",
            "text": "Unit 7: Arithmetic Operations\n\n\nYou have seen the \n+\n operator in the previous units.  You can use \n+\n to add two variables, a value and a variable, or two values:\n\n\n1\n2\n3\n4\n5\n6\nlong\n \na\n \n=\n \n1\n;\n\n\nlong\n \nb\n \n=\n \n2\n;\n\n\nlong\n \nc\n \n=\n \n3\n;\n\n\na\n \n=\n \nb\n \n+\n \nc\n;\n \n// add two variables\n\n\nb\n \n=\n \na\n \n+\n \n4\n;\n \n// add a variable to a value\n\n\nc\n \n=\n \n5\n \n+\n \n6\n;\n \n// add two values\n\n\n\n\n\n\n\nYou can also use \n+\n on values returned by functions:\n\n\n1\nhypotenuse\n \n=\n \nsqrt\n(\nsquare\n(\nbase\n)\n \n+\n \nsquare\n(\nheight\n));\n\n\n\n\n\n\n\nYou have also seen the multiplication operator \n*\n.  It can be used in the same way as the \n+\n operator.  Three other useful operators are:\n\n\n\n\n/\n - division (e.g., \ndouble half_x = x / 2;\n)\n\n\n-\n - subtraction (e.g., \nlong deducted = income - 100\n)\n\n\n%\n - modulo (e.g, \nlong last_digit = number % 10\n);\n\n\n\n\nThe \n+\n, \n-\n, \n*\n, and \n/\n operators work on both integer types (\nchar\n, \nshort\n, \nint\n, \nlong\n, \nlong long\n) and real numbers (\nfloat\n, \ndouble\n).  The module operator \n%\n works only on integer types.\n\n\nOperator Precedence\n\n\nWe can chain the operations together to form expressions such as:\n\n\n1\n2\n3\nlong\n \nb\n \n=\n \n10\n;\n\n\nlong\n \nc\n \n=\n \n2\n;\n\n\nlong\n \na\n \n=\n \nb\n \n+\n \n2\n \n*\n \nc\n \n/\n \n4\n;\n\n\n\n\n\n\n\nWhen we have multiple operations appearing, however, it becomes harder to trace the sequence of evaluation.  What is the value of \na\n after the three lines above are executed?\n\n\nC actually has well-defined rules to the order of evaluation for the operators: \n*\n, \n/\n, and \n%\n take precedence over \n+\n and \n-\n, and the operators are evaluated from left to right.  \n\n\nThus, in the example above, \na\n will be 11 instead of 6 after the execution.\n\n\nTo change the order of execution, we can add parenthesis to the expression.  For instance:\n\n\n1\n2\nlong\n \na\n \n=\n \n(\nb\n \n+\n \n2\n)\n \n*\n \nc\n \n/\n \n4\n;\n \n// 6\n\n\nlong\n \na\n \n=\n \nb\n \n+\n \n(\n2\n \n*\n \nc\n \n/\n \n4\n);\n \n// 11\n\n\n\n\n\n\n\nThe expression in the parenthesis will be evaluated first.  To make your code easier to understand, \nyou should add parenthesis even if the order of evaluation is from left to right\n to make the order of evaluation explicit.\n\n\nCompound Operators\n\n\nIt is common to modify the value of a variable and store new value back to the same variable.  For example,\n\n\n1\n2\nindex\n \n=\n \nindex\n \n+\n \n1\n;\n  \n// increment the variable index\n\n\nage\n \n=\n \nage\n \n*\n \n2\n;\n  \n// double the variable age\n\n\n\n\n\n\n\nC provides \ncompound operators\n that simplify the expressions above.  For example,\n\n\n1\n2\nindex\n \n+=\n \n1\n;\n\n\nage\n \n*=\n \n2\n;\n\n\n\n\n\n\n\nThe syntax for a compound operator is \nop=\n, where \nop\n can be \n+\n, \n-\n, \n*\n, \n/\n, \n%\n, or other binary operators.  The statement:\n\n\n1\na op= b;\n\n\n\n\n\n\nmodifies \na\n the same way as:\n\n\n1\na = a op b\n\n\n\n\n\n\nCommon Mistakes Using Arithmetic Operations\n\n\nIt is important to remember that, when arithmetic operations in C is performed on a sequence of bits, where the value that it can represent is limited and is determined by its type.  A common mistake for beginner programmers is to forget this fact and treat the arithmetic operations as the same as the ones seen in mathematics.  \n\n\nLet's look at two common gotchas.\n\n\nOverflow\n\n\nConsider the following code:\n\n\n1\n2\nuint8_t\n \nc\n \n=\n \n255\n;\n\n\nc\n \n+=\n \n1\n;\n\n\n\n\n\n\n\nWhat is the value of variable \nc\n after the operation above?\n\n\nHere, we are adding one to the value 255, so \nc\n must store the value 256, right?\n\n\nIt turns out that after the execution above, \nc\n contains the value 0.  The variable \nc\n is of the type \nuint8_t\n, which is the unsigned 8-bit integer.  Being 8-bit, the variable can store values from 0 to 255.  When we add 1 to 255, even though we get the result 256, mathematically, we cannot store 256 in \nc\n -- there is not enough bits!  In this case, the value stored is \"wrap around\", and we get the value 0 instead.\n\n\nThe variable \nc\n above is unsigned. It gets trickier if \nc\n is signed.  In the case of overflowing signed integer, the behavior depends on the compiler and is undefined in the C standard.\n\n\nInteger Division\n\n\nNow, let's consider the following code:\n\n\n1\ndouble\n \nhalf\n \n=\n \n3\n/\n2\n;\n\n\n\n\n\n\n\nWhat is the value of variable \nhalf\n after the operation above?\n\n\nIt got to be 1.5, right?  \n\n\nIt turns out that, after executing the code above, the value of \nhalf\n is 1.0.  \n\n\nTo understand this, first, let's see what happen when we assign a floating point number to an integer type:\n\n\n1\nint\n \nx\n \n=\n \n1.5\n;\n\n\n\n\n\n\n\nC truncates the floating number and only stores the integer part of the value, 1 in this case, in \nx\n.\n\n\nSecond, when we perform an arithmetic operation, the resulting value will be an integer if both values are integer types.  If one of the operands is a floating point number, the result will be a floating point number\n1\n.\n\n\nSince 3 and 2 are both integers, the resulting value 1.5 are stored in an integer, which causes it to become 1.  We then store 1 into a \ndouble\n variable, causing the value of \nhalf\n to become \n1.0\n.\n\n\nBecause of this limitation, the operation \n/\n is sometimes also known as integer division when both operands are integers.  \n\n\nIn order to get the result 1.5 as expected, we can write either:\n\n1\ndouble\n \nhalf\n \n=\n \n3\n/\n2.0\n;\n\n\n\n\n\n\nor \n\n\n1\ndouble\n \nhalf\n \n=\n \n3\n/\n(\ndouble\n)\n2\n;\n\n\n\n\n\n\n\nThe second fix above explicitly convert the type, or \ncast\n the type of value 2 into a \ndouble\n.\n\n\nAvoid Increment / Decrement Operator\n\n\nIf you read C code in other places, you will certainly come across the increment or decrement operator, \n++\n or \n--\n.  The operators add one and minus one from the operand respectively.  So, the statement\n\n\n1\nindex\n \n+=\n \n1\n;\n\n\n\n\n\n\n\ncan be further shortened into \n\n\n1\nindex++;\n\n\n\n\n\n\nand the statement\n\n\n1\nindex\n \n-=\n \n1\n;\n\n\n\n\n\n\n\ncan be further shorten into \n\n\n1\nindex--;\n\n\n\n\n\n\nUsing these two operators only shorten your code by two characters per statement, but introduces several issues.  As such, we \nban the use of both increment and decrement operator in CS1010\n.\n\n\nSo, why aren't \n++\n and \n--\n welcomed in CS1010?  The \n++\n and \n--\n operators not only modify the value of the operand, it also returns a value.  We can write \nj = i++;\n to both increment \ni\n and assign the pre-incremented value of \ni\n to \nj\n.  In C, we can also write \nj = ++i;\n, which again, increment \ni\n, and assign the post-incremented value of \ni\n to \nj\n.  Things get tricky, when we write \ni = i++;\n, it is not clear how to interpret this.  The C standard leaves this behavior undefined and leaves it to the compiler to define its behavior.  Wei Tsang thinks that introducing all these complexities just to save two characters is not warranted.\n\n\n\n\n\n\n\n\n\n\nThe actual rules used by C, called \ninteger promotion\n and \nusual arithmetic conversion\n, are much more complex and are outside the scope of CS1010.  You should take a note of this, however, and in a later part of your study or career, if you need to delve deeper into writing or debugging C code, take a look at \nthis\n.\u00a0\n\u21a9",
            "title": "7. Arithmetic Operations"
        },
        {
            "location": "/07-arithmetic-ops/index.html#unit-7-arithmetic-operations",
            "text": "You have seen the  +  operator in the previous units.  You can use  +  to add two variables, a value and a variable, or two values:  1\n2\n3\n4\n5\n6 long   a   =   1 ;  long   b   =   2 ;  long   c   =   3 ;  a   =   b   +   c ;   // add two variables  b   =   a   +   4 ;   // add a variable to a value  c   =   5   +   6 ;   // add two values    You can also use  +  on values returned by functions:  1 hypotenuse   =   sqrt ( square ( base )   +   square ( height ));    You have also seen the multiplication operator  * .  It can be used in the same way as the  +  operator.  Three other useful operators are:   /  - division (e.g.,  double half_x = x / 2; )  -  - subtraction (e.g.,  long deducted = income - 100 )  %  - modulo (e.g,  long last_digit = number % 10 );   The  + ,  - ,  * , and  /  operators work on both integer types ( char ,  short ,  int ,  long ,  long long ) and real numbers ( float ,  double ).  The module operator  %  works only on integer types.",
            "title": "Unit 7: Arithmetic Operations"
        },
        {
            "location": "/07-arithmetic-ops/index.html#operator-precedence",
            "text": "We can chain the operations together to form expressions such as:  1\n2\n3 long   b   =   10 ;  long   c   =   2 ;  long   a   =   b   +   2   *   c   /   4 ;    When we have multiple operations appearing, however, it becomes harder to trace the sequence of evaluation.  What is the value of  a  after the three lines above are executed?  C actually has well-defined rules to the order of evaluation for the operators:  * ,  / , and  %  take precedence over  +  and  - , and the operators are evaluated from left to right.    Thus, in the example above,  a  will be 11 instead of 6 after the execution.  To change the order of execution, we can add parenthesis to the expression.  For instance:  1\n2 long   a   =   ( b   +   2 )   *   c   /   4 ;   // 6  long   a   =   b   +   ( 2   *   c   /   4 );   // 11    The expression in the parenthesis will be evaluated first.  To make your code easier to understand,  you should add parenthesis even if the order of evaluation is from left to right  to make the order of evaluation explicit.",
            "title": "Operator Precedence"
        },
        {
            "location": "/07-arithmetic-ops/index.html#compound-operators",
            "text": "It is common to modify the value of a variable and store new value back to the same variable.  For example,  1\n2 index   =   index   +   1 ;    // increment the variable index  age   =   age   *   2 ;    // double the variable age    C provides  compound operators  that simplify the expressions above.  For example,  1\n2 index   +=   1 ;  age   *=   2 ;    The syntax for a compound operator is  op= , where  op  can be  + ,  - ,  * ,  / ,  % , or other binary operators.  The statement:  1 a op= b;   modifies  a  the same way as:  1 a = a op b",
            "title": "Compound Operators"
        },
        {
            "location": "/07-arithmetic-ops/index.html#common-mistakes-using-arithmetic-operations",
            "text": "It is important to remember that, when arithmetic operations in C is performed on a sequence of bits, where the value that it can represent is limited and is determined by its type.  A common mistake for beginner programmers is to forget this fact and treat the arithmetic operations as the same as the ones seen in mathematics.    Let's look at two common gotchas.",
            "title": "Common Mistakes Using Arithmetic Operations"
        },
        {
            "location": "/07-arithmetic-ops/index.html#overflow",
            "text": "Consider the following code:  1\n2 uint8_t   c   =   255 ;  c   +=   1 ;    What is the value of variable  c  after the operation above?  Here, we are adding one to the value 255, so  c  must store the value 256, right?  It turns out that after the execution above,  c  contains the value 0.  The variable  c  is of the type  uint8_t , which is the unsigned 8-bit integer.  Being 8-bit, the variable can store values from 0 to 255.  When we add 1 to 255, even though we get the result 256, mathematically, we cannot store 256 in  c  -- there is not enough bits!  In this case, the value stored is \"wrap around\", and we get the value 0 instead.  The variable  c  above is unsigned. It gets trickier if  c  is signed.  In the case of overflowing signed integer, the behavior depends on the compiler and is undefined in the C standard.",
            "title": "Overflow"
        },
        {
            "location": "/07-arithmetic-ops/index.html#integer-division",
            "text": "Now, let's consider the following code:  1 double   half   =   3 / 2 ;    What is the value of variable  half  after the operation above?  It got to be 1.5, right?    It turns out that, after executing the code above, the value of  half  is 1.0.    To understand this, first, let's see what happen when we assign a floating point number to an integer type:  1 int   x   =   1.5 ;    C truncates the floating number and only stores the integer part of the value, 1 in this case, in  x .  Second, when we perform an arithmetic operation, the resulting value will be an integer if both values are integer types.  If one of the operands is a floating point number, the result will be a floating point number 1 .  Since 3 and 2 are both integers, the resulting value 1.5 are stored in an integer, which causes it to become 1.  We then store 1 into a  double  variable, causing the value of  half  to become  1.0 .  Because of this limitation, the operation  /  is sometimes also known as integer division when both operands are integers.    In order to get the result 1.5 as expected, we can write either: 1 double   half   =   3 / 2.0 ;    or   1 double   half   =   3 / ( double ) 2 ;    The second fix above explicitly convert the type, or  cast  the type of value 2 into a  double .",
            "title": "Integer Division"
        },
        {
            "location": "/07-arithmetic-ops/index.html#avoid-increment-decrement-operator",
            "text": "If you read C code in other places, you will certainly come across the increment or decrement operator,  ++  or  -- .  The operators add one and minus one from the operand respectively.  So, the statement  1 index   +=   1 ;    can be further shortened into   1 index++;   and the statement  1 index   -=   1 ;    can be further shorten into   1 index--;   Using these two operators only shorten your code by two characters per statement, but introduces several issues.  As such, we  ban the use of both increment and decrement operator in CS1010 .  So, why aren't  ++  and  --  welcomed in CS1010?  The  ++  and  --  operators not only modify the value of the operand, it also returns a value.  We can write  j = i++;  to both increment  i  and assign the pre-incremented value of  i  to  j .  In C, we can also write  j = ++i; , which again, increment  i , and assign the post-incremented value of  i  to  j .  Things get tricky, when we write  i = i++; , it is not clear how to interpret this.  The C standard leaves this behavior undefined and leaves it to the compiler to define its behavior.  Wei Tsang thinks that introducing all these complexities just to save two characters is not warranted.      The actual rules used by C, called  integer promotion  and  usual arithmetic conversion , are much more complex and are outside the scope of CS1010.  You should take a note of this, however, and in a later part of your study or career, if you need to delve deeper into writing or debugging C code, take a look at  this .\u00a0 \u21a9",
            "title": "Avoid Increment / Decrement Operator"
        },
        {
            "location": "/08-if-else/index.html",
            "text": "Unit 8: Conditional Statement\n\n\nSo far the C programs that we have written has a straightforward \nexecution path\n.  The execution flows from top to bottom in \nmain\n, jumping to a function being called (or \ncallee\n), and back to the caller when the function returns.\n\n\nWe have, however, seen a few examples so far where the execution path can \nbranch\n off to either one of two paths, depends on a condition:\n\n\n\n\nIn the algorithm to compute the \nmax(L, k)\nmax(L, k)\n, we check if \nl_i > m\nl_i > m\n, and update \nm\nm\n only if this is true.  \n\n\nIn the algorithm to compute the \nfactorial(n)\nfactorial(n)\n, we check if \nn\nn\n equals 0, and return 1 if it is true, otherwise, we return \nn \\times factorial(n-1)\nn \\times factorial(n-1)\n.\n\n\n\n\nWe are not ready to write C code that processes a list yet, so let's use the \nfactorial(n)\nfactorial(n)\n function as an example.  In C, the \nfactorial(n)\nfactorial(n)\n would look like this:\n\n\n1\n2\n3\n4\n5\n6\n7\nlong\n \nfactorial\n(\nlong\n \nn\n)\n \n\n{\n\n  \nif\n \n(\nn\n \n==\n \n0\n)\n \n{\n\n    \nreturn\n \n1\n;\n\n  \n}\n\n  \nreturn\n \nn\n \n*\n \nfactorial\n(\nn\n \n-\n \n1\n);\n\n\n}\n\n\n\n\n\n\n\n\n\nIn this example, you see a new C keyword \nif\n.  This keyword is used at the beginning of a conditional block of code.  The general syntax is:\n\n\n1\n2\n3\nif\n \n(\n<\nlogical\n \nexpression\n>\n)\n \n{\n \n  \n\"true block\"\n:\n \nstatements\n \nto\n \nbe\n \nexecuted\n \nif\n \nexpression\n \nevaluates\n \nto\n \ntrue\n\n\n}\n\n\n\n\n\n\n\nThe \nif\n keyword is followed by a \nlogical expression\n in parenthesis.  This is followed by a block of statements (in curly braces \n{\n and \n}\n).  If the logical expression is true, then the statements are executed, otherwise, they are skipped.  For this reason, the group of statements is known as a \ntrue block\n.\n\n\nComparison Operator\n\n\nThe logical expression \nn == 0\n is true if the variable \nn\n holds the value of \n0\n.  \n\n\n\n\n==\n vs \n=\n\n\nNote that use of TWO \n=\n signs.  This is often confused by newbie programmers with a single \n=\n sign, which is used for assignment.  A common bug is to write\n\n\n1\n2\n3\n  \nif\n \n(\nn\n \n=\n \n0\n)\n \n{\n\n     \n:\n\n  \n}\n\n\n\n\n\n\n\n\n\nThe \n==\n is known as a \ncomparison operator\n.  It compares if the left-hand side has the same value as the right-hand side. Other comparison operators include \n>\n (greater than), \n<\n (less than), \n>=\n (greater or equal to), \n<=\n (less than or equal to), and \n!=\n (not equal).\n\n\nIn other words, the function \nfactorial\n will exit and return \n1\n if the parameter \nn\n equals to \n0\n.  The rest of the code (particularly, Line \n5\n 6) will be skipped.\n\n\nWhat if \nn\n is not \n0\n?  The block that contains Line 3 \nreturn 1;\n will be skipped, and Line \n5\n 6 \nreturn n * factorial(n - 1);\n will be executed instead, which is what we intended for the \nfactorial\n function to do.\n\n\nExample: Max of two numbers\n\n\nLet's switch to another example: suppose we have three variables, \nx\n, \ny\n, and \nmax\n, and we want to set \nmax\n to the maximum of \nx\n and \ny\n.\n\n\nConsider the following code snippet:\n\n\n1\n2\n3\n4\n5\n6\nif\n \n(\nx\n \n>\n \ny\n)\n \n{\n\n  \nmax\n \n=\n \nx\n;\n\n\n}\n \n\nif\n \n(\nx\n \n<\n \ny\n)\n \n{\n\n  \nmax\n \n=\n \ny\n;\n\n\n}\n\n\n\n\n\n\n\nTake a moment to understand the code above, and see if you can figure out what is wrong.\n\n\nWhen we think about writing conditionals, we have to exhaustively reason about what are all the possible scenarios that could occur.  In this example, we need to think about what are the possible relationships between \nx\n and \ny\n when we compare \nx\n an \ny\n.  There are actually three possibilities!\n\n\n\n\nx > y\n: in this case, \nx\n is larger and we set \nmax\n to \nx\n\n\ny > x\n: in this case, \ny\n is larger and we set \nmax\n to \ny\n\n\nx == y\n: in this case, both are equally large, so the maximum of the two can be either \nx\n or \ny\n.\n\n\n\n\nIn the code above, \nmax\n is not set properly if \nx == y\n!\n\n\nThe following code adds the third case and arbitrarily chooses to set \nmax\n to \ny\n if both \nx\n and \ny\n have the same value.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nif\n \n(\nx\n \n>\n \ny\n)\n \n{\n\n  \nmax\n \n=\n \nx\n;\n\n\n}\n \n\nif\n \n(\nx\n \n<\n \ny\n)\n \n{\n\n  \nmax\n \n=\n \ny\n;\n\n\n}\n\n\nif\n \n(\nx\n \n==\n \ny\n)\n \n{\n\n  \nmax\n \n=\n \ny\n;\n\n\n}\n\n\n\n\n\n\n\nElse\n\n\nThe code snippet above now correctly sets \nmax\n to the maximum of \nx\n and \ny\n.\nThe code, however, is not very satisfying, since we compare between \nx\n and \ny\n three times.   Let's see how we can reduce the number of comparisons to one.  We are going to do some \nrefactoring\n of the code above.\n\n\nFirst, observe that the \"true block\" for \nx < y\n and \nx == y\n are the same, and we can combine it into a single comparison \nx <= y\n.\n\n\n1\n2\n3\n4\n5\n6\nif\n \n(\nx\n \n>\n \ny\n)\n \n{\n\n  \nmax\n \n=\n \nx\n;\n\n\n}\n \n\nif\n \n(\nx\n \n<=\n \ny\n)\n \n{\n\n  \nmax\n \n=\n \ny\n;\n\n\n}\n\n\n\n\n\n\n\nSecond, observe that if \nx > y\n is false, then \nx <= y\n must be true.  We say that \nx > y\n and \nx <= y\n are \nnegation\n (or opposite) of each other.  So, the check for \nx <= y\n is redundant -- checking \nx > y\n is enough to tell us if \nx <= y\n.  We can re-write the code above as:\n\n\n1\n2\n3\n4\n5\nif\n \n(\nx\n \n>\n \ny\n)\n \n{\n\n  \nmax\n \n=\n \nx\n;\n\n\n}\n \nelse\n \n{\n\n  \nmax\n \n=\n \ny\n;\n\n\n}\n\n\n\n\n\n\n\nThe word \nelse\n as seen above is another C keyword -- it must be used in conjunction with \nif\n to indicate an alternate path of execution if the logical expression is false.\n\n\n1\n2\n3\n4\n5\nif\n \n(\n<\nlogical\n \nexpression\n>\n)\n \n{\n \n  \n\"true block\"\n:\n \nstatements\n \nto\n \nbe\n \nexecuted\n \nif\n \nexpression\n \nevaluates\n \nto\n \ntrue\n\n\n}\n \nelse\n \n{\n\n  \n\"false block\"\n:\n \nstatements\n \nto\n \nbe\n \nexecuted\n \nif\n \nexpression\n \nevaluates\n \nto\n \nfalse\n\n\n}\n\n\n\n\n\n\n\nNested Else-If\n\n\nThe example above considers \ntwo\n possible execution paths only.  In some situations, we may need to consider more than two execution paths.  Take the following problem for example.  You are given the numerical score for an assignment, ranged between 0 and 10.  Print out the letter grade of the assignment according to the table below:\n\n\n\n\n\n\n\n\nScore\n\n\nLetter Grade\n\n\n\n\n\n\n\n\n\n\n8 or higher\n\n\nA\n\n\n\n\n\n\nLess than 8 but 5 or higher\n\n\nB\n\n\n\n\n\n\nLess than 5 but 3 or higher\n\n\nC\n\n\n\n\n\n\nLess than 3\n\n\nD\n\n\n\n\n\n\n\n\nSince the \nif\n-\nelse\n statement only allows branching into two possibilities, we can branch into multiple possibilities by nesting the \nif\n-\nelse\n statements hierarchically.  We can first break the table down into three tables, each containing only two rows, with one row a negation of the other row.\n\n\n\n\n\n\n\n\nScore\n\n\nLetter Grade\n\n\n\n\n\n\n\n\n\n\n8 or higher\n\n\nA\n\n\n\n\n\n\nLess than 8\n\n\nSee Table 1\n\n\n\n\n\n\n\n\nTable 1 (less than 8)\n\n\n\n\n\n\n\n\nScore\n\n\nLetter Grade\n\n\n\n\n\n\n\n\n\n\n5 or higher\n\n\nB\n\n\n\n\n\n\nLess than 5\n\n\nSee Table 2\n\n\n\n\n\n\n\n\nTable 2 (less than 5)\n\n\n\n\n\n\n\n\nScore\n\n\nLetter Grade\n\n\n\n\n\n\n\n\n\n\n3 or higher\n\n\nC\n\n\n\n\n\n\nLess than 3\n\n\nD\n\n\n\n\n\n\n\n\nThe tables above can then be written into the following function:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\nvoid\n \nprint_score\n(\ndouble\n \nscore\n)\n \n\n{\n\n  \nif\n \n(\nscore\n \n>=\n \n8\n)\n \n{\n\n    \ncs1010_println_string\n(\n\"A\"\n);\n\n  \n}\n \nelse\n \n{\n\n    \n// Table 1\n\n    \nif\n \n(\nscore\n \n>=\n \n5\n)\n \n{\n\n      \ncs1010_println_string\n(\n\"B\"\n);\n\n    \n}\n \nelse\n \n{\n\n      \n// Table 2\n\n      \nif\n \n(\nscore\n \n>=\n \n3\n)\n \n{\n\n        \ncs1010_println_string\n(\n\"C\"\n);\n\n      \n}\n \nelse\n \n{\n\n        \ncs1010_println_string\n(\n\"D\"\n);\n\n      \n}\n\n    \n}\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\nThere are three nested \nif\n-\nelse\n in the function above.  Note how I use indentation to clearly indicate the nesting of blocks.  Such nesting or indentation is not required by C standard, but is a commonly accepted coding practice, and is required for CS1010.\n\n\nThe code below compiles perfectly but is not as easy to read by a human as the above.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\nvoid\n \nprint_score\n(\ndouble\n \nscore\n)\n \n\n{\n\n  \nif\n \n(\nscore\n \n>=\n \n8\n)\n \n{\n\n    \ncs1010_println_string\n(\n\"A\"\n);\n \n}\n \nelse\n \n{\n \n// Table 1 \n\n    \nif\n \n(\nscore\n \n>=\n \n5\n)\n \n{\n \ncs1010_println_string\n(\n\"B\"\n);\n\n  \n}\n \nelse\n \n{\n \n// Table 2\n\n\nif\n \n(\nscore\n \n>=\n \n3\n)\n \n{\n\n  \ncs1010_println_string\n(\n\"C\"\n);\n\n      \n}\n \nelse\n \n{\n\n        \ncs1010_println_string\n(\n\"D\"\n);\n\n    \n}\n \n}\n \n}\n \n}\n\n\n// Don't write code like this.\n\n\n\n\n\n\n\nThere are also a couple of \"first\" in the sample code above:\n\n\n\n\nYou see the keyword \nvoid\n for the first time.  \nvoid\n is a special type that indicates nothing.  The function \nprint_score\n does not return anything, it accepts an input \nscore\n and print something to screen.  As such, we say that the return type of \nprint_score\n is \nvoid\n.\n\n\nYou see \nstrings\n for the first time (\n\"A\"\n, etc.).  A \nstring\n basically is a sequence of characters.  We use double quotes \n\"\n to mark the beginning and the end of a string, and use the CS1010 I/O library function \ncs1010_println_string\n to print a string to the screen. \n\n\n\n\nYou can imagine that as the number of possible letter grades increases (NUS has 11), we will have many nested \nif\n-\nelse\n, and the code gets complicated.  To reduce the number of nesting, we can write \nelse if\n directly, without nesting:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\nvoid\n \nprint_score\n(\ndouble\n \nscore\n)\n \n\n{\n\n  \nif\n \n(\nscore\n \n>=\n \n8\n)\n \n{\n\n    \ncs1010_println_string\n(\n\"A\"\n);\n\n  \n}\n \nelse\n \nif\n \n(\nscore\n \n>=\n \n5\n)\n \n{\n\n    \ncs1010_println_string\n(\n\"B\"\n);\n\n  \n}\n \nelse\n \nif\n \n(\nscore\n \n>=\n \n3\n)\n \n{\n\n    \ncs1010_println_string\n(\n\"C\"\n);\n\n  \n}\n \nelse\n \n{\n\n    \ncs1010_println_string\n(\n\"D\"\n);\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\nThe above code is easier to read, but has exactly the same flow as the one with nested \nif\n-\nelse\n earlier.\n\n\nAvoid Skipping the Curly Braces\n\n\nThe C standard says that, if the block contains only one statement, we can skip the curly braces \n{\n and \n}\n.  In the example above, we can write:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\nvoid\n \nprint_score\n(\ndouble\n \nscore\n)\n \n\n{\n\n  \nif\n \n(\nscore\n \n>=\n \n8\n)\n \n    \ncs1010_println_string\n(\n\"A\"\n);\n\n  \nelse\n \nif\n \n(\nscore\n \n>=\n \n5\n)\n\n    \ncs1010_println_string\n(\n\"B\"\n);\n\n  \nelse\n \nif\n \n(\nscore\n \n>=\n \n3\n)\n\n    \ncs1010_println_string\n(\n\"C\"\n);\n\n  \nelse\n\n    \ncs1010_println_string\n(\n\"D\"\n);\n\n\n}\n\n\n\n\n\n\n\nDespite being allowed by the C standard, this is considered a bad practice, and should be avoided.  Imagine some time later, you go back to this code, and want to write something extra:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\nvoid\n \nprint_score\n(\ndouble\n \nscore\n)\n \n\n{\n\n  \nif\n \n(\nscore\n \n>=\n \n8\n)\n \n    \ncs1010_println_string\n(\n\"A\"\n);\n\n  \nelse\n \nif\n \n(\nscore\n \n>=\n \n5\n)\n\n    \ncs1010_println_string\n(\n\"B\"\n);\n\n  \nelse\n \nif\n \n(\nscore\n \n>=\n \n3\n)\n\n    \ncs1010_println_string\n(\n\"C\"\n);\n\n  \nelse\n\n    \ncs1010_println_string\n(\n\"You can do better!\"\n);\n\n    \ncs1010_println_string\n(\n\"D\"\n);\n\n\n}\n\n\n\n\n\n\n\nWhat would be printed?\n\n\nThe famous \nApple \ngoto fail\n bug\n wouldn't have happened in the there is a pair of curly braces added!\n\n\nAlternatively, if you have code like this:\n\n\n1\n2\n3\n4\n5\nif\n \n(\nscore\n \n>=\n \n8\n)\n\n  \nif\n \n(\nlate_penalty\n \n!=\n \n0\n)\n \n      \ncs1010_println_string\n(\n\"late submission\"\n);\n\n\nelse\n \n  \ncs1010_println_string\n(\n\"you can do better!\"\n);\n\n\n\n\n\n\n\nIt might look like \nyou can do better!\n will be printed if \nscore\n is less than 8, but actually, \nyou can do better!\n will be printed if the \nscore\n is larger or equal to 8 and there is no late penalty, which is not what is intended.\n\n\nConditional Operator\n\n\nThe conditional operator consists of two special characters \n?\n and \n:\n and is used in the format of:\n\n\n1\ncondition ? true expression : false expression;\n\n\n\n\n\n\nIf the \ncondition\n evaluates to true, then the \ntrue expression\n will be evaluated and returned, otherwise, the \nfalse expression\n will be evaluated and returned.\n\n\nThe conditional operator allows us to replace\n\n\n1\n2\n3\n4\n5\nif\n \n(\nx\n \n>\n \ny\n)\n \n{\n\n  \nmax\n \n=\n \nx\n;\n\n\n}\n \nelse\n \n{\n\n  \nmax\n \n=\n \ny\n;\n\n\n}\n\n\n\n\n\n\n\nwith a single line:\n\n\n1\nmax = (x > y) ? x : y;\n\n\n\n\n\n\nWe can nest the conditional operator as well, but it does not necessarily make your code easier to read once you start nesting them up.  We do not encourage you to nest the conditional operator in CS1010 and to limit its usage to simple cases above.\n\n\nComparing Real Numbers\n\n\nRecall that we said \nreal numbers cannot be represented exactly in computers\n.  Comparing real numbers, therefore, becomes a little bit trickier in programming.  The \nif\n statement\n\n\n1\n2\n3\n4\n5\ndouble\n \nexpected_value\n \n=\n \n0.3\n;\n\n\ndouble\n \nsum\n \n=\n \n0.1\n \n+\n \n0.2\n;\n\n\nif\n \n(\nsum\n \n==\n \nexpected_value\n)\n \n{\n\n \n:\n\n\n}\n\n\n\n\n\n\n\nwould not be evaluated as \ntrue\n as expected!\n\n\nThus, to compare real numbers, we normally allow some errors in comparisons -- we want the absolute difference between \nsum\n and \nexpected_value\n to be small enough.\n\n\n1\n2\n3\n4\n5\ndouble\n \nexpected_value\n \n=\n \n0.3\n;\n\n\ndouble\n \nsum\n \n=\n \n0.1\n \n+\n \n0.2\n;\n\n\nif\n \n(\nfabs\n(\nsum\n \n-\n \nexpected_value\n)\n \n<\n \n0.000001\n)\n \n{\n\n \n:\n\n\n}\n\n\n\n\n\n\n\nProblem Sets\n\n\nProblem 8.1\n\n\n(a) Do the following two functions behave the same way?  Explain.\n\n\n1\n2\n3\n4\n5\n6\n7\nlong\n \nfactorial\n(\nlong\n \nn\n)\n \n\n{\n\n  \nif\n \n(\nn\n \n==\n \n0\n)\n \n{\n\n    \nreturn\n \n1\n;\n\n  \n}\n\n  \nreturn\n \nn\n \n*\n \nfactorial\n(\nn\n \n-\n \n1\n);\n\n\n}\n\n\n\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\nlong\n \nfactorial\n(\nlong\n \nn\n)\n \n\n{\n\n  \nif\n \n(\nn\n \n==\n \n0\n)\n \n{\n\n    \nreturn\n \n1\n;\n\n  \n}\n \nelse\n \n{\n\n    \nreturn\n \nn\n \n*\n \nfactorial\n(\nn\n \n-\n \n1\n);\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\n(b) How about:\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nlong\n \nfactorial\n(\nlong\n \nn\n)\n \n\n{\n\n  \nlong\n \nresult\n;\n\n  \nif\n \n(\nn\n \n==\n \n0\n)\n \n{\n\n    \nresult\n \n=\n \n1\n;\n\n  \n}\n\n  \nresult\n \n=\n \nn\n \n*\n \nfactorial\n(\nn\n \n-\n \n1\n);\n\n  \nreturn\n \nresult\n;\n\n\n}\n\n\n\n\n\n\n\nand \n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\nlong\n \nfactorial\n(\nlong\n \nn\n)\n \n\n{\n\n  \nlong\n \nresult\n;\n\n  \nif\n \n(\nn\n \n==\n \n0\n)\n \n{\n\n    \nresult\n \n=\n \n1\n;\n\n  \n}\n \nelse\n \n{\n\n    \nresult\n \n=\n \nn\n \n*\n \nfactorial\n(\nn\n \n-\n \n1\n);\n\n  \n}\n\n  \nreturn\n \nresult\n;\n\n\n}\n\n\n\n\n\n\n\nProblem 8.2\n\n\nDraw the flowchart for the code snippet\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nif\n \n(\nx\n \n>\n \ny\n)\n \n{\n\n  \nmax\n \n=\n \nx\n;\n\n\n}\n \n\nif\n \n(\nx\n \n<\n \ny\n)\n \n{\n\n  \nmax\n \n=\n \ny\n;\n\n\n}\n\n\nif\n \n(\nx\n \n==\n \ny\n)\n \n{\n\n  \nmax\n \n=\n \ny\n;\n\n\n}\n\n\n\n\n\n\n\nand\n\n\n1\n2\n3\n4\n5\nif\n \n(\nx\n \n>\n \ny\n)\n \n{\n\n  \nmax\n \n=\n \nx\n;\n\n\n}\n \nelse\n \n{\n\n  \nmax\n \n=\n \ny\n;\n\n\n}\n\n\n\n\n\n\n\nProblem 8.3\n\n\nSuppose we break down the table below in a slightly different way.\n\n\n\n\n\n\n\n\nScore\n\n\nLetter Grade\n\n\n\n\n\n\n\n\n\n\n8 or higher\n\n\nA\n\n\n\n\n\n\nLess than 8 but 5 or higher\n\n\nB\n\n\n\n\n\n\nLess than 5 but 3 or higher\n\n\nC\n\n\n\n\n\n\nLess than 3\n\n\nD\n\n\n\n\n\n\n\n\nWe rewrite the tables into three smaller tables, as:\n\n\n\n\n\n\n\n\nScore\n\n\nLetter Grade\n\n\n\n\n\n\n\n\n\n\n5 or higher\n\n\nSee Table 3\n\n\n\n\n\n\nLess than 5\n\n\nSee Table 4\n\n\n\n\n\n\n\n\nwhere Table 3 (5 or higher) is\n\n\n\n\n\n\n\n\nScore\n\n\nLetter Grade\n\n\n\n\n\n\n\n\n\n\n8 or higher\n\n\nA\n\n\n\n\n\n\nLess than 8\n\n\nB\n\n\n\n\n\n\n\n\nand Table 4 (less than 5) is\n\n\n\n\n\n\n\n\nScore\n\n\nLetter Grade\n\n\n\n\n\n\n\n\n\n\n3 or higher\n\n\nC\n\n\n\n\n\n\nLess than 3\n\n\nD\n\n\n\n\n\n\n\n\nWrite the corresponding \nif\n-\nelse\n statements to print out the letter grade based on the tables above.\n\n\nAppendix: Code From Lecture\n\n\nHere are the C files that Wei Tsang wrote during the lecture.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n#include\n \n\"cs1010.h\"\n\n\n\nlong\n \nfactorial\n(\nlong\n \nn\n)\n\n\n{\n\n  \nif\n \n(\nn\n \n==\n \n0\n)\n \n{\n\n    \nreturn\n \n1\n;\n\n  \n}\n \n  \nreturn\n \nn\n \n*\n \nfactorial\n(\nn\n-\n1\n);\n\n\n}\n\n\n\nint\n \nmain\n()\n\n\n{\n\n  \nlong\n \nn\n \n=\n \ncs1010_read_long\n();\n\n  \nlong\n \nfac\n \n=\n \nfactorial\n(\nn\n);\n\n  \ncs1010_println_long\n(\nfac\n);\n\n\n}\n\n\n\n\n\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n#include\n \n\"cs1010.h\"\n\n\n\nlong\n \nmax\n(\nlong\n \nx\n,\n \nlong\n \ny\n)\n\n\n{\n\n  \nif\n \n(\nx\n \n>\n \ny\n)\n \n{\n\n    \nreturn\n \nx\n;\n\n  \n}\n \nelse\n \n{\n\n    \nreturn\n \ny\n;\n\n  \n}\n\n  \n// alternatively, using the conditional operator ? :\n\n  \n// return (x > y) ? x : y;\n\n\n}\n\n\n\nint\n \nmain\n()\n\n\n{\n\n  \nlong\n \nx\n \n=\n \ncs1010_read_long\n();\n\n  \nlong\n \ny\n \n=\n \ncs1010_read_long\n();\n\n  \nlong\n \nm\n \n=\n \nmax\n(\nx\n,\n \ny\n);\n\n  \ncs1010_println_long\n(\nm\n);\n\n\n}\n\n\n\n\n\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n#include\n \n\"cs1010.h\"\n\n\n\nvoid\n \nprint_score\n(\ndouble\n \nx\n)\n\n\n{\n\n  \nif\n \n(\nx\n \n>=\n \n8\n)\n\n    \ncs1010_println_string\n(\n\"A\"\n);\n\n  \nelse\n \nif\n \n(\nx\n \n>=\n \n5\n)\n\n    \ncs1010_println_string\n(\n\"B\"\n);\n\n  \nelse\n \nif\n \n(\nx\n \n>=\n \n3\n)\n\n    \ncs1010_println_string\n(\n\"C\"\n);\n\n  \nelse\n\n    \ncs1010_println_string\n(\n\"D\"\n);\n\n\n}\n\n\n\nint\n \nmain\n()\n\n\n{\n\n  \ndouble\n \nscore\n \n=\n \ncs1010_read_double\n();\n\n  \nprint_score\n(\nscore\n);\n\n\n}",
            "title": "8. If Else"
        },
        {
            "location": "/08-if-else/index.html#unit-8-conditional-statement",
            "text": "So far the C programs that we have written has a straightforward  execution path .  The execution flows from top to bottom in  main , jumping to a function being called (or  callee ), and back to the caller when the function returns.  We have, however, seen a few examples so far where the execution path can  branch  off to either one of two paths, depends on a condition:   In the algorithm to compute the  max(L, k) max(L, k) , we check if  l_i > m l_i > m , and update  m m  only if this is true.    In the algorithm to compute the  factorial(n) factorial(n) , we check if  n n  equals 0, and return 1 if it is true, otherwise, we return  n \\times factorial(n-1) n \\times factorial(n-1) .   We are not ready to write C code that processes a list yet, so let's use the  factorial(n) factorial(n)  function as an example.  In C, the  factorial(n) factorial(n)  would look like this:  1\n2\n3\n4\n5\n6\n7 long   factorial ( long   n )   { \n   if   ( n   ==   0 )   { \n     return   1 ; \n   } \n   return   n   *   factorial ( n   -   1 );  }     In this example, you see a new C keyword  if .  This keyword is used at the beginning of a conditional block of code.  The general syntax is:  1\n2\n3 if   ( < logical   expression > )   {  \n   \"true block\" :   statements   to   be   executed   if   expression   evaluates   to   true  }    The  if  keyword is followed by a  logical expression  in parenthesis.  This is followed by a block of statements (in curly braces  {  and  } ).  If the logical expression is true, then the statements are executed, otherwise, they are skipped.  For this reason, the group of statements is known as a  true block .",
            "title": "Unit 8: Conditional Statement"
        },
        {
            "location": "/08-if-else/index.html#comparison-operator",
            "text": "The logical expression  n == 0  is true if the variable  n  holds the value of  0 .     ==  vs  =  Note that use of TWO  =  signs.  This is often confused by newbie programmers with a single  =  sign, which is used for assignment.  A common bug is to write  1\n2\n3    if   ( n   =   0 )   { \n      : \n   }     The  ==  is known as a  comparison operator .  It compares if the left-hand side has the same value as the right-hand side. Other comparison operators include  >  (greater than),  <  (less than),  >=  (greater or equal to),  <=  (less than or equal to), and  !=  (not equal).  In other words, the function  factorial  will exit and return  1  if the parameter  n  equals to  0 .  The rest of the code (particularly, Line  5  6) will be skipped.  What if  n  is not  0 ?  The block that contains Line 3  return 1;  will be skipped, and Line  5  6  return n * factorial(n - 1);  will be executed instead, which is what we intended for the  factorial  function to do.",
            "title": "Comparison Operator"
        },
        {
            "location": "/08-if-else/index.html#example-max-of-two-numbers",
            "text": "Let's switch to another example: suppose we have three variables,  x ,  y , and  max , and we want to set  max  to the maximum of  x  and  y .  Consider the following code snippet:  1\n2\n3\n4\n5\n6 if   ( x   >   y )   { \n   max   =   x ;  }   if   ( x   <   y )   { \n   max   =   y ;  }    Take a moment to understand the code above, and see if you can figure out what is wrong.  When we think about writing conditionals, we have to exhaustively reason about what are all the possible scenarios that could occur.  In this example, we need to think about what are the possible relationships between  x  and  y  when we compare  x  an  y .  There are actually three possibilities!   x > y : in this case,  x  is larger and we set  max  to  x  y > x : in this case,  y  is larger and we set  max  to  y  x == y : in this case, both are equally large, so the maximum of the two can be either  x  or  y .   In the code above,  max  is not set properly if  x == y !  The following code adds the third case and arbitrarily chooses to set  max  to  y  if both  x  and  y  have the same value.  1\n2\n3\n4\n5\n6\n7\n8\n9 if   ( x   >   y )   { \n   max   =   x ;  }   if   ( x   <   y )   { \n   max   =   y ;  }  if   ( x   ==   y )   { \n   max   =   y ;  }",
            "title": "Example: Max of two numbers"
        },
        {
            "location": "/08-if-else/index.html#else",
            "text": "The code snippet above now correctly sets  max  to the maximum of  x  and  y .\nThe code, however, is not very satisfying, since we compare between  x  and  y  three times.   Let's see how we can reduce the number of comparisons to one.  We are going to do some  refactoring  of the code above.  First, observe that the \"true block\" for  x < y  and  x == y  are the same, and we can combine it into a single comparison  x <= y .  1\n2\n3\n4\n5\n6 if   ( x   >   y )   { \n   max   =   x ;  }   if   ( x   <=   y )   { \n   max   =   y ;  }    Second, observe that if  x > y  is false, then  x <= y  must be true.  We say that  x > y  and  x <= y  are  negation  (or opposite) of each other.  So, the check for  x <= y  is redundant -- checking  x > y  is enough to tell us if  x <= y .  We can re-write the code above as:  1\n2\n3\n4\n5 if   ( x   >   y )   { \n   max   =   x ;  }   else   { \n   max   =   y ;  }    The word  else  as seen above is another C keyword -- it must be used in conjunction with  if  to indicate an alternate path of execution if the logical expression is false.  1\n2\n3\n4\n5 if   ( < logical   expression > )   {  \n   \"true block\" :   statements   to   be   executed   if   expression   evaluates   to   true  }   else   { \n   \"false block\" :   statements   to   be   executed   if   expression   evaluates   to   false  }",
            "title": "Else"
        },
        {
            "location": "/08-if-else/index.html#nested-else-if",
            "text": "The example above considers  two  possible execution paths only.  In some situations, we may need to consider more than two execution paths.  Take the following problem for example.  You are given the numerical score for an assignment, ranged between 0 and 10.  Print out the letter grade of the assignment according to the table below:     Score  Letter Grade      8 or higher  A    Less than 8 but 5 or higher  B    Less than 5 but 3 or higher  C    Less than 3  D     Since the  if - else  statement only allows branching into two possibilities, we can branch into multiple possibilities by nesting the  if - else  statements hierarchically.  We can first break the table down into three tables, each containing only two rows, with one row a negation of the other row.     Score  Letter Grade      8 or higher  A    Less than 8  See Table 1     Table 1 (less than 8)     Score  Letter Grade      5 or higher  B    Less than 5  See Table 2     Table 2 (less than 5)     Score  Letter Grade      3 or higher  C    Less than 3  D     The tables above can then be written into the following function:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18 void   print_score ( double   score )   { \n   if   ( score   >=   8 )   { \n     cs1010_println_string ( \"A\" ); \n   }   else   { \n     // Table 1 \n     if   ( score   >=   5 )   { \n       cs1010_println_string ( \"B\" ); \n     }   else   { \n       // Table 2 \n       if   ( score   >=   3 )   { \n         cs1010_println_string ( \"C\" ); \n       }   else   { \n         cs1010_println_string ( \"D\" ); \n       } \n     } \n   }  }    There are three nested  if - else  in the function above.  Note how I use indentation to clearly indicate the nesting of blocks.  Such nesting or indentation is not required by C standard, but is a commonly accepted coding practice, and is required for CS1010.  The code below compiles perfectly but is not as easy to read by a human as the above.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12 void   print_score ( double   score )   { \n   if   ( score   >=   8 )   { \n     cs1010_println_string ( \"A\" );   }   else   {   // Table 1  \n     if   ( score   >=   5 )   {   cs1010_println_string ( \"B\" ); \n   }   else   {   // Table 2  if   ( score   >=   3 )   { \n   cs1010_println_string ( \"C\" ); \n       }   else   { \n         cs1010_println_string ( \"D\" ); \n     }   }   }   }  // Don't write code like this.    There are also a couple of \"first\" in the sample code above:   You see the keyword  void  for the first time.   void  is a special type that indicates nothing.  The function  print_score  does not return anything, it accepts an input  score  and print something to screen.  As such, we say that the return type of  print_score  is  void .  You see  strings  for the first time ( \"A\" , etc.).  A  string  basically is a sequence of characters.  We use double quotes  \"  to mark the beginning and the end of a string, and use the CS1010 I/O library function  cs1010_println_string  to print a string to the screen.    You can imagine that as the number of possible letter grades increases (NUS has 11), we will have many nested  if - else , and the code gets complicated.  To reduce the number of nesting, we can write  else if  directly, without nesting:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12 void   print_score ( double   score )   { \n   if   ( score   >=   8 )   { \n     cs1010_println_string ( \"A\" ); \n   }   else   if   ( score   >=   5 )   { \n     cs1010_println_string ( \"B\" ); \n   }   else   if   ( score   >=   3 )   { \n     cs1010_println_string ( \"C\" ); \n   }   else   { \n     cs1010_println_string ( \"D\" ); \n   }  }    The above code is easier to read, but has exactly the same flow as the one with nested  if - else  earlier.",
            "title": "Nested Else-If"
        },
        {
            "location": "/08-if-else/index.html#avoid-skipping-the-curly-braces",
            "text": "The C standard says that, if the block contains only one statement, we can skip the curly braces  {  and  } .  In the example above, we can write:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11 void   print_score ( double   score )   { \n   if   ( score   >=   8 )  \n     cs1010_println_string ( \"A\" ); \n   else   if   ( score   >=   5 ) \n     cs1010_println_string ( \"B\" ); \n   else   if   ( score   >=   3 ) \n     cs1010_println_string ( \"C\" ); \n   else \n     cs1010_println_string ( \"D\" );  }    Despite being allowed by the C standard, this is considered a bad practice, and should be avoided.  Imagine some time later, you go back to this code, and want to write something extra:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12 void   print_score ( double   score )   { \n   if   ( score   >=   8 )  \n     cs1010_println_string ( \"A\" ); \n   else   if   ( score   >=   5 ) \n     cs1010_println_string ( \"B\" ); \n   else   if   ( score   >=   3 ) \n     cs1010_println_string ( \"C\" ); \n   else \n     cs1010_println_string ( \"You can do better!\" ); \n     cs1010_println_string ( \"D\" );  }    What would be printed?  The famous  Apple  goto fail  bug  wouldn't have happened in the there is a pair of curly braces added!  Alternatively, if you have code like this:  1\n2\n3\n4\n5 if   ( score   >=   8 ) \n   if   ( late_penalty   !=   0 )  \n       cs1010_println_string ( \"late submission\" );  else  \n   cs1010_println_string ( \"you can do better!\" );    It might look like  you can do better!  will be printed if  score  is less than 8, but actually,  you can do better!  will be printed if the  score  is larger or equal to 8 and there is no late penalty, which is not what is intended.",
            "title": "Avoid Skipping the Curly Braces"
        },
        {
            "location": "/08-if-else/index.html#conditional-operator",
            "text": "The conditional operator consists of two special characters  ?  and  :  and is used in the format of:  1 condition ? true expression : false expression;   If the  condition  evaluates to true, then the  true expression  will be evaluated and returned, otherwise, the  false expression  will be evaluated and returned.  The conditional operator allows us to replace  1\n2\n3\n4\n5 if   ( x   >   y )   { \n   max   =   x ;  }   else   { \n   max   =   y ;  }    with a single line:  1 max = (x > y) ? x : y;   We can nest the conditional operator as well, but it does not necessarily make your code easier to read once you start nesting them up.  We do not encourage you to nest the conditional operator in CS1010 and to limit its usage to simple cases above.",
            "title": "Conditional Operator"
        },
        {
            "location": "/08-if-else/index.html#comparing-real-numbers",
            "text": "Recall that we said  real numbers cannot be represented exactly in computers .  Comparing real numbers, therefore, becomes a little bit trickier in programming.  The  if  statement  1\n2\n3\n4\n5 double   expected_value   =   0.3 ;  double   sum   =   0.1   +   0.2 ;  if   ( sum   ==   expected_value )   { \n  :  }    would not be evaluated as  true  as expected!  Thus, to compare real numbers, we normally allow some errors in comparisons -- we want the absolute difference between  sum  and  expected_value  to be small enough.  1\n2\n3\n4\n5 double   expected_value   =   0.3 ;  double   sum   =   0.1   +   0.2 ;  if   ( fabs ( sum   -   expected_value )   <   0.000001 )   { \n  :  }",
            "title": "Comparing Real Numbers"
        },
        {
            "location": "/08-if-else/index.html#problem-sets",
            "text": "",
            "title": "Problem Sets"
        },
        {
            "location": "/08-if-else/index.html#problem-81",
            "text": "(a) Do the following two functions behave the same way?  Explain.  1\n2\n3\n4\n5\n6\n7 long   factorial ( long   n )   { \n   if   ( n   ==   0 )   { \n     return   1 ; \n   } \n   return   n   *   factorial ( n   -   1 );  }    1\n2\n3\n4\n5\n6\n7\n8 long   factorial ( long   n )   { \n   if   ( n   ==   0 )   { \n     return   1 ; \n   }   else   { \n     return   n   *   factorial ( n   -   1 ); \n   }  }    (b) How about:  1\n2\n3\n4\n5\n6\n7\n8\n9 long   factorial ( long   n )   { \n   long   result ; \n   if   ( n   ==   0 )   { \n     result   =   1 ; \n   } \n   result   =   n   *   factorial ( n   -   1 ); \n   return   result ;  }    and    1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10 long   factorial ( long   n )   { \n   long   result ; \n   if   ( n   ==   0 )   { \n     result   =   1 ; \n   }   else   { \n     result   =   n   *   factorial ( n   -   1 ); \n   } \n   return   result ;  }",
            "title": "Problem 8.1"
        },
        {
            "location": "/08-if-else/index.html#problem-82",
            "text": "Draw the flowchart for the code snippet  1\n2\n3\n4\n5\n6\n7\n8\n9 if   ( x   >   y )   { \n   max   =   x ;  }   if   ( x   <   y )   { \n   max   =   y ;  }  if   ( x   ==   y )   { \n   max   =   y ;  }    and  1\n2\n3\n4\n5 if   ( x   >   y )   { \n   max   =   x ;  }   else   { \n   max   =   y ;  }",
            "title": "Problem 8.2"
        },
        {
            "location": "/08-if-else/index.html#problem-83",
            "text": "Suppose we break down the table below in a slightly different way.     Score  Letter Grade      8 or higher  A    Less than 8 but 5 or higher  B    Less than 5 but 3 or higher  C    Less than 3  D     We rewrite the tables into three smaller tables, as:     Score  Letter Grade      5 or higher  See Table 3    Less than 5  See Table 4     where Table 3 (5 or higher) is     Score  Letter Grade      8 or higher  A    Less than 8  B     and Table 4 (less than 5) is     Score  Letter Grade      3 or higher  C    Less than 3  D     Write the corresponding  if - else  statements to print out the letter grade based on the tables above.",
            "title": "Problem 8.3"
        },
        {
            "location": "/08-if-else/index.html#appendix-code-from-lecture",
            "text": "Here are the C files that Wei Tsang wrote during the lecture.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16 #include   \"cs1010.h\"  long   factorial ( long   n )  { \n   if   ( n   ==   0 )   { \n     return   1 ; \n   }  \n   return   n   *   factorial ( n - 1 );  }  int   main ()  { \n   long   n   =   cs1010_read_long (); \n   long   fac   =   factorial ( n ); \n   cs1010_println_long ( fac );  }     1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20 #include   \"cs1010.h\"  long   max ( long   x ,   long   y )  { \n   if   ( x   >   y )   { \n     return   x ; \n   }   else   { \n     return   y ; \n   } \n   // alternatively, using the conditional operator ? : \n   // return (x > y) ? x : y;  }  int   main ()  { \n   long   x   =   cs1010_read_long (); \n   long   y   =   cs1010_read_long (); \n   long   m   =   max ( x ,   y ); \n   cs1010_println_long ( m );  }     1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19 #include   \"cs1010.h\"  void   print_score ( double   x )  { \n   if   ( x   >=   8 ) \n     cs1010_println_string ( \"A\" ); \n   else   if   ( x   >=   5 ) \n     cs1010_println_string ( \"B\" ); \n   else   if   ( x   >=   3 ) \n     cs1010_println_string ( \"C\" ); \n   else \n     cs1010_println_string ( \"D\" );  }  int   main ()  { \n   double   score   =   cs1010_read_double (); \n   print_score ( score );  }",
            "title": "Appendix: Code From Lecture"
        },
        {
            "location": "/09-logical-exp/index.html",
            "text": "Unit 9: Logical Expression\n\n\nRepresenting a Boolean Value\n\n\nYou have seen some basic logical expressions in \nUnit 8\n. \nn == 0\n, \nx > y\n, \ny > x\n, are all logical expressions.  They evaluate to either true or false.\n\n\nWe call a type that can contain either true or false as a Boolean data type, named after \nGeorge Boole\n, a mathematician.\n\n\nThe Boolean data type in C named \nbool\n.  It can hold two values: \ntrue\n or \nfalse\n.  All three of \nbool\n, \ntrue\n, and \nfalse\n are keywords introduced in modern C.  To use them, you need to include the file \nstdbool.h\n at the top of your program.  \n\n\nUse \nbool\n is considered a cleaner way of representing true and false in C.  Classically,  C defines the numeric value 0 to be false, and everything else to be true.  So, you can write code like this:\n\n\n1\n2\n3\n4\n5\n// x and y are long.\n\n\nlong\n \nis_diff\n \n=\n \nx\n \n-\n \ny\n;\n\n\nif\n \n(\nis_diff\n)\n \n{\n\n  \ncs1010_println_string\n(\n\"x and y store different values.\"\n);\n\n\n}\n\n\n\n\n\n\n\nThe above is harder to understand and should be avoided.  A cleaner way is to write:\n\n\n1\n2\n3\n4\nbool\n \nis_diff\n \n=\n \nx\n \n!=\n \ny\n;\n\n\nif\n \n(\nis_diff\n)\n \n{\n\n  \ncs1010_println_string\n(\n\"x and y store different values.\"\n);\n\n\n}\n\n\n\n\n\n\n\nAlthough not required by C, we will name a \nbool\n variable with a prefix \nis_\n or \nhas_\n as a convention.  \n\n\nThe code above can also be written as:\n\n1\n2\n3\n4\nbool\n \nis_diff\n \n=\n \nx\n \n!=\n \ny\n;\n\n\nif\n \n(\nis_diff\n \n==\n \ntrue\n)\n \n{\n\n  \ncs1010_println_string\n(\n\"x and y store different values.\"\n);\n\n\n}\n\n\n\n\n\n\nThe comparison with \ntrue\n is redundant, however, and should be skipped.\n\n\nLogical Operators\n\n\nJust like we can perform arithmetic operations on integers and real numbers, we can perform logical operations on boolean values.  These allow us to write complex logical expressions.\n\n\nConsider the example problem: Write a function that, given the birth year of a person, determine if he or she belongs to Generation Z, defined as someone whose birth is between 1995 and 2005, inclusive. \n\n\nWe can write the function as follows using what we have known:\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nbool\n \nis_gen_z\n(\nlong\n \nbirth_year\n)\n \n\n{\n\n  \nif\n \n(\nbirth_year\n \n>=\n \n1995\n)\n \n{\n\n    \nif\n \n(\nbirth_year\n \n<=\n \n2005\n)\n \n{\n\n      \nreturn\n \ntrue\n;\n\n    \n}\n \n  \n}\n\n  \nreturn\n \nfalse\n;\n\n\n}\n\n\n\n\n\n\nTo be in Generation Z, both conditions \nbirth_year >= 1995\n and \nbirth_year <= 2005\n must be true.  We can use the logical AND \n&&\n operator to simplify the code above to:\n\n\n1\n2\n3\n4\n5\n6\n7\nbool\n \nis_gen_z\n(\nlong\n \nbirth_year\n)\n \n\n{\n\n  \nif\n \n((\nbirth_year\n \n>=\n \n1995\n)\n \n&&\n \n(\nbirth_year\n \n<=\n \n2005\n))\n \n{\n\n    \nreturn\n \ntrue\n;\n\n  \n}\n\n  \nreturn\n \nfalse\n;\n\n\n}\n\n\n\n\n\n\n\nor simply:\n\n1\n2\n3\n4\nbool\n \nis_gen_z\n(\nlong\n \nbirth_year\n)\n \n\n{\n\n  \nreturn\n \n((\nbirth_year\n \n>=\n \n1995\n)\n \n&&\n \n(\nbirth_year\n \n<=\n \n2005\n));\n\n\n}\n\n\n\n\n\n\nThe AND operator, \n&&\n, evaluates to true if and only if both operands are true.\n\n\n\n\nCommon Error\n\n\nA common mistake by a new C programmer is to write \n1995 <= birth_year <= 2005\n as the logical expression.  Unfortunately, in C, we cannot chain the comparison operators together.\n\n\n\n\nWhat if we want to write a function to determine if someone is NOT part of Generation Z?   This means that they are born \neither\n before 1995 \nor\n after 2005.  To have an expression that evaluates to true if either one of two expressions is true, we can use the OR operator, \n||\n.\n\n\n1\n2\n3\n4\nbool\n \nis_not_gen_z\n(\nlong\n \nbirth_year\n)\n \n\n{\n\n  \nreturn\n \n((\nbirth_year\n \n<\n \n1995\n)\n \n||\n \n(\nbirth_year\n \n>\n \n2005\n));\n\n\n}\n\n\n\n\n\n\n\nGenerally, we prefer to write functions that check for the positives, as it is generally easier to think in terms of the positives.  So the example \nis_not_gen_z\n above is for illustration purposes only, we do not encourage you to write functions that check for the negatives.   In any case, if we want to check if someone is not a Generation Z, we can use the \n!\n NOT operator.\n\n\n1\n2\n3\nif\n \n(\n!\nis_gen_z\n(\nbirth_year\n))\n \n{\n\n     \n:\n\n\n}\n\n\n\n\n\n\n\nThis operator can be used as part of the boolean expression:\n\n\n1\n2\n3\n4\nbool\n \nis_not_gen_z\n(\nlong\n \nbirth_year\n)\n \n\n{\n\n  \nreturn\n \n!\n((\nbirth_year\n \n>=\n \n1995\n)\n \n&&\n \n(\nbirth_year\n \n<=\n \n2005\n));\n\n\n}\n\n\n\n\n\n\n\nShort Circuiting\n\n\nWhen evaluating the logical expressions that involve \n&&\n and \n||\n, C uses \"short-circuiting\".  This means that, if we already know, for sure, that a logical expression is true or is false, there is no need to continue the evaluation.  The corresponding \ntrue\n and \nfalse\n value will be returned.\n\n\nConsider the following:\n\n1\n2\n3\n4\nbool\n \nis_gen_z\n(\nlong\n \nbirth_year\n)\n \n\n{\n\n  \nreturn\n \n((\nbirth_year\n \n>=\n \n1995\n)\n \n&&\n \n(\nbirth_year\n \n<=\n \n2005\n));\n\n\n}\n\n\n\n\n\n\nIf the argument \nbirth_year\n is \n1970\n, then, the expression \n(birth_year >= 1995)\n already evaluates to \nfalse\n, and the whole statement is false.  We do not need to evaluate the second expression \n(birth_year <= 2005)\n.  \n\n\nSimilarly, for \n\n1\n2\n3\n4\nbool\n \nis_not_gen_z\n(\nlong\n \nbirth_year\n)\n \n\n{\n\n  \nreturn\n \n((\nbirth_year\n \n<\n \n1995\n)\n \n||\n \n(\nbirth_year\n \n>\n \n2005\n));\n\n\n}\n\n\n\n\n\n\nWhen \nbirth_year\n is \n1970\n, the expression \n(birth_year < 1995)\n is \ntrue\n, so we know that the whole statement is \ntrue\n.  There is no need to check if \n(birth_year > 2005)\n.\n\n\nIn both examples above, the savings due to short-circuiting is not much -- since we are basically comparing two numbers, and there is no \nside effects\n in comparing \nbirth_year\n to \n2005\n.  But, let's suppose that we introduce two functions with side effects (of printing to screen):\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\nbool\n \nnot_too_old\n(\nlong\n \nbirth_year\n)\n\n\n{\n\n  \nif\n \n(\nbirth_year\n \n>=\n \n1995\n)\n \n{\n\n    \ncs1010_print_string\n(\n\"not too old..\"\n);\n\n    \nreturn\n \ntrue\n;\n\n  \n}\n\n  \ncs1010_print_string\n(\n\"too old..\"\n);\n\n  \nreturn\n \nfalse\n;\n\n\n}\n\n\n\nbool\n \nnot_too_young\n(\nlong\n \nbirth_year\n)\n\n\n{\n\n  \nif\n \n(\nbirth_year\n \n<=\n \n2005\n)\n \n{\n\n    \ncs1010_print_string\n(\n\"not too young..\"\n);\n\n    \nreturn\n \ntrue\n;\n\n  \n}\n\n  \ncs1010_print_string\n(\n\"too young..\"\n);\n\n  \nreturn\n \nfalse\n;\n\n\n}\n\n\n\nbool\n \nis_gen_z\n(\nlong\n \nbirth_year\n)\n \n\n{\n\n  \nreturn\n \nnot_too_old\n(\nbirth_year\n)\n \n&&\n \nnot_too_young\n(\nbirth_year\n);\n\n\n}\n\n\n\n\n\n\n\nWhen we call \nis_gen_z(1984)\n, you might expect \ntoo old..not too young..\n to be printed, but due to short-circuiting, the code only prints \ntoo old..\n.\n\n\nAnother reason to keep short-circuiting in mind is that the order of the logical expressions matter: we would want to put the logical expression that involves more work in the second half of the expression.  Take the following example:\n\n\n1\n2\n3\nif\n \n(\nnumber\n \n<\n \n100000\n \n&&\n \nis_prime\n(\nnumber\n))\n \n{\n\n    \n:\n\n\n}\n\n\n\n\n\n\n\nChecking whether a number is below 100,000 is easier than checking if a number is prime.  So, we can skip checking for primality if the \nnumber\n is too big.  Compare this to:\n\n\n1\n2\n3\nif\n \n(\nis_prime\n(\nnumber\n)\n \n&&\n \nnumber\n \n<\n \n100000\n)\n \n{\n\n    \n:\n\n\n}\n\n\n\n\n\n\n\nSuppose \nnumber\n is a gigantic integer, then we would have spent lots of effort checking if \nnumber\n is a prime, only to find out that it is too big anyway!\n\n\nProblem Sets\n\n\nProblem 9.1\n\n\nGiven two \nbool\n variables, \na\n and \nb\n, there are four possible combinations of \ntrue\n \nfalse\n values.  What are the values of \na && b\n, \na || b\n, and \n!a\n for each of these combinations?  Fill in the table below.\n\n\n\n\n\n\n\n\na\n\n\nb\n\n\na && b\n\n\na || b\n\n\n!a\n\n\n\n\n\n\n\n\n\n\ntrue\n\n\ntrue\n\n\n\n\n\n\n\n\n\n\n\n\ntrue\n\n\nfalse\n\n\n\n\n\n\n\n\n\n\n\n\nfalse\n\n\ntrue\n\n\n\n\n\n\n\n\n\n\n\n\nfalse\n\n\nfalse\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nProblem 9.2\n\n\nConsider the function below, which aims to return the maximum value given three numbers.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\nlong\n \nmax_of_three\n(\nlong\n \na\n,\n \nlong\n \nb\n,\n \nlong\n \nc\n)\n \n\n{\n\n  \nlong\n \nmax\n \n=\n \n0\n;\n\n  \nif\n \n((\na\n \n>\n \nb\n)\n \n&&\n \n(\na\n \n>\n \nc\n))\n \n{\n\n    \n// a is larger than b and c\n\n    \nmax\n \n=\n \na\n;\n\n  \n}\n\n  \nif\n \n((\nb\n \n>\n \na\n)\n \n&&\n \n(\nb\n \n>\n \nc\n))\n \n{\n\n    \n// b is larger than a and c\n\n    \nmax\n \n=\n \nb\n;\n\n  \n}\n\n  \nif\n \n((\nc\n \n>\n \na\n)\n \n&&\n \n(\nc\n \n>\n \nb\n))\n \n{\n\n    \n// c is larger than a and b\n\n    \nmax\n \n=\n \nc\n;\n\n  \n}\n\n  \nreturn\n \nmax\n;\n\n\n}\n\n\n\n\n\n\n\n(a) What is wrong with the code above?\n\n\n(b) Give a sample test value of \na\n, \nb\n, and \nc\n that would expose the bug.\n\n\n(C) Fix the code above to remove the bug.\n\n\n(d) Replace the three \nif\n statements in the code above with \nif\n-\nelse\n statements.  Draw the corresponding flowchart.\n\n\nProblem 9.3\n\n\nWrite a function that takes in a blood pressure measurement, and prints either \nlow\n, \nideal\n, \npre-high\n, and \nhigh\n depending on the input values.  The blood pressure is given as two \nlong\n values, the systolic and the diastolic.  The text to be printed depends on the range, depicted in the figure below.\n\n\n1\n2\n3\n4\nvoid\n \nprint_blood_pressure\n(\nlong\n \nsystolic\n,\n \nlong\n \ndiastolic\n)\n\n\n{\n\n  \n:\n\n\n}\n\n\n\n\n\n\n\n\n\nThe figure does not say how to classify the data if the values fall exactly on the boundary of two regions.  In this case, you can classify it to either region.\n\n\nAppendix: Code from Lecture\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n#include\n \n\"cs1010.h\"\n\n\n#include\n \n<stdbool.h>\n\n\n\nbool\n \nis_gen_z\n(\nlong\n \nyear\n)\n\n\n{\n\n  \nreturn\n \n((\nyear\n \n>=\n \n1995\n)\n \n&&\n \n(\nyear\n \n<=\n \n2005\n));\n\n\n}\n\n\n\nbool\n \nis_not_gen_z\n(\nlong\n \nyear\n)\n\n\n{\n\n  \nreturn\n \n((\nyear\n \n<\n \n1995\n)\n \n||\n \n(\nyear\n \n>\n \n2005\n));\n\n\n}\n\n\n\nint\n \nmain\n()\n\n\n{\n\n  \nlong\n \nyear\n \n=\n \ncs1010_read_long\n();\n\n  \nif\n \n(\nis_gen_z\n(\nyear\n))\n \n{\n\n    \ncs1010_println_string\n(\n\"Z!\"\n);\n\n  \n}\n \nelse\n \n{\n\n    \ncs1010_println_string\n(\n\"Not Z!\"\n);\n\n  \n}\n\n\n}",
            "title": "9. Logical Expression"
        },
        {
            "location": "/09-logical-exp/index.html#unit-9-logical-expression",
            "text": "",
            "title": "Unit 9: Logical Expression"
        },
        {
            "location": "/09-logical-exp/index.html#representing-a-boolean-value",
            "text": "You have seen some basic logical expressions in  Unit 8 .  n == 0 ,  x > y ,  y > x , are all logical expressions.  They evaluate to either true or false.  We call a type that can contain either true or false as a Boolean data type, named after  George Boole , a mathematician.  The Boolean data type in C named  bool .  It can hold two values:  true  or  false .  All three of  bool ,  true , and  false  are keywords introduced in modern C.  To use them, you need to include the file  stdbool.h  at the top of your program.    Use  bool  is considered a cleaner way of representing true and false in C.  Classically,  C defines the numeric value 0 to be false, and everything else to be true.  So, you can write code like this:  1\n2\n3\n4\n5 // x and y are long.  long   is_diff   =   x   -   y ;  if   ( is_diff )   { \n   cs1010_println_string ( \"x and y store different values.\" );  }    The above is harder to understand and should be avoided.  A cleaner way is to write:  1\n2\n3\n4 bool   is_diff   =   x   !=   y ;  if   ( is_diff )   { \n   cs1010_println_string ( \"x and y store different values.\" );  }    Although not required by C, we will name a  bool  variable with a prefix  is_  or  has_  as a convention.    The code above can also be written as: 1\n2\n3\n4 bool   is_diff   =   x   !=   y ;  if   ( is_diff   ==   true )   { \n   cs1010_println_string ( \"x and y store different values.\" );  }    The comparison with  true  is redundant, however, and should be skipped.",
            "title": "Representing a Boolean Value"
        },
        {
            "location": "/09-logical-exp/index.html#logical-operators",
            "text": "Just like we can perform arithmetic operations on integers and real numbers, we can perform logical operations on boolean values.  These allow us to write complex logical expressions.  Consider the example problem: Write a function that, given the birth year of a person, determine if he or she belongs to Generation Z, defined as someone whose birth is between 1995 and 2005, inclusive.   We can write the function as follows using what we have known: 1\n2\n3\n4\n5\n6\n7\n8\n9 bool   is_gen_z ( long   birth_year )   { \n   if   ( birth_year   >=   1995 )   { \n     if   ( birth_year   <=   2005 )   { \n       return   true ; \n     }  \n   } \n   return   false ;  }    To be in Generation Z, both conditions  birth_year >= 1995  and  birth_year <= 2005  must be true.  We can use the logical AND  &&  operator to simplify the code above to:  1\n2\n3\n4\n5\n6\n7 bool   is_gen_z ( long   birth_year )   { \n   if   (( birth_year   >=   1995 )   &&   ( birth_year   <=   2005 ))   { \n     return   true ; \n   } \n   return   false ;  }    or simply: 1\n2\n3\n4 bool   is_gen_z ( long   birth_year )   { \n   return   (( birth_year   >=   1995 )   &&   ( birth_year   <=   2005 ));  }    The AND operator,  && , evaluates to true if and only if both operands are true.   Common Error  A common mistake by a new C programmer is to write  1995 <= birth_year <= 2005  as the logical expression.  Unfortunately, in C, we cannot chain the comparison operators together.   What if we want to write a function to determine if someone is NOT part of Generation Z?   This means that they are born  either  before 1995  or  after 2005.  To have an expression that evaluates to true if either one of two expressions is true, we can use the OR operator,  || .  1\n2\n3\n4 bool   is_not_gen_z ( long   birth_year )   { \n   return   (( birth_year   <   1995 )   ||   ( birth_year   >   2005 ));  }    Generally, we prefer to write functions that check for the positives, as it is generally easier to think in terms of the positives.  So the example  is_not_gen_z  above is for illustration purposes only, we do not encourage you to write functions that check for the negatives.   In any case, if we want to check if someone is not a Generation Z, we can use the  !  NOT operator.  1\n2\n3 if   ( ! is_gen_z ( birth_year ))   { \n      :  }    This operator can be used as part of the boolean expression:  1\n2\n3\n4 bool   is_not_gen_z ( long   birth_year )   { \n   return   ! (( birth_year   >=   1995 )   &&   ( birth_year   <=   2005 ));  }",
            "title": "Logical Operators"
        },
        {
            "location": "/09-logical-exp/index.html#short-circuiting",
            "text": "When evaluating the logical expressions that involve  &&  and  || , C uses \"short-circuiting\".  This means that, if we already know, for sure, that a logical expression is true or is false, there is no need to continue the evaluation.  The corresponding  true  and  false  value will be returned.  Consider the following: 1\n2\n3\n4 bool   is_gen_z ( long   birth_year )   { \n   return   (( birth_year   >=   1995 )   &&   ( birth_year   <=   2005 ));  }    If the argument  birth_year  is  1970 , then, the expression  (birth_year >= 1995)  already evaluates to  false , and the whole statement is false.  We do not need to evaluate the second expression  (birth_year <= 2005) .    Similarly, for  1\n2\n3\n4 bool   is_not_gen_z ( long   birth_year )   { \n   return   (( birth_year   <   1995 )   ||   ( birth_year   >   2005 ));  }    When  birth_year  is  1970 , the expression  (birth_year < 1995)  is  true , so we know that the whole statement is  true .  There is no need to check if  (birth_year > 2005) .  In both examples above, the savings due to short-circuiting is not much -- since we are basically comparing two numbers, and there is no  side effects  in comparing  birth_year  to  2005 .  But, let's suppose that we introduce two functions with side effects (of printing to screen):   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24 bool   not_too_old ( long   birth_year )  { \n   if   ( birth_year   >=   1995 )   { \n     cs1010_print_string ( \"not too old..\" ); \n     return   true ; \n   } \n   cs1010_print_string ( \"too old..\" ); \n   return   false ;  }  bool   not_too_young ( long   birth_year )  { \n   if   ( birth_year   <=   2005 )   { \n     cs1010_print_string ( \"not too young..\" ); \n     return   true ; \n   } \n   cs1010_print_string ( \"too young..\" ); \n   return   false ;  }  bool   is_gen_z ( long   birth_year )   { \n   return   not_too_old ( birth_year )   &&   not_too_young ( birth_year );  }    When we call  is_gen_z(1984) , you might expect  too old..not too young..  to be printed, but due to short-circuiting, the code only prints  too old.. .  Another reason to keep short-circuiting in mind is that the order of the logical expressions matter: we would want to put the logical expression that involves more work in the second half of the expression.  Take the following example:  1\n2\n3 if   ( number   <   100000   &&   is_prime ( number ))   { \n     :  }    Checking whether a number is below 100,000 is easier than checking if a number is prime.  So, we can skip checking for primality if the  number  is too big.  Compare this to:  1\n2\n3 if   ( is_prime ( number )   &&   number   <   100000 )   { \n     :  }    Suppose  number  is a gigantic integer, then we would have spent lots of effort checking if  number  is a prime, only to find out that it is too big anyway!",
            "title": "Short Circuiting"
        },
        {
            "location": "/09-logical-exp/index.html#problem-sets",
            "text": "",
            "title": "Problem Sets"
        },
        {
            "location": "/09-logical-exp/index.html#problem-91",
            "text": "Given two  bool  variables,  a  and  b , there are four possible combinations of  true   false  values.  What are the values of  a && b ,  a || b , and  !a  for each of these combinations?  Fill in the table below.     a  b  a && b  a || b  !a      true  true       true  false       false  true       false  false",
            "title": "Problem 9.1"
        },
        {
            "location": "/09-logical-exp/index.html#problem-92",
            "text": "Consider the function below, which aims to return the maximum value given three numbers.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17 long   max_of_three ( long   a ,   long   b ,   long   c )   { \n   long   max   =   0 ; \n   if   (( a   >   b )   &&   ( a   >   c ))   { \n     // a is larger than b and c \n     max   =   a ; \n   } \n   if   (( b   >   a )   &&   ( b   >   c ))   { \n     // b is larger than a and c \n     max   =   b ; \n   } \n   if   (( c   >   a )   &&   ( c   >   b ))   { \n     // c is larger than a and b \n     max   =   c ; \n   } \n   return   max ;  }    (a) What is wrong with the code above?  (b) Give a sample test value of  a ,  b , and  c  that would expose the bug.  (C) Fix the code above to remove the bug.  (d) Replace the three  if  statements in the code above with  if - else  statements.  Draw the corresponding flowchart.",
            "title": "Problem 9.2"
        },
        {
            "location": "/09-logical-exp/index.html#problem-93",
            "text": "Write a function that takes in a blood pressure measurement, and prints either  low ,  ideal ,  pre-high , and  high  depending on the input values.  The blood pressure is given as two  long  values, the systolic and the diastolic.  The text to be printed depends on the range, depicted in the figure below.  1\n2\n3\n4 void   print_blood_pressure ( long   systolic ,   long   diastolic )  { \n   :  }     The figure does not say how to classify the data if the values fall exactly on the boundary of two regions.  In this case, you can classify it to either region.",
            "title": "Problem 9.3"
        },
        {
            "location": "/09-logical-exp/index.html#appendix-code-from-lecture",
            "text": "1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22 #include   \"cs1010.h\"  #include   <stdbool.h>  bool   is_gen_z ( long   year )  { \n   return   (( year   >=   1995 )   &&   ( year   <=   2005 ));  }  bool   is_not_gen_z ( long   year )  { \n   return   (( year   <   1995 )   ||   ( year   >   2005 ));  }  int   main ()  { \n   long   year   =   cs1010_read_long (); \n   if   ( is_gen_z ( year ))   { \n     cs1010_println_string ( \"Z!\" ); \n   }   else   { \n     cs1010_println_string ( \"Not Z!\" ); \n   }  }",
            "title": "Appendix: Code from Lecture"
        },
        {
            "location": "/10-assert/index.html",
            "text": "Unit 10: Assertion\n\n\nAn assertion is a logical expression that must always be true for the program to be correct.  We can write assertions either as part of the comment for the code, or use the \nassert()\n macro in C.  Let's look at what is assertion first.  We will introduce the use of \nassert()\n later.\n\n\nTo get started, let's first look at the most trivial assertion:\n\n\n1\n2\nlong\n \nx\n \n=\n \n1\n;\n\n\n// { x == 1 }\n\n\n\n\n\n\n\nThe line above initialize the variable \nx\n to be \n1\n.  The next line, a comment, uses the curly braces \n{\n and \n}\n with a logical expression in between, to indicate that \nx\n must be equals to \n1\n after the assignment.  We use the curly braces as a notation in CS1010, following \nC. A. R. Hoare\n's notation, but this is not part of any C standard.\n\n\nThe assertion above is kind of trivial and not very meaningful. \n\n\nLet's revisit this snippet:\n\n\n1\n2\n3\n4\n5\nif\n \n(\nx\n \n>\n \ny\n)\n \n{\n\n  \nmax\n \n=\n \nx\n;\n\n\n}\n \nelse\n \n{\n\n  \nmax\n \n=\n \ny\n;\n\n\n}\n\n\n\n\n\n\n\nLet's consider the true block and the false block.  Inside the true block, since \nx > y\n, we can assert that, well, \nx > y\n, and inside the false block, we have the negation, so \nx <= y\n.\n\n\n1\n2\n3\n4\n5\n6\n7\nif\n \n(\nx\n \n>\n \ny\n)\n \n{\n\n  \n// { x > y }\n\n  \nmax\n \n=\n \nx\n;\n\n\n}\n \nelse\n \n{\n\n  \n// { x <= y }\n\n  \nmax\n \n=\n \ny\n;\n\n\n}\n\n\n\n\n\n\n\nLet's now consider what happens after initializing \nmax\n to either \nx\n or \ny\n.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nif\n \n(\nx\n \n>\n \ny\n)\n \n{\n\n  \n// { x > y }\n\n  \nmax\n \n=\n \nx\n;\n\n  \n// { max == x && max > y }\n\n\n}\n \nelse\n \n{\n\n  \n// { x <= y }\n\n  \nmax\n \n=\n \ny\n;\n\n  \n// { max >= x && max == y }\n\n\n}\n\n\n\n\n\n\n\nThe assertion on Line 4 consists of two parts: \nmax == x\n which is the result of the assignment (the trivial assertion), but since inside this block, \nx > y\n, we must have \nmax > y\n to be true as well.\n\n\nSimilarly, we can argue the assertion in Line 8 to be true.  \n\n\nWhat can we assert after we exit from the \nif\n-\nelse\n block?  We have either \nmax == x && max > y\n or \nmax >= x && max == y\n.  This is exactly the property we are looking for in \nmax\n when we set it to the maximum of \nx\n and \ny\n!  \n\n\nLet's look at another example:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n  \nif\n \n(\nscore\n \n>=\n \n8\n)\n \n{\n\n    \ncs1010_println_string\n(\n\"A\"\n);\n\n  \n}\n \nelse\n \n{\n\n    \nif\n \n(\nscore\n \n>=\n \n5\n)\n \n{\n\n      \ncs1010_println_string\n(\n\"B\"\n);\n\n    \n}\n \nelse\n \n{\n\n      \nif\n \n(\nscore\n \n>=\n \n3\n)\n \n{\n\n        \ncs1010_println_string\n(\n\"C\"\n);\n\n      \n}\n \nelse\n \n{\n\n        \ncs1010_println_string\n(\n\"D\"\n);\n\n      \n}\n\n    \n}\n\n  \n}\n\n\n\n\n\n\n\nLet's focus on the case of printing \nC\n.  We should print \nC\n if \nscore\n is less than 5 but is 3 or higher.  Let's check if this is correct by finding out what we can assert wrt \nscore\n just before printing \nC\n.  We first add the assert condition to all the true blocks and the false block by negating the \nif\n condition.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n  \nif\n \n(\nscore\n \n>=\n \n8\n)\n \n{\n\n    \ncs1010_println_string\n(\n\"A\"\n);\n\n  \n}\n \nelse\n \n{\n\n    \nif\n \n(\nscore\n \n>=\n \n5\n)\n \n{\n\n      \n// { score >= 5 }\n\n      \ncs1010_println_string\n(\n\"B\"\n);\n\n    \n}\n \nelse\n \n{\n\n      \n// { score < 5 }\n\n      \nif\n \n(\nscore\n \n>=\n \n3\n)\n \n{\n\n        \n// { score < 5 && score >= 3 }\n\n        \ncs1010_println_string\n(\n\"C\"\n);\n\n      \n}\n \nelse\n \n{\n\n        \n// { score < 5 && score < 3 }\n\n        \ncs1010_println_string\n(\n\"D\"\n);\n\n      \n}\n\n    \n}\n\n  \n}\n\n\n\n\n\n\n\nWe can see that, we are printing \nC\n when \nscore < 5 && score >= 3\n, which is what we want.  \n\n\nNote that the last assert \nscore < 5 && score < 3\n can be simplified to \nscore < 3\n.\n\n\nDe Morgan's Law\n\n\nTo write an assertion for the false block, it is useful to know the De Morgan's law, which tells us how to negate some logical expression.  Suppose we have two logical expressions \ne1\n and \ne2\n. \n\n\n\n\n!(e1 && e2)\n is the same as \n(!e1) || (!e2)\n\n\n!(e1 || e2)\n is the same as \n(!e1) && (!e2)\n\n\n\n\nWe have actually seen it in action.  Recall the expression for Generation Z: \n\n\n(birth_year >= 1995) && (birth_year <= 2005)\n.  \n\n\nTo check for NOT Generation Z, we can write it as \n\n\n!((birth_year >= 1995) && (birth_year <= 2005))\n, \n\n\nwhich according to De Morgan's law, is the same as \n\n\n!(birth_year >= 1995) || !(birth_year <= 2005)\n, \n\n\nwhich is just \n\n\n(birth_year < 1995) || (birth_year > 2005)\n, \n\n\nexactly as we have written before!\n\n\nProblem Set 10\n\n\nProblem 10.1\n\n\nNegate the following logical expression, then apply De Morgan's Law to simplify the resulting expression.  Assume all variable names mentioned are boolean variables.\n\n\n(a) \n(x > 1) && (y != 10)\n\n\n(b) \n!eating && drinking\n\n\n(C) \n(has_cs2030 || has_cs2113) && has_cs2040c\n\n\nProblem 10.2\n\n\nIn the code below, replace \n???\n with the appropriate assertion.  What will be printed?\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\nlong\n \nscore\n \n=\n \n4\n;\n\n\nif\n \n(\nsomething\n)\n \n{\n\n  \nscore\n \n=\n \n10\n;\n\n\n}\n \nelse\n \n{\n\n  \nscore\n \n=\n \n0\n;\n\n\n}\n\n\n// { ??? }\n\n\n\nif\n \n(\nscore\n \n==\n \n4\n)\n \n{\n\n    \nscore\n \n=\n \n1\n;\n\n\n}\n \nelse\n \n{\n\n    \nscore\n \n+=\n \n10\n;\n\n\n}\n\n\n// { ??? }\n\n\n\nif\n \n(\nscore\n \n>=\n \n10\n)\n \n{\n\n    \ncs1010_println_string\n(\n\"ok\"\n);\n\n\n}\n \nelse\n \n{\n\n    \ncs1010_println_string\n(\n\"failed\"\n);\n\n\n}",
            "title": "10. Assertion"
        },
        {
            "location": "/10-assert/index.html#unit-10-assertion",
            "text": "An assertion is a logical expression that must always be true for the program to be correct.  We can write assertions either as part of the comment for the code, or use the  assert()  macro in C.  Let's look at what is assertion first.  We will introduce the use of  assert()  later.  To get started, let's first look at the most trivial assertion:  1\n2 long   x   =   1 ;  // { x == 1 }    The line above initialize the variable  x  to be  1 .  The next line, a comment, uses the curly braces  {  and  }  with a logical expression in between, to indicate that  x  must be equals to  1  after the assignment.  We use the curly braces as a notation in CS1010, following  C. A. R. Hoare 's notation, but this is not part of any C standard.  The assertion above is kind of trivial and not very meaningful.   Let's revisit this snippet:  1\n2\n3\n4\n5 if   ( x   >   y )   { \n   max   =   x ;  }   else   { \n   max   =   y ;  }    Let's consider the true block and the false block.  Inside the true block, since  x > y , we can assert that, well,  x > y , and inside the false block, we have the negation, so  x <= y .  1\n2\n3\n4\n5\n6\n7 if   ( x   >   y )   { \n   // { x > y } \n   max   =   x ;  }   else   { \n   // { x <= y } \n   max   =   y ;  }    Let's now consider what happens after initializing  max  to either  x  or  y .  1\n2\n3\n4\n5\n6\n7\n8\n9 if   ( x   >   y )   { \n   // { x > y } \n   max   =   x ; \n   // { max == x && max > y }  }   else   { \n   // { x <= y } \n   max   =   y ; \n   // { max >= x && max == y }  }    The assertion on Line 4 consists of two parts:  max == x  which is the result of the assignment (the trivial assertion), but since inside this block,  x > y , we must have  max > y  to be true as well.  Similarly, we can argue the assertion in Line 8 to be true.    What can we assert after we exit from the  if - else  block?  We have either  max == x && max > y  or  max >= x && max == y .  This is exactly the property we are looking for in  max  when we set it to the maximum of  x  and  y !    Let's look at another example:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13    if   ( score   >=   8 )   { \n     cs1010_println_string ( \"A\" ); \n   }   else   { \n     if   ( score   >=   5 )   { \n       cs1010_println_string ( \"B\" ); \n     }   else   { \n       if   ( score   >=   3 )   { \n         cs1010_println_string ( \"C\" ); \n       }   else   { \n         cs1010_println_string ( \"D\" ); \n       } \n     } \n   }    Let's focus on the case of printing  C .  We should print  C  if  score  is less than 5 but is 3 or higher.  Let's check if this is correct by finding out what we can assert wrt  score  just before printing  C .  We first add the assert condition to all the true blocks and the false block by negating the  if  condition.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17    if   ( score   >=   8 )   { \n     cs1010_println_string ( \"A\" ); \n   }   else   { \n     if   ( score   >=   5 )   { \n       // { score >= 5 } \n       cs1010_println_string ( \"B\" ); \n     }   else   { \n       // { score < 5 } \n       if   ( score   >=   3 )   { \n         // { score < 5 && score >= 3 } \n         cs1010_println_string ( \"C\" ); \n       }   else   { \n         // { score < 5 && score < 3 } \n         cs1010_println_string ( \"D\" ); \n       } \n     } \n   }    We can see that, we are printing  C  when  score < 5 && score >= 3 , which is what we want.    Note that the last assert  score < 5 && score < 3  can be simplified to  score < 3 .",
            "title": "Unit 10: Assertion"
        },
        {
            "location": "/10-assert/index.html#de-morgans-law",
            "text": "To write an assertion for the false block, it is useful to know the De Morgan's law, which tells us how to negate some logical expression.  Suppose we have two logical expressions  e1  and  e2 .    !(e1 && e2)  is the same as  (!e1) || (!e2)  !(e1 || e2)  is the same as  (!e1) && (!e2)   We have actually seen it in action.  Recall the expression for Generation Z:   (birth_year >= 1995) && (birth_year <= 2005) .    To check for NOT Generation Z, we can write it as   !((birth_year >= 1995) && (birth_year <= 2005)) ,   which according to De Morgan's law, is the same as   !(birth_year >= 1995) || !(birth_year <= 2005) ,   which is just   (birth_year < 1995) || (birth_year > 2005) ,   exactly as we have written before!",
            "title": "De Morgan's Law"
        },
        {
            "location": "/10-assert/index.html#problem-set-10",
            "text": "",
            "title": "Problem Set 10"
        },
        {
            "location": "/10-assert/index.html#problem-101",
            "text": "Negate the following logical expression, then apply De Morgan's Law to simplify the resulting expression.  Assume all variable names mentioned are boolean variables.  (a)  (x > 1) && (y != 10)  (b)  !eating && drinking  (C)  (has_cs2030 || has_cs2113) && has_cs2040c",
            "title": "Problem 10.1"
        },
        {
            "location": "/10-assert/index.html#problem-102",
            "text": "In the code below, replace  ???  with the appropriate assertion.  What will be printed?   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20 long   score   =   4 ;  if   ( something )   { \n   score   =   10 ;  }   else   { \n   score   =   0 ;  }  // { ??? }  if   ( score   ==   4 )   { \n     score   =   1 ;  }   else   { \n     score   +=   10 ;  }  // { ??? }  if   ( score   >=   10 )   { \n     cs1010_println_string ( \"ok\" );  }   else   { \n     cs1010_println_string ( \"failed\" );  }",
            "title": "Problem 10.2"
        },
        {
            "location": "/11-loop/index.html",
            "text": "Unit 11: Loops\n\n\nIn \nUnit 8\n, you were introduced to writing code that follows one of two possible execution paths using the \nif\n-\nelse\n statements, using a logical expression to decide which path to take.\n\n\nSometimes, we want to execute one of the branches repeatedly (or interatively), over-and-over again, until a certain logical condition is met.  You have seen this construct in the \nmax\nmax\n and \nsum\nsum\n example, where we repeatedly go through the numbers in the list until \ni == k\ni == k\n.\n\n\nWriting Loops\n\n\nTo write a loop, we need to think about the following four questions:\n\n\n\n\nwhat do we want to do repeatedly?\n\n\nwhat do we need to set up before repeating the above?\n\n\nwhat changes from one repetition to another?  \n\n\nhow to decide if we should stop repeating (or conversely, to continue repeating?)\n\n\n\n\nThere is a fifth question that is as important as the above but is harder to answer (and not necessary for writing simple loops), so we will leave it to \nUnit 12\n.\n\n\nLet's revisit the example of \nmax\n.  Here is the answer to the questions:\n\n\n\n\n\n\nWhat do we want to do repeatedly?  We want to compare the element \nl_i\nl_i\n to \nm\nm\n, and update \nm\nm\n to \nl_i\nl_i\n if \nl_i > m\nl_i > m\n.\n\n\n\n\n\n\nWhat do we need to set up before repeating the above?  We need to have some initial value of \nm\nm\n and \ni\ni\n.  We set it up as \nm = l_0\nm = l_0\n and \ni = 1\ni = 1\n.\n\n\n\n\n\n\nWhat would be different each time we repeat the above?  Every time we repeat, \ni\ni\n will be different.  To be more precise, \ni\ni\n is one more than before.\n\n\n\n\n\n\nHow to decide if we should continue repeating the above?  We stop when there is no more element to compare, i.e., \ni\ni\n equals \nk\nk\n.  In other words, we continue if \ni < k\ni < k\n.\n\n\n\n\n\n\n\n\nLet's consider another example.  We have seen how to compute factorial recursively.  Let's try to compute factorial using a loop.\n\n\nRecall that \nn! = n \\times n-1 \\times n-2 .. 2 \\times 1\nn! = n \\times n-1 \\times n-2 .. 2 \\times 1\n.  Given \nn\nn\n, how do we find \nn!\nn!\n using a loop?  \n\n\nThe idea to solve this with a loop is to start with the value \nn\nn\n, and repeatedly multiply another value \ni\ni\n, starting with \ni = n - 1\ni = n - 1\n, then \ni = n - 2\ni = n - 2\n, etc, until \ni = 2\ni = 2\n.  We do not need to multiple with \ni = 1\ni = 1\n since it does not change the value.\n\n\nLike any other problem, we need to consider what are the variables we need to maintain.  In this case, we should maintain the partial product of the factorial and a variable \ni\ni\n that corresponds to value to multiple into the partial product.\n\n\n\n\nWhat do we want to do repeatedly?  Multiply \ni\ni\n into the partial product. \n\n\nWhat do we need to set up before repeating the above?  We set up the partial product to be \nn\nn\n and \ni\ni\n to be \nn - 1\nn - 1\n.\n\n\nWhat changes from one repetition to another?  \ni\ni\n would decrease by one every time we repeat the above.\n\n\nHow to decide if we should stop repeating (or conversely, to continue repeating?)  We can stop when we have multiplied \ni = 2\ni = 2\n to the partial product.\n\n\n\n\nWe can express the algorithm above using the following flowchart:\n\n\n\n\nA \nfor\n loop\n\n\nC provides three ways to write a loop.  Let's start with a simple one first, a \nfor\n loop.  \n\n\nThe \nfor\n loop in C has the following syntax:\n\n\n1\n2\n3\nfor\n \n(\n<\ninitialize\n>\n;\n \n<\ncondition\n>\n;\n \n<\nupdate\n>\n)\n \n{\n\n    \n<\nbody\n>\n\n\n}\n\n\n\n\n\n\n\nThere are four components, corresponding to the four questions above:\n\n\n\n\nThe \ninitialize\n statement set up the loop (i.e., \"What do we need to set up before repeating the above?\").  \n\n\nThe \ncondition\n statement indicates when we should stop repeating.  If it evaluates to \ntrue\n, it will cause the loop to continue, otherwise, the loop stops.\n\n\nThe \nupdate\n statement is executed after every loop.  (i.e., \"What changes from one repetition to another?\")\n\n\nThe \nbody\n statement is the action that we want to do repeatedly.  \n\n\n\n\n\n\nFor the \ninitialize\n and \nupdate\n statement, even though C allows us to include multiple initializations and multiple updates, it makes the code harder to read and understand.  C also allows us to have empty statements for \ninitialize\n, \ncondition\n and/or \nupdate\n.  As such, in CS1010, we will stick to performing one initialization and one update only.\n\n\nFor example, in the setup phase for factorial, we should initialize the partial product to \nn\nn\n and \ni\ni\n to \nn - 1\nn - 1\n, that's two assignments.  We commonly choose the index which we increment or decrement as we loop, hence we choose to initialize \ni\ni\n in the \ninitialize\n statement of the \nfor\n loop, and leave the initialization of \nproduct\n to a separate assignment before the \nfor\n loop.\n\n\nHere is the example for computing the factorial:\n\n\n1\n2\n3\n4\n5\n6\n7\n8\nlong\n \nfactorial\n(\nlong\n \nn\n)\n \n\n{\n\n    \nlong\n \nproduct\n \n=\n \nn\n;\n\n    \nfor\n \n(\nlong\n \ni\n \n=\n \nn\n-\n1\n;\n \ni\n \n>=\n \n2\n;\n \ni\n \n-=\n \n1\n)\n \n{\n\n        \nproduct\n \n*=\n \ni\n;\n\n    \n}\n\n    \nreturn\n \nproduct\n;\n\n\n}\n\n\n\n\n\n\n\nThe code above is almost correct.  We only need to handle the special case when \nn\n is 0.  The complete code for the function is thus:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\nlong\n \nfactorial\n(\nlong\n \nn\n)\n \n\n{\n\n    \nif\n \n(\nn\n \n==\n \n0\n)\n \n{\n\n        \nreturn\n \n1\n;\n\n    \n}\n\n    \nlong\n \nproduct\n \n=\n \nn\n;\n\n    \nfor\n \n(\nlong\n \ni\n \n=\n \nn\n-\n1\n;\n \ni\n \n>=\n \n2\n;\n \ni\n \n-=\n \n1\n)\n \n{\n\n        \nproduct\n \n*=\n \ni\n;\n\n    \n}\n\n    \nreturn\n \nproduct\n;\n\n\n}\n\n\n\n\n\n\n\nwhile\n Loop\n\n\nThe second way to write a loop in C is to use a \nwhile\n loop.  The while loop looks like this:\n\n\n1\n2\n3\nwhile\n \n(\n<\ncondition\n>\n)\n \n{\n\n    \n<\nbody\n>\n\n\n}\n\n\n\n\n\n\n\nThe statements in \n<body>\n will be executed if \n<condition>\n is true.  \n\n\nNote that the syntax of the \nwhile\n loop above does not contain the \n<initialize>\n and the \n<update>\n component.  When we write the loop, however, we still need to think about them, and add them to the appropriate place in the code, as follows:\n\n\n1\n2\n3\n4\n5\n<\ninitialize\n>\n\n\nwhile\n \n(\n<\ncondition\n>\n)\n \n{\n\n    \n<\nbody\n>\n\n    \n<\nupdate\n>\n\n\n}\n\n\n\n\n\n\n\nThe corresponding flowchart for \nwhile\n is:\n\n\n\n\nCompare the flowchart for \nwhile\n to the flowchart for \nfor\n earlier.  You will see that they are exactly the same!\n\n\nHere is the \nwhile\n version of the \nfactorial\n function:\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\nlong\n \nfactorial\n(\nlong\n \nn\n)\n \n\n{\n\n    \nif\n \n(\nn\n \n==\n \n0\n)\n \n{\n\n        \nreturn\n \n1\n;\n\n    \n}\n\n    \nlong\n \nproduct\n \n=\n \nn\n;\n\n    \nlong\n \ni\n \n=\n \nn\n \n-\n \n1\n;\n\n    \nwhile\n \n(\ni\n \n>=\n \n2\n)\n \n{\n\n        \nproduct\n \n*=\n \ni\n;\n\n        \ni\n \n-=\n \n1\n;\n\n    \n}\n\n    \nreturn\n \nproduct\n;\n\n\n}\n\n\n\n\n\n\nIn the \nwhile\n loop, however, we can be more flexible in terms of what we want to do inside the loop.  Technically, there is no difference between \nupdate\n and \nbody\n since they are just a bunch of C statements.  We can interleave \n<update>\n and \n<body>\n or execute \n<update>\n first before \n<body>\n, depending on the algorithm.  With \nfor\n loop, there is no such flexibility as \n<update>\n has to be executed after \n<body>\n.\n\n\nA \ndo-while\n loop\n\n\nThe third way we can write a loop in C is to use a \ndo-while\n loop.  The \ndo-while\n loop is very similar to \nwhile\n, except that the body of the loop is guaranteed to be executed at least once.  \n\n\n1\n2\n3\n4\n5\n<\ninitialize\n>\n\n\ndo\n \n{\n\n    \n<\nbody\n>\n\n    \n<\nupdate\n>\n\n\n}\n \nwhile\n \n(\n<\ncondition\n>\n);\n\n\n\n\n\n\n\n\n\nSimilar to the \nwhile\n loop, the \n<body>\n component and \n<update>\n component in the loop does not have to be in order.\n\n\n\n\nThere is a semicolor \n;\n after a \ndo-while\n loop.\n\n\n\n\nLet's look at an example where using \ndo-while\n is more natural than \nwhile\n.  \n\n\nExample: Guess a Number\n\n\nLet's write a program that plays a game with the user.  The program generates a random integer number between 1 and 100.  The user will guess what that number is.  If the user guesses correctly, the program congratulates the user.  Otherwise, the program tells the user whether the guess is too high or too low, and let the user guess again.  This process repeats until the guess is correct.\n\n\nNote that, here, the user needs to guess at least once, so it is more natural to use a \ndo\n-\nwhile\n loop than a \nwhile\n or a \nfor\n.\n\n\nAnswering The Four Questions\n\n\n\n\nWhat do we want to do repeatedly?  We want to read the guess from the user and respond back to the user.\n\n\nWhat do we need to set up before repeating the above?  We need to generate a random integer between 1 and 100.\n\n\nWhat changes from one repetition to another?  The guess \nmay\n be different.\n\n\nHow to decide if we should continue repeating the above?  We stop when the guess is correct.\n\n\n\n\nDesigning the Flowchart\n\n\nHere is the flowchart of the steps described above.  \n\n\n\n\nThe C code\n\n\nThe entire corresponding program is shown below:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n#include\n \n<stdlib.h>\n\n\n#include\n \n<sys/times.h>\n\n\n#include\n \n\"cs1010.h\"\n\n\n\nint\n \nmain\n()\n\n\n{\n\n  \n// Initialize the random number generator\n\n  \nsrandom\n(\ntimes\n(\n0\n));\n\n\n  \n// Generate a random number between 1 and 100\n\n  \nlong\n \nanswer\n \n=\n \n(\nrandom\n()\n \n%\n \n100\n)\n \n+\n \n1\n;\n\n\n  \nlong\n \nguess\n;\n\n  \ndo\n \n{\n\n    \n// Read guess and feedback to user\n\n    \nguess\n \n=\n \ncs1010_read_long\n();\n\n    \nif\n \n(\nguess\n \n>\n \nanswer\n)\n \n{\n\n      \ncs1010_println_string\n(\n\"too high\"\n);\n\n    \n}\n \nelse\n \nif\n \n(\nguess\n \n<\n \nanswer\n)\n \n{\n\n      \ncs1010_println_string\n(\n\"too low\"\n);\n\n    \n}\n\n  \n}\n \nwhile\n \n(\nguess\n \n!=\n \nanswer\n);\n\n\n  \n// { guess == answer }\n\n  \ncs1010_println_string\n(\n\"you got it.  congrats!\"\n);\n\n\n}\n\n\n\n\n\n\n\nI will not go into details of what \nsrandom(times(0))\n means.  You can look it up on your own if you are interested (InfoSec students may want to do this as generating good random number is key to keeping systems secure).  \n\n\nThe function \nrandom()\n generates a random integer, which we limit to 0 to 99 by modulo-ing it with 100.  We then add 1 to it to a number between 1 and 100, inclusive.\n\n\nProblem Set\n\n\nProblem 11.1\n\n\nHere is another version of the \nfactorial\n function:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\nlong\n \nfactorial\n(\nlong\n \nn\n)\n \n\n{\n\n    \nlong\n \ni\n \n=\n \nn\n \n-\n \n1\n;\n\n    \nlong\n \nproduct\n;\n\n    \nfor\n \n(\nproduct\n \n=\n \nn\n;\n \ni\n \n>=\n \n2\n;\n \nproduct\n \n*=\n \ni\n)\n\n    \n{\n\n        \ni\n \n-=\n \n1\n;\n\n    \n}\n\n    \nreturn\n \nproduct\n;\n\n\n}\n\n\n\n\n\n\n\nDoes this code runs correctly?  If it is incorrect, explain what is wrong and suggest a fix.  (Hint: translate this to the corresponding flowchart and trace through the flowchart).\n\n\nProblem 11.2\n\n\n(a) Rewrite the \"Guess A Number\" program so that it shows the user the number of guesses made before the correct guess is entered.\n\n\n(b) Rewrite the \"Guess A Number\" program with a \nwhile\n loop.\n\n\n(C) Extend the \"Guess A Number\" program so that it plays the game for five rounds with the user, and at the end, shows the user the average number of guesses over five rounds.  (Hint: you should put the loop that reads the guess and prints feedback to the user into another function.)\n\n\n(d) What is the optimal strategy to play the game?\n\n\nProblem 11.3\n\n\nTrace the following algorithms:\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nlong\n \nmystery\n(\nlong\n \nn\n,\n \nlong\n \nk\n)\n \n{\n\n    \nlong\n \nsomething\n \n=\n \nn\n;\n\n    \nlong\n \ncount\n \n=\n \n-\n1\n;\n\n    \nwhile\n \n(\nsomething\n \n>=\n \n1\n)\n \n{\n\n        \nsomething\n \n/=\n \nk\n;\n \n        \ncount\n \n+=\n \n1\n;\n\n    \n}\n\n    \nreturn\n \ncount\n;\n\n\n}\n\n\n\n\n\n\n\n(a) \nWhat is the return value when \n\n\n\n\nn\n is 8 and \nk\n is 2?  \n\n\nn\n is 81 and \nk\n is 3?  \n\n\nn\n is 100 and \nk\n is 5?\n\n\n\n\nAnswer these questions by reading the code first, instead of trying it out on a computer (you can verify later).\n\n\n(b)\nWhat is the mathematical expression that our mystery function here is trying to compute based on the examples above?\n\n\n(C)\nGive a pair of inputs that would cause the function to return the wrong answer.\n\n\n(d) \nGive a pair of inputs that would cause the function to loop forever.",
            "title": "11. Loops"
        },
        {
            "location": "/11-loop/index.html#unit-11-loops",
            "text": "In  Unit 8 , you were introduced to writing code that follows one of two possible execution paths using the  if - else  statements, using a logical expression to decide which path to take.  Sometimes, we want to execute one of the branches repeatedly (or interatively), over-and-over again, until a certain logical condition is met.  You have seen this construct in the  max max  and  sum sum  example, where we repeatedly go through the numbers in the list until  i == k i == k .",
            "title": "Unit 11: Loops"
        },
        {
            "location": "/11-loop/index.html#writing-loops",
            "text": "To write a loop, we need to think about the following four questions:   what do we want to do repeatedly?  what do we need to set up before repeating the above?  what changes from one repetition to another?    how to decide if we should stop repeating (or conversely, to continue repeating?)   There is a fifth question that is as important as the above but is harder to answer (and not necessary for writing simple loops), so we will leave it to  Unit 12 .  Let's revisit the example of  max .  Here is the answer to the questions:    What do we want to do repeatedly?  We want to compare the element  l_i l_i  to  m m , and update  m m  to  l_i l_i  if  l_i > m l_i > m .    What do we need to set up before repeating the above?  We need to have some initial value of  m m  and  i i .  We set it up as  m = l_0 m = l_0  and  i = 1 i = 1 .    What would be different each time we repeat the above?  Every time we repeat,  i i  will be different.  To be more precise,  i i  is one more than before.    How to decide if we should continue repeating the above?  We stop when there is no more element to compare, i.e.,  i i  equals  k k .  In other words, we continue if  i < k i < k .     Let's consider another example.  We have seen how to compute factorial recursively.  Let's try to compute factorial using a loop.  Recall that  n! = n \\times n-1 \\times n-2 .. 2 \\times 1 n! = n \\times n-1 \\times n-2 .. 2 \\times 1 .  Given  n n , how do we find  n! n!  using a loop?    The idea to solve this with a loop is to start with the value  n n , and repeatedly multiply another value  i i , starting with  i = n - 1 i = n - 1 , then  i = n - 2 i = n - 2 , etc, until  i = 2 i = 2 .  We do not need to multiple with  i = 1 i = 1  since it does not change the value.  Like any other problem, we need to consider what are the variables we need to maintain.  In this case, we should maintain the partial product of the factorial and a variable  i i  that corresponds to value to multiple into the partial product.   What do we want to do repeatedly?  Multiply  i i  into the partial product.   What do we need to set up before repeating the above?  We set up the partial product to be  n n  and  i i  to be  n - 1 n - 1 .  What changes from one repetition to another?   i i  would decrease by one every time we repeat the above.  How to decide if we should stop repeating (or conversely, to continue repeating?)  We can stop when we have multiplied  i = 2 i = 2  to the partial product.   We can express the algorithm above using the following flowchart:",
            "title": "Writing Loops"
        },
        {
            "location": "/11-loop/index.html#a-for-loop",
            "text": "C provides three ways to write a loop.  Let's start with a simple one first, a  for  loop.    The  for  loop in C has the following syntax:  1\n2\n3 for   ( < initialize > ;   < condition > ;   < update > )   { \n     < body >  }    There are four components, corresponding to the four questions above:   The  initialize  statement set up the loop (i.e., \"What do we need to set up before repeating the above?\").    The  condition  statement indicates when we should stop repeating.  If it evaluates to  true , it will cause the loop to continue, otherwise, the loop stops.  The  update  statement is executed after every loop.  (i.e., \"What changes from one repetition to another?\")  The  body  statement is the action that we want to do repeatedly.      For the  initialize  and  update  statement, even though C allows us to include multiple initializations and multiple updates, it makes the code harder to read and understand.  C also allows us to have empty statements for  initialize ,  condition  and/or  update .  As such, in CS1010, we will stick to performing one initialization and one update only.  For example, in the setup phase for factorial, we should initialize the partial product to  n n  and  i i  to  n - 1 n - 1 , that's two assignments.  We commonly choose the index which we increment or decrement as we loop, hence we choose to initialize  i i  in the  initialize  statement of the  for  loop, and leave the initialization of  product  to a separate assignment before the  for  loop.  Here is the example for computing the factorial:  1\n2\n3\n4\n5\n6\n7\n8 long   factorial ( long   n )   { \n     long   product   =   n ; \n     for   ( long   i   =   n - 1 ;   i   >=   2 ;   i   -=   1 )   { \n         product   *=   i ; \n     } \n     return   product ;  }    The code above is almost correct.  We only need to handle the special case when  n  is 0.  The complete code for the function is thus:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11 long   factorial ( long   n )   { \n     if   ( n   ==   0 )   { \n         return   1 ; \n     } \n     long   product   =   n ; \n     for   ( long   i   =   n - 1 ;   i   >=   2 ;   i   -=   1 )   { \n         product   *=   i ; \n     } \n     return   product ;  }",
            "title": "A for loop"
        },
        {
            "location": "/11-loop/index.html#while-loop",
            "text": "The second way to write a loop in C is to use a  while  loop.  The while loop looks like this:  1\n2\n3 while   ( < condition > )   { \n     < body >  }    The statements in  <body>  will be executed if  <condition>  is true.    Note that the syntax of the  while  loop above does not contain the  <initialize>  and the  <update>  component.  When we write the loop, however, we still need to think about them, and add them to the appropriate place in the code, as follows:  1\n2\n3\n4\n5 < initialize >  while   ( < condition > )   { \n     < body > \n     < update >  }    The corresponding flowchart for  while  is:   Compare the flowchart for  while  to the flowchart for  for  earlier.  You will see that they are exactly the same!  Here is the  while  version of the  factorial  function:  1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13 long   factorial ( long   n )   { \n     if   ( n   ==   0 )   { \n         return   1 ; \n     } \n     long   product   =   n ; \n     long   i   =   n   -   1 ; \n     while   ( i   >=   2 )   { \n         product   *=   i ; \n         i   -=   1 ; \n     } \n     return   product ;  }    In the  while  loop, however, we can be more flexible in terms of what we want to do inside the loop.  Technically, there is no difference between  update  and  body  since they are just a bunch of C statements.  We can interleave  <update>  and  <body>  or execute  <update>  first before  <body> , depending on the algorithm.  With  for  loop, there is no such flexibility as  <update>  has to be executed after  <body> .",
            "title": "while Loop"
        },
        {
            "location": "/11-loop/index.html#a-do-while-loop",
            "text": "The third way we can write a loop in C is to use a  do-while  loop.  The  do-while  loop is very similar to  while , except that the body of the loop is guaranteed to be executed at least once.    1\n2\n3\n4\n5 < initialize >  do   { \n     < body > \n     < update >  }   while   ( < condition > );     Similar to the  while  loop, the  <body>  component and  <update>  component in the loop does not have to be in order.   There is a semicolor  ;  after a  do-while  loop.   Let's look at an example where using  do-while  is more natural than  while .",
            "title": "A do-while loop"
        },
        {
            "location": "/11-loop/index.html#example-guess-a-number",
            "text": "Let's write a program that plays a game with the user.  The program generates a random integer number between 1 and 100.  The user will guess what that number is.  If the user guesses correctly, the program congratulates the user.  Otherwise, the program tells the user whether the guess is too high or too low, and let the user guess again.  This process repeats until the guess is correct.  Note that, here, the user needs to guess at least once, so it is more natural to use a  do - while  loop than a  while  or a  for .",
            "title": "Example: Guess a Number"
        },
        {
            "location": "/11-loop/index.html#answering-the-four-questions",
            "text": "What do we want to do repeatedly?  We want to read the guess from the user and respond back to the user.  What do we need to set up before repeating the above?  We need to generate a random integer between 1 and 100.  What changes from one repetition to another?  The guess  may  be different.  How to decide if we should continue repeating the above?  We stop when the guess is correct.",
            "title": "Answering The Four Questions"
        },
        {
            "location": "/11-loop/index.html#designing-the-flowchart",
            "text": "Here is the flowchart of the steps described above.",
            "title": "Designing the Flowchart"
        },
        {
            "location": "/11-loop/index.html#the-c-code",
            "text": "The entire corresponding program is shown below:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26 #include   <stdlib.h>  #include   <sys/times.h>  #include   \"cs1010.h\"  int   main ()  { \n   // Initialize the random number generator \n   srandom ( times ( 0 )); \n\n   // Generate a random number between 1 and 100 \n   long   answer   =   ( random ()   %   100 )   +   1 ; \n\n   long   guess ; \n   do   { \n     // Read guess and feedback to user \n     guess   =   cs1010_read_long (); \n     if   ( guess   >   answer )   { \n       cs1010_println_string ( \"too high\" ); \n     }   else   if   ( guess   <   answer )   { \n       cs1010_println_string ( \"too low\" ); \n     } \n   }   while   ( guess   !=   answer ); \n\n   // { guess == answer } \n   cs1010_println_string ( \"you got it.  congrats!\" );  }    I will not go into details of what  srandom(times(0))  means.  You can look it up on your own if you are interested (InfoSec students may want to do this as generating good random number is key to keeping systems secure).    The function  random()  generates a random integer, which we limit to 0 to 99 by modulo-ing it with 100.  We then add 1 to it to a number between 1 and 100, inclusive.",
            "title": "The C code"
        },
        {
            "location": "/11-loop/index.html#problem-set",
            "text": "",
            "title": "Problem Set"
        },
        {
            "location": "/11-loop/index.html#problem-111",
            "text": "Here is another version of the  factorial  function:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10 long   factorial ( long   n )   { \n     long   i   =   n   -   1 ; \n     long   product ; \n     for   ( product   =   n ;   i   >=   2 ;   product   *=   i ) \n     { \n         i   -=   1 ; \n     } \n     return   product ;  }    Does this code runs correctly?  If it is incorrect, explain what is wrong and suggest a fix.  (Hint: translate this to the corresponding flowchart and trace through the flowchart).",
            "title": "Problem 11.1"
        },
        {
            "location": "/11-loop/index.html#problem-112",
            "text": "(a) Rewrite the \"Guess A Number\" program so that it shows the user the number of guesses made before the correct guess is entered.  (b) Rewrite the \"Guess A Number\" program with a  while  loop.  (C) Extend the \"Guess A Number\" program so that it plays the game for five rounds with the user, and at the end, shows the user the average number of guesses over five rounds.  (Hint: you should put the loop that reads the guess and prints feedback to the user into another function.)  (d) What is the optimal strategy to play the game?",
            "title": "Problem 11.2"
        },
        {
            "location": "/11-loop/index.html#problem-113",
            "text": "Trace the following algorithms:  1\n2\n3\n4\n5\n6\n7\n8\n9 long   mystery ( long   n ,   long   k )   { \n     long   something   =   n ; \n     long   count   =   - 1 ; \n     while   ( something   >=   1 )   { \n         something   /=   k ;  \n         count   +=   1 ; \n     } \n     return   count ;  }    (a) \nWhat is the return value when    n  is 8 and  k  is 2?    n  is 81 and  k  is 3?    n  is 100 and  k  is 5?   Answer these questions by reading the code first, instead of trying it out on a computer (you can verify later).  (b)\nWhat is the mathematical expression that our mystery function here is trying to compute based on the examples above?  (C)\nGive a pair of inputs that would cause the function to return the wrong answer.  (d) \nGive a pair of inputs that would cause the function to loop forever.",
            "title": "Problem 11.3"
        },
        {
            "location": "/12-invariant/index.html",
            "text": "Unit 12: Reasoning About Loops\n\n\nUsing Assertions\n\n\nWe have seen how we can use assertions to reason about the state of our program at different points of execution for conditional \nif\n-\nelse\n statements.  We can apply the same techniques to loops.  Take the simple program below:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\nlong\n \ncount\n(\nlong\n \nn\n)\n \n{\n\n  \nlong\n \ny\n \n=\n \n0\n;\n\n  \nlong\n \nx\n \n=\n \nn\n;\n\n  \nwhile\n \n(\nx\n \n>\n \n0\n)\n \n{\n\n    \n// line A\n\n    \nx\n \n-=\n \n1\n;\n\n    \n// line B\n\n    \nif\n \n(\nx\n \n%\n \n5\n \n==\n \n0\n)\n \n{\n\n      \n// line C\n\n      \ny\n \n+=\n \n1\n;\n\n    \n}\n\n  \n}\n\n  \n// line D\n\n  \nreturn\n \ny\n;\n\n\n}\n\n\n\n\n\n\n\nBefore we continue, study this program and try to analyze what the function is counting and returning.\n\n\nTo do this more systematically, we can use assertions.  Let's ask ourselves: what can be said about the variables \nx\n and \ny\n at Lines A, B, C?  Let starts with \nx\n first.\n\n\n\n\nLine A is the first line after entering the loop, so we can reason that to enter the loop (the first time or subsequent times), \nx > 0\n and \nx <= n\n (since we initialize the \nx\n to \nn\n).\n\n\nAt Line B, we decrease \nx\n by 1, so \nx >= 0 && x < n\n must be true.\n\n\nAt Line C, \nx % 5 == 0\n (i.e., x is multiple of 5) must \nalso\n be true (since it is in the true block of the \nif\n block).\n\n\nAt Line D, we already exit from the loop, and the only way to exit here is that \nx > 0\n is false.  So we know that \nx <= 0\n.\n\n\n\n\nLet's annotate the code with the assertions:\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\nlong\n \ncount\n(\nlong\n \nn\n)\n \n{\n\n  \nlong\n \ny\n \n=\n \n0\n;\n\n  \nlong\n \nx\n \n=\n \nn\n;\n\n  \nwhile\n \n(\nx\n \n>\n \n0\n)\n \n{\n\n    \n// { x > 0 && x <= n }\n\n    \nx\n \n-=\n \n1\n;\n\n    \n// { (x >= 0) && (x < n) }\n\n    \nif\n \n(\nx\n \n%\n \n5\n \n==\n \n0\n)\n \n{\n\n      \n// { (x >= 0) && (x < n) && x is multiple of 5 }\n\n      \ny\n \n+=\n \n1\n;\n\n    \n}\n\n  \n}\n\n  \n// { x <= 0 }\n\n  \nreturn\n \ny\n;\n\n\n}\n\n\n\n\n\n\nWhat can be said about \ny\n?  It should be clear now that we increment \ny\n for every value between 0 and \nn-1\n (inclusive) that is a multiple of 5, based on the condition on Line C.  That is, it is counting the number of multiple of 5s between 0 and n-1.\n\n\nLoop Invariant\n\n\nIn the last unit, we say that there are actually five questions that we have to think about when designing loops.  The fifth question is: what is the \nloop invariant\n?  A loop invariant is an assertion that is true before the loop, during the loop, and after the loop.  Thinking about the loop invariant is helpful to convince ourselves that a loop is correct, or to identify bugs in a loop.\n\n\nLet's see an example of a loop invariant.  Consider the example of calculating a factorial using a loop as before.  To make the invariant simpler, let's tweak the loop slightly and start looping from \ni\n equals 1 up to \nn\n.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\nlong\n \nfactorial\n(\nlong\n \nn\n)\n \n\n{\n\n  \nif\n \n(\nn\n \n==\n \n0\n)\n \n{\n\n      \nreturn\n \n1\n;\n\n  \n}\n\n  \nlong\n \nproduct\n \n=\n \n1\n;\n\n  \nlong\n \ni\n \n=\n \n1\n;\n\n  \n// Line A\n\n  \nwhile\n \n(\ni\n \n<\n \nn\n)\n \n{\n\n    \ni\n \n+=\n \n1\n;\n\n    \nproduct\n \n*=\n \ni\n;\n\n    \n// Line B\n\n  \n}\n\n  \n// Line C\n\n  \nreturn\n \nproduct\n;\n\n\n}\n\n\n\n\n\n\n\nThe loop invariant for each line A, B, and C are the same: \n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\nlong\n \nfactorial\n(\nlong\n \nn\n)\n \n\n{\n\n  \nif\n \n(\nn\n \n==\n \n0\n)\n \n{\n\n      \nreturn\n \n1\n;\n\n  \n}\n\n  \nlong\n \nproduct\n \n=\n \n1\n;\n\n  \nlong\n \ni\n \n=\n \n1\n;\n\n  \n// A: { product == i! }\n\n  \nwhile\n \n(\ni\n \n<\n \nn\n)\n \n{\n\n    \ni\n \n+=\n \n1\n;\n\n    \nproduct\n \n*=\n \ni\n;\n\n    \n// B: { product == i! }\n\n  \n}\n\n  \n// C: { product == i! }\n\n  \nreturn\n \nproduct\n;\n\n\n}\n\n\n\n\n\n\n\nIn Line A, the assertion is obvious.  Let's look at Line B.  Since, at the beginning of the loop (before Line 10) we have \nproduct == i!\n, after Line 10, we have \nproduct == (i-1)!\n (since we have incremented \ni\n).  After Line 11, we have \nproduct == i * (i - 1)! == i!\n again.  The assertion remains true once we exit the loop.\n\n\nThe key here is that after we exit the loop, we can also assert that \ni == n\n, and so combining \nproduct == i! && i == n\n we have \nproduct == n!\n, which is what we want.\n\n\nProblem Set 12\n\n\nProblem 12.1\n\n\n1\n2\n3\n4\n5\n6\nlong\n \ni\n \n=\n \n10\n;\n\n\nlong\n \nj\n \n=\n \n0\n;\n\n\nwhile\n \n(\ni\n \n!=\n \n0\n)\n \n{\n\n    \ni\n \n-=\n \n1\n;\n\n    \nj\n \n+=\n \n1\n;\n\n\n}\n\n\n\n\n\n\n\n(a) Trace through the program.  What is the value of \nj\n when the loop exits?\n\n\n(b) Do you recognize any pattern on the relationship of \ni\n and \nj\n?\n\n\n(C) What is the loop invariant?",
            "title": "12. Reasoning About Loops"
        },
        {
            "location": "/12-invariant/index.html#unit-12-reasoning-about-loops",
            "text": "",
            "title": "Unit 12: Reasoning About Loops"
        },
        {
            "location": "/12-invariant/index.html#using-assertions",
            "text": "We have seen how we can use assertions to reason about the state of our program at different points of execution for conditional  if - else  statements.  We can apply the same techniques to loops.  Take the simple program below:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15 long   count ( long   n )   { \n   long   y   =   0 ; \n   long   x   =   n ; \n   while   ( x   >   0 )   { \n     // line A \n     x   -=   1 ; \n     // line B \n     if   ( x   %   5   ==   0 )   { \n       // line C \n       y   +=   1 ; \n     } \n   } \n   // line D \n   return   y ;  }    Before we continue, study this program and try to analyze what the function is counting and returning.  To do this more systematically, we can use assertions.  Let's ask ourselves: what can be said about the variables  x  and  y  at Lines A, B, C?  Let starts with  x  first.   Line A is the first line after entering the loop, so we can reason that to enter the loop (the first time or subsequent times),  x > 0  and  x <= n  (since we initialize the  x  to  n ).  At Line B, we decrease  x  by 1, so  x >= 0 && x < n  must be true.  At Line C,  x % 5 == 0  (i.e., x is multiple of 5) must  also  be true (since it is in the true block of the  if  block).  At Line D, we already exit from the loop, and the only way to exit here is that  x > 0  is false.  So we know that  x <= 0 .   Let's annotate the code with the assertions:  1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15 long   count ( long   n )   { \n   long   y   =   0 ; \n   long   x   =   n ; \n   while   ( x   >   0 )   { \n     // { x > 0 && x <= n } \n     x   -=   1 ; \n     // { (x >= 0) && (x < n) } \n     if   ( x   %   5   ==   0 )   { \n       // { (x >= 0) && (x < n) && x is multiple of 5 } \n       y   +=   1 ; \n     } \n   } \n   // { x <= 0 } \n   return   y ;  }    What can be said about  y ?  It should be clear now that we increment  y  for every value between 0 and  n-1  (inclusive) that is a multiple of 5, based on the condition on Line C.  That is, it is counting the number of multiple of 5s between 0 and n-1.",
            "title": "Using Assertions"
        },
        {
            "location": "/12-invariant/index.html#loop-invariant",
            "text": "In the last unit, we say that there are actually five questions that we have to think about when designing loops.  The fifth question is: what is the  loop invariant ?  A loop invariant is an assertion that is true before the loop, during the loop, and after the loop.  Thinking about the loop invariant is helpful to convince ourselves that a loop is correct, or to identify bugs in a loop.  Let's see an example of a loop invariant.  Consider the example of calculating a factorial using a loop as before.  To make the invariant simpler, let's tweak the loop slightly and start looping from  i  equals 1 up to  n .   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16 long   factorial ( long   n )   { \n   if   ( n   ==   0 )   { \n       return   1 ; \n   } \n   long   product   =   1 ; \n   long   i   =   1 ; \n   // Line A \n   while   ( i   <   n )   { \n     i   +=   1 ; \n     product   *=   i ; \n     // Line B \n   } \n   // Line C \n   return   product ;  }    The loop invariant for each line A, B, and C are the same:    1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16 long   factorial ( long   n )   { \n   if   ( n   ==   0 )   { \n       return   1 ; \n   } \n   long   product   =   1 ; \n   long   i   =   1 ; \n   // A: { product == i! } \n   while   ( i   <   n )   { \n     i   +=   1 ; \n     product   *=   i ; \n     // B: { product == i! } \n   } \n   // C: { product == i! } \n   return   product ;  }    In Line A, the assertion is obvious.  Let's look at Line B.  Since, at the beginning of the loop (before Line 10) we have  product == i! , after Line 10, we have  product == (i-1)!  (since we have incremented  i ).  After Line 11, we have  product == i * (i - 1)! == i!  again.  The assertion remains true once we exit the loop.  The key here is that after we exit the loop, we can also assert that  i == n , and so combining  product == i! && i == n  we have  product == n! , which is what we want.",
            "title": "Loop Invariant"
        },
        {
            "location": "/12-invariant/index.html#problem-set-12",
            "text": "",
            "title": "Problem Set 12"
        },
        {
            "location": "/12-invariant/index.html#problem-121",
            "text": "1\n2\n3\n4\n5\n6 long   i   =   10 ;  long   j   =   0 ;  while   ( i   !=   0 )   { \n     i   -=   1 ; \n     j   +=   1 ;  }    (a) Trace through the program.  What is the value of  j  when the loop exits?  (b) Do you recognize any pattern on the relationship of  i  and  j ?  (C) What is the loop invariant?",
            "title": "Problem 12.1"
        },
        {
            "location": "/13-call-stack/index.html",
            "text": "Unit 13: Call Stack\n\n\nIn this unit, we will delve deeper into how variables are stored in the memory and what happens when we call a function.\n\n\nStack Frame\n\n\nModern OS typically divide the memory into several regions.  The region that we are concerned with for now is called the \ncall stack\n.\n\nEvery function invocation causes the OS to allocate some memory on the call stack to store (among other things) the parameters passed into the function and the variables declared and used in the function.  The memory allocated to each function call is called a \nstack frame\n.  When a function returns, the stack frame is deallocated and freed up for other uses.\n\n\nLet's start with the following simple program as an example.\n\n\n1\n2\n3\n4\n5\nint\n \nmain\n()\n\n\n{\n\n  \nlong\n \nx\n \n=\n \n1\n;\n\n  \nlong\n \ny\n;\n\n\n}\n\n\n\n\n\n\n\nWhen the OS runs the program above, it invokes, or calls, the function \nmain\n.  A new stack frame is created for \nmain()\n.  There are two variables \nx\n and \ny\n declared in \nmain\n.  Recall from \nUnit 2\n that a variable is a location in the memory which holds a value.  Thus, the stack frame of \nmain\n will include these two variables.  We initialize \nx\n to 1 in the code above, so the value 1 will be placed in the memory location of \nx\n.  The variable \ny\n remains uninitialized, so it will contain whatever value that happens to be in the memory at that time.\n\n\n\n\nNow, let's consider the program\n1\n:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\nlong\n \nadd\n(\nlong\n \na\n,\n \nlong\n \nb\n)\n \n{\n\n  \nlong\n \nsum\n;\n\n  \nsum\n \n=\n \na\n \n+\n \nb\n;\n\n  \nreturn\n \nsum\n;\n\n\n}\n\n\n\nint\n \nmain\n()\n\n\n{\n\n  \nlong\n \nx\n \n=\n \n1\n;\n\n  \nlong\n \ny\n;\n\n  \ny\n \n=\n \nadd\n(\nx\n,\n \n10\n);\n\n\n}\n\n\n\n\n\n\n\nNow, the program invokes the function \nadd\n with two parameters, using \nx\n and 10 as arguments.  What the OS does when \nadd\n is called, is that it allocates another stack frame for \nadd\n.  We can visualize the stack frame for \nadd\n as being placed on top of the stack frame of \nmain\n.  The stack frame for \nadd\n includes two variables corresponding to the parameters \na\n, \nb\n, and the variable \nsum\n declared in the function \nadd\n.\n\n\nWhen the stack frame for \nadd\n is created, \nsum\n is uninitialized, but \na\n is initialized to whatever the value of \nx\n is when the function is invoked (1 in this example), and \nb\n is initialized to 10, since that is the argument passed into \nadd\n.\n\n\n\n\nAfter the stack frame for \nadd\n is set up, the code is executed.  The memory location for \nsum\n is then initialized to the sum of \na\n and \nb\n (11 in this example), and the return statement is executed.  \n\n\n\n\nWhen a function returns, the stack frame for \nsum\n is removed.  The variables \nsum\n, \na\n, \nb\n crumble into dust and no longer exist in the memory.  The value of the variable being returned (\nsum\n in this case) is then copied back to the stack frame of the \nmain\n (the \ncallee\n).  In this example, this value is copied into the memory location of \ny\n.\n\n\n\n\nWhat would happen if we change the value of \na\n within \nadd\n?\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\nlong\n \nadd\n(\nlong\n \na\n,\n \nlong\n \nb\n)\n \n{\n\n  \nsum\n \n=\n \na\n \n+\n \nb\n;\n\n  \na\n \n=\n \n42\n;\n  \n// change a\n\n  \nreturn\n \nsum\n;\n\n\n}\n\n\n\nint\n \nmain\n()\n\n\n{\n\n  \nlong\n \nx\n \n=\n \n1\n;\n\n  \nlong\n \ny\n;\n\n  \ny\n \n=\n \nadd\n(\nx\n,\n \n10\n);\n\n\n}\n\n\n\n\n\n\n\nIn this example, we change the value of \na\n in the call stack of \nadd\n to 42.  This has no effect on any variable in \nmain\n, since the changes apply only within the stack frame of \nadd\n.\n\n\nA common bug by beginners is to try to write a function this way:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\nvoid\n \nadd\n(\nlong\n \nsum\n,\n \nlong\n \na\n,\n \nlong\n \nb\n)\n \n{\n\n  \nsum\n \n=\n \na\n \n+\n \nb\n;\n\n\n}\n\n\n\nint\n \nmain\n()\n\n\n{\n\n  \nlong\n \nx\n \n=\n \n1\n;\n\n  \nlong\n \nsum\n;\n\n  \nadd\n(\nsum\n,\n \nx\n,\n \n10\n);\n\n\n}\n\n\n\n\n\n\n\nHere, there are actually two versions of \nsum\n, one in the stack frame of \nmain\n, the other in the stack frame of \nadd\n.  When we change \nsum\n in \nadd\n, we are changing a local copy which will eventually get deleted.  The assignment to \nsum\n in Line 2 has no effect on the variable \nsum\n on Line 8 of \nmain\n.\n\n\nThis explanation explains why a function is a black box, we can only pass in parameters and get a value in return.  Nothing else gets in and out.  There are no \"side effects\" -- whatever happen in the function, stays in the function and does not affect the caller (excepts if it reads or writes to the standard input/output).   Such a function is sometimes called a \"pure function\".\n\n\nAutomatic Variable\n\n\nBecause of the way the memory for the variables are automatically allocated and deallocated when a function is invoked and when the function returns, we call these variables \nautomatic variables\n.  \n\n\nThere are two other types of variables, \nglobal variable\n, which we have mentioned is a very very bad programming practice in Lecture 5 and is banned from CS1010, and \nstatic variable\n, which could be useful in rare occasion but we shouldn't concern ourselves with this type of variable in CS1010 for the moment.\n\n\nStack Size\n\n\nThe OS typically reserves a limited amount of memory for each program for the stack.  You can find out, on your system, what is the maximum allocated stack size with the command \n\n1\nulimit -s\n\n\n\n\n\nOn our CS1010 PE hosts, the limit is 8 MB.  \n\n\nProblem Set 13\n\n\nProblem 13.1\n\n\nTrace through what gets stored in the call stack when we run the following programs:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n#include\n \n<math.h>\n\n\n\nlong\n \nsquare\n(\nlong\n \nx\n)\n\n\n{\n\n  \nreturn\n \nx\n*\nx\n;\n\n\n}\n\n\n\ndouble\n \nhypotenuse_of\n(\nlong\n \nbase\n,\n \nlong\n \nheight\n)\n\n\n{\n\n  \nreturn\n \nsqrt\n(\nsquare\n(\nbase\n)\n \n+\n \nsquare\n(\nheight\n));\n\n\n}\n\n\n\nint\n \nmain\n()\n\n\n{\n\n  \nhypotenuse_of\n(\n3\n,\n \n4\n);\n\n\n}\n\n\n\n\n\n\n\nProblem 13.2\n\n\nTrace through what gets stored in the call stack when we run the following programs:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n#include\n \n\"cs1010.h\"\n\n\n\nlong\n \nfactorial\n(\nlong\n \nn\n)\n\n\n{\n\n  \nif\n \n(\nn\n \n==\n \n0\n)\n \n{\n\n    \nreturn\n \n1\n;\n\n  \n}\n\n  \nreturn\n \nfactorial\n(\nn\n-\n1\n)\n \n*\n \nn\n;\n\n\n}\n\n\n\nint\n \nmain\n()\n\n\n{\n\n  \nfactorial\n(\n3\n);\n\n\n}\n\n\n\n\n\n\n\nProblem 13.3\n\n\nWhat will be printed by the program below?\nTrace through what gets stored in the call stack when we run the following programs:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n#include\n \n\"cs1010.h\"\n\n\n\nvoid\n \nincr\n(\nlong\n \nx\n)\n \n{\n\n    \nx\n \n+=\n \n1\n;\n\n\n}\n\n\n\nint\n \nmain\n()\n\n\n{\n\n    \nlong\n \nx\n \n=\n \n10\n;\n\n    \nincr\n(\nx\n);\n\n    \nincr\n(\nx\n);\n\n    \ncs1010_print_long\n(\nx\n);\n\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe variable \nsum\n is not necessary and the function can be better written as a one-liner \nreturn a + b;\n.  But I introduce the additional variable \nsum\n here to make the example more meaningful in explaining about stack frame.\u00a0\n\u21a9",
            "title": "13. Call Stack"
        },
        {
            "location": "/13-call-stack/index.html#unit-13-call-stack",
            "text": "In this unit, we will delve deeper into how variables are stored in the memory and what happens when we call a function.",
            "title": "Unit 13: Call Stack"
        },
        {
            "location": "/13-call-stack/index.html#stack-frame",
            "text": "Modern OS typically divide the memory into several regions.  The region that we are concerned with for now is called the  call stack . \nEvery function invocation causes the OS to allocate some memory on the call stack to store (among other things) the parameters passed into the function and the variables declared and used in the function.  The memory allocated to each function call is called a  stack frame .  When a function returns, the stack frame is deallocated and freed up for other uses.  Let's start with the following simple program as an example.  1\n2\n3\n4\n5 int   main ()  { \n   long   x   =   1 ; \n   long   y ;  }    When the OS runs the program above, it invokes, or calls, the function  main .  A new stack frame is created for  main() .  There are two variables  x  and  y  declared in  main .  Recall from  Unit 2  that a variable is a location in the memory which holds a value.  Thus, the stack frame of  main  will include these two variables.  We initialize  x  to 1 in the code above, so the value 1 will be placed in the memory location of  x .  The variable  y  remains uninitialized, so it will contain whatever value that happens to be in the memory at that time.   Now, let's consider the program 1 :   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12 long   add ( long   a ,   long   b )   { \n   long   sum ; \n   sum   =   a   +   b ; \n   return   sum ;  }  int   main ()  { \n   long   x   =   1 ; \n   long   y ; \n   y   =   add ( x ,   10 );  }    Now, the program invokes the function  add  with two parameters, using  x  and 10 as arguments.  What the OS does when  add  is called, is that it allocates another stack frame for  add .  We can visualize the stack frame for  add  as being placed on top of the stack frame of  main .  The stack frame for  add  includes two variables corresponding to the parameters  a ,  b , and the variable  sum  declared in the function  add .  When the stack frame for  add  is created,  sum  is uninitialized, but  a  is initialized to whatever the value of  x  is when the function is invoked (1 in this example), and  b  is initialized to 10, since that is the argument passed into  add .   After the stack frame for  add  is set up, the code is executed.  The memory location for  sum  is then initialized to the sum of  a  and  b  (11 in this example), and the return statement is executed.     When a function returns, the stack frame for  sum  is removed.  The variables  sum ,  a ,  b  crumble into dust and no longer exist in the memory.  The value of the variable being returned ( sum  in this case) is then copied back to the stack frame of the  main  (the  callee ).  In this example, this value is copied into the memory location of  y .   What would happen if we change the value of  a  within  add ?   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12 long   add ( long   a ,   long   b )   { \n   sum   =   a   +   b ; \n   a   =   42 ;    // change a \n   return   sum ;  }  int   main ()  { \n   long   x   =   1 ; \n   long   y ; \n   y   =   add ( x ,   10 );  }    In this example, we change the value of  a  in the call stack of  add  to 42.  This has no effect on any variable in  main , since the changes apply only within the stack frame of  add .  A common bug by beginners is to try to write a function this way:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10 void   add ( long   sum ,   long   a ,   long   b )   { \n   sum   =   a   +   b ;  }  int   main ()  { \n   long   x   =   1 ; \n   long   sum ; \n   add ( sum ,   x ,   10 );  }    Here, there are actually two versions of  sum , one in the stack frame of  main , the other in the stack frame of  add .  When we change  sum  in  add , we are changing a local copy which will eventually get deleted.  The assignment to  sum  in Line 2 has no effect on the variable  sum  on Line 8 of  main .  This explanation explains why a function is a black box, we can only pass in parameters and get a value in return.  Nothing else gets in and out.  There are no \"side effects\" -- whatever happen in the function, stays in the function and does not affect the caller (excepts if it reads or writes to the standard input/output).   Such a function is sometimes called a \"pure function\".",
            "title": "Stack Frame"
        },
        {
            "location": "/13-call-stack/index.html#automatic-variable",
            "text": "Because of the way the memory for the variables are automatically allocated and deallocated when a function is invoked and when the function returns, we call these variables  automatic variables .    There are two other types of variables,  global variable , which we have mentioned is a very very bad programming practice in Lecture 5 and is banned from CS1010, and  static variable , which could be useful in rare occasion but we shouldn't concern ourselves with this type of variable in CS1010 for the moment.",
            "title": "Automatic Variable"
        },
        {
            "location": "/13-call-stack/index.html#stack-size",
            "text": "The OS typically reserves a limited amount of memory for each program for the stack.  You can find out, on your system, what is the maximum allocated stack size with the command  1 ulimit -s   On our CS1010 PE hosts, the limit is 8 MB.",
            "title": "Stack Size"
        },
        {
            "location": "/13-call-stack/index.html#problem-set-13",
            "text": "",
            "title": "Problem Set 13"
        },
        {
            "location": "/13-call-stack/index.html#problem-131",
            "text": "Trace through what gets stored in the call stack when we run the following programs:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16 #include   <math.h>  long   square ( long   x )  { \n   return   x * x ;  }  double   hypotenuse_of ( long   base ,   long   height )  { \n   return   sqrt ( square ( base )   +   square ( height ));  }  int   main ()  { \n   hypotenuse_of ( 3 ,   4 );  }",
            "title": "Problem 13.1"
        },
        {
            "location": "/13-call-stack/index.html#problem-132",
            "text": "Trace through what gets stored in the call stack when we run the following programs:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14 #include   \"cs1010.h\"  long   factorial ( long   n )  { \n   if   ( n   ==   0 )   { \n     return   1 ; \n   } \n   return   factorial ( n - 1 )   *   n ;  }  int   main ()  { \n   factorial ( 3 );  }",
            "title": "Problem 13.2"
        },
        {
            "location": "/13-call-stack/index.html#problem-133",
            "text": "What will be printed by the program below?\nTrace through what gets stored in the call stack when we run the following programs:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13 #include   \"cs1010.h\"  void   incr ( long   x )   { \n     x   +=   1 ;  }  int   main ()  { \n     long   x   =   10 ; \n     incr ( x ); \n     incr ( x ); \n     cs1010_print_long ( x );  }        The variable  sum  is not necessary and the function can be better written as a one-liner  return a + b; .  But I introduce the additional variable  sum  here to make the example more meaningful in explaining about stack frame.\u00a0 \u21a9",
            "title": "Problem 13.3"
        },
        {
            "location": "/14-pointers/index.html",
            "text": "Unit 14: Memory Addresses or Pointers\n\n\nEvery memory location has an address.  Unlike many higher level languages, such as Java, Python, and JavaScript, C allows us direct access to memory addresses.  This empowers programmers to do wonderful things that cannot be done in other languages.  But, it is also dangerous at the same time -- using it improperly can lead to bugs that are hard to track down and debug.\n\n\nThe Address-of Operator\n\n\nC has an operator called \"address-of\", denoted by \n&\n.  This operator, returns, well, the address of a variable.\n\n\nWe can type cast the address of a variable into \nlong\n and print it out to examine its value.  Consider this:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n#include\n \n\"cs1010.h\"\n\n\n\nvoid\n \nadd\n(\nlong\n \nsum\n,\n \nlong\n \na\n,\n \nlong\n \nb\n)\n \n{\n\n  \nsum\n \n=\n \na\n \n+\n \nb\n;\n\n  \ncs1010_println_long\n((\nlong\n)\n&\nsum\n);\n\n\n}\n\n\n\nint\n \nmain\n()\n\n\n{\n\n  \nlong\n \nx\n \n=\n \n1\n;\n\n  \nlong\n \nsum\n;\n\n  \nadd\n(\nsum\n,\n \nx\n,\n \n10\n);\n\n  \ncs1010_println_long\n((\nlong\n)\n&\nsum\n);\n\n\n}\n\n\n\n\n\n\n\nRunning the program above prints something like this:\n\n1\n2\n140723025685528\n140723025685552\n\n\n\n\n\nYour results will most likely be different, since the OS allocates different regions of the memory to this program every time it is run.  \n\n\n\n\nThe Deference Operator\n\n\nThe dereference operator is the reversed of address-of, and is denoted by \n*\n.  I call it \"location-of-address\".  We use this operator in two places:\n\n\n\n\nto declare an \"address\" variable, and\n\n\nto reference the location of an address.\n\n\n\n\nWe can declare a variable that is an address type.  We need to tell C the type of the variable this address is referencing.  For instance,\n\n\n1\ndouble\n \n*\naddr\n;\n\n\n\n\n\n\n\ndeclares a variable \naddr\n that is an address to a variable of type \ndouble\n.  The way to read this is that \n*addr\n, or location-of-address \naddr\n is of type \ndouble\n, so \naddr\n is an address of a location containing a \ndouble\n.\n\n\n\n\nCommon Bug\n\n\nIt is possible to write as\n\n1\ndouble\n*\n \naddr\n;\n\n\n\n\n\ntoo, but this is not recommended.  Suppose you want to declare two addresses, you might write, \n\n1\ndouble\n*\n \nfrom_addr\n,\n \nto_addr\n;\n\n\n\n\n\nthinking that both \nfrom_addr\n and \nto_addr\n are of type \ndouble*\n.  But, actually, C treats \nto_addr\n as a \ndouble\n, not an address of a \ndouble\n!  In any case, if you follow CS1010 style, you shouldn't be declaring two variables in one line.\n\n\n\n\nAnother name for a variable of type address is \npointer\n.  We can visualize a pointer as pointing to some location in the memory.\n\n\nChanging the Value via Pointer\n\n\nSuppose we declare a pointer to a \ndouble\n variable (or, for short, a \ndouble\n pointer):\n\n1\ndouble\n \n*\naddr\n;\n\n\n\n\n\n\nWe can use \n*addr\n just like a normal \ndouble\n variable:\n\n1\n*\naddr\n \n=\n \n1.0\n;\n\n\n\n\n\n\nThe line above means that, \nwe take the address stored in addr, go to the location at that address, and store the value 1.0 in the location.\n\n\nThis is where things can get dangerous.  You could be changing the value in a memory location that you do not mean to.  If you are lucky, your program crashes with a \nsegmentation fault\n error\n1\n. We say that your program has segfault.  If you are unlucky, your program runs normally but produces incorrect output occasionally.\n\n\n\n\nSo, \nalways make sure that your pointer is pointing to the right location before dereferencing and writing to the location.\n\n\nIn the code above, if we write:\n\n1\n2\ndouble\n \n*\naddr\n;\n\n\n*\naddr\n \n=\n \n1.0\n;\n\n\n\n\n\n\nback-to-back, the program will almost certainly segfault, because the pointer variable \naddr\n is not initialized, so it is pointing to the location of whatever address happens to be in the memory at that time.\n\n\nWe should point addr to a value location first, like this:\n\n1\n2\n3\n4\ndouble\n \nc\n;\n\n\ndouble\n \n*\naddr\n;\n\n\naddr\n \n=\n \n&\nc\n;\n\n\n*\naddr\n \n=\n \n1.0\n;\n\n\n\n\n\n\n\n\nOf course, the above could be simply written as:\n\n1\ndouble\n \nc\n \n=\n \n1.0\n;\n\n\n\n\n\n\nI am just doing it the complicated way (which you should avoid unless you have good reasons to do so) to demonstrate the concept of pointers.\n\n\nBasic Rules About Using Pointers\n\n\n\n\n\n\nWhen we use pointers, it must point to the variable of the same type as that declared by the pointer.  For instance,\n\n\n1\n2\n3\n4\n5\ndouble\n \npi\n \n=\n \n3.1415926\n;\n\n\nlong\n \nradius\n \n=\n \n5\n;\n\n\ndouble\n \n*\naddr\n;\n\n\naddr\n \n=\n \n&\npi\n;\n \n// ok\n\n\naddr\n \n=\n \n&\nradius\n;\n \n// not ok\n\n\n\n\n\n\n\nLine 4 above would lead to a compilation error since we try to point a \ndouble\n pointer to a \nlong\n.  \n\n\n\n\n\n\nWe cannot change the address of a variable.  For instance\n\n\n1\n2\n3\nlong\n \nx\n \n=\n \n1\n;\n\n\nlong\n \ny\n \n=\n \n2\n;\n\n\n&\nx\n \n=\n \n&\ny\n;\n \n\n\n\n\n\n\nWe try to set the address of \nx\n to be the address of \ny\n.  This is not allowed since allocation of variables in the memory is determined by the OS, a process we have no control over.\n\n\n\n\n\n\nWe can perform arithmetic operations on pointers, but not in the way you expect.\n\n\nSuppose we have a pointer:\n\n1\n2\n3\n4\n5\nlong\n \nx\n;\n\n\nlong\n \n*\nptr\n;\n\n\nx\n \n=\n \n1\n;\n\n\nptr\n \n=\n \n&\nx\n;\n\n\nptr\n \n+=\n \n1\n;\n\n\n\n\n\n\nSuppose that \nx\n is stored in memory address 1000, after Line 4, \nptr\n would have the value of 1000. \nAfter the line \nptr += 1\n, using normal arithmetic operation, we would think that \nptr\n will have the value of 1001.  However, the semantic for arithmetic operation is different for pointers.  The \n+\n operation for \nptr\n causes the \nptr\n variable to move forward by the size of the variable pointed to by the pointer.  In this example, \nptr\n points to \nlong\n, assuming that \nlong\n is 8 bytes, after \nptr += 1\n, \nptr\n will have the value of 1008.\n\n\nWe can only do addition and subtraction for pointers.\n\n\n\n\n\n\nPointer of Pointer (of Pointer..)\n\n\nA pointer variable is also stored in the memory, so it itself has an address too.\n\n\n1\n2\n3\nlong\n \nx\n;\n\n\nlong\n \n*\nptr\n;\n\n\nptr\n \n=\n \n&\nx\n;\n\n\n\n\n\n\n\nFor instance, in the above, \nptr\n would have a memory location allocated on the stack too, and so it itself has an address, and we can have a variable \nptrptr\n referring to the address of \nptr\n.  What would the type of this variable be?  Since \nptr\n is an address of \nlong\n, \nptrptr\n is an address of an address of \nlong\n, and can be written as:\n\n\n1\n2\n3\n4\n5\nlong\n \nx\n;\n\n\nlong\n \n*\nptr\n;\n\n\nlong\n \n**\nptrptr\n;\n\n\nptr\n \n=\n \n&\nx\n;\n\n\nptrptr\n \n=\n \n&\nptr\n;\n\n\n\n\n\n\n\nThis deference can go on since \nptrptr\n is also a variable and have been allocated in some memory location on the stack.  We rarely need to dereference more than twice in practice, but if the situation arises, such multiple layers of dereferencing is possible.\n\n\nThe \nNULL\n Pointer\n\n\nNULL\n is a special value that is used to indicate that a pointer is pointing to nothing.  In C, \nNULL\n is actually 0 (i.e., pointing to memory location 0).\n\n\nWe use \nNULL\n to indicate that the pointer is invalid, typically to mean that we have not initialized the pointer or to flag an error condition.\n\n\n\n\nBillion Dollar Mistakes\n\n\nSir Tony Hoare (the same one whom we met when we talked about \nAssertion\n) also invented the null pointer.  He called it his billion-dollar mistake.  Quoting from him: \"I couldn't resist the temptation to put in a null reference, simply because it was so easy to implement. This has led to innumerable errors, vulnerabilities, and system crashes, which have probably caused a billion dollars of pain and damage in the last forty years.\"  As you start to use pointers in CS1010, you will see why it is a pain.\n\n\n\n\nProblem Set 14\n\n\nProblem 14.1\n\n\nSketch the content of the memory while tracing through the following code.  What would be printed?\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\nlong\n \n*\nptr1\n;\n\n\nlong\n \n*\nptr2\n;\n\n\nlong\n \nx\n;\n\n\nlong\n \ny\n;\n\n\n\nptr1\n \n=\n \n&\nx\n;\n\n\nptr2\n \n=\n \n&\ny\n;\n\n\n\n*\nptr1\n \n=\n \n123\n;\n\n\n*\nptr2\n \n=\n \n-\n1\n;\n\n\n\ncs1010_println_long\n(\nx\n);\n\n\ncs1010_println_long\n(\ny\n);\n\n\ncs1010_println_long\n(\n*\nptr1\n);\n\n\ncs1010_println_long\n(\n*\nptr2\n);\n\n\n\nptr1\n \n=\n \nptr1\n;\n\n\n*\nptr1\n \n=\n \n1946\n;\n\n\n\ncs1010_println_long\n(\nx\n);\n\n\ncs1010_println_long\n(\ny\n);\n\n\ncs1010_println_long\n(\n*\nptr1\n);\n\n\ncs1010_println_long\n(\n*\nptr2\n);\n\n\n\ny\n \n=\n \n10\n;\n\n\n\ncs1010_println_long\n(\nx\n);\n\n\ncs1010_println_long\n(\ny\n);\n\n\ncs1010_println_long\n(\n*\nptr1\n);\n\n\ncs1010_println_long\n(\n*\nptr2\n);\n\n\n\n\n\n\n\nProblem 14.2\n\n\nWhat is wrong with both programs below?\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\ndouble\n \n*\naddr_of\n(\ndouble\n \nx\n)\n\n\n{\n\n  \nreturn\n \n&\nx\n;\n\n\n}\n\n\n\nint\n \nmain\n()\n\n\n{\n\n  \ndouble\n \nc\n \n=\n \n0.0\n;\n\n  \ndouble\n \n*\nptr\n;\n\n\n  \nptr\n \n=\n \naddr_of\n(\nc\n);\n\n  \n*\nptr\n \n=\n \n10\n;\n\n\n}\n\n\n\n\n\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\ndouble\n \n*\ntriple_of\n(\ndouble\n \nx\n)\n\n\n{\n\n  \ndouble\n \ntriple\n \n=\n \n3\n \n*\n \nx\n;\n\n  \nreturn\n \n&\ntriple\n;\n\n\n}\n\n\n\nint\n \nmain\n()\n\n\n{\n\n  \ndouble\n \n*\nptr\n;\n\n\n  \nptr\n \n=\n \ntriple_of\n(\n10\n);\n\n  \ncs1010_println_double\n(\n*\nptr\n);\n\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nI leave it to the later OS classes CG2271 / CS2016 to explain the term \"segmentation\" and \"fault\".  Interested students can always google and \nread on Wikipedia\n.\u00a0\n\u21a9",
            "title": "14. Pointers"
        },
        {
            "location": "/14-pointers/index.html#unit-14-memory-addresses-or-pointers",
            "text": "Every memory location has an address.  Unlike many higher level languages, such as Java, Python, and JavaScript, C allows us direct access to memory addresses.  This empowers programmers to do wonderful things that cannot be done in other languages.  But, it is also dangerous at the same time -- using it improperly can lead to bugs that are hard to track down and debug.",
            "title": "Unit 14: Memory Addresses or Pointers"
        },
        {
            "location": "/14-pointers/index.html#the-address-of-operator",
            "text": "C has an operator called \"address-of\", denoted by  & .  This operator, returns, well, the address of a variable.  We can type cast the address of a variable into  long  and print it out to examine its value.  Consider this:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14 #include   \"cs1010.h\"  void   add ( long   sum ,   long   a ,   long   b )   { \n   sum   =   a   +   b ; \n   cs1010_println_long (( long ) & sum );  }  int   main ()  { \n   long   x   =   1 ; \n   long   sum ; \n   add ( sum ,   x ,   10 ); \n   cs1010_println_long (( long ) & sum );  }    Running the program above prints something like this: 1\n2 140723025685528\n140723025685552   Your results will most likely be different, since the OS allocates different regions of the memory to this program every time it is run.",
            "title": "The Address-of Operator"
        },
        {
            "location": "/14-pointers/index.html#the-deference-operator",
            "text": "The dereference operator is the reversed of address-of, and is denoted by  * .  I call it \"location-of-address\".  We use this operator in two places:   to declare an \"address\" variable, and  to reference the location of an address.   We can declare a variable that is an address type.  We need to tell C the type of the variable this address is referencing.  For instance,  1 double   * addr ;    declares a variable  addr  that is an address to a variable of type  double .  The way to read this is that  *addr , or location-of-address  addr  is of type  double , so  addr  is an address of a location containing a  double .   Common Bug  It is possible to write as 1 double *   addr ;   \ntoo, but this is not recommended.  Suppose you want to declare two addresses, you might write,  1 double *   from_addr ,   to_addr ;   \nthinking that both  from_addr  and  to_addr  are of type  double* .  But, actually, C treats  to_addr  as a  double , not an address of a  double !  In any case, if you follow CS1010 style, you shouldn't be declaring two variables in one line.   Another name for a variable of type address is  pointer .  We can visualize a pointer as pointing to some location in the memory.",
            "title": "The Deference Operator"
        },
        {
            "location": "/14-pointers/index.html#changing-the-value-via-pointer",
            "text": "Suppose we declare a pointer to a  double  variable (or, for short, a  double  pointer): 1 double   * addr ;    We can use  *addr  just like a normal  double  variable: 1 * addr   =   1.0 ;    The line above means that,  we take the address stored in addr, go to the location at that address, and store the value 1.0 in the location.  This is where things can get dangerous.  You could be changing the value in a memory location that you do not mean to.  If you are lucky, your program crashes with a  segmentation fault  error 1 . We say that your program has segfault.  If you are unlucky, your program runs normally but produces incorrect output occasionally.   So,  always make sure that your pointer is pointing to the right location before dereferencing and writing to the location.  In the code above, if we write: 1\n2 double   * addr ;  * addr   =   1.0 ;    back-to-back, the program will almost certainly segfault, because the pointer variable  addr  is not initialized, so it is pointing to the location of whatever address happens to be in the memory at that time.  We should point addr to a value location first, like this: 1\n2\n3\n4 double   c ;  double   * addr ;  addr   =   & c ;  * addr   =   1.0 ;     Of course, the above could be simply written as: 1 double   c   =   1.0 ;    I am just doing it the complicated way (which you should avoid unless you have good reasons to do so) to demonstrate the concept of pointers.",
            "title": "Changing the Value via Pointer"
        },
        {
            "location": "/14-pointers/index.html#basic-rules-about-using-pointers",
            "text": "When we use pointers, it must point to the variable of the same type as that declared by the pointer.  For instance,  1\n2\n3\n4\n5 double   pi   =   3.1415926 ;  long   radius   =   5 ;  double   * addr ;  addr   =   & pi ;   // ok  addr   =   & radius ;   // not ok    Line 4 above would lead to a compilation error since we try to point a  double  pointer to a  long .      We cannot change the address of a variable.  For instance  1\n2\n3 long   x   =   1 ;  long   y   =   2 ;  & x   =   & y ;     We try to set the address of  x  to be the address of  y .  This is not allowed since allocation of variables in the memory is determined by the OS, a process we have no control over.    We can perform arithmetic operations on pointers, but not in the way you expect.  Suppose we have a pointer: 1\n2\n3\n4\n5 long   x ;  long   * ptr ;  x   =   1 ;  ptr   =   & x ;  ptr   +=   1 ;    Suppose that  x  is stored in memory address 1000, after Line 4,  ptr  would have the value of 1000. \nAfter the line  ptr += 1 , using normal arithmetic operation, we would think that  ptr  will have the value of 1001.  However, the semantic for arithmetic operation is different for pointers.  The  +  operation for  ptr  causes the  ptr  variable to move forward by the size of the variable pointed to by the pointer.  In this example,  ptr  points to  long , assuming that  long  is 8 bytes, after  ptr += 1 ,  ptr  will have the value of 1008.  We can only do addition and subtraction for pointers.",
            "title": "Basic Rules About Using Pointers"
        },
        {
            "location": "/14-pointers/index.html#pointer-of-pointer-of-pointer",
            "text": "A pointer variable is also stored in the memory, so it itself has an address too.  1\n2\n3 long   x ;  long   * ptr ;  ptr   =   & x ;    For instance, in the above,  ptr  would have a memory location allocated on the stack too, and so it itself has an address, and we can have a variable  ptrptr  referring to the address of  ptr .  What would the type of this variable be?  Since  ptr  is an address of  long ,  ptrptr  is an address of an address of  long , and can be written as:  1\n2\n3\n4\n5 long   x ;  long   * ptr ;  long   ** ptrptr ;  ptr   =   & x ;  ptrptr   =   & ptr ;    This deference can go on since  ptrptr  is also a variable and have been allocated in some memory location on the stack.  We rarely need to dereference more than twice in practice, but if the situation arises, such multiple layers of dereferencing is possible.",
            "title": "Pointer of Pointer (of Pointer..)"
        },
        {
            "location": "/14-pointers/index.html#the-null-pointer",
            "text": "NULL  is a special value that is used to indicate that a pointer is pointing to nothing.  In C,  NULL  is actually 0 (i.e., pointing to memory location 0).  We use  NULL  to indicate that the pointer is invalid, typically to mean that we have not initialized the pointer or to flag an error condition.   Billion Dollar Mistakes  Sir Tony Hoare (the same one whom we met when we talked about  Assertion ) also invented the null pointer.  He called it his billion-dollar mistake.  Quoting from him: \"I couldn't resist the temptation to put in a null reference, simply because it was so easy to implement. This has led to innumerable errors, vulnerabilities, and system crashes, which have probably caused a billion dollars of pain and damage in the last forty years.\"  As you start to use pointers in CS1010, you will see why it is a pain.",
            "title": "The NULL Pointer"
        },
        {
            "location": "/14-pointers/index.html#problem-set-14",
            "text": "",
            "title": "Problem Set 14"
        },
        {
            "location": "/14-pointers/index.html#problem-141",
            "text": "Sketch the content of the memory while tracing through the following code.  What would be printed?   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30 long   * ptr1 ;  long   * ptr2 ;  long   x ;  long   y ;  ptr1   =   & x ;  ptr2   =   & y ;  * ptr1   =   123 ;  * ptr2   =   - 1 ;  cs1010_println_long ( x );  cs1010_println_long ( y );  cs1010_println_long ( * ptr1 );  cs1010_println_long ( * ptr2 );  ptr1   =   ptr1 ;  * ptr1   =   1946 ;  cs1010_println_long ( x );  cs1010_println_long ( y );  cs1010_println_long ( * ptr1 );  cs1010_println_long ( * ptr2 );  y   =   10 ;  cs1010_println_long ( x );  cs1010_println_long ( y );  cs1010_println_long ( * ptr1 );  cs1010_println_long ( * ptr2 );",
            "title": "Problem 14.1"
        },
        {
            "location": "/14-pointers/index.html#problem-142",
            "text": "What is wrong with both programs below?   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13 double   * addr_of ( double   x )  { \n   return   & x ;  }  int   main ()  { \n   double   c   =   0.0 ; \n   double   * ptr ; \n\n   ptr   =   addr_of ( c ); \n   * ptr   =   10 ;  }     1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13 double   * triple_of ( double   x )  { \n   double   triple   =   3   *   x ; \n   return   & triple ;  }  int   main ()  { \n   double   * ptr ; \n\n   ptr   =   triple_of ( 10 ); \n   cs1010_println_double ( * ptr );  }        I leave it to the later OS classes CG2271 / CS2016 to explain the term \"segmentation\" and \"fault\".  Interested students can always google and  read on Wikipedia .\u00a0 \u21a9",
            "title": "Problem 14.2"
        },
        {
            "location": "/15-array/index.html",
            "text": "Unit 15: Array\n\n\nWe now look at the first of the two compound data types in C --  arrays.  \n\n\nA variable can be declared to be of an array, in which case it can hold one or more values.  An array variable can only store values of the \nsame\n type \nT\nT\n.  We say that the array variable is an array of \nT\nT\n.  For instance, we can declare a variable \nmarks\n to be an array of \nlong\n, in which case, \nmarks\n can hold one or more \nlong\n values.  \n\n\nArray Declaration\n\n\nThe declaration syntax for an array in C takes the following form:\n\n\n1\nlong\n \nmarks\n[\n10\n];\n\n\n\n\n\n\n\nWe use the square bracket \n[\n and \n]\n to indicate that the variable \nmarks\n is an array.  The number \n10\n indicates that \nmarks\n holds 10 \nlong\n values.\n\n\nOnce declared, the variables in the array are uninitialized and will contain whatever value happened to be in the memory at that time.\n\n\nAccessing the Array Elements\n\n\nWe can access the array elements using the index of the element, starting from 0.  For instance, to initialize the marks for the first three students to 1, 2, 4, respectively, we can write:\n\n\n1\n2\n3\n4\nlong\n \nmarks\n[\n10\n];\n\n\nmarks\n[\n0\n]\n \n=\n \n1\n;\n\n\nmarks\n[\n1\n]\n \n=\n \n2\n;\n\n\nmarks\n[\n2\n]\n \n=\n \n4\n;\n\n\n\n\n\n\n\nArray Initialization\n\n\nInitializing a large array using the method above could be tedious.  Alternatively, we can initialize an array using a list of values when we declare the array.  \n\n\n1\nlong\n \nmarks\n[\n10\n]\n \n=\n \n{\n1\n,\n \n2\n,\n \n3\n,\n \n1\n,\n \n5\n,\n \n10\n,\n \n10\n,\n \n4\n,\n \n5\n,\n \n3\n,\n \n};\n\n\n\n\n\n\n\nIf we do not specify a value during initialization, it will be set to 0 by default.  \n\n\n1\n2\nlong\n \nmarks\n[\n10\n]\n \n=\n \n{\n1\n,\n \n2\n,\n \n3\n,\n \n1\n,\n \n5\n,\n \n10\n,\n \n10\n,\n \n4\n,\n \n};\n\n\n// marks[8] and marks[9] are both initialized to 0\n\n\n\n\n\n\n\nNote that, after the declaration, we can no longer using this technique to reinitialized or initialize the array.\n\n\n1\n2\nlong\n \nmarks\n[\n10\n];\n\n\nmarks\n \n=\n \n{\n1\n,\n \n2\n,\n \n3\n,\n \n1\n,\n \n5\n,\n \n10\n,\n \n10\n,\n \n4\n,\n \n5\n,\n \n3\n,\n \n};\n  \n// error\n\n\n\n\n\n\n\nExample 1: Array As Lookup Table\n\n\nOne way the array is useful is that it can be used as a lookup table.\n\n\nConsider the following function \ndays()\n, which, given a month, return the number of days from the 1\nst\n of January until the 1\nst\n of the month.  So \ndays(1)\n returns 0, \ndays(2)\n returns 31 (since January has 31 days), \ndays(3)\n returns 31 + 28 = 59 (assuming non-leap year), etc.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\nlong\n \ndays\n(\nlong\n \nmonth\n)\n\n\n{\n\n  \nlong\n \ndays_since\n \n=\n \n0\n;\n\n  \nif\n \n(\nmonth\n \n==\n \n2\n)\n \n{\n\n    \ndays_since\n \n=\n \n31\n;\n\n  \n}\n \nelse\n \nif\n \n(\nmonth\n \n==\n \n3\n)\n \n{\n\n    \ndays_since\n \n=\n \n31\n \n+\n \n28\n;\n\n  \n}\n \nelse\n \nif\n \n(\nmonth\n \n==\n \n4\n)\n \n{\n\n    \ndays_since\n \n=\n \n31\n \n+\n \n28\n \n+\n \n31\n;\n\n  \n}\n \nelse\n \nif\n \n(\nmonth\n \n==\n \n5\n)\n \n{\n\n    \ndays_since\n \n=\n \n31\n \n+\n \n28\n \n+\n \n31\n \n+\n \n30\n;\n\n  \n}\n \nelse\n \nif\n \n(\nmonth\n \n==\n \n6\n)\n \n{\n\n    \ndays_since\n \n=\n \n31\n \n+\n \n28\n \n+\n \n31\n \n+\n \n30\n \n+\n \n31\n;\n\n  \n}\n \nelse\n \nif\n \n(\nmonth\n \n==\n \n7\n)\n \n{\n\n    \ndays_since\n \n=\n \n31\n \n+\n \n28\n \n+\n \n31\n \n+\n \n30\n \n+\n \n31\n \n+\n \n30\n;\n\n  \n}\n \nelse\n \nif\n \n(\nmonth\n \n==\n \n8\n)\n \n{\n\n    \ndays_since\n \n=\n \n31\n \n+\n \n28\n \n+\n \n31\n \n+\n \n30\n \n+\n \n31\n \n+\n \n30\n \n+\n \n31\n;\n\n  \n}\n \nelse\n \nif\n \n(\nmonth\n \n==\n \n9\n)\n \n{\n\n    \ndays_since\n \n=\n \n31\n \n+\n \n28\n \n+\n \n31\n \n+\n \n30\n \n+\n \n31\n \n+\n \n30\n \n+\n \n31\n \n+\n \n31\n;\n\n  \n}\n \nelse\n \nif\n \n(\nmonth\n \n==\n \n10\n)\n \n{\n\n    \ndays_since\n \n=\n \n31\n \n+\n \n28\n \n+\n \n31\n \n+\n \n30\n \n+\n \n31\n \n+\n \n30\n \n+\n \n31\n \n+\n \n31\n \n+\n \n30\n;\n\n  \n}\n \nelse\n \nif\n \n(\nmonth\n \n==\n \n11\n)\n \n{\n\n    \ndays_since\n \n=\n \n31\n \n+\n \n28\n \n+\n \n31\n \n+\n \n30\n \n+\n \n31\n \n+\n \n30\n \n+\n \n31\n \n+\n \n31\n \n+\n \n30\n \n+\n \n31\n;\n\n  \n}\n \nelse\n \nif\n \n(\nmonth\n \n==\n \n12\n)\n \n{\n\n    \ndays_since\n \n=\n \n31\n \n+\n \n28\n \n+\n \n31\n \n+\n \n30\n \n+\n \n31\n \n+\n \n30\n \n+\n \n31\n \n+\n \n31\n \n+\n \n30\n \n+\n \n31\n \n+\n \n30\n;\n\n  \n}\n\n  \nreturn\n \ndays_since\n;\n\n\n}\n\n\n\n\n\n\n\nThe code is ugly and bug-prone.  Consider an alternative solution using an array.\n\n\n1\nlong\n \ndays_in_month\n[\n12\n]\n \n=\n \n{\n31\n,\n \n28\n,\n \n31\n,\n \n30\n,\n \n31\n,\n \n30\n,\n \n31\n,\n \n31\n,\n \n30\n,\n \n31\n,\n \n30\n,\n \n31\n};\n\n\n\n\n\n\n\nThe array above is initialized with the number of days in a month.  \ndays_in_month[0]\n stores the number of days in January, \ndays_in_month[1]\n stores the number of days in February, etc.\n\n\nThe code above can then be written as:\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nlong\n \ndays\n(\nlong\n \nmonth\n)\n\n\n{\n\n  \nlong\n \ndays_in_month\n[\n12\n]\n \n=\n \n{\n31\n,\n \n28\n,\n \n31\n,\n \n30\n,\n \n31\n,\n \n30\n,\n \n31\n,\n \n31\n,\n \n30\n,\n \n31\n,\n \n30\n,\n \n31\n};\n\n  \nlong\n \ndays_since\n \n=\n \n0\n;\n\n  \nfor\n \n(\nlong\n \ni\n \n=\n \n0\n;\n \ni\n \n<\n \nmonth\n \n-\n \n1\n;\n \ni\n \n+=\n \n1\n)\n \n{\n\n    \ndays_since\n \n+=\n \ndays_in_month\n[\ni\n];\n\n  \n}\n\n  \nreturn\n \ndays_since\n;\n\n\n}\n\n\n\n\n\n\n\nExample 2: Array As List\n\n\nWe can now revisit the flowchart for \nmax\nmax\n and write the corresponding code.  The code would look like this:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\nlong\n \nmax\n(\nlong\n \nlist\n[],\n \nlong\n \nlength\n)\n\n\n{\n\n  \nlong\n \nmax_so_far\n \n=\n \nlist\n[\n0\n];\n\n  \nfor\n \n(\nlong\n \ni\n \n=\n \n1\n;\n \ni\n \n!=\n \nlength\n;\n \ni\n \n+=\n \n1\n)\n \n{\n\n    \nif\n \n(\nlist\n[\ni\n]\n \n>\n \nmax_so_far\n)\n \n{\n\n      \nmax_so_far\n \n=\n \nlist\n[\ni\n];\n\n    \n}\n\n  \n}\n\n  \nreturn\n \nmax_so_far\n;\n\n\n}\n\n\n\n\n\n\n\nNote that, in the type of the array passed into the function above, we only need to use \n[]\n without specifying the length.  It is also almost always necessary to pass in the number of elements in the array together with the array so that we know how many elements are there to process.  To understand why, we have to understand something called \narray decay\n.\n\n\nArray and Pointers\n\n\nThe relationship between array and pointer can be confusing to beginners.  Some might even think that arrays are pointers due to the way they are passed around and used.  But \narrays are not pointers\n.  The relationship between the two, boils down to a very simple rule, as follows.\n\n\nIn C, the name of the variable of an array is treated differently from a non-array variable.  If we declare an array\n\n\n1\ntype\n \nname\n[\nnum_of_elems\n];\n\n\n\n\n\n\n\nthen any reference to \nname\n is a synonym to \n&name[0]\n whenever we need the value of the array.  In other words, \nname\n is the pointer to the first element in the array.  This is known as the \"array decay\" operation.\n\n\nThere are several implications of this.\n\n\nFirst, it is not possible to compare two arrays or assign one array to another.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\nlong\n \na\n[\n2\n]\n \n=\n \n{\n0\n,\n \n1\n};\n\n\nlong\n \nb\n[\n2\n]\n \n=\n \n{\n0\n,\n \n1\n};\n\n\n\nif\n \n(\na\n \n==\n \nb\n)\n \n{\n  \n// always false\n\n  \n:\n\n\n}\n\n\n\nb\n \n=\n \na\n;\n \n// not possible\n\n\n\n\n\n\n\nLine 4 above is equivalent to comparing \n&a[0]\n to \n&b[0]\n, due to array decay, and therefore is always false (since the array elements do not have the same memory address).\n\n\nLine 8 above is equivalent to assigning \n&a[0]\n to \n&b[0]\n, as we seen in (Unit 14)[14-pointers.md], we cannot change the memory address of a variable since this is determined by the OS.\n\n\nSecond, the expression \nname[i]\n is actually the same as \n*(name + i)\n.  Although we should always write \nname[i]\n as it is easier to understand, internally, this translates to accessing the value stored at the i-th location after the first element of the array.  (Revisit \nUnit 14\n if you are unfamiliar with pointer arithmetic).\n\n\nThird, when we pass an array into a function, we are only passing in the address of the first element.\n\n\nConsider the example below:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\nlong\n \nmax\n(\nlong\n \nlist\n[],\n \nlong\n \nlength\n)\n\n\n{\n\n  \nlong\n \nmax_so_far\n \n=\n \nlist\n[\n0\n];\n\n  \nfor\n \n(\nlong\n \ni\n \n=\n \n1\n;\n \ni\n \n!=\n \nlength\n;\n \ni\n \n+=\n \n1\n)\n \n{\n\n    \nif\n \n(\nlist\n[\ni\n]\n \n>\n \nmax_so_far\n)\n \n{\n\n      \nmax_so_far\n \n=\n \nlist\n[\ni\n];\n\n    \n}\n\n  \n}\n\n  \nreturn\n \nmax_so_far\n;\n\n\n}\n\n\n\nint\n \nmain\n()\n\n\n{\n\n  \nlong\n \na\n[\n10\n]\n \n=\n \n{\n1\n,\n \n2\n,\n \n3\n,\n \n4\n,\n \n1\n,\n \n9\n,\n \n10\n,\n \n44\n,\n \n-\n1\n,\n \n-\n5\n};\n\n  \ncs1010_println_long\n(\nmax\n(\na\n,\n \n10\n));\n\n\n}\n\n\n\n\n\n\n\nOn Line 14, we pass \na\n into the function \nmax\n.  Due to array decay, we are not passing in the whole array, but only the \n&a[0]\n.  Inside \nmax\n, we no longer have access to the whole array, but only the address of the first element.  Luckily, due to pointer arithmetic and equivalence of \nlist[i]\n to \n*(list + i)\n, we can still access the elements of the array.  \n\n\nDue to this, the size of \nlist\n in the function parameter does not matter, and we need to pass in the size of the array \nlength\n to \nmax\n so that inside \nmax\n we know the size of the array that we are dealing with.\n\n\nArray decay also means that, when passing in an array as an argument to a function, we can very well write it as:\n\n\n1\n2\n3\n4\nlong\n \nmax\n(\nlong\n \n*\nlist\n,\n \nlong\n \nlength\n)\n\n\n{\n\n    \n:\n\n\n}\n\n\n\n\n\n\n\nFor readability, however, we should convey to the reader of the code that \nlist\n is an array and not just a pointer to \nlong\n, thus we should still use the \n[]\n notation.\n\n\nAnother implication of array decay when passing an array into a function, is that it is possible to write programs that behave incorrectly, without any compiler error or warning.  Consider the following:\n\n\n1\n2\n3\n4\n5\nint\n \nmain\n()\n\n\n{\n\n  \nlong\n \na\n \n=\n \n0\n;\n\n  \nprintf\n(\n\"%ld\n\\n\n\"\n,\n \nmax\n(\n&\na\n,\n \n10\n));\n\n\n}\n\n\n\n\n\n\n\nThe compiler \nclang\n would happily compile this and generate an executable.  When executed, it would print a gibberish to the standard output.\n\n\nOther Facts About Arrays\n\n\nVariable Length Array\n\n\nWe can also declare an array where the number of elements depends on the value of a variable.\n\n\n1\n2\nlong\n \nnum_of_students\n \n=\n \n10\n;\n\n\nlong\n \nmarks\n[\nnum_of_students\n];\n\n\n\n\n\n\n\nSuch arrays, where the number of elements (or length) depends on the value of a variable, are sometimes called \nvariable-length array\n.  This is a misnomer since once the array is created, the length is fixed.  Changing the value of the variable \nnum_of_students\n above will not change the length of \nmarks\n.  \n\n\nSkipping Elements During Initialization\n\n\nIf we have a large array, and we want most of it to be initialized to 0, and only some non-zero, we can use \nelement designators\n, putting the index of the element we want to initialize to non-zero in square brackets \n[\n and \n]\n.\n\n\n1\nlong\n \nvector\n[\n100\n]\n \n=\n \n{\n1\n,\n \n[\n5\n]\n \n=\n \n2\n,\n \n3\n,\n \n[\n99\n]\n \n=\n \n-\n1\n};\n\n\n\n\n\n\n\nAn earlier version of this note has a typo, initializing \n[100] = -1\n instead.\n\n\nThis statement initializes \nvector[0]\n to 1, \nvector[5]\n to 2, \nvector[6]\n to 3, and \nvector[99]\n to -1.  The rest of the elements will be 0.\n\n\nSkipping the Size in Declaration\n\n\nIf you supply an initialization list, the number of elements already indicates the length to the compiler, so you can skip the length.\n\n\n1\nlong\n \nmarks\n[]\n \n=\n \n{\n1\n,\n \n3\n,\n \n2\n,\n \n8\n,\n \n5\n,}\n\n\n\n\n\n\n\nThis makes it easy to add or remove items from the array, without having to remember to keep the array length consistent.  \n\n\nDetermining the Number of Elements in the Array\n\n\nC provides a \nsizeof\n operator, which returns the number of bytes allocated to a type.  We can use \nsizeof long\n for instance, to determine the number of bytes allocated to \nlong\n on a platform.  We can also use \nsizeof\n on a variable instead of the type.  This becomes useful to determine, programmatically, the length of an array (esp if the array length is skipped in the array declaration).  We can calculate the number of elements in \nmarks\n with \n\n\n1\nlong\n \nnum_of_elem\n \n=\n \nsizeof\n \nmarks\n/\nsizeof\n \nmarks\n[\n0\n];\n\n\n\n\n\n\n\nNote that array decay does not apply for only two operators: the \nsizeof\n operator, and the address-of \n&\n operator.  So the expression above works as intended.\n\n\nDynamically Allocated Array\n\n\nIt is often not possible to determine the length of the array beforehand.  So, it is useful to be able to allocate an array with a length that is determined during runtime (not hard-coding the length of the array in the program).\n\n\nFor instance, if I want to keep a \nmarks\n array for a module, it is unclear how big I should set the array to.  How big is big enough?  While I can use a variable-length array for this purpose, it is not ideal -- if the system does not have enough memory to store the array, the program would simply crash with a segfault and there is no way to recover from this.\n\n\nFor this reason, it is useful to request memory from the OS which we will manage ourselves in our program.  Unlike memory space on the call stack which is managed entirely by the OS, there is another region of memory called the \nheap\n, which we can use.  We can request for memory from \nheap\n using the method \ncalloc()\n and return the memory back to the heap when we are done with \nfree()\n.  We will visit these in more details later, but this shallow understanding is enough for now.\n\n\nCS1010 I/O Library\n\n\nTo wrap up this unit, we will look at the CS1010 library functions that help us read in an array of either \nlong\n values or \ndouble\n values.  These functions, \ncs1010_read_long_array\n or \ncs1010_read_double_array\n takes in a parameter, which is the number of elements to read, and it returns a pointer to the array allocated within the function.\n\n\nFor instance, to read in an array of 100 integers, we can write:\n\n\n1\n2\n3\n4\n5\nlong\n \n*\nmarks\n;\n\n\nmarks\n \n=\n \ncs1010_read_long_array\n(\n100\n);\n\n\nfor\n \n(\nlong\n \ni\n \n=\n \n0\n;\n \ni\n \n<\n \n100\n;\n \ni\n \n+=\n \n1\n)\n \n{\n\n  \ncs1010_println_long\n(\nmarks\n[\ni\n]);\n\n\n}\n\n\n\n\n\n\n\nThis should be straightforward enough.  There are, however, two cases to consider.  What if the OS failed to allocate the memory for our array?  In this case, marks would be \nNULL\n and access \nmarks[i]\n would cause a segfault. Second, we must return the memory allocated to us back to the OS once we are done.  To let go of this memory, we call the function \nfree\n.  The complete code looks like this:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\nlong\n \n*\nmarks\n;\n\n\nmarks\n \n=\n \ncs1010_read_long_array\n(\n100\n);\n\n\nif\n \n(\nmarks\n \n==\n \nNULL\n)\n \n{\n\n  \n// signal error and return\n\n\n}\n\n\n\nfor\n \n(\nlong\n \ni\n \n=\n \n0\n;\n \ni\n \n<\n \n100\n;\n \ni\n \n+=\n \n1\n)\n \n{\n\n  \ncs1010_println_long\n(\nmarks\n[\ni\n]);\n\n\n}\n\n\n// do other things to marks \n\n  \n:\n\n\nfree\n(\nmarks\n);\n\n\n\n\n\n\n\nProblem Set 15\n\n\nProblem 15.1\n\n\nWrite the function \naverage\n that takes an array of \nk\nk\n integers and \nk\nk\n and returns the average of the \nk\nk\n values in the array.\n\n\nProblem 15.2\n\n\nExplain why the following would lead to senseless output:\n\n\n1\n2\n3\n4\n5\nint\n \nmain\n()\n\n\n{\n\n  \nlong\n \na\n \n=\n \n0\n;\n\n  \nprintf\n(\n\"%ld\n\\n\n\"\n,\n \nmax\n(\n&\na\n,\n \n10\n));\n\n\n}\n\n\n\n\n\n\n\nHow about the following? Would the output be correct?\n\n\n1\n2\n3\n4\n5\nint\n \nmain\n()\n\n\n{\n\n  \nlong\n \na\n \n=\n \n0\n;\n\n  \nprintf\n(\n\"%ld\n\\n\n\"\n,\n \nmax\n(\n&\na\n,\n \n1\n));\n \n// change 10 to 1\n\n\n}\n\n\n\n\n\n\n\nProblem 15.3\n\n\nExplain how the following code iterates through every element in the list, when called with an array of length \nlength\n as the first argument.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\nlong\n \nmax\n(\nlong\n \n*\nlist\n,\n \nlong\n \nlength\n)\n\n\n{\n\n  \nlong\n \nmax_so_far\n;\n\n  \nlong\n \n*\ncurr\n;\n\n\n  \nmax_so_far\n \n=\n \n*\nlist\n;\n\n  \ncurr\n \n=\n \nlist\n \n+\n \n1\n;\n\n  \nfor\n \n(\nlong\n \ni\n \n=\n \n1\n;\n \ni\n \n!=\n \nlength\n;\n \ni\n \n+=\n \n1\n)\n \n{\n\n    \nif\n \n(\n*\ncurr\n \n>\n \nmax_so_far\n)\n \n{\n\n      \nmax_so_far\n \n=\n \n*\ncurr\n;\n\n    \n}\n\n    \ncurr\n \n+=\n \n1\n;\n\n  \n}\n\n  \nreturn\n \nmax_so_far\n;\n\n\n}",
            "title": "15. Arrays"
        },
        {
            "location": "/15-array/index.html#unit-15-array",
            "text": "We now look at the first of the two compound data types in C --  arrays.    A variable can be declared to be of an array, in which case it can hold one or more values.  An array variable can only store values of the  same  type  T T .  We say that the array variable is an array of  T T .  For instance, we can declare a variable  marks  to be an array of  long , in which case,  marks  can hold one or more  long  values.",
            "title": "Unit 15: Array"
        },
        {
            "location": "/15-array/index.html#array-declaration",
            "text": "The declaration syntax for an array in C takes the following form:  1 long   marks [ 10 ];    We use the square bracket  [  and  ]  to indicate that the variable  marks  is an array.  The number  10  indicates that  marks  holds 10  long  values.  Once declared, the variables in the array are uninitialized and will contain whatever value happened to be in the memory at that time.",
            "title": "Array Declaration"
        },
        {
            "location": "/15-array/index.html#accessing-the-array-elements",
            "text": "We can access the array elements using the index of the element, starting from 0.  For instance, to initialize the marks for the first three students to 1, 2, 4, respectively, we can write:  1\n2\n3\n4 long   marks [ 10 ];  marks [ 0 ]   =   1 ;  marks [ 1 ]   =   2 ;  marks [ 2 ]   =   4 ;",
            "title": "Accessing the Array Elements"
        },
        {
            "location": "/15-array/index.html#array-initialization",
            "text": "Initializing a large array using the method above could be tedious.  Alternatively, we can initialize an array using a list of values when we declare the array.    1 long   marks [ 10 ]   =   { 1 ,   2 ,   3 ,   1 ,   5 ,   10 ,   10 ,   4 ,   5 ,   3 ,   };    If we do not specify a value during initialization, it will be set to 0 by default.    1\n2 long   marks [ 10 ]   =   { 1 ,   2 ,   3 ,   1 ,   5 ,   10 ,   10 ,   4 ,   };  // marks[8] and marks[9] are both initialized to 0    Note that, after the declaration, we can no longer using this technique to reinitialized or initialize the array.  1\n2 long   marks [ 10 ];  marks   =   { 1 ,   2 ,   3 ,   1 ,   5 ,   10 ,   10 ,   4 ,   5 ,   3 ,   };    // error",
            "title": "Array Initialization"
        },
        {
            "location": "/15-array/index.html#example-1-array-as-lookup-table",
            "text": "One way the array is useful is that it can be used as a lookup table.  Consider the following function  days() , which, given a month, return the number of days from the 1 st  of January until the 1 st  of the month.  So  days(1)  returns 0,  days(2)  returns 31 (since January has 31 days),  days(3)  returns 31 + 28 = 59 (assuming non-leap year), etc.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28 long   days ( long   month )  { \n   long   days_since   =   0 ; \n   if   ( month   ==   2 )   { \n     days_since   =   31 ; \n   }   else   if   ( month   ==   3 )   { \n     days_since   =   31   +   28 ; \n   }   else   if   ( month   ==   4 )   { \n     days_since   =   31   +   28   +   31 ; \n   }   else   if   ( month   ==   5 )   { \n     days_since   =   31   +   28   +   31   +   30 ; \n   }   else   if   ( month   ==   6 )   { \n     days_since   =   31   +   28   +   31   +   30   +   31 ; \n   }   else   if   ( month   ==   7 )   { \n     days_since   =   31   +   28   +   31   +   30   +   31   +   30 ; \n   }   else   if   ( month   ==   8 )   { \n     days_since   =   31   +   28   +   31   +   30   +   31   +   30   +   31 ; \n   }   else   if   ( month   ==   9 )   { \n     days_since   =   31   +   28   +   31   +   30   +   31   +   30   +   31   +   31 ; \n   }   else   if   ( month   ==   10 )   { \n     days_since   =   31   +   28   +   31   +   30   +   31   +   30   +   31   +   31   +   30 ; \n   }   else   if   ( month   ==   11 )   { \n     days_since   =   31   +   28   +   31   +   30   +   31   +   30   +   31   +   31   +   30   +   31 ; \n   }   else   if   ( month   ==   12 )   { \n     days_since   =   31   +   28   +   31   +   30   +   31   +   30   +   31   +   31   +   30   +   31   +   30 ; \n   } \n   return   days_since ;  }    The code is ugly and bug-prone.  Consider an alternative solution using an array.  1 long   days_in_month [ 12 ]   =   { 31 ,   28 ,   31 ,   30 ,   31 ,   30 ,   31 ,   31 ,   30 ,   31 ,   30 ,   31 };    The array above is initialized with the number of days in a month.   days_in_month[0]  stores the number of days in January,  days_in_month[1]  stores the number of days in February, etc.  The code above can then be written as:  1\n2\n3\n4\n5\n6\n7\n8\n9 long   days ( long   month )  { \n   long   days_in_month [ 12 ]   =   { 31 ,   28 ,   31 ,   30 ,   31 ,   30 ,   31 ,   31 ,   30 ,   31 ,   30 ,   31 }; \n   long   days_since   =   0 ; \n   for   ( long   i   =   0 ;   i   <   month   -   1 ;   i   +=   1 )   { \n     days_since   +=   days_in_month [ i ]; \n   } \n   return   days_since ;  }",
            "title": "Example 1: Array As Lookup Table"
        },
        {
            "location": "/15-array/index.html#example-2-array-as-list",
            "text": "We can now revisit the flowchart for  max max  and write the corresponding code.  The code would look like this:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10 long   max ( long   list [],   long   length )  { \n   long   max_so_far   =   list [ 0 ]; \n   for   ( long   i   =   1 ;   i   !=   length ;   i   +=   1 )   { \n     if   ( list [ i ]   >   max_so_far )   { \n       max_so_far   =   list [ i ]; \n     } \n   } \n   return   max_so_far ;  }    Note that, in the type of the array passed into the function above, we only need to use  []  without specifying the length.  It is also almost always necessary to pass in the number of elements in the array together with the array so that we know how many elements are there to process.  To understand why, we have to understand something called  array decay .",
            "title": "Example 2: Array As List"
        },
        {
            "location": "/15-array/index.html#array-and-pointers",
            "text": "The relationship between array and pointer can be confusing to beginners.  Some might even think that arrays are pointers due to the way they are passed around and used.  But  arrays are not pointers .  The relationship between the two, boils down to a very simple rule, as follows.  In C, the name of the variable of an array is treated differently from a non-array variable.  If we declare an array  1 type   name [ num_of_elems ];    then any reference to  name  is a synonym to  &name[0]  whenever we need the value of the array.  In other words,  name  is the pointer to the first element in the array.  This is known as the \"array decay\" operation.  There are several implications of this.  First, it is not possible to compare two arrays or assign one array to another.  1\n2\n3\n4\n5\n6\n7\n8 long   a [ 2 ]   =   { 0 ,   1 };  long   b [ 2 ]   =   { 0 ,   1 };  if   ( a   ==   b )   {    // always false \n   :  }  b   =   a ;   // not possible    Line 4 above is equivalent to comparing  &a[0]  to  &b[0] , due to array decay, and therefore is always false (since the array elements do not have the same memory address).  Line 8 above is equivalent to assigning  &a[0]  to  &b[0] , as we seen in (Unit 14)[14-pointers.md], we cannot change the memory address of a variable since this is determined by the OS.  Second, the expression  name[i]  is actually the same as  *(name + i) .  Although we should always write  name[i]  as it is easier to understand, internally, this translates to accessing the value stored at the i-th location after the first element of the array.  (Revisit  Unit 14  if you are unfamiliar with pointer arithmetic).  Third, when we pass an array into a function, we are only passing in the address of the first element.  Consider the example below:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16 long   max ( long   list [],   long   length )  { \n   long   max_so_far   =   list [ 0 ]; \n   for   ( long   i   =   1 ;   i   !=   length ;   i   +=   1 )   { \n     if   ( list [ i ]   >   max_so_far )   { \n       max_so_far   =   list [ i ]; \n     } \n   } \n   return   max_so_far ;  }  int   main ()  { \n   long   a [ 10 ]   =   { 1 ,   2 ,   3 ,   4 ,   1 ,   9 ,   10 ,   44 ,   - 1 ,   - 5 }; \n   cs1010_println_long ( max ( a ,   10 ));  }    On Line 14, we pass  a  into the function  max .  Due to array decay, we are not passing in the whole array, but only the  &a[0] .  Inside  max , we no longer have access to the whole array, but only the address of the first element.  Luckily, due to pointer arithmetic and equivalence of  list[i]  to  *(list + i) , we can still access the elements of the array.    Due to this, the size of  list  in the function parameter does not matter, and we need to pass in the size of the array  length  to  max  so that inside  max  we know the size of the array that we are dealing with.  Array decay also means that, when passing in an array as an argument to a function, we can very well write it as:  1\n2\n3\n4 long   max ( long   * list ,   long   length )  { \n     :  }    For readability, however, we should convey to the reader of the code that  list  is an array and not just a pointer to  long , thus we should still use the  []  notation.  Another implication of array decay when passing an array into a function, is that it is possible to write programs that behave incorrectly, without any compiler error or warning.  Consider the following:  1\n2\n3\n4\n5 int   main ()  { \n   long   a   =   0 ; \n   printf ( \"%ld \\n \" ,   max ( & a ,   10 ));  }    The compiler  clang  would happily compile this and generate an executable.  When executed, it would print a gibberish to the standard output.",
            "title": "Array and Pointers"
        },
        {
            "location": "/15-array/index.html#other-facts-about-arrays",
            "text": "",
            "title": "Other Facts About Arrays"
        },
        {
            "location": "/15-array/index.html#variable-length-array",
            "text": "We can also declare an array where the number of elements depends on the value of a variable.  1\n2 long   num_of_students   =   10 ;  long   marks [ num_of_students ];    Such arrays, where the number of elements (or length) depends on the value of a variable, are sometimes called  variable-length array .  This is a misnomer since once the array is created, the length is fixed.  Changing the value of the variable  num_of_students  above will not change the length of  marks .",
            "title": "Variable Length Array"
        },
        {
            "location": "/15-array/index.html#skipping-elements-during-initialization",
            "text": "If we have a large array, and we want most of it to be initialized to 0, and only some non-zero, we can use  element designators , putting the index of the element we want to initialize to non-zero in square brackets  [  and  ] .  1 long   vector [ 100 ]   =   { 1 ,   [ 5 ]   =   2 ,   3 ,   [ 99 ]   =   - 1 };    An earlier version of this note has a typo, initializing  [100] = -1  instead.  This statement initializes  vector[0]  to 1,  vector[5]  to 2,  vector[6]  to 3, and  vector[99]  to -1.  The rest of the elements will be 0.",
            "title": "Skipping Elements During Initialization"
        },
        {
            "location": "/15-array/index.html#skipping-the-size-in-declaration",
            "text": "If you supply an initialization list, the number of elements already indicates the length to the compiler, so you can skip the length.  1 long   marks []   =   { 1 ,   3 ,   2 ,   8 ,   5 ,}    This makes it easy to add or remove items from the array, without having to remember to keep the array length consistent.",
            "title": "Skipping the Size in Declaration"
        },
        {
            "location": "/15-array/index.html#determining-the-number-of-elements-in-the-array",
            "text": "C provides a  sizeof  operator, which returns the number of bytes allocated to a type.  We can use  sizeof long  for instance, to determine the number of bytes allocated to  long  on a platform.  We can also use  sizeof  on a variable instead of the type.  This becomes useful to determine, programmatically, the length of an array (esp if the array length is skipped in the array declaration).  We can calculate the number of elements in  marks  with   1 long   num_of_elem   =   sizeof   marks / sizeof   marks [ 0 ];    Note that array decay does not apply for only two operators: the  sizeof  operator, and the address-of  &  operator.  So the expression above works as intended.",
            "title": "Determining the Number of Elements in the Array"
        },
        {
            "location": "/15-array/index.html#dynamically-allocated-array",
            "text": "It is often not possible to determine the length of the array beforehand.  So, it is useful to be able to allocate an array with a length that is determined during runtime (not hard-coding the length of the array in the program).  For instance, if I want to keep a  marks  array for a module, it is unclear how big I should set the array to.  How big is big enough?  While I can use a variable-length array for this purpose, it is not ideal -- if the system does not have enough memory to store the array, the program would simply crash with a segfault and there is no way to recover from this.  For this reason, it is useful to request memory from the OS which we will manage ourselves in our program.  Unlike memory space on the call stack which is managed entirely by the OS, there is another region of memory called the  heap , which we can use.  We can request for memory from  heap  using the method  calloc()  and return the memory back to the heap when we are done with  free() .  We will visit these in more details later, but this shallow understanding is enough for now.",
            "title": "Dynamically Allocated Array"
        },
        {
            "location": "/15-array/index.html#cs1010-io-library",
            "text": "To wrap up this unit, we will look at the CS1010 library functions that help us read in an array of either  long  values or  double  values.  These functions,  cs1010_read_long_array  or  cs1010_read_double_array  takes in a parameter, which is the number of elements to read, and it returns a pointer to the array allocated within the function.  For instance, to read in an array of 100 integers, we can write:  1\n2\n3\n4\n5 long   * marks ;  marks   =   cs1010_read_long_array ( 100 );  for   ( long   i   =   0 ;   i   <   100 ;   i   +=   1 )   { \n   cs1010_println_long ( marks [ i ]);  }    This should be straightforward enough.  There are, however, two cases to consider.  What if the OS failed to allocate the memory for our array?  In this case, marks would be  NULL  and access  marks[i]  would cause a segfault. Second, we must return the memory allocated to us back to the OS once we are done.  To let go of this memory, we call the function  free .  The complete code looks like this:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12 long   * marks ;  marks   =   cs1010_read_long_array ( 100 );  if   ( marks   ==   NULL )   { \n   // signal error and return  }  for   ( long   i   =   0 ;   i   <   100 ;   i   +=   1 )   { \n   cs1010_println_long ( marks [ i ]);  }  // do other things to marks  \n   :  free ( marks );",
            "title": "CS1010 I/O Library"
        },
        {
            "location": "/15-array/index.html#problem-set-15",
            "text": "",
            "title": "Problem Set 15"
        },
        {
            "location": "/15-array/index.html#problem-151",
            "text": "Write the function  average  that takes an array of  k k  integers and  k k  and returns the average of the  k k  values in the array.",
            "title": "Problem 15.1"
        },
        {
            "location": "/15-array/index.html#problem-152",
            "text": "Explain why the following would lead to senseless output:  1\n2\n3\n4\n5 int   main ()  { \n   long   a   =   0 ; \n   printf ( \"%ld \\n \" ,   max ( & a ,   10 ));  }    How about the following? Would the output be correct?  1\n2\n3\n4\n5 int   main ()  { \n   long   a   =   0 ; \n   printf ( \"%ld \\n \" ,   max ( & a ,   1 ));   // change 10 to 1  }",
            "title": "Problem 15.2"
        },
        {
            "location": "/15-array/index.html#problem-153",
            "text": "Explain how the following code iterates through every element in the list, when called with an array of length  length  as the first argument.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15 long   max ( long   * list ,   long   length )  { \n   long   max_so_far ; \n   long   * curr ; \n\n   max_so_far   =   * list ; \n   curr   =   list   +   1 ; \n   for   ( long   i   =   1 ;   i   !=   length ;   i   +=   1 )   { \n     if   ( * curr   >   max_so_far )   { \n       max_so_far   =   * curr ; \n     } \n     curr   +=   1 ; \n   } \n   return   max_so_far ;  }",
            "title": "Problem 15.3"
        },
        {
            "location": "/16-string/index.html",
            "text": "Unit 16: Strings\n\n\nWe have seen strings as a sequence of characters stored in double quotes, e.g., \"hello!\".  In C, a string is nothing more than just an array of \nchar\n values (Recall from \nUnit 5\n that \nsizeof char\n is 1).\n\n\nJust a \nchar\n Array\n\n\nThe only thing special about a string is that it \nalways\n end with a \n0\n value (note: not character '0' which has a value of 48, but the value 0).  Since the character with value 0 is called the null character, written as '\\0', we refer that strings in C as null-terminated strings.\n\n\nIn C, we distinguish between a string and a \nchar\n by the quotes used.  String uses double quotes \n\"\n, while a \nchar\n uses single quote \n'\n.  So we can do the following and they are equivalent:\n\n\n1\n2\nchar\n \nhello1\n[\n7\n]\n \n=\n \n{\n'h'\n,\n \n'e'\n,\n \n'l'\n,\n \n'l'\n,\n \n'o'\n,\n \n'!'\n,\n \n0\n};\n \n\nchar\n \nhello2\n[\n7\n]\n \n=\n \n\"hello!\"\n;\n\n\n\n\n\n\n\nOf course, nobody actually initializes a string in the first way above.\n\n\nWe can also skip the size of the array, as mentioned above, or, more commonly, use a \nchar *\n type for a variable storing a constant string.\n\n1\n2\nchar\n \nhello3\n[]\n \n=\n \n\"hello!\"\n;\n\n\nchar\n \n*\nhello4\n \n=\n \n\"hello!\"\n;\n\n\n\n\n\n\nSpecial Characters\n\n\nThe null character is written as '\\0'.  The use of the backslash \n\\\n creates an escape sequence that can be used to denote characters that would otherwise not visible on screen.  For instance, besides '\\0', we will likely encounter '\\n' (the newline character) '\\t' (the tab character) and '\\a' (the beep character) regularly.  \n\n\nFurthermore, since we already use \n\\\n to indicate the escape sequence, \n'\n to indicate a character, and \n\"\n to indicate a string, in order to use these characters, we need to \"escape\" them -- we use '\\' for the backslash character, '\\'', the single quote character, and the '\\\"' double quote character.\n\n\nEmpty String\n\n\nWe commonly use the empty string \n\"\"\n to indicate a special condition or to initialize a string variable, where appropriate.  The empty string is basically an array where the 0-th element is '\\0'.\n\n\nCS1010 I/O Library\n\n\nThe CS1010 I/O library provides two functions, one to read a word (separated by white-space characters) and the other to read a line (separated by a newline character).  They are \ncs1010_read_word()\n and \ncs1010_read_line()\n respectively.  We can also read multiple words and multiple lines with \ncs1010_read_word_array()\n and \ncs1010_read_line_array()\n.  The results are stored in an array of strings.\n\n\nProblem Set 16\n\n\nProblem 16.1\n\n\nWrite the following functions (without calling the standard C functions declared in \n<string.h>\n such as \nstrlen\n, \nstrcmp\n, \nstrstr\n):\n\n\na) \nlong string_length(char *str)\n return the length (i.e., the number of characters) of the string \nstr\n.\n\n\nb) \nbool string_equal(char *str1, char *str2)\n return \ntrue\n if the two strings \nstr1\n and \nstr2\n contains exactly the same content, \nfalse\n otherwise.  (Note: \nstr1 == str2\n does not compare if two strings have the same content. (Why?))\n\n\nc) \nchar *string_in_string(char *needle, char *haystack)\n return a pointer to the first character of the first occurance of \nneedle\n in \nhaystack\n, if found.  If \nneedle\n does not occur anywhere in \nhaystack\n, return NULL.  If \nneedle\n is an empty string, \nhaystack\n is returned.",
            "title": "16. Strings"
        },
        {
            "location": "/16-string/index.html#unit-16-strings",
            "text": "We have seen strings as a sequence of characters stored in double quotes, e.g., \"hello!\".  In C, a string is nothing more than just an array of  char  values (Recall from  Unit 5  that  sizeof char  is 1).",
            "title": "Unit 16: Strings"
        },
        {
            "location": "/16-string/index.html#just-a-char-array",
            "text": "The only thing special about a string is that it  always  end with a  0  value (note: not character '0' which has a value of 48, but the value 0).  Since the character with value 0 is called the null character, written as '\\0', we refer that strings in C as null-terminated strings.  In C, we distinguish between a string and a  char  by the quotes used.  String uses double quotes  \" , while a  char  uses single quote  ' .  So we can do the following and they are equivalent:  1\n2 char   hello1 [ 7 ]   =   { 'h' ,   'e' ,   'l' ,   'l' ,   'o' ,   '!' ,   0 };   char   hello2 [ 7 ]   =   \"hello!\" ;    Of course, nobody actually initializes a string in the first way above.  We can also skip the size of the array, as mentioned above, or, more commonly, use a  char *  type for a variable storing a constant string. 1\n2 char   hello3 []   =   \"hello!\" ;  char   * hello4   =   \"hello!\" ;",
            "title": "Just a char Array"
        },
        {
            "location": "/16-string/index.html#special-characters",
            "text": "The null character is written as '\\0'.  The use of the backslash  \\  creates an escape sequence that can be used to denote characters that would otherwise not visible on screen.  For instance, besides '\\0', we will likely encounter '\\n' (the newline character) '\\t' (the tab character) and '\\a' (the beep character) regularly.    Furthermore, since we already use  \\  to indicate the escape sequence,  '  to indicate a character, and  \"  to indicate a string, in order to use these characters, we need to \"escape\" them -- we use '\\' for the backslash character, '\\'', the single quote character, and the '\\\"' double quote character.",
            "title": "Special Characters"
        },
        {
            "location": "/16-string/index.html#empty-string",
            "text": "We commonly use the empty string  \"\"  to indicate a special condition or to initialize a string variable, where appropriate.  The empty string is basically an array where the 0-th element is '\\0'.",
            "title": "Empty String"
        },
        {
            "location": "/16-string/index.html#cs1010-io-library",
            "text": "The CS1010 I/O library provides two functions, one to read a word (separated by white-space characters) and the other to read a line (separated by a newline character).  They are  cs1010_read_word()  and  cs1010_read_line()  respectively.  We can also read multiple words and multiple lines with  cs1010_read_word_array()  and  cs1010_read_line_array() .  The results are stored in an array of strings.",
            "title": "CS1010 I/O Library"
        },
        {
            "location": "/16-string/index.html#problem-set-16",
            "text": "",
            "title": "Problem Set 16"
        },
        {
            "location": "/16-string/index.html#problem-161",
            "text": "Write the following functions (without calling the standard C functions declared in  <string.h>  such as  strlen ,  strcmp ,  strstr ):  a)  long string_length(char *str)  return the length (i.e., the number of characters) of the string  str .  b)  bool string_equal(char *str1, char *str2)  return  true  if the two strings  str1  and  str2  contains exactly the same content,  false  otherwise.  (Note:  str1 == str2  does not compare if two strings have the same content. (Why?))  c)  char *string_in_string(char *needle, char *haystack)  return a pointer to the first character of the first occurance of  needle  in  haystack , if found.  If  needle  does not occur anywhere in  haystack , return NULL.  If  needle  is an empty string,  haystack  is returned.",
            "title": "Problem 16.1"
        },
        {
            "location": "/ex01/index.html",
            "text": "Exercise 1: Freezer\n\n\nThis is your first programming exercise.  An exercise is something that you do on your own.  You can submit them but it will not be graded.   Test cases are provided for the exercises so that you can test and check on your own if your code is correct.  This is in contrast to an assignment, where you need to submit for grading and for credits.\n\n\nPrerequisite\n\n\n\n\nYou are able to access the \nCS1010 programming environment\n.\n\n\nYou are familiar with \nbasic UNIX CLI\n and using terminal-based editor \nvim\n.\n\n\n\n\nLearning Outcomes\n\n\n\n\nBe comfortable writing simple C programs that involves arithmetic operations, \nlong\n and \ndouble\n types.\n\n\n\n\nOne-Time Setup\n\n\nBefore going into their first programming exercise, you need to do a one time setup of your account on PE. You need to create a file called \n.gitconfig\n in your home directory and with the following content:\n\n\n1\n2\n3\n4\n5\n[user]\n  name = Your Name\n  email = Your Email\n[github]  \n  user = Your GitHub ID\n\n\n\n\n\n\nYour email should be whatever you used to sign up Github.\n\n\nFor example, a sample \n.gitconfig\n looks like this:\n\n\n1\n2\n3\n4\n5\n[user]\n  name = Jon Snow\n  email = king@north.gov\n[github]  \n  user = jonsnow\n\n\n\n\n\n\nAfter saving this file, run:\n\n\n1\ngit config --get github.user\n\n\n\n\n\n\nIt should return your GitHub user id.\n\n\nIt should print your GitHub user id as set.  If there is a typo, you need to edit \n.gitconfig\n again and reload it by repeating the command above.\n\n\nSetup\n\n\n\n\nClick on \nthis link\n to accept the exercise.\n\n\nLogin to one of the hosts of \nCS1010 programming environment (PE)\n\n\nRun the following on the command line on one of the PE hosts:\n\n\n\n\n1\n~cs1010/get-ex01\n\n\n\n\n\n\n\n\nYou should see a new subdirectory \nex01-<githubid>\n in your current working directory, where \ngithubid\n is your GitHub ID.\n\n\n\n\nWe will call this directory your \nexercise directory\n or \nassignment directory\n.\n\n\n\n\n\n\nInside that directory, you should see a bunch of files:\n\n\n\n\nfreezer1.c\n and \nfreezer2.c\n are the most important files.  They are the skeleton C code that you should edit to solve the exercise.\n\n\ninputs\n and \noutputs\n are sub directories that contain test inputs and test outputs.  We use the convention \nproblem-name\n.\ntest-id\n.in for input test data, and \nproblem-name\n.\ntest-id\n.out for output test data.  So, you will see \nfreezer1.1.in\n, \nfreezer1.1.out\n, etc.  The expected output for \nfreezer1.1.in\n is in \nfreezer1.1.out\n.  You can look at the content of these files if you wish (which \nUNIX\n command should you use to do this?).  You can edit these files to change the test input and output.\n\n\nMakefile\n: This is the configuration for the tool \nmake\n that we use to automate the compilation and testing of the programs.  You do not have to understand how to write a \nMakefile\n for CS1010.  If you are interested to learn how to write a \nMakefile\n, talk to either Wei Tsang or Google.\n\n\ntest.sh\n: This is a bash script for testing your code.  You do not have to edit this file nor call it directly.  It is called by \nmake\n.  If you are interested to learn how to write bash script, talk to either Wei Tsang or Google.\n\n\n\n\n\n\n\n\nIdentifying Yourself\n\n\nIn every C file that you submit to CS1010, you need to identify yourself by writing your name and tutorial group.  Marks will be deducted if you fail to do so.  You need to edit the line:\n\n\n1\n@author XXXX (Group YYYY)\n\n\n\n\n\n\nand change it to something like:\n\n\n1\n@author Jon Snow (Group 10)\n\n\n\n\n\n\nSolving The Assignments\n\n\n\n\nEdit the files \nfreezer1.c\n and \nfreezer2.c\n to solve the corresponding question as described below.\n\n\nTo compile and run the given tests with the sample inputs and outputs, run on the command line,\n\n\n\n\n1\nmake\n\n\n\n\n\n\nThis will compile both C files and if there is no error, run the test scripts.\n\n\nSubmission\n\n\nWhen you are ready, run the following command while you are in the exercise directory:\n\n\n1\n~cs1010/submit-ex01\n\n\n\n\n\n\nThe files \nfreezer1.c\n and \nfreezer2.c\n will be uploaded to GitHub.  You can submit multiple times.\n\n\nGrading\n\n\nThis assignment is not graded.\n\n\n\n\nQuestion 1: Freezer\n\n\n(a)\n\n\nWrite a program \nfreezer1\n (source file \nfreezer1.c\n) that estimates the temperature (in degree Celsius) in a freezer given the elapsed time (in hours) since a power failure.\n\n\nAssume this temperature \nT\nT\n is given by\n1\n:\n\n\n\n\n\nT = \\frac{4t^2}{t + 2} - 20;\n\n\n\n\nT = \\frac{4t^2}{t + 2} - 20;\n\n\n\n\n\nwhere \nt\nt\n is the time (in hours) since the power failure.\n\n\nYour program reads in an integer: the number of hours since the start of the power failure.\n\n\nSample run:\n\n\n1\n2\n3\n4\n5\n6\nooiwt@pe111:~/ex01-ooiwt$ ./freezer1\n0\n-20.0000\nooiwt@pe111:~/ex01-ooiwt$ ./freezer1\n1\n-18.6667\n\n\n\n\n\n\nThe text \nooiwt@pe111:~/ex01-ooiwt$\n is the command prompt.  Yours will look different, of course.  \nfreezer1\n is the executable you created.  The next line, \n0\n, is the input you provide.  Press enter after the input.  \n-20.0000\n is the output printed by \nfreezer1\n.\n\n\n(b)\n\n\nfreezer1\n is rather restrictive, as we can only calculate the temperature after one hour, two hours, etc.  The equation given above works for fractional hours as well.  Modify your program, call it \nfreezer2\n (source file \nfreezer2.c\n), so that it now reads in two integers: the number of hours and the number of additional minutes since the start of the power failure.  For example, to calculate the temperature after 2 hours and 45 minutes of power failure:\n\n\n1\n2\n3\nooiwt@pe111:~/ex01-ooiwt$ ./freezer2\n2 45\n-13.6316\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nI do not know where this formula comes from or if it is correct.  Please ignore the fact that, according to this formula, 32 hours after the power is turned off, the freezer will reach the boiling point of 100 Celsius!\u00a0\n\u21a9",
            "title": "1. Freezer"
        },
        {
            "location": "/ex01/index.html#exercise-1-freezer",
            "text": "This is your first programming exercise.  An exercise is something that you do on your own.  You can submit them but it will not be graded.   Test cases are provided for the exercises so that you can test and check on your own if your code is correct.  This is in contrast to an assignment, where you need to submit for grading and for credits.",
            "title": "Exercise 1: Freezer"
        },
        {
            "location": "/ex01/index.html#prerequisite",
            "text": "You are able to access the  CS1010 programming environment .  You are familiar with  basic UNIX CLI  and using terminal-based editor  vim .",
            "title": "Prerequisite"
        },
        {
            "location": "/ex01/index.html#learning-outcomes",
            "text": "Be comfortable writing simple C programs that involves arithmetic operations,  long  and  double  types.",
            "title": "Learning Outcomes"
        },
        {
            "location": "/ex01/index.html#one-time-setup",
            "text": "Before going into their first programming exercise, you need to do a one time setup of your account on PE. You need to create a file called  .gitconfig  in your home directory and with the following content:  1\n2\n3\n4\n5 [user]\n  name = Your Name\n  email = Your Email\n[github]  \n  user = Your GitHub ID   Your email should be whatever you used to sign up Github.  For example, a sample  .gitconfig  looks like this:  1\n2\n3\n4\n5 [user]\n  name = Jon Snow\n  email = king@north.gov\n[github]  \n  user = jonsnow   After saving this file, run:  1 git config --get github.user   It should return your GitHub user id.  It should print your GitHub user id as set.  If there is a typo, you need to edit  .gitconfig  again and reload it by repeating the command above.",
            "title": "One-Time Setup"
        },
        {
            "location": "/ex01/index.html#setup",
            "text": "Click on  this link  to accept the exercise.  Login to one of the hosts of  CS1010 programming environment (PE)  Run the following on the command line on one of the PE hosts:   1 ~cs1010/get-ex01    You should see a new subdirectory  ex01-<githubid>  in your current working directory, where  githubid  is your GitHub ID.   We will call this directory your  exercise directory  or  assignment directory .    Inside that directory, you should see a bunch of files:   freezer1.c  and  freezer2.c  are the most important files.  They are the skeleton C code that you should edit to solve the exercise.  inputs  and  outputs  are sub directories that contain test inputs and test outputs.  We use the convention  problem-name . test-id .in for input test data, and  problem-name . test-id .out for output test data.  So, you will see  freezer1.1.in ,  freezer1.1.out , etc.  The expected output for  freezer1.1.in  is in  freezer1.1.out .  You can look at the content of these files if you wish (which  UNIX  command should you use to do this?).  You can edit these files to change the test input and output.  Makefile : This is the configuration for the tool  make  that we use to automate the compilation and testing of the programs.  You do not have to understand how to write a  Makefile  for CS1010.  If you are interested to learn how to write a  Makefile , talk to either Wei Tsang or Google.  test.sh : This is a bash script for testing your code.  You do not have to edit this file nor call it directly.  It is called by  make .  If you are interested to learn how to write bash script, talk to either Wei Tsang or Google.",
            "title": "Setup"
        },
        {
            "location": "/ex01/index.html#identifying-yourself",
            "text": "In every C file that you submit to CS1010, you need to identify yourself by writing your name and tutorial group.  Marks will be deducted if you fail to do so.  You need to edit the line:  1 @author XXXX (Group YYYY)   and change it to something like:  1 @author Jon Snow (Group 10)",
            "title": "Identifying Yourself"
        },
        {
            "location": "/ex01/index.html#solving-the-assignments",
            "text": "Edit the files  freezer1.c  and  freezer2.c  to solve the corresponding question as described below.  To compile and run the given tests with the sample inputs and outputs, run on the command line,   1 make   This will compile both C files and if there is no error, run the test scripts.",
            "title": "Solving The Assignments"
        },
        {
            "location": "/ex01/index.html#submission",
            "text": "When you are ready, run the following command while you are in the exercise directory:  1 ~cs1010/submit-ex01   The files  freezer1.c  and  freezer2.c  will be uploaded to GitHub.  You can submit multiple times.",
            "title": "Submission"
        },
        {
            "location": "/ex01/index.html#grading",
            "text": "This assignment is not graded.",
            "title": "Grading"
        },
        {
            "location": "/ex01/index.html#question-1-freezer",
            "text": "",
            "title": "Question 1: Freezer"
        },
        {
            "location": "/ex01/index.html#a",
            "text": "Write a program  freezer1  (source file  freezer1.c ) that estimates the temperature (in degree Celsius) in a freezer given the elapsed time (in hours) since a power failure.  Assume this temperature  T T  is given by 1 :   \nT = \\frac{4t^2}{t + 2} - 20;  \nT = \\frac{4t^2}{t + 2} - 20;   where  t t  is the time (in hours) since the power failure.  Your program reads in an integer: the number of hours since the start of the power failure.",
            "title": "(a)"
        },
        {
            "location": "/ex01/index.html#sample-run",
            "text": "1\n2\n3\n4\n5\n6 ooiwt@pe111:~/ex01-ooiwt$ ./freezer1\n0\n-20.0000\nooiwt@pe111:~/ex01-ooiwt$ ./freezer1\n1\n-18.6667   The text  ooiwt@pe111:~/ex01-ooiwt$  is the command prompt.  Yours will look different, of course.   freezer1  is the executable you created.  The next line,  0 , is the input you provide.  Press enter after the input.   -20.0000  is the output printed by  freezer1 .",
            "title": "Sample run:"
        },
        {
            "location": "/ex01/index.html#b",
            "text": "freezer1  is rather restrictive, as we can only calculate the temperature after one hour, two hours, etc.  The equation given above works for fractional hours as well.  Modify your program, call it  freezer2  (source file  freezer2.c ), so that it now reads in two integers: the number of hours and the number of additional minutes since the start of the power failure.  For example, to calculate the temperature after 2 hours and 45 minutes of power failure:  1\n2\n3 ooiwt@pe111:~/ex01-ooiwt$ ./freezer2\n2 45\n-13.6316       I do not know where this formula comes from or if it is correct.  Please ignore the fact that, according to this formula, 32 hours after the power is turned off, the freezer will reach the boiling point of 100 Celsius!\u00a0 \u21a9",
            "title": "(b)"
        },
        {
            "location": "/ex02/index.html",
            "text": "Exercise 2: Leap, Suffix, Days\n\n\nThis is a programming exercise for you to solve on your own.  You can submit but it will not be graded.  Test cases are provided for the exercises so that you can test and check on your own if your code is correct.  Feel free to discuss your solution with your peers or your TAs.\n\n\nPrerequisite\n\n\n\n\nYou are able to access the \nCS1010 programming environment\n.\n\n\nYou are familiar with \nbasic UNIX CLI\n and using terminal-based editor \nvim\n.\n\n\nYou have a GitHub account and have setup \n.gitconfig\n (see \nExercise 1\n).\n\n\n\n\nLearning Outcomes\n\n\n\n\nBe comfortable writing correct C programs that involve \nif\n, \nelse\n, and logical statements.\n\n\n\n\nSetup\n\n\n\n\nClick on \nthis link\n to accept the exercise.\n\n\nLog in to one of the hosts of \nCS1010 programming environment (PE)\n\n\nRun the following on the command line on one of the PE hosts:\n\n\n\n\n1\n~cs1010/get-ex02\n\n\n\n\n\n\n\n\nYou should see a new subdirectory \nex02-<githubid>\n in your current working directory, where \ngithubid\n is your GitHub ID.\n\n\nInside that directory, you should see a bunch of files:\n\n\nleap.c\n, \nsuffix.c\n, and \ndays.c\n are the most important files.  They are the skeleton C code that you should edit to solve the exercise.\n\n\ninputs\n and \noutputs\n are subdirectories that contain test inputs and test outputs.  We use the same convention as Exercise 1 so you should be familiar with them.\n\n\nMakefile\n: This is the configuration for the tool \nmake\n that we use to automate the compilation and testing of the programs.  \n\n\ntest.sh\n: This is a bash script for testing your code.\n\n\n\n\n\n\n\n\nSolving The Assignments\n\n\n\n\nEdit the .c files to solve the corresponding question as described below\n\n\nYou can assume that all test inputs are valid inputs.\n\n\nTo compile and run the given tests with the sample inputs and outputs, run on the command line,\n\n\n\n\n1\nmake\n\n\n\n\n\n\nThis will compile all your C files and if there is no error, run the test scripts.\n\n\nSubmission\n\n\nWhen you are ready, run the following command while you are in the exercise directory:\n\n\n1\n~cs1010/submit-ex02\n\n\n\n\n\n\nThe .c files will be uploaded to GitHub.  You can submit multiple times.  As an exercise is not graded, submitting your code only serves the purpose of archiving your work for backup purposes.\n\n\n\n\nQuestion 1: Leap Year\n\n\nA \nleap year\n is a calendar year containing an extra day to synchronize the calendar to seasons and astronomical events.  In the Gregorian calendar, years that are multiples of four (with the exception of years divisible by 100 but not by 400) are leap years.\n\n\nWrite a program that reads in an integer representing a year from the standard input and prints out \"\n is a leap year\" if the input is a leap year.  Otherwise, print \"\n is not a leap year\" to the standard output.\n\n\nYour program should include a \nbool\n function \nis_leap_year\n that takes in the input year and returns \ntrue\n if the input is a leap year and returns \nfalse\n otherwise.\n\n\nSample run:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\nooiwt@pe112:~/ex02-ooiwt$ ./leap\n1995\n1995 is not a leap year\nooiwt@pe112:~/ex02-ooiwt$ ./leap\n1996\n1996 is a leap year\nooiwt@pe112:~/ex02-ooiwt$ ./leap\n1900\n1900 is not a leap year\nooiwt@pe112:~/ex02-ooiwt$ ./leap\n2000\n2000 is a leap year\n\n\n\n\n\n\nQuestion 2: Ordinal Suffix\n\n\nIn English, an ordinal number is written with numerals, followed by its letter suffixes.  For instance: 1\nst\n, 2\nnd\n, 3\nrd\n, 4\nth\n, 11\nth\n, 31\nst\n, etc.  The rule is that, a number that ends with digit 1 should have a suffix \"st\" (except if it ends with 11), a number that ends with 2 should have a suffix \"nd\" (except if it ends with 12), and a number that ends with 3 should have a suffix \"rd\" (except if it ends with 13).  All other numbers should end with \"th\".\n\n\nWrite a program \nsuffix\n that reads in an integer number from the standard input and prints out the number with its ordinal suffix.\n\n\nYour program should include a \nvoid\n function \nprint_with_suffix(long n)\n that takes in the input and prints out the number followed by its suffix.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\nooiwt@pe112:~/ex02-ooiwt$ ./suffix\n2\n2nd\nooiwt@pe112:~/ex02-ooiwt$ ./suffix\n13\n13th\nooiwt@pe112:~/ex02-ooiwt$ ./suffix\n412\n412th\nooiwt@pe112:~/ex02-ooiwt$ ./suffix\n3\n3rd\n\n\n\n\n\n\nQuestion 3: Days Since 1 January\n\n\nWrite a program called \ndays\n that reads in two integers from the standard input, the first is the month (ranged 1 to 12, inclusive) and the second is the day (ranged 1 to 31, inclusive).  The program should print to the standard output which day of the year it is.  \nAssume that the year is not a leap year\n.  You can reuse the method \nprint_suffix\n from the previous question.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nooiwt@pe112:~/ex02-ooiwt$ ./days\n1 1\n1st\nooiwt@pe112:~/ex02-ooiwt$ ./days\n8 15\n227th\nooiwt@pe112:~/ex02-ooiwt$ ./days\n12 31\n365th",
            "title": "2. Leap, Suffix, Days"
        },
        {
            "location": "/ex02/index.html#exercise-2-leap-suffix-days",
            "text": "This is a programming exercise for you to solve on your own.  You can submit but it will not be graded.  Test cases are provided for the exercises so that you can test and check on your own if your code is correct.  Feel free to discuss your solution with your peers or your TAs.",
            "title": "Exercise 2: Leap, Suffix, Days"
        },
        {
            "location": "/ex02/index.html#prerequisite",
            "text": "You are able to access the  CS1010 programming environment .  You are familiar with  basic UNIX CLI  and using terminal-based editor  vim .  You have a GitHub account and have setup  .gitconfig  (see  Exercise 1 ).",
            "title": "Prerequisite"
        },
        {
            "location": "/ex02/index.html#learning-outcomes",
            "text": "Be comfortable writing correct C programs that involve  if ,  else , and logical statements.",
            "title": "Learning Outcomes"
        },
        {
            "location": "/ex02/index.html#setup",
            "text": "Click on  this link  to accept the exercise.  Log in to one of the hosts of  CS1010 programming environment (PE)  Run the following on the command line on one of the PE hosts:   1 ~cs1010/get-ex02    You should see a new subdirectory  ex02-<githubid>  in your current working directory, where  githubid  is your GitHub ID.  Inside that directory, you should see a bunch of files:  leap.c ,  suffix.c , and  days.c  are the most important files.  They are the skeleton C code that you should edit to solve the exercise.  inputs  and  outputs  are subdirectories that contain test inputs and test outputs.  We use the same convention as Exercise 1 so you should be familiar with them.  Makefile : This is the configuration for the tool  make  that we use to automate the compilation and testing of the programs.    test.sh : This is a bash script for testing your code.",
            "title": "Setup"
        },
        {
            "location": "/ex02/index.html#solving-the-assignments",
            "text": "Edit the .c files to solve the corresponding question as described below  You can assume that all test inputs are valid inputs.  To compile and run the given tests with the sample inputs and outputs, run on the command line,   1 make   This will compile all your C files and if there is no error, run the test scripts.",
            "title": "Solving The Assignments"
        },
        {
            "location": "/ex02/index.html#submission",
            "text": "When you are ready, run the following command while you are in the exercise directory:  1 ~cs1010/submit-ex02   The .c files will be uploaded to GitHub.  You can submit multiple times.  As an exercise is not graded, submitting your code only serves the purpose of archiving your work for backup purposes.",
            "title": "Submission"
        },
        {
            "location": "/ex02/index.html#question-1-leap-year",
            "text": "A  leap year  is a calendar year containing an extra day to synchronize the calendar to seasons and astronomical events.  In the Gregorian calendar, years that are multiples of four (with the exception of years divisible by 100 but not by 400) are leap years.  Write a program that reads in an integer representing a year from the standard input and prints out \"  is a leap year\" if the input is a leap year.  Otherwise, print \"  is not a leap year\" to the standard output.  Your program should include a  bool  function  is_leap_year  that takes in the input year and returns  true  if the input is a leap year and returns  false  otherwise.",
            "title": "Question 1: Leap Year"
        },
        {
            "location": "/ex02/index.html#sample-run",
            "text": "1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12 ooiwt@pe112:~/ex02-ooiwt$ ./leap\n1995\n1995 is not a leap year\nooiwt@pe112:~/ex02-ooiwt$ ./leap\n1996\n1996 is a leap year\nooiwt@pe112:~/ex02-ooiwt$ ./leap\n1900\n1900 is not a leap year\nooiwt@pe112:~/ex02-ooiwt$ ./leap\n2000\n2000 is a leap year",
            "title": "Sample run:"
        },
        {
            "location": "/ex02/index.html#question-2-ordinal-suffix",
            "text": "In English, an ordinal number is written with numerals, followed by its letter suffixes.  For instance: 1 st , 2 nd , 3 rd , 4 th , 11 th , 31 st , etc.  The rule is that, a number that ends with digit 1 should have a suffix \"st\" (except if it ends with 11), a number that ends with 2 should have a suffix \"nd\" (except if it ends with 12), and a number that ends with 3 should have a suffix \"rd\" (except if it ends with 13).  All other numbers should end with \"th\".  Write a program  suffix  that reads in an integer number from the standard input and prints out the number with its ordinal suffix.  Your program should include a  void  function  print_with_suffix(long n)  that takes in the input and prints out the number followed by its suffix.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12 ooiwt@pe112:~/ex02-ooiwt$ ./suffix\n2\n2nd\nooiwt@pe112:~/ex02-ooiwt$ ./suffix\n13\n13th\nooiwt@pe112:~/ex02-ooiwt$ ./suffix\n412\n412th\nooiwt@pe112:~/ex02-ooiwt$ ./suffix\n3\n3rd",
            "title": "Question 2: Ordinal Suffix"
        },
        {
            "location": "/ex02/index.html#question-3-days-since-1-january",
            "text": "Write a program called  days  that reads in two integers from the standard input, the first is the month (ranged 1 to 12, inclusive) and the second is the day (ranged 1 to 31, inclusive).  The program should print to the standard output which day of the year it is.   Assume that the year is not a leap year .  You can reuse the method  print_suffix  from the previous question.  1\n2\n3\n4\n5\n6\n7\n8\n9 ooiwt@pe112:~/ex02-ooiwt$ ./days\n1 1\n1st\nooiwt@pe112:~/ex02-ooiwt$ ./days\n8 15\n227th\nooiwt@pe112:~/ex02-ooiwt$ ./days\n12 31\n365th",
            "title": "Question 3: Days Since 1 January"
        },
        {
            "location": "/ex03/index.html",
            "text": "Exercise 3: Binary, Rectangle, Fibonacci, Prime\n\n\nThis is a programming exercise for you to solve on your own.  You can submit but it will not be graded.  Test cases are provided for the exercises so that you can test and check on your own if your code is correct.  Feel free to discuss your solution with your peers or your TAs.\n\n\nPrerequisite\n\n\n\n\nYou are able to access the \nCS1010 programming environment\n.\n\n\nYou are familiar with \nbasic UNIX CLI\n and using terminal-based editor \nvim\n.\n\n\nYou have a GitHub account and have setup \n.gitconfig\n (see \nExercise 1\n).\n\n\n\n\nLearning Outcomes\n\n\n\n\nBe comfortable writing correct C programs that involve \nif\n, \nelse\n, loops, and logical statements.\n\n\nBe able to decompose a more complex problem into smaller subproblems and write functions to solve the sub-problems.\n\n\n\n\nSetup\n\n\n\n\nClick on \nthis link\n to accept the exercise.\n\n\nLog in to one of the hosts of \nCS1010 programming environment (PE)\n\n\nRun the following on the command line on one of the PE hosts:\n\n\n\n\n1\n~cs1010/get-ex03\n\n\n\n\n\n\n\n\nYou should see a new subdirectory \nex03-<githubid>\n in your current working directory, where \ngithubid\n is your GitHub ID.\n\n\nInside that directory, you should see a bunch of files:\n\n\nbinary.c\n, \nrectangle.c\n, \nprime.c\n and \nfibonacci.c\n are the most important files.  They are the skeleton C code that you should edit to solve the exercise.\n\n\ninputs\n and \noutputs\n are subdirectories that contain test inputs and test outputs.  We use the same convention as Exercise 1 so you should be familiar with them.\n\n\nMakefile\n: This is the configuration for the tool \nmake\n that we use to automate the compilation and testing of the programs.  \n\n\ntest.sh\n: This is a bash script for testing your code.\n\n\n\n\n\n\n\n\nSolving The Assignments\n\n\n\n\nEdit the .c files on the PE hosts to solve the corresponding question as described below.\n\n\nYou can assume that all test inputs are valid inputs.\n\n\nTo compile and run the given tests with the sample inputs and outputs, run on the command line,\n\n\n\n\n1\nmake\n\n\n\n\n\n\nThis will compile all your C files and if there is no error, run the test scripts.\n\n\nSubmission\n\n\nWhen you are ready, run the following command while you are in the exercise directory:\n\n\n1\n~cs1010/submit-ex03\n\n\n\n\n\n\nThe .c files will be uploaded to GitHub.  You can submit multiple times.  As an exercise is not graded, submitting your code only serves the purpose of archiving your work for backup purposes.\n\n\n\n\nQuestion 1: Binary\n\n\nIn this question, you are asked to convert a number represented in binary format (using digits 0 and 1) into the decimal format (using digits 0 and 9).  A number in decimal format is represented with based 10.  The last digit (rightmost) corresponds to the unit of \n10^0 = 1\n10^0 = 1\n, the next digit (second last) corresponds to the unit of \n10^1 = 10\n10^1 = 10\n, and so on.  So, one can write the decimal number, for instance, 7146 as \n\n7 \\times 10^3 + 1 \\times 10^2 + 4 \\times 10^1 + 6 \\times 10^0\n7 \\times 10^3 + 1 \\times 10^2 + 4 \\times 10^1 + 6 \\times 10^0\n.\n\n\nA number represented in binary uses base 2 instead of base 10.  The last digit corresponds to \n2^0 = 1\n2^0 = 1\n.  The second last digit correponds to \n2^1 = 2\n2^1 = 2\n, the third last digit corresponds to \n2^2 = 4\n2^2 = 4\n, and so on.  So, the binary number 1101, for instance, corresponds to \n1 \\times 2^3 + 1 \\times 2^2 + 1 \\times 2^0 = 13\n1 \\times 2^3 + 1 \\times 2^2 + 1 \\times 2^0 = 13\n.\n\n\nWrite a program called \nbinary\n that reads in a positive integer consists of only 0s and 1s from the standard input, treats it as a binary number, and prints the corresponding decimal number to the standard output.\n\n\nSample run:\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nooiwt@pe113:~/ex03-ooiwt$ ./binary\n1101\n13\nooiwt@pe113:~/ex03-ooiwt$ ./binary\n111\n7\nooiwt@pe113:~/ex03-ooiwt$ ./binary\n10110100\n180\n\n\n\n\n\n\nQuestion 2: Rectangle\n\n\nWrite a program called \nrectangle\n that reads two positive integers from the standard input, corresponding to the width and the height of the rectangle.  The width and height must be at least 2.  Draw a rectangle on the screen using the special ASCII characters #define \"\u2554\" \"\u2557\" \"\u255d\" \"\u255a\" \"\u2550\" \"\u2551\", which corresponds to the top left, top right, bottom right, bottom left, top/bottom edge, and left/right edge of the rectangle respectively.   Strings consisting of these special characters have been given to you in \nrectangle.c\n and we have defined them as constants.   For instance, \"\u2554\" is called \nTOP_LEFT\n, and to print this out, you can write\n\n1\ncs1010_print_string\n(\nTOP_LEFT\n);\n\n\n\n\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\nooiwt@pe113:~/ex03-ooiwt$ ./rectangle\n2 2\n\u2554\u2557\n\u255a\u255d\nooiwt@pe113:~/ex03-ooiwt$ ./rectangle\n2 10\n\u2554\u2557\n\u2551\u2551\n\u2551\u2551\n\u2551\u2551\n\u2551\u2551\n\u2551\u2551\n\u2551\u2551\n\u2551\u2551\n\u2551\u2551\n\u255a\u255d\nooiwt@pe113:~/ex03-ooiwt$ ./rectangle\n10 10\n\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n\u2551        \u2551\n\u2551        \u2551\n\u2551        \u2551\n\u2551        \u2551\n\u2551        \u2551\n\u2551        \u2551\n\u2551        \u2551\n\u2551        \u2551\n\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n\n\n\n\n\n\nQuestion 3: Fibonacci\n\n\nThe Fibonacci sequence is a sequence of numbers 1, 1, 2, 3, 5, 8, 13, ... Fibonacci numbers often appear in mathematics as well as in nature and have \nmany fascinating properties\n. \n\n\nThe Fibonacci sequence can be constructed as follows.  The first Fibonacci number is 1.  The second Fibonacci number is also 1.  Subsequently, the i-th Fibonacci number is computed as the sum of the previous two Fibonacci numbers, the (i-2)-th, and the (i-1)-th.\n\n\nWrite a program called \nfibonacci\n that reads a positive integer number \nn\n from the standard input, and print the \nn\n-th Fibonacci number to the standard output.  Your program must not use recursion.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nooiwt@pe113:~/ex03-ooiwt$ ./fibonacci\n1\n1\nooiwt@pe113:~/ex03-ooiwt$ ./fibonacci\n10\n55\nooiwt@pe113:~/ex03-ooiwt$ ./fibonacci\n83\n99194853094755497\n\n\n\n\n\n\nQuestion 4: Prime\n\n\nWrite a program called \nprime\n that reads a positive integer \nn\n from the standard input and either prints \nprime\n if \nn\n is a prime number, or prints \nnot prime\n if \nn\n is not a prime number.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nooiwt@pe113:~/ex03-ooiwt$ ./prime\n2\nprime\nooiwt@pe113:~/ex03-ooiwt$ ./prime\n14000605\nnot prime\nooiwt@pe113:~/ex03-ooiwt$ ./prime\n99194853094755497\nprime\n\n\n\n\n\n\nBonus: UNIX Pipe\n\n\nIf you look at the output from the last \nfibonacci\n example and the input to the last \nprime\n example, you will see that they are the same number.  This means that the 83\nrd\n Fibonacci number is prime!  \n\n\nSuppose now you want to ask, is the 13\nth\n Fibonacci number a prime?  How can we use the programs that we have wrote to do this?  There are several ways\n\n\n\n\nYou can merge the two C files to create a new program that, given \nn\n, calculate the \nn\n-th Fibonacci number, then check if it is prime.\n\n\nYou can reuse the two programs you have already written.  First, run \nfibonacci\n with input 13, then cut-and-paste the output as input to \nprime\n.\n\n\n\n\nA better alternative is to use a \n|\n in a UNIX-based system.  A \n|\n, called a \npipe\n, basically interconnects the standard output of one command to the standard input of the second command.  Consider the following:\n\n\n1\nooiwt@pe113:~/ex03-ooiwt$ a | b\n\n\n\n\n\n\nWhatever the program \na\n prints to the standard output, will be read by the program \nb\n when it reads from the standard input.  You have seen how the standard input can refer to a keyboard or a file, now you have seen how the standard input can also be another program!\n\n\nBack to the original problem: how to check if the 83\nrd\n Fibonnacci number is prime?  You can run:\n\n1\n2\n3\nooiwt@pe113:~/ex03-ooiwt$ ./fibonacci | ./prime\n83\nprime",
            "title": "3. Binary, Rectangle, Fibonacci, Prime"
        },
        {
            "location": "/ex03/index.html#exercise-3-binary-rectangle-fibonacci-prime",
            "text": "This is a programming exercise for you to solve on your own.  You can submit but it will not be graded.  Test cases are provided for the exercises so that you can test and check on your own if your code is correct.  Feel free to discuss your solution with your peers or your TAs.",
            "title": "Exercise 3: Binary, Rectangle, Fibonacci, Prime"
        },
        {
            "location": "/ex03/index.html#prerequisite",
            "text": "You are able to access the  CS1010 programming environment .  You are familiar with  basic UNIX CLI  and using terminal-based editor  vim .  You have a GitHub account and have setup  .gitconfig  (see  Exercise 1 ).",
            "title": "Prerequisite"
        },
        {
            "location": "/ex03/index.html#learning-outcomes",
            "text": "Be comfortable writing correct C programs that involve  if ,  else , loops, and logical statements.  Be able to decompose a more complex problem into smaller subproblems and write functions to solve the sub-problems.",
            "title": "Learning Outcomes"
        },
        {
            "location": "/ex03/index.html#setup",
            "text": "Click on  this link  to accept the exercise.  Log in to one of the hosts of  CS1010 programming environment (PE)  Run the following on the command line on one of the PE hosts:   1 ~cs1010/get-ex03    You should see a new subdirectory  ex03-<githubid>  in your current working directory, where  githubid  is your GitHub ID.  Inside that directory, you should see a bunch of files:  binary.c ,  rectangle.c ,  prime.c  and  fibonacci.c  are the most important files.  They are the skeleton C code that you should edit to solve the exercise.  inputs  and  outputs  are subdirectories that contain test inputs and test outputs.  We use the same convention as Exercise 1 so you should be familiar with them.  Makefile : This is the configuration for the tool  make  that we use to automate the compilation and testing of the programs.    test.sh : This is a bash script for testing your code.",
            "title": "Setup"
        },
        {
            "location": "/ex03/index.html#solving-the-assignments",
            "text": "Edit the .c files on the PE hosts to solve the corresponding question as described below.  You can assume that all test inputs are valid inputs.  To compile and run the given tests with the sample inputs and outputs, run on the command line,   1 make   This will compile all your C files and if there is no error, run the test scripts.",
            "title": "Solving The Assignments"
        },
        {
            "location": "/ex03/index.html#submission",
            "text": "When you are ready, run the following command while you are in the exercise directory:  1 ~cs1010/submit-ex03   The .c files will be uploaded to GitHub.  You can submit multiple times.  As an exercise is not graded, submitting your code only serves the purpose of archiving your work for backup purposes.",
            "title": "Submission"
        },
        {
            "location": "/ex03/index.html#question-1-binary",
            "text": "In this question, you are asked to convert a number represented in binary format (using digits 0 and 1) into the decimal format (using digits 0 and 9).  A number in decimal format is represented with based 10.  The last digit (rightmost) corresponds to the unit of  10^0 = 1 10^0 = 1 , the next digit (second last) corresponds to the unit of  10^1 = 10 10^1 = 10 , and so on.  So, one can write the decimal number, for instance, 7146 as  7 \\times 10^3 + 1 \\times 10^2 + 4 \\times 10^1 + 6 \\times 10^0 7 \\times 10^3 + 1 \\times 10^2 + 4 \\times 10^1 + 6 \\times 10^0 .  A number represented in binary uses base 2 instead of base 10.  The last digit corresponds to  2^0 = 1 2^0 = 1 .  The second last digit correponds to  2^1 = 2 2^1 = 2 , the third last digit corresponds to  2^2 = 4 2^2 = 4 , and so on.  So, the binary number 1101, for instance, corresponds to  1 \\times 2^3 + 1 \\times 2^2 + 1 \\times 2^0 = 13 1 \\times 2^3 + 1 \\times 2^2 + 1 \\times 2^0 = 13 .  Write a program called  binary  that reads in a positive integer consists of only 0s and 1s from the standard input, treats it as a binary number, and prints the corresponding decimal number to the standard output.",
            "title": "Question 1: Binary"
        },
        {
            "location": "/ex03/index.html#sample-run",
            "text": "1\n2\n3\n4\n5\n6\n7\n8\n9 ooiwt@pe113:~/ex03-ooiwt$ ./binary\n1101\n13\nooiwt@pe113:~/ex03-ooiwt$ ./binary\n111\n7\nooiwt@pe113:~/ex03-ooiwt$ ./binary\n10110100\n180",
            "title": "Sample run:"
        },
        {
            "location": "/ex03/index.html#question-2-rectangle",
            "text": "Write a program called  rectangle  that reads two positive integers from the standard input, corresponding to the width and the height of the rectangle.  The width and height must be at least 2.  Draw a rectangle on the screen using the special ASCII characters #define \"\u2554\" \"\u2557\" \"\u255d\" \"\u255a\" \"\u2550\" \"\u2551\", which corresponds to the top left, top right, bottom right, bottom left, top/bottom edge, and left/right edge of the rectangle respectively.   Strings consisting of these special characters have been given to you in  rectangle.c  and we have defined them as constants.   For instance, \"\u2554\" is called  TOP_LEFT , and to print this out, you can write 1 cs1010_print_string ( TOP_LEFT );     1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28 ooiwt@pe113:~/ex03-ooiwt$ ./rectangle\n2 2\n\u2554\u2557\n\u255a\u255d\nooiwt@pe113:~/ex03-ooiwt$ ./rectangle\n2 10\n\u2554\u2557\n\u2551\u2551\n\u2551\u2551\n\u2551\u2551\n\u2551\u2551\n\u2551\u2551\n\u2551\u2551\n\u2551\u2551\n\u2551\u2551\n\u255a\u255d\nooiwt@pe113:~/ex03-ooiwt$ ./rectangle\n10 10\n\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n\u2551        \u2551\n\u2551        \u2551\n\u2551        \u2551\n\u2551        \u2551\n\u2551        \u2551\n\u2551        \u2551\n\u2551        \u2551\n\u2551        \u2551\n\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d",
            "title": "Question 2: Rectangle"
        },
        {
            "location": "/ex03/index.html#question-3-fibonacci",
            "text": "The Fibonacci sequence is a sequence of numbers 1, 1, 2, 3, 5, 8, 13, ... Fibonacci numbers often appear in mathematics as well as in nature and have  many fascinating properties .   The Fibonacci sequence can be constructed as follows.  The first Fibonacci number is 1.  The second Fibonacci number is also 1.  Subsequently, the i-th Fibonacci number is computed as the sum of the previous two Fibonacci numbers, the (i-2)-th, and the (i-1)-th.  Write a program called  fibonacci  that reads a positive integer number  n  from the standard input, and print the  n -th Fibonacci number to the standard output.  Your program must not use recursion.  1\n2\n3\n4\n5\n6\n7\n8\n9 ooiwt@pe113:~/ex03-ooiwt$ ./fibonacci\n1\n1\nooiwt@pe113:~/ex03-ooiwt$ ./fibonacci\n10\n55\nooiwt@pe113:~/ex03-ooiwt$ ./fibonacci\n83\n99194853094755497",
            "title": "Question 3: Fibonacci"
        },
        {
            "location": "/ex03/index.html#question-4-prime",
            "text": "Write a program called  prime  that reads a positive integer  n  from the standard input and either prints  prime  if  n  is a prime number, or prints  not prime  if  n  is not a prime number.  1\n2\n3\n4\n5\n6\n7\n8\n9 ooiwt@pe113:~/ex03-ooiwt$ ./prime\n2\nprime\nooiwt@pe113:~/ex03-ooiwt$ ./prime\n14000605\nnot prime\nooiwt@pe113:~/ex03-ooiwt$ ./prime\n99194853094755497\nprime",
            "title": "Question 4: Prime"
        },
        {
            "location": "/ex03/index.html#bonus-unix-pipe",
            "text": "If you look at the output from the last  fibonacci  example and the input to the last  prime  example, you will see that they are the same number.  This means that the 83 rd  Fibonacci number is prime!    Suppose now you want to ask, is the 13 th  Fibonacci number a prime?  How can we use the programs that we have wrote to do this?  There are several ways   You can merge the two C files to create a new program that, given  n , calculate the  n -th Fibonacci number, then check if it is prime.  You can reuse the two programs you have already written.  First, run  fibonacci  with input 13, then cut-and-paste the output as input to  prime .   A better alternative is to use a  |  in a UNIX-based system.  A  | , called a  pipe , basically interconnects the standard output of one command to the standard input of the second command.  Consider the following:  1 ooiwt@pe113:~/ex03-ooiwt$ a | b   Whatever the program  a  prints to the standard output, will be read by the program  b  when it reads from the standard input.  You have seen how the standard input can refer to a keyboard or a file, now you have seen how the standard input can also be another program!  Back to the original problem: how to check if the 83 rd  Fibonnacci number is prime?  You can run: 1\n2\n3 ooiwt@pe113:~/ex03-ooiwt$ ./fibonacci | ./prime\n83\nprime",
            "title": "Bonus: UNIX Pipe"
        },
        {
            "location": "/ex04/index.html",
            "text": "Exercise 4: ID, Grade, Index, Max\n\n\nThis is a programming exercise for you to solve on your own.  You can submit but it will not be graded.  Test cases are provided for the exercises so that you can test and check on your own if your code is correct.  Feel free to discuss your solution with your peers or your TAs.\n\n\nPrerequisite\n\n\n\n\nYou are able to access the \nCS1010 programming environment\n.\n\n\nYou are familiar with \nbasic UNIX CLI\n and using terminal-based editor \nvim\n.\n\n\nYou have a GitHub account and have setup \n.gitconfig\n (see \nExercise 1\n).\n\n\n\n\nLearning Outcomes\n\n\n\n\nBe comfortable writing correct C programs that involve \nif\n, \nelse\n, loops, logical statements, and arrays.\n\n\nBe able to decompose a more complex problem into smaller subproblems and write functions to solve the sub-problems.\n\n\n\n\nSetup\n\n\n\n\nClick on \nthis link\n to accept the exercise.\n\n\nLog in to one of the hosts of \nCS1010 programming environment (PE)\n\n\nRun the following on the command line on one of the PE hosts:\n\n\n\n\n1\n~cs1010/get-ex04\n\n\n\n\n\n\n\n\nYou should see a new subdirectory \nex04-<githubid>\n in your current working directory, where \ngithubid\n is your GitHub ID.\n\n\nInside that directory, you should see a bunch of files:\n\n\nid.c\n, \ngrade.c\n, \nindex.c\n and \nmax.c\n are the most important files.  They are the skeleton C code that you should edit to solve the exercise.\n\n\ninputs\n and \noutputs\n are subdirectories that contain test inputs and test outputs.  We use the same convention as Exercise 1 so you should be familiar with them.\n\n\nMakefile\n: This is the configuration for the tool \nmake\n that we use to automate the compilation and testing of the programs.  \n\n\ntest.sh\n: This is a bash script for testing your code.\n\n\n\n\n\n\n\n\nSolving The Assignments\n\n\n\n\nEdit the .c files on the PE hosts to solve the corresponding question as described below.\n\n\nYou can assume that all test inputs are valid inputs.\n\n\nTo compile and run the given tests with the sample inputs and outputs, run on the command line,\n\n\n\n\n1\nmake\n\n\n\n\n\n\nThis will compile all your C files and if there is no error, run the test scripts.\n\n\nSubmission\n\n\nWhen you are ready, run the following command while you are in the exercise directory:\n\n\n1\n~cs1010/submit-ex04\n\n\n\n\n\n\nThe .c files will be uploaded to GitHub.  You can submit multiple times.  As an exercise is not graded, submitting your code only serves the purpose of archiving your work for backup purposes.\n\n\n\n\nQuestion 1: ID\n\n\nYour NUS student id has a letter at the end.  This letter is called a \ncheck code\n and is a form of redundancy check used for detecting errors, especially when your student id is manually entered into a software application.\n\n\nYour check code is calculated by:\n\n\n\n\nSum up the digits in your student id.  Let the sum be \nN\nN\n.\n\n\nDivide \nN\nN\n by 13, and take the remainder.  Let the remainder be \nR\nR\n\n\nLook up the table below:\n\n\n\n\n\n\n\n\n\n\nRemainder\n\n\nCheck Code\n\n\n\n\n\n\n\n\n\n\n0\n\n\nY\n\n\n\n\n\n\n1\n\n\nX\n\n\n\n\n\n\n2\n\n\nW\n\n\n\n\n\n\n3\n\n\nU\n\n\n\n\n\n\n4\n\n\nR\n\n\n\n\n\n\n5\n\n\nN\n\n\n\n\n\n\n6\n\n\nM\n\n\n\n\n\n\n7\n\n\nL\n\n\n\n\n\n\n8\n\n\nJ\n\n\n\n\n\n\n9\n\n\nH\n\n\n\n\n\n\n10\n\n\nE\n\n\n\n\n\n\n11\n\n\nA\n\n\n\n\n\n\n12\n\n\nB\n\n\n\n\n\n\n\n\nWrite a program that reads in an integer containing the digits of a student's id from the standard input.  Print out the check code to the standard output.\n\n\nYou should practice using array to solve this problem instead of using a long if-else statement.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nooiwt@pe116:~/ex04-ooiwt$ ./studentid\n1933091\nY\nooiwt@pe116:~/ex04-ooiwt$ ./studentid\n3364497\nE\nooiwt@pe116:~/ex04-ooiwt$ ./studentid\n0123456\nJ\n\n\n\n\n\n\nQuestion 2: Grade\n\n\nIn a mirror universe, there is an evil version of your professor who is especially tough on his CS1010 students.  He use the following grading scheme to decide the letter grade to give out.\n\n\n\n\n\n\n\n\nMarks\n\n\nLetter Grade\n\n\n\n\n\n\n\n\n\n\n100\n\n\nA+\n\n\n\n\n\n\n99\n\n\nA\n\n\n\n\n\n\n98\n\n\nA-\n\n\n\n\n\n\n96-97\n\n\nB+\n\n\n\n\n\n\n91-95\n\n\nB\n\n\n\n\n\n\n86-90\n\n\nB-\n\n\n\n\n\n\n81-85\n\n\nC+\n\n\n\n\n\n\n71-80\n\n\nC\n\n\n\n\n\n\n61-70\n\n\nD+\n\n\n\n\n\n\n51-60\n\n\nD\n\n\n\n\n\n\n0 -50\n\n\nF\n\n\n\n\n\n\n\n\nWrite a program called \ngrade\n that reads in an integer corresponding to the marks given to a student. Print out the letter graded given by the evil professor.\n\n\nYou should practice using array to solve this problem instead of using a long if-else statement as done in \nUnit 8\n.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\nooiwt@pe116:~/ex04-ooiwt$ ./grade\n100\nA+\nooiwt@pe116:~/ex04-ooiwt$ ./grade\n99\nA\nooiwt@pe116:~/ex04-ooiwt$ ./grade\n50\nF\nooiwt@pe116:~/ex04-ooiwt$ ./grade\n87\nB-\n\n\n\n\n\n\nQuestion 3: Index\n\n\nWrite a program \nindex\n that finds a given number from a list of \nn\nn\n integers \nL\nL\n.\n\n\nThe program should read the following from the standard inputs in order:\n\n\n\n\nThe first number is a positive integer \nn\nn\n\n\nThe next \nn\nn\n numbers corresponds to the list of integers \nl_0, l_1, ... l_{n-1}\nl_0, l_1, ... l_{n-1}\n in \nL\nL\n.\n\n\nThe next number is a positive integer \nk\nk\n\n\nThe next \nk\nk\n numbers are integers corresponds to a list of queries \nq_0, q_1, .. q_k\nq_0, q_1, .. q_k\n\n\n\n\nFor each query, the program should print (on a new line) the position of the integer in the list, or \"not found\" if the query cannot be found.  To be more precise, for each \ni\ni\n, if \nq_i == l_j\nq_i == l_j\n for some \nj\nj\n, print \nj\nj\n.  If \nq_i\nq_i\n appears multiple times in \nL\nL\n, print the smallest \nj\nj\n.  If \nq_i\nq_i\n is not in \nL\nL\n, then print \"not found\".\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nooiwt@pe116:~/ex04-ooiwt$ cat input\n5\n-5 3 1 8 -5\n3\n1 4 -5\nooiwt@pe116:~/ex04-ooiwt$ ./index < input\n2\nnot found\n0\n\n\n\n\n\n\nLine 1 of the input file \ninput\n tells the program that there are five integers to read.  The next five integers should be read in as the list.  The next integer (Line 3) is 3.  The next three integers should be read in as queries.  The first query is 1, which can be found at position 2 (we start counting from 0).  The next query is 4, which is not found in the list.  Finally, the last query is -5, which can be found at position 0 and 4, but we return only the one at position 0.\n\n\nQuestion 4: Max\n\n\nWrite a program \nmax\n that finds the maximum value from a list of \nn\nn\n integers \nL\nL\n.\n\n\nInstead of doing this with a loop, you should solve this question with recursion.  Write a function\n\n\n1\n2\n3\nlong max(const long list[], long start, long end)\n{\n}\n\n\n\n\n\n\nthat calls itself and return the maximum value among the array elements \nlist[start]\n .. \nlist[end - 1]\n.  It should split the the input list into two halves (roughly), find the maximum of the left half, find the maximum of the right half, and return the larger of these two maximums.\n\n\nIn the function definition above, the keyword \nconst\n (short for constant) is used to annotate that the array \nlist\n is meant to remain unchanged.\n\n\nThe program should read the following from the standard inputs:\n\n\n\n\nThe first number is a positive integer \nn\nn\n\n\nThe next \nn\nn\n numbers corresponds to the list of integers \nL\nL\n.\n\n\n\n\nand print to largest value among the inputs to the standard output.\n\n\n1\n2\n3\n4\n5\nooiwt@pe116:~/ex04-ooiwt$ cat input\n5\n-5 3 1 8 2\nooiwt@pe116:~/ex04-ooiwt$ ./max < input\n8",
            "title": "4. ID, Grade, Index, Max"
        },
        {
            "location": "/ex04/index.html#exercise-4-id-grade-index-max",
            "text": "This is a programming exercise for you to solve on your own.  You can submit but it will not be graded.  Test cases are provided for the exercises so that you can test and check on your own if your code is correct.  Feel free to discuss your solution with your peers or your TAs.",
            "title": "Exercise 4: ID, Grade, Index, Max"
        },
        {
            "location": "/ex04/index.html#prerequisite",
            "text": "You are able to access the  CS1010 programming environment .  You are familiar with  basic UNIX CLI  and using terminal-based editor  vim .  You have a GitHub account and have setup  .gitconfig  (see  Exercise 1 ).",
            "title": "Prerequisite"
        },
        {
            "location": "/ex04/index.html#learning-outcomes",
            "text": "Be comfortable writing correct C programs that involve  if ,  else , loops, logical statements, and arrays.  Be able to decompose a more complex problem into smaller subproblems and write functions to solve the sub-problems.",
            "title": "Learning Outcomes"
        },
        {
            "location": "/ex04/index.html#setup",
            "text": "Click on  this link  to accept the exercise.  Log in to one of the hosts of  CS1010 programming environment (PE)  Run the following on the command line on one of the PE hosts:   1 ~cs1010/get-ex04    You should see a new subdirectory  ex04-<githubid>  in your current working directory, where  githubid  is your GitHub ID.  Inside that directory, you should see a bunch of files:  id.c ,  grade.c ,  index.c  and  max.c  are the most important files.  They are the skeleton C code that you should edit to solve the exercise.  inputs  and  outputs  are subdirectories that contain test inputs and test outputs.  We use the same convention as Exercise 1 so you should be familiar with them.  Makefile : This is the configuration for the tool  make  that we use to automate the compilation and testing of the programs.    test.sh : This is a bash script for testing your code.",
            "title": "Setup"
        },
        {
            "location": "/ex04/index.html#solving-the-assignments",
            "text": "Edit the .c files on the PE hosts to solve the corresponding question as described below.  You can assume that all test inputs are valid inputs.  To compile and run the given tests with the sample inputs and outputs, run on the command line,   1 make   This will compile all your C files and if there is no error, run the test scripts.",
            "title": "Solving The Assignments"
        },
        {
            "location": "/ex04/index.html#submission",
            "text": "When you are ready, run the following command while you are in the exercise directory:  1 ~cs1010/submit-ex04   The .c files will be uploaded to GitHub.  You can submit multiple times.  As an exercise is not graded, submitting your code only serves the purpose of archiving your work for backup purposes.",
            "title": "Submission"
        },
        {
            "location": "/ex04/index.html#question-1-id",
            "text": "Your NUS student id has a letter at the end.  This letter is called a  check code  and is a form of redundancy check used for detecting errors, especially when your student id is manually entered into a software application.  Your check code is calculated by:   Sum up the digits in your student id.  Let the sum be  N N .  Divide  N N  by 13, and take the remainder.  Let the remainder be  R R  Look up the table below:      Remainder  Check Code      0  Y    1  X    2  W    3  U    4  R    5  N    6  M    7  L    8  J    9  H    10  E    11  A    12  B     Write a program that reads in an integer containing the digits of a student's id from the standard input.  Print out the check code to the standard output.  You should practice using array to solve this problem instead of using a long if-else statement.  1\n2\n3\n4\n5\n6\n7\n8\n9 ooiwt@pe116:~/ex04-ooiwt$ ./studentid\n1933091\nY\nooiwt@pe116:~/ex04-ooiwt$ ./studentid\n3364497\nE\nooiwt@pe116:~/ex04-ooiwt$ ./studentid\n0123456\nJ",
            "title": "Question 1: ID"
        },
        {
            "location": "/ex04/index.html#question-2-grade",
            "text": "In a mirror universe, there is an evil version of your professor who is especially tough on his CS1010 students.  He use the following grading scheme to decide the letter grade to give out.     Marks  Letter Grade      100  A+    99  A    98  A-    96-97  B+    91-95  B    86-90  B-    81-85  C+    71-80  C    61-70  D+    51-60  D    0 -50  F     Write a program called  grade  that reads in an integer corresponding to the marks given to a student. Print out the letter graded given by the evil professor.  You should practice using array to solve this problem instead of using a long if-else statement as done in  Unit 8 .   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12 ooiwt@pe116:~/ex04-ooiwt$ ./grade\n100\nA+\nooiwt@pe116:~/ex04-ooiwt$ ./grade\n99\nA\nooiwt@pe116:~/ex04-ooiwt$ ./grade\n50\nF\nooiwt@pe116:~/ex04-ooiwt$ ./grade\n87\nB-",
            "title": "Question 2: Grade"
        },
        {
            "location": "/ex04/index.html#question-3-index",
            "text": "Write a program  index  that finds a given number from a list of  n n  integers  L L .  The program should read the following from the standard inputs in order:   The first number is a positive integer  n n  The next  n n  numbers corresponds to the list of integers  l_0, l_1, ... l_{n-1} l_0, l_1, ... l_{n-1}  in  L L .  The next number is a positive integer  k k  The next  k k  numbers are integers corresponds to a list of queries  q_0, q_1, .. q_k q_0, q_1, .. q_k   For each query, the program should print (on a new line) the position of the integer in the list, or \"not found\" if the query cannot be found.  To be more precise, for each  i i , if  q_i == l_j q_i == l_j  for some  j j , print  j j .  If  q_i q_i  appears multiple times in  L L , print the smallest  j j .  If  q_i q_i  is not in  L L , then print \"not found\".  1\n2\n3\n4\n5\n6\n7\n8\n9 ooiwt@pe116:~/ex04-ooiwt$ cat input\n5\n-5 3 1 8 -5\n3\n1 4 -5\nooiwt@pe116:~/ex04-ooiwt$ ./index < input\n2\nnot found\n0   Line 1 of the input file  input  tells the program that there are five integers to read.  The next five integers should be read in as the list.  The next integer (Line 3) is 3.  The next three integers should be read in as queries.  The first query is 1, which can be found at position 2 (we start counting from 0).  The next query is 4, which is not found in the list.  Finally, the last query is -5, which can be found at position 0 and 4, but we return only the one at position 0.",
            "title": "Question 3: Index"
        },
        {
            "location": "/ex04/index.html#question-4-max",
            "text": "Write a program  max  that finds the maximum value from a list of  n n  integers  L L .  Instead of doing this with a loop, you should solve this question with recursion.  Write a function  1\n2\n3 long max(const long list[], long start, long end)\n{\n}   that calls itself and return the maximum value among the array elements  list[start]  ..  list[end - 1] .  It should split the the input list into two halves (roughly), find the maximum of the left half, find the maximum of the right half, and return the larger of these two maximums.  In the function definition above, the keyword  const  (short for constant) is used to annotate that the array  list  is meant to remain unchanged.  The program should read the following from the standard inputs:   The first number is a positive integer  n n  The next  n n  numbers corresponds to the list of integers  L L .   and print to largest value among the inputs to the standard output.  1\n2\n3\n4\n5 ooiwt@pe116:~/ex04-ooiwt$ cat input\n5\n-5 3 1 8 2\nooiwt@pe116:~/ex04-ooiwt$ ./max < input\n8",
            "title": "Question 4: Max"
        },
        {
            "location": "/assignment/index.html",
            "text": "Guide to Programming Assignments\n\n\nTimeline\n\n\nThere will be weekly take-home programming assignments, each consisting of 2 to 4 questions. \nThese programming assignments collectively contribute to 30% of your final grade.\n\n\nThe programming assignment is released on the CS1010 website every Friday, with a deadline given.  You must submit all questions for each particular programming assignment before the deadline.\n\n\nGeneral Advice\n\n\nYou are advised to (i) spend some time thinking before you begin coding, (ii) practice incremental coding and (iii) test your programs thoroughly.\n\n\nRemember to spend some time thinking about the algorithm for each question.  Write out the pseudo-code or draw out the flowchart on your own before you start typing in your program. \n\n\nIncremental coding means do NOT type in the whole long program in a single session and then compile it. Instead, type your program in bits and pieces and compile it incrementally. Try to maintain a compilable program even while you are working on it. Submitting a compilable program that partially works is better than submitting an un-compilable one; this is especially important for your practical exams. \n\n\nYou should test your program thoroughly with your own test data before submission.  \n\n\nPlease note that:\n\n\n\n\n\n\nYou may assume that all input data are correct unless otherwise stated. Hence you do NOT need to do input data validation. This is to allow you to focus on getting the program right, instead of worrying about making your program fool-proof which involves a lot more work. \n\n\n\n\n\n\nCopying others' programs or relying on others to help you with these assignments will only offer a short-term reprieve. When Practical Exam (PE) time comes, your inadequacy will be exposed and the consequence would be dire.\n\n\n\n\n\n\nLate Submission\n\n\nAll programming assignments must be submitted on time.  If you need an extension, please ask for one and provide a justification for approval.  Only academic reasons and compassionate reasons can be considered (e.g., representing NUS for a sports event is OK; Attending a wedding is not.)\n\n\nFor late submission, there is a 1% penalty (of the total awarded marks for that particular assignment) for every 5-minute after the deadline, capped at 80%.  For example, if an assignment is awarded 40 marks, and it is submitted 100 minutes after the deadline, the student will get 32 marks instead (20% penalty).  If it is submitted 10 hours after the deadline, the student will get 8 marks (as it has hit the cap of 80% penalty).\n\n\nMethod of Submission\n\n\nPlease follow the instructions provided in each programming assignment to submit the programs to GitHub.  Programs submitted through other means, such as emails, will NOT be accepted.\n\n\nIdentifying Yourself\n\n\nIn every C file that you submit to CS1010, you need to identify yourself by writing your name and tutorial group. Marks will be deducted if you fail to do so. You need to edit the line:\n\n\n1\n@author XXXX (Group YYYY)\n\n\n\n\n\n\nand change it to something like:\n\n\n1\n@author Gamora (Group 10)\n\n\n\n\n\n\nPlease follow the instructions provided in each programming assignment to submit the programs to GitHub.  Programs submitted through other means, such as emails, will NOT be accepted.\n\n\nGrading\n\n\nOnly the final submission of each exercise will be graded.  For each exercise, we will provide you will a limited set of test data.  During grading, we may grade your program with additional test data.\n\n\nEach programming assignment will be graded differently.  Generally, marks are given for attempt, correctness, design, and style, and documentation.  The weight of each one will be adjusted over the semester.  \n\n\nA program that cannot compile will receive 0 marks for correctness.\n\n\nFeedback will be provided by the graders on GitHub.\n\n\nUse of Piazza\n\n\nIf you have doubts about the problem statements of an assignment, you may raise them on Piazza.  But before that, please read through the problem statements carefully first, and check if the same questions have been asked and answered on the forum.\n\n\nPlease exercise discretion when posting to Piazza.  \n\n\nBefore the deadline, you are NOT to post the solution to the assignment, complete or partial, on Piazza (or any publicly accessible online site).\n\n\nDisallowed Syntax\n\n\nSome programming assignments may explicitly disallow the use of certain syntax. Generally, using syntax or statements which are not yet covered either in class or in the assignment statement is strongly discouraged.  We also discourage the use of certain syntax for this module, (e.g., \n++\n) you should not use them.  The assignments are designed such that you should not need to do so (even though doing so may result in your program being shorter or more efficient). If the objective of the assignment is undermined, the penalty for using such forbidden syntax will be heavy. If in doubt, please ask for clarification.\n\n\nPlagiarism\n\n\nYou are NOT to copy from others or allow others to copy your programs.  We take plagiarism seriously.  See \nour policies\n page for details.\n\n\nThis means that you should also guard your solution carefully, not posting them to publicly accessible places, or change the permissions of the files on the CS1010 PE hosts so that it is accessible by others.\n\n\n\n\nThis guideline is adapted from Aaron Tan's CS1010 guideline.",
            "title": "General Guide"
        },
        {
            "location": "/assignment/index.html#guide-to-programming-assignments",
            "text": "",
            "title": "Guide to Programming Assignments"
        },
        {
            "location": "/assignment/index.html#timeline",
            "text": "There will be weekly take-home programming assignments, each consisting of 2 to 4 questions. \nThese programming assignments collectively contribute to 30% of your final grade.  The programming assignment is released on the CS1010 website every Friday, with a deadline given.  You must submit all questions for each particular programming assignment before the deadline.",
            "title": "Timeline"
        },
        {
            "location": "/assignment/index.html#general-advice",
            "text": "You are advised to (i) spend some time thinking before you begin coding, (ii) practice incremental coding and (iii) test your programs thoroughly.  Remember to spend some time thinking about the algorithm for each question.  Write out the pseudo-code or draw out the flowchart on your own before you start typing in your program.   Incremental coding means do NOT type in the whole long program in a single session and then compile it. Instead, type your program in bits and pieces and compile it incrementally. Try to maintain a compilable program even while you are working on it. Submitting a compilable program that partially works is better than submitting an un-compilable one; this is especially important for your practical exams.   You should test your program thoroughly with your own test data before submission.    Please note that:    You may assume that all input data are correct unless otherwise stated. Hence you do NOT need to do input data validation. This is to allow you to focus on getting the program right, instead of worrying about making your program fool-proof which involves a lot more work.     Copying others' programs or relying on others to help you with these assignments will only offer a short-term reprieve. When Practical Exam (PE) time comes, your inadequacy will be exposed and the consequence would be dire.",
            "title": "General Advice"
        },
        {
            "location": "/assignment/index.html#late-submission",
            "text": "All programming assignments must be submitted on time.  If you need an extension, please ask for one and provide a justification for approval.  Only academic reasons and compassionate reasons can be considered (e.g., representing NUS for a sports event is OK; Attending a wedding is not.)  For late submission, there is a 1% penalty (of the total awarded marks for that particular assignment) for every 5-minute after the deadline, capped at 80%.  For example, if an assignment is awarded 40 marks, and it is submitted 100 minutes after the deadline, the student will get 32 marks instead (20% penalty).  If it is submitted 10 hours after the deadline, the student will get 8 marks (as it has hit the cap of 80% penalty).",
            "title": "Late Submission"
        },
        {
            "location": "/assignment/index.html#method-of-submission",
            "text": "Please follow the instructions provided in each programming assignment to submit the programs to GitHub.  Programs submitted through other means, such as emails, will NOT be accepted.",
            "title": "Method of Submission"
        },
        {
            "location": "/assignment/index.html#identifying-yourself",
            "text": "In every C file that you submit to CS1010, you need to identify yourself by writing your name and tutorial group. Marks will be deducted if you fail to do so. You need to edit the line:  1 @author XXXX (Group YYYY)   and change it to something like:  1 @author Gamora (Group 10)   Please follow the instructions provided in each programming assignment to submit the programs to GitHub.  Programs submitted through other means, such as emails, will NOT be accepted.",
            "title": "Identifying Yourself"
        },
        {
            "location": "/assignment/index.html#grading",
            "text": "Only the final submission of each exercise will be graded.  For each exercise, we will provide you will a limited set of test data.  During grading, we may grade your program with additional test data.  Each programming assignment will be graded differently.  Generally, marks are given for attempt, correctness, design, and style, and documentation.  The weight of each one will be adjusted over the semester.    A program that cannot compile will receive 0 marks for correctness.  Feedback will be provided by the graders on GitHub.",
            "title": "Grading"
        },
        {
            "location": "/assignment/index.html#use-of-piazza",
            "text": "If you have doubts about the problem statements of an assignment, you may raise them on Piazza.  But before that, please read through the problem statements carefully first, and check if the same questions have been asked and answered on the forum.  Please exercise discretion when posting to Piazza.    Before the deadline, you are NOT to post the solution to the assignment, complete or partial, on Piazza (or any publicly accessible online site).",
            "title": "Use of Piazza"
        },
        {
            "location": "/assignment/index.html#disallowed-syntax",
            "text": "Some programming assignments may explicitly disallow the use of certain syntax. Generally, using syntax or statements which are not yet covered either in class or in the assignment statement is strongly discouraged.  We also discourage the use of certain syntax for this module, (e.g.,  ++ ) you should not use them.  The assignments are designed such that you should not need to do so (even though doing so may result in your program being shorter or more efficient). If the objective of the assignment is undermined, the penalty for using such forbidden syntax will be heavy. If in doubt, please ask for clarification.",
            "title": "Disallowed Syntax"
        },
        {
            "location": "/assignment/index.html#plagiarism",
            "text": "You are NOT to copy from others or allow others to copy your programs.  We take plagiarism seriously.  See  our policies  page for details.  This means that you should also guard your solution carefully, not posting them to publicly accessible places, or change the permissions of the files on the CS1010 PE hosts so that it is accessible by others.   This guideline is adapted from Aaron Tan's CS1010 guideline.",
            "title": "Plagiarism"
        },
        {
            "location": "/as01/index.html",
            "text": "Assignment 1\n\n\nDeadline\n\n\n14 September, 2018 (Friday), 6:00pm.\n\n\nPrerequisite\n\n\n\n\nYou are able to access the \nCS1010 programming environment\n.\n\n\nYou are familiar with \nbasic UNIX CLI\n and using terminal-based editor \nvim\n.\n\n\nYou have gone through Exercise 1 and have already setup your \n.gitconfig\n.\n\n\nYou are familiar with the steps of accepting, downloading, and submitting your exercise and assignment.\n\n\nYou are familiar with the directory structure and the common files included in your assignment skeleton.\n\n\n\n\nLearning Outcomes\n\n\n\n\nBe comfortable writing simple C programs that involves arithmetic operations, \nlong\n, \ndouble\n, and \nbool\n types, and conditional \nif\n/\nelse\n statements.\n\n\nBe comfortable breaking down a problem into smaller subproblems which can be resolved using functions, including reusing existing functions written for other programs (with a tweak), writing a function that calls itself, designing what should the inputs and return values/types of a function be.\n\n\n\n\nSetup\n\n\n\n\nClick on this link\n to accept the assignment.\n\n\nLogin to one of the hosts of \nCS1010 programming environment\n\n\nRun:\n\n\n\n\n1\n~cs1010/get-as01\n\n\n\n\n\n\n\n\nYou should see the folder \nas01-<github id>\n in your home directory with the assignment skeleton inside.\n\n\n\n\nSolving The Assignments\n\n\n\n\nEdit the files \ninvest.c\n, \nbox.c\n, \ndigits.c\n, and \ntaxi.c\n to solve the corresponding question as described below.\n\n\nTo compile and run tests with the sample inputs and outputs:\n\n\n\n\n1\nmake \n\n\n\n\n\n\n\n\nThe test cases are given in the \ninputs\n and \noutputs\n subdirectory.  You can use \ncat\n or \nless\n to look at the content of these test cases.  You can add more test cases or edit the given ones if needed.\n\n\n\n\nSubmission\n\n\nWhen you are ready, run the following command to submit:\n\n\n1\n~cs1010/submit-as01\n\n\n\n\n\n\nThe four files \ninvest.c\n, \nbox.c\n, \ndigits.c\n, and \ntaxi.c\n will be uploaded to GitHub.  You can submit multiple times, but only the last submission will be graded.\n\n\nIdentifying Yourself\n\n\nIn every C file that you submit to CS1010, you need to identify yourself by writing your name and tutorial group. Marks will be deducted if you fail to do so. You need to edit the line:\n\n\n1\n@author XXXX (Group YYYY)\n\n\n\n\n\n\nand change it to something like:\n\n\n1\n@author Hermione Granger (Group 9)\n\n\n\n\n\n\nGrading\n\n\nThis assignment contributes towards 3% of your final grade.  The total marks for this assignment is 30.  For Programming Assignment 1, the sole criteria for grading is correctness.\n\n\nQuestion 1: Invest (5 marks)\n\n\nIf you invest \nm\nm\n dollars at \nr\nr\n% interest rate compounded annually, after \nn\nn\n years, your investment will grow to \n\\frac{m(1 - (r/100)^{n+1})}{1 - r/100}\n\\frac{m(1 - (r/100)^{n+1})}{1 - r/100}\n dollars.\n\n\nWrite a program \ninvest.c\n that accepts three integers as input: principal \nm\nm\n, rate \nr\nr\n, and number of years \nn\nn\n, and computes the amount of money earned after \nn\nn\n years.\n\n\nYou may assume that \nr <= 100\n \nr < 100\nr < 100\n.\n\n\nSample Run\n\n\n1\n2\n3\n4\n5\n6\nooiwt@pe111:~/as01-skeleton$ ./invest\n100 10 5\n111.1110\nooiwt@pe111:~/as01-skeleton$ ./invest\n20000 5 10\n21052.6316\n\n\n\n\n\n\nQuestion 2: Box (5 marks)\n\n\nWrite a program \nbox.c\n that reads three positive integers representing the length, width, and height of a box, and output (i) its surface area, and (ii) the length of the diagonal between two vertices of the box that are furthest apart (see figure).\n\n\n\n\nYou may assume that the surface area of the box does not exceed the maximum value representable in the \nlong\n data type.\n\n\nYou should break down the problem into smaller ones:\n\n\n\n\nWrite a new method \narea_of_rectangle\n that computes the area of a rectangle given the width and height of the rectangle, then use it to compute the surface area.\n\n\nModify the method \nhypotenuse_of\n seen in \nUnit 5\n to compute the diagonal of the box.  (hint: pay attention to the type of the parameter and the return value).\n\n\n\n\nSample Run\n\n\n1\n2\n3\n4\n5\n6\nooiwt@pe111:~/as01-skeleton$ ./box \n12 3 10\n372 15.9060\nooiwt@pe111:~/as01-skeleton$ ./box \n10 20 30\n2200 37.4166\n\n\n\n\n\n\nQuestion 3: Digits (5 marks)\n\n\nWrite a program \ndigits.c\n that reads in a non-negative integer, and prints the sum of the individual digits in this integer. \n\n\nFor instance, if the input is \n1933091\n, then the sum is 1 + 9 + 3 + 3 + 0 + 9 + 1 = 26.\n\n\nYou should not use a loop to solve this, but rather, you should write a function \nsum_of_digits\n that takes in an integer and return the sum of the digits of that integer, that calls itself:\n\n\n\n\nif the input to \nsum_of_digits\n has only one digit, return this digit.\n\n\nOtherwise, use the modulo operator \n%\n and integer division \n/\n to extract the last digit (e.g., \n1\n) and the rest of the digits (e.g., \n193309\n) respectively, and call \nsum_of_digits\n on the rest of the digits to find its sum (e.g., 1+9+3+3+0+9 = 25).  Finally we add the last digit to this sum to get the total we seek (e.g., 1 + 25 = 26).\n\n\n\n\nSample Run\n\n\n1\n2\n3\n4\n5\n6\nooiwt@pe111:~/as01-skeleton$ ./digits \n1933091\n26\nooiwt@pe111:~/as01-skeleton$ ./digits \n0\n0\n\n\n\n\n\n\nQuestion 4: Taxi Fare (15 marks)\n\n\nThe taxi fare structure in Singapore must be one of the most complex in the world! Check out:\n\nhttp://www.taxisingapore.com/taxi-fare/\n.\n\n\nFor the purpose of this exercise, we will just use the following simpli\ufb01ed fare structure: \n\n\n\n\n\n\n\n\nBasic Fare\n\n\n\n\n\n\n\n\n\n\n\n\nThe first 1 km or less (Flag Down)\n\n\n$3.40\n\n\n\n\n\n\nEvery 400 m thereafter or less, up to 10.2 km\n\n\n$0.22\n\n\n\n\n\n\nEvery 350 m thereafter or less, after 10.2 km\n\n\n$0.22\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSurcharge\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMonday to Friday\n\n\n6:00 to 9:29\n\n\n25% of metered fare\n\n\n\n\n\n\nDaily\n\n\n18:00 to 23:59\n\n\n25% of metered fare\n\n\n\n\n\n\nDaily\n\n\n0:00 (midnight) to 5:59\n\n\n50% of metered fare\n\n\n\n\n\n\n\n\nNote that the surcharge is applicable based on the boarding time. For instance, if the trip started at 17:50 and ended at 18:10, then no surcharged is incurred.\n\n\nWrite a program \ntaxi.c\n that computes the taxi fare.  The program, called \ntaxi\n, takes in four integers as inputs:\n\n\n\n\nThe first is the day of the week.  It can only be the value \n1\n to \n7\n, \n1\n being Monday, \n7\n being Sunday.\n\n\nThe second and the third is the starting time of the trip: the second input indicates the hours since midnight of the stated day, the third input indicates the minutes since the beginning of the stated hours.\n\n\nThe forth and final input is the distance of the trip, in meters.\n\n\n\n\nYour program should print a single floating point number, which is the cost of the fare in dollars.\n\n\nExamine the following examples for more details:\n\n\nExample 1\n\n\n1\n2\n3\nooiwt@pe111:~/as01-skeleton$ ./taxi \n1 17 59 1000\n3.4000\n\n\n\n\n\n\n\n\nStart: Mon 17:59 \n\n\nDistance: 1,000 m\n\n\n\n\nThe metered fare is $3.40 since the distance travelled is 1km.  The boarding time is before 18:00 so there is no surcharge.  The total fare is $3.40.\n\n\nExample 2\n\n\n1\n2\n3\nooiwt@pe111:~/as01-skeleton$ ./taxi \n1 17 57 2000\n4.0600\n\n\n\n\n\n\n\n\nStart: Mon 17:57 \n\n\nDistance: 2,000 m\n\n\n\n\nThe metered fare for the first 1,000 m (1km) is $3.40.  The next 1,000 m is charged $0.22 for every 400 m (or less) travelled.  The pessengar is charged an additional 3 x $0.22, giving the total of metered fare of $4.06.\n\nThe boarding time is before 18:00 so there is no surcharge.\n\n\nExample 3\n\n\n1\n2\n3\nooiwt@pe111:~/as01-skeleton$ ./taxi \n1 5 50 15000\n17.3100\n\n\n\n\n\n\n\n\nStart: Mon 05:50\n\n\nDistance: 15,000 m\n\n\n\n\nThe metered fare for the first 1,000 m (1km) is $3.40.  The next 9,200 m is charged $0.22 for every 400 m travelled.  The pessengar is charged an additional 23 x $0.22 = $5.06.  The remaining 4,800 m is charged $0.22 for every 350 m (or less) travelled).  The pessengar is charged an additional 14 x $0.22 = $3.08.  The total metered fare is $11.54.\n\n\nThe boarding time is before 6:00 so there is a 50% surcharge.  Total fare is $17.31.\n\n\nHints\n\n\n\n\n\n\nYou can break down this problem into multiple subproblems, each can be solved by a function.  \nWrite one function to answer each question below\n:\n\n\n\n\ngiven the day of the week, is it a weekday? \n\n\ngiven the time of boarding, does it fall under the morning peak hour (6:00 - 9:29)?\n\n\ngiven the time of boarding, does it fall under the evening peak hour (18:00 - 23:59)?\n\n\ngiven the time of boarding, does it fall under the midnight peak hour (0:00 - 5:59)?\n\n\n\n\n\n\n\n\nYou can further breakdown the calculation of fare into two parts: the basic metered fare and the surcharge. Each of these can be its own function.  Think about the four inputs to the \ntaxi\n program.  Which one is needed to compute the metered fare?  Which ones are used to compute the surcharge?  Pass in the appropriate arguments to the function that computes the metered fare and the function that computes the surcharge.",
            "title": "1. Invest, Box, Digits, and Taxi"
        },
        {
            "location": "/as01/index.html#assignment-1",
            "text": "",
            "title": "Assignment 1"
        },
        {
            "location": "/as01/index.html#deadline",
            "text": "14 September, 2018 (Friday), 6:00pm.",
            "title": "Deadline"
        },
        {
            "location": "/as01/index.html#prerequisite",
            "text": "You are able to access the  CS1010 programming environment .  You are familiar with  basic UNIX CLI  and using terminal-based editor  vim .  You have gone through Exercise 1 and have already setup your  .gitconfig .  You are familiar with the steps of accepting, downloading, and submitting your exercise and assignment.  You are familiar with the directory structure and the common files included in your assignment skeleton.",
            "title": "Prerequisite"
        },
        {
            "location": "/as01/index.html#learning-outcomes",
            "text": "Be comfortable writing simple C programs that involves arithmetic operations,  long ,  double , and  bool  types, and conditional  if / else  statements.  Be comfortable breaking down a problem into smaller subproblems which can be resolved using functions, including reusing existing functions written for other programs (with a tweak), writing a function that calls itself, designing what should the inputs and return values/types of a function be.",
            "title": "Learning Outcomes"
        },
        {
            "location": "/as01/index.html#setup",
            "text": "Click on this link  to accept the assignment.  Login to one of the hosts of  CS1010 programming environment  Run:   1 ~cs1010/get-as01    You should see the folder  as01-<github id>  in your home directory with the assignment skeleton inside.",
            "title": "Setup"
        },
        {
            "location": "/as01/index.html#solving-the-assignments",
            "text": "Edit the files  invest.c ,  box.c ,  digits.c , and  taxi.c  to solve the corresponding question as described below.  To compile and run tests with the sample inputs and outputs:   1 make     The test cases are given in the  inputs  and  outputs  subdirectory.  You can use  cat  or  less  to look at the content of these test cases.  You can add more test cases or edit the given ones if needed.",
            "title": "Solving The Assignments"
        },
        {
            "location": "/as01/index.html#submission",
            "text": "When you are ready, run the following command to submit:  1 ~cs1010/submit-as01   The four files  invest.c ,  box.c ,  digits.c , and  taxi.c  will be uploaded to GitHub.  You can submit multiple times, but only the last submission will be graded.",
            "title": "Submission"
        },
        {
            "location": "/as01/index.html#identifying-yourself",
            "text": "In every C file that you submit to CS1010, you need to identify yourself by writing your name and tutorial group. Marks will be deducted if you fail to do so. You need to edit the line:  1 @author XXXX (Group YYYY)   and change it to something like:  1 @author Hermione Granger (Group 9)",
            "title": "Identifying Yourself"
        },
        {
            "location": "/as01/index.html#grading",
            "text": "This assignment contributes towards 3% of your final grade.  The total marks for this assignment is 30.  For Programming Assignment 1, the sole criteria for grading is correctness.",
            "title": "Grading"
        },
        {
            "location": "/as01/index.html#question-1-invest-5-marks",
            "text": "If you invest  m m  dollars at  r r % interest rate compounded annually, after  n n  years, your investment will grow to  \\frac{m(1 - (r/100)^{n+1})}{1 - r/100} \\frac{m(1 - (r/100)^{n+1})}{1 - r/100}  dollars.  Write a program  invest.c  that accepts three integers as input: principal  m m , rate  r r , and number of years  n n , and computes the amount of money earned after  n n  years.  You may assume that  r <= 100   r < 100 r < 100 .",
            "title": "Question 1: Invest (5 marks)"
        },
        {
            "location": "/as01/index.html#sample-run",
            "text": "1\n2\n3\n4\n5\n6 ooiwt@pe111:~/as01-skeleton$ ./invest\n100 10 5\n111.1110\nooiwt@pe111:~/as01-skeleton$ ./invest\n20000 5 10\n21052.6316",
            "title": "Sample Run"
        },
        {
            "location": "/as01/index.html#question-2-box-5-marks",
            "text": "Write a program  box.c  that reads three positive integers representing the length, width, and height of a box, and output (i) its surface area, and (ii) the length of the diagonal between two vertices of the box that are furthest apart (see figure).   You may assume that the surface area of the box does not exceed the maximum value representable in the  long  data type.  You should break down the problem into smaller ones:   Write a new method  area_of_rectangle  that computes the area of a rectangle given the width and height of the rectangle, then use it to compute the surface area.  Modify the method  hypotenuse_of  seen in  Unit 5  to compute the diagonal of the box.  (hint: pay attention to the type of the parameter and the return value).",
            "title": "Question 2: Box (5 marks)"
        },
        {
            "location": "/as01/index.html#sample-run_1",
            "text": "1\n2\n3\n4\n5\n6 ooiwt@pe111:~/as01-skeleton$ ./box \n12 3 10\n372 15.9060\nooiwt@pe111:~/as01-skeleton$ ./box \n10 20 30\n2200 37.4166",
            "title": "Sample Run"
        },
        {
            "location": "/as01/index.html#question-3-digits-5-marks",
            "text": "Write a program  digits.c  that reads in a non-negative integer, and prints the sum of the individual digits in this integer.   For instance, if the input is  1933091 , then the sum is 1 + 9 + 3 + 3 + 0 + 9 + 1 = 26.  You should not use a loop to solve this, but rather, you should write a function  sum_of_digits  that takes in an integer and return the sum of the digits of that integer, that calls itself:   if the input to  sum_of_digits  has only one digit, return this digit.  Otherwise, use the modulo operator  %  and integer division  /  to extract the last digit (e.g.,  1 ) and the rest of the digits (e.g.,  193309 ) respectively, and call  sum_of_digits  on the rest of the digits to find its sum (e.g., 1+9+3+3+0+9 = 25).  Finally we add the last digit to this sum to get the total we seek (e.g., 1 + 25 = 26).",
            "title": "Question 3: Digits (5 marks)"
        },
        {
            "location": "/as01/index.html#sample-run_2",
            "text": "1\n2\n3\n4\n5\n6 ooiwt@pe111:~/as01-skeleton$ ./digits \n1933091\n26\nooiwt@pe111:~/as01-skeleton$ ./digits \n0\n0",
            "title": "Sample Run"
        },
        {
            "location": "/as01/index.html#question-4-taxi-fare-15-marks",
            "text": "The taxi fare structure in Singapore must be one of the most complex in the world! Check out: http://www.taxisingapore.com/taxi-fare/ .  For the purpose of this exercise, we will just use the following simpli\ufb01ed fare structure:      Basic Fare       The first 1 km or less (Flag Down)  $3.40    Every 400 m thereafter or less, up to 10.2 km  $0.22    Every 350 m thereafter or less, after 10.2 km  $0.22        Surcharge        Monday to Friday  6:00 to 9:29  25% of metered fare    Daily  18:00 to 23:59  25% of metered fare    Daily  0:00 (midnight) to 5:59  50% of metered fare     Note that the surcharge is applicable based on the boarding time. For instance, if the trip started at 17:50 and ended at 18:10, then no surcharged is incurred.  Write a program  taxi.c  that computes the taxi fare.  The program, called  taxi , takes in four integers as inputs:   The first is the day of the week.  It can only be the value  1  to  7 ,  1  being Monday,  7  being Sunday.  The second and the third is the starting time of the trip: the second input indicates the hours since midnight of the stated day, the third input indicates the minutes since the beginning of the stated hours.  The forth and final input is the distance of the trip, in meters.   Your program should print a single floating point number, which is the cost of the fare in dollars.  Examine the following examples for more details:",
            "title": "Question 4: Taxi Fare (15 marks)"
        },
        {
            "location": "/as01/index.html#example-1",
            "text": "1\n2\n3 ooiwt@pe111:~/as01-skeleton$ ./taxi \n1 17 59 1000\n3.4000    Start: Mon 17:59   Distance: 1,000 m   The metered fare is $3.40 since the distance travelled is 1km.  The boarding time is before 18:00 so there is no surcharge.  The total fare is $3.40.",
            "title": "Example 1"
        },
        {
            "location": "/as01/index.html#example-2",
            "text": "1\n2\n3 ooiwt@pe111:~/as01-skeleton$ ./taxi \n1 17 57 2000\n4.0600    Start: Mon 17:57   Distance: 2,000 m   The metered fare for the first 1,000 m (1km) is $3.40.  The next 1,000 m is charged $0.22 for every 400 m (or less) travelled.  The pessengar is charged an additional 3 x $0.22, giving the total of metered fare of $4.06. \nThe boarding time is before 18:00 so there is no surcharge.",
            "title": "Example 2"
        },
        {
            "location": "/as01/index.html#example-3",
            "text": "1\n2\n3 ooiwt@pe111:~/as01-skeleton$ ./taxi \n1 5 50 15000\n17.3100    Start: Mon 05:50  Distance: 15,000 m   The metered fare for the first 1,000 m (1km) is $3.40.  The next 9,200 m is charged $0.22 for every 400 m travelled.  The pessengar is charged an additional 23 x $0.22 = $5.06.  The remaining 4,800 m is charged $0.22 for every 350 m (or less) travelled).  The pessengar is charged an additional 14 x $0.22 = $3.08.  The total metered fare is $11.54.  The boarding time is before 6:00 so there is a 50% surcharge.  Total fare is $17.31.",
            "title": "Example 3"
        },
        {
            "location": "/as01/index.html#hints",
            "text": "You can break down this problem into multiple subproblems, each can be solved by a function.   Write one function to answer each question below :   given the day of the week, is it a weekday?   given the time of boarding, does it fall under the morning peak hour (6:00 - 9:29)?  given the time of boarding, does it fall under the evening peak hour (18:00 - 23:59)?  given the time of boarding, does it fall under the midnight peak hour (0:00 - 5:59)?     You can further breakdown the calculation of fare into two parts: the basic metered fare and the surcharge. Each of these can be its own function.  Think about the four inputs to the  taxi  program.  Which one is needed to compute the metered fare?  Which ones are used to compute the surcharge?  Pass in the appropriate arguments to the function that computes the metered fare and the function that computes the surcharge.",
            "title": "Hints"
        },
        {
            "location": "/as01-comments/index.html",
            "text": "Assignment 1: Comments\n\n\nNotes on Marking Schemes\n\n\n\n\nWe apply the penalty to each program independently, i.e., the same mistake repeated in the different program get penalized multiple times.  \n\n\n\n\nYou will receive 0 marks if your program cannot be compiled or is plagiarised from another.\n\n\n\n\n\n\nCode that fails all test cases and showing that student does not understand the main concept tested in each question (writing arithmetic expressions in \ninvest\n, recursion in \ndigits\n, use of functions in \nbox\n, and logical expressions and conditionals in \ntaxi\n), receives 0 marks straight away.\n\n\n\n\n\n\nFor the rest, we start with full marks and start deducting marks for each error.\n\n\n\n\n\n\nWhile the teaching team tries to ensure fair and consistent grading of assignments across all groups, each TA can, at his/her own discretion, and with the approval of Wei Tsang, adjust the grading criteria to align with the messages that they sent to the students in their tutorial group.\n\n\n\n\n\n\nThe following list includes some of the common mistakes we encountered.  \n\n\n\n\n\n\nGeneral Mistakes\n\n\nThis penalty applies once per program (not per occurrence).\n\n\n\n\n-1 for missing type in function declaration or definition\n\n\n-1 for using \nint\n/\nlong\n instead of \nbool\n for boolean functions or variables\n\n\n-1 for using \ndouble\n instead of \nlong\n when it is not necessary (does not involve integer division).  For instance, using \ndouble\n for \ninvest.c\n during calculation is ok, using \ndouble\n for calculating the area of the box is not.\n\n\n-1 for using of \nint\n instead of \nlong\n.  Using \nint\n for this assignment is ok only for \nday\n, \nhour\n, and \nminute\n, where there is an implicit constraint on the range of the value.\n\n\n-1 for failing to use parenthesis (e.g., \na && b || c\n)\n\n\n-1 for unnecessary/unused parameters passed into a function\n\n\n-1 for unnecessary/unused variables declared\n\n\n-1 for not including @author/@group\n\n\n-1 for global variables\n\n\n-1 for unreachable code / return\n\n\n-1 for using \n==\n to compare real numbers\n\n\n\n\nLogical Mistakes (bugs)\n\n\nIn general, -1 for each bug.\n\n\n\n\n-1 for each incorrect logical expression\n\n\n-1 for each incorrect arithmetic expression\n\n\n-1 for each incorrect use of \nif\n-\nelse\n\n\n-1 for each uninitialized variables causing incorrect output.\n\n\n-1 if program prints extra text / newline\n\n\n-1 if the program returns non-zero from \nmain\n even if the program exits successfully.\n\n\n\n\nAnswer Keys\n\n\nInvest\n\n\nThis problem assesses if students know how to use arithmetic operations, parenthesis, and math library properly.  Most common mistakes include using \nfloat\n and \nint\n as data type, which would lead to loss of precision and overflow.  Suppose someone has $2.6 billion in his bank account, using \nint\n would cause an overflow.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n/**\n\n\n * CS1010 Semester 1 AY18/19\n\n\n * Assignment 1: Invest\n\n\n *\n\n\n * Read in three positive integer corresponding to the principal, the\n\n\n * interest rate, and the number of years.  Print the resulting amount\n\n\n * after the given num of years to the standard output.\n\n\n *\n\n\n * @file: invest.c\n\n\n * @author: XXX (Group YYY)\n\n\n */\n\n\n\n#include\n \n\"cs1010.h\"\n\n\n#include\n \n<math.h>\n\n\n\n\nint\n \nmain\n()\n\n\n{\n\n  \nlong\n \nprincipal\n \n=\n \ncs1010_read_long\n();\n\n  \nlong\n \nrate\n \n=\n \ncs1010_read_long\n();\n\n  \nlong\n \nnum_of_years\n \n=\n \ncs1010_read_long\n();\n\n\n  \ndouble\n \nr\n \n=\n \nrate\n/\n100.0\n;\n\n  \ndouble\n \nresult\n \n=\n \nprincipal\n*\n(\n1\n \n-\n \npow\n(\nr\n,\n \nnum_of_years\n \n+\n \n1\n))\n/\n(\n1\n \n-\n \nr\n);\n\n\n  \ncs1010_println_double\n(\nresult\n);\n\n\n}\n\n\n\n\n\n\n\nBox\n\n\nThis problem tests if students know how to write and reuse functions.  \n\n\nSome students wrote different versions of \narea_of_rectangle\n:\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\nlong\n \narea_of_rectangle1\n(\nlong\n \nwidth\n,\n \nlong\n \nheight\n)\n\n\n{\n\n  \nreturn\n \nwidth\n \n*\n \nheight\n;\n\n\n}\n\n\n\nlong\n \narea_of_rectangle2\n(\nlong\n \nwidth\n,\n \nlong\n \nbase\n)\n\n\n{\n\n  \nreturn\n \nwidth\n \n*\n \nbase\n;\n\n\n}\n\n\n\nlong\n \narea_of_rectangle3\n(\nlong\n \nbase\n,\n \nlong\n \nheight\n)\n\n\n{\n\n  \nreturn\n \nbase\n \n*\n \nheight\n;\n\n\n}\n\n\n\n\n\n\ndemonstrating that they do not understand how functions can be reused by passing in different parameters.\n\n\nThis problem also demonstrates how functions written for another problem (calculating the hypotenuse of a triangle in class) can be used to solve a different problem (diagonal of the box).  The \nhypotenuse_of\n function written in class, however, takes in \nlong\n instead of \ndouble\n, so we have to change that.  Some of you also change the \nhypotenuse_of\n method to take in three parameters so that it calculates the diagonal directly.  This solution is fine as well.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n/**\n\n\n * CS1010 Semester 1 AY18/19\n\n\n * Assignment 1: Box\n\n\n *\n\n\n * Read in three positive integer corresponding to the width,\n\n\n * height, and length of a box from the standard input, and\n\n\n * print the total surface area and the length of the diagonal\n\n\n * to the standard output.\n\n\n *\n\n\n * @file: box.c\n\n\n * @author: XXX (Group YYY)\n\n\n */\n\n\n\n#include\n \n\"cs1010.h\"\n\n\n#include\n \n<math.h>\n\n\n\n/**\n\n\n * Calculate the hypotenuse of a triangle.\n\n\n *\n\n\n * @param[in] base The base of the triangle.\n\n\n * @param[in] height The height of the triangle.\n\n\n * @return The hypotenuse of the triangle.\n\n\n */\n\n\ndouble\n \nhypotenuse_of\n(\ndouble\n \nbase\n,\n \ndouble\n \nheight\n)\n\n\n{\n\n  \nreturn\n \nsqrt\n(\nbase\n*\nbase\n \n+\n \nheight\n*\nheight\n);\n\n\n}\n\n\n\n/**\n\n\n * Calculate the area of a rectangle.\n\n\n *\n\n\n * @param[in] width The width of the rectangle.\n\n\n * @param[in] height The height of the rectangle.\n\n\n * @return The surface area of the rectangle.\n\n\n */\n\n\nlong\n \narea_of_rectangle\n(\nlong\n \nwidth\n,\n \nlong\n \nheight\n)\n\n\n{\n\n  \nreturn\n \nwidth\n \n*\n \nheight\n;\n\n\n}\n\n\n\nint\n \nmain\n()\n\n\n{\n\n  \nlong\n \nwidth\n \n=\n \ncs1010_read_long\n();\n\n  \nlong\n \nheight\n \n=\n \ncs1010_read_long\n();\n\n  \nlong\n \nlength\n \n=\n \ncs1010_read_long\n();\n\n\n  \nlong\n \nsurface_area\n \n=\n \n2\n*\narea_of_rectangle\n(\nwidth\n,\n \nheight\n)\n \n+\n\n    \n2\n*\narea_of_rectangle\n(\nwidth\n,\n \nlength\n)\n \n+\n\n    \n2\n*\narea_of_rectangle\n(\nlength\n,\n \nheight\n);\n\n  \ncs1010_print_long\n(\nsurface_area\n);\n\n\n  \ncs1010_print_string\n(\n\" \"\n);\n\n\n  \ndouble\n \nhypotenuse\n \n=\n \nhypotenuse_of\n(\nhypotenuse_of\n(\nwidth\n,\n \nheight\n),\n \nlength\n);\n\n  \ncs1010_println_double\n(\nhypotenuse\n);\n\n\n}\n\n\n\n\n\n\n\nDigits\n\n\nMost students who solve this correctly (without a loop and without segmentation fault) are able to get the idea of how recursion can be used here.  The most common error we see if a mismatch of types, where students use \nint\n leading to failure when we test with a large integer beyond the range of \nint\n.  \n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n/**\n\n\n * CS1010 Semester 1 AY18/19\n\n\n * Assignment 1: Digits\n\n\n *\n\n\n * Read in a positive integer from the standard input and print\n\n\n * the sum of all digits in the integer to the standard output.\n\n\n *\n\n\n * @file: digits.c\n\n\n * @author: XXX (Group YYY)\n\n\n */\n\n\n\n#include\n \n\"cs1010.h\"\n\n\n\n/**\n\n\n * Sum the digits in input.\n\n\n *\n\n\n * @param[in] input The integer whose digits we are summing.\n\n\n * @return The sum of digits in the parameter input.\n\n\n */\n\n\nlong\n \nsum_of_digits\n(\nlong\n \ninput\n)\n\n\n{\n\n  \nif\n \n(\ninput\n \n<\n \n10\n)\n \n{\n\n    \nreturn\n \ninput\n;\n\n  \n}\n\n  \nlong\n \nlast_digit\n \n=\n \ninput\n \n%\n \n10\n;\n\n  \nlong\n \nrest\n \n=\n \ninput\n \n/\n \n10\n;\n\n  \nreturn\n \nlast_digit\n \n+\n \nsum_of_digits\n(\nrest\n);\n\n\n}\n\n\n\nint\n \nmain\n()\n\n\n{\n\n  \nlong\n \ninput\n \n=\n \ncs1010_read_long\n();\n\n  \ncs1010_println_long\n(\nsum_of_digits\n(\ninput\n));\n\n\n}\n\n\n\n\n\n\n\nTaxi\n\n\nThis is a more complex problem.  We hope that students, when thinking about the solution of this problem, can appreciate the importance of breaking down the problem into simpler subproblems so that you can think, solve, and test the sub-solutions, independently, before combining them to solve the larger problem.  \n\n\nAnother objective of this question is to get students to think about what parameters and variables are needed to solve a subproblem.  Students who think through this should realize that to calculate the metered fare only the distance is needed and to calculate the surcharge, only the day and time is needed.  Further, to determine evening peak and midnight peak, only the hour is needed (not minutes nor day).\n\n\nSome common mistakes include being careless in checking for the peak hour surcharge (bug in logical expressions).  \n\n\nSome students use \nceil\n to calculate the metered fare, which is fine (simpler than the sample code below).  But a few students incorrectly use \nround\n instead.  \n\n\n  1\n  2\n  3\n  4\n  5\n  6\n  7\n  8\n  9\n 10\n 11\n 12\n 13\n 14\n 15\n 16\n 17\n 18\n 19\n 20\n 21\n 22\n 23\n 24\n 25\n 26\n 27\n 28\n 29\n 30\n 31\n 32\n 33\n 34\n 35\n 36\n 37\n 38\n 39\n 40\n 41\n 42\n 43\n 44\n 45\n 46\n 47\n 48\n 49\n 50\n 51\n 52\n 53\n 54\n 55\n 56\n 57\n 58\n 59\n 60\n 61\n 62\n 63\n 64\n 65\n 66\n 67\n 68\n 69\n 70\n 71\n 72\n 73\n 74\n 75\n 76\n 77\n 78\n 79\n 80\n 81\n 82\n 83\n 84\n 85\n 86\n 87\n 88\n 89\n 90\n 91\n 92\n 93\n 94\n 95\n 96\n 97\n 98\n 99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n/**\n\n\n * CS1010 Semester 1 AY18/19\n\n\n * Assignment 1: Taxi\n\n\n *\n\n\n * Read in four positive integer corresponding to the day of the week,\n\n\n * the hour and minute of boarding, and the distance traveled.  Print\n\n\n * to the standard output, the fare of the taxi.\n\n\n * height, and length of a box from the standard input, and\n\n\n * print the total surface area and the length of the diagonal\n\n\n * to the standard output.\n\n\n *\n\n\n * @file: taxi.c\n\n\n * @author: XXX (Group YYY)\n\n\n */\n\n\n\n#include\n \n\"cs1010.h\"\n\n\n#include\n \n<stdbool.h>\n\n\n\n/**\n\n\n * Check if a given day is a weekday.\n\n\n *\n\n\n * @param[in] day The day of the week (1 for Monday, 7 for Sunday).\n\n\n * @return true if the day is a weekday, false otherwise.\n\n\n */\n\n\nbool\n \nis_weekday\n(\nlong\n \nday\n)\n\n\n{\n\n  \nreturn\n \n(\nday\n \n>=\n \n1\n \n&&\n \nday\n \n<=\n \n5\n);\n\n\n}\n\n\n\n/**\n\n\n * Check if a given time falls under morning peak hour (6am to 9:29am)\n\n\n *\n\n\n * @param[in] hour The given hour.\n\n\n * @param[in] minute The given minute.\n\n\n * @return true if the given time falls under morning peak hour.  \n\n\n *         false otherwise.\n\n\n */\n\n\nbool\n \nis_morning_peak\n(\nlong\n \nhour\n,\n \nlong\n \nminute\n)\n\n\n{\n\n  \nreturn\n \n(\nhour\n \n>=\n \n6\n \n&&\n \nhour\n \n<\n \n9\n)\n \n||\n \n(\nhour\n \n==\n \n9\n \n&&\n \nminute\n \n<=\n \n29\n);\n\n\n}\n\n\n\n/**\n\n\n * Check if a given time falls under evening peak hour (6pm to 11:59pm).\n\n\n *\n\n\n * @param[in] hour The given hour.\n\n\n * @return true if the given time falls under morning peak hour.  \n\n\n *         false otherwise.\n\n\n */\n\n\nbool\n \nis_evening_peak\n(\nlong\n \nhour\n)\n\n\n{\n\n  \nreturn\n \n(\nhour\n \n>=\n \n18\n \n&&\n \nhour\n \n<=\n \n23\n);\n\n\n}\n\n\n\n/**\n\n\n * Check if a given time falls under midnight peak hour (0:00 to 5:59am).\n\n\n *\n\n\n * @param[in] hour The given hour.\n\n\n * @return true if the given time falls under midnight peak hour.  \n\n\n *         false otherwise.\n\n\n */\n\n\nbool\n \nis_midnight_peak\n(\nlong\n \nhour\n)\n\n\n{\n\n  \nreturn\n \n(\nhour\n \n>=\n \n0\n \n&&\n \nhour\n \n<\n \n6\n);\n\n\n}\n\n\n\n/**\n\n\n * Check if surchange should be applied given day and time.\n\n\n *\n\n\n * @param[in] day Day of the taxi trip\n\n\n * @param[in] hour Hour of boarding time.\n\n\n * @param[in] minute Minute of boarding time\n\n\n * @return The surchage applied (1.0 if no surcharge)).\n\n\n */\n\n\ndouble\n \nsurcharge\n(\nlong\n \nday\n,\n \nlong\n \nhour\n,\n \nlong\n \nminute\n)\n\n\n{\n\n  \nif\n \n(\nis_weekday\n(\nday\n)\n \n&&\n \nis_morning_peak\n(\nhour\n,\n \nminute\n))\n \n{\n\n    \nreturn\n \n1.25\n;\n\n  \n}\n\n  \nif\n \n(\nis_evening_peak\n(\nhour\n))\n \n{\n\n    \nreturn\n \n1.25\n;\n\n  \n}\n\n  \nif\n \n(\nis_midnight_peak\n(\nhour\n))\n \n{\n\n    \nreturn\n \n1.5\n;\n\n  \n}\n\n  \nreturn\n \n1.0\n;\n\n\n}\n\n\n\n/**\n\n\n * Calculate the metered fare for a taxi trip (before surcharge).\n\n\n *\n\n\n * @param[in] distance The distance travelled.\n\n\n */\n\n\ndouble\n \nmetered_fare\n(\nlong\n \ndistance\n)\n\n\n{\n\n  \ndouble\n \nfare\n \n=\n \n3.40\n;\n\n\n  \ndistance\n \n-=\n \n1000\n;\n\n  \nif\n \n(\ndistance\n \n<=\n \n0\n)\n \n{\n\n    \nreturn\n \nfare\n;\n\n  \n}\n\n\n  \nif\n \n(\ndistance\n \n<=\n \n9200\n)\n \n{\n\n    \nfare\n \n+=\n \n0.22\n \n*\n \n(\ndistance\n \n/\n \n400\n);\n\n    \nif\n \n(\ndistance\n \n%\n \n400\n \n>\n \n0\n)\n \n{\n\n      \nfare\n \n+=\n \n0.22\n;\n\n    \n}\n\n  \n}\n \nelse\n \n{\n\n    \nfare\n \n+=\n \n0.22\n \n*\n \n(\n9200\n \n/\n \n400\n);\n\n  \n}\n\n\n  \ndistance\n \n-=\n \n9200\n;\n\n  \nif\n \n(\ndistance\n \n<=\n \n0\n)\n \n{\n\n    \nreturn\n \nfare\n;\n\n  \n}\n\n\n  \nfare\n \n+=\n \n0.22\n \n*\n \n(\ndistance\n \n/\n \n350\n);\n\n  \nif\n \n(\ndistance\n \n%\n \n350\n \n>\n \n0\n)\n \n{\n\n    \nfare\n \n+=\n \n0.22\n;\n\n  \n}\n\n\n  \nreturn\n \nfare\n;\n\n\n}\n\n\n\n/**\n\n\n * Calculate the fare for a taxi trip (including surcharge).\n\n\n *\n\n\n * @param[in] day Day of the taxi trip\n\n\n * @param[in] hour Hour of boarding time\n\n\n * @param[in] minute Minute of boarding time\n\n\n * @param[in] distance The distance travelled\n\n\n */\n\n\ndouble\n \nfare\n(\nlong\n \nday\n,\n \nlong\n \nhour\n,\n \nlong\n \nminute\n,\n \nlong\n \ndistance\n)\n\n\n{\n\n  \nreturn\n \nmetered_fare\n(\ndistance\n)\n \n*\n \nsurcharge\n(\nday\n,\n \nhour\n,\n \nminute\n);\n\n\n}\n\n\n\n\nint\n \nmain\n()\n\n\n{\n\n  \nlong\n \nday\n \n=\n \ncs1010_read_long\n();\n\n  \nlong\n \nstart_hour\n \n=\n \ncs1010_read_long\n();\n\n  \nlong\n \nstart_minute\n \n=\n \ncs1010_read_long\n();\n\n  \nlong\n \ndistance\n \n=\n \ncs1010_read_long\n();\n\n\n  \ncs1010_println_double\n(\nfare\n(\nday\n,\n \nstart_hour\n,\n \nstart_minute\n,\n \ndistance\n));\n\n\n}",
            "title": "1. Comments and Answer Keys"
        },
        {
            "location": "/as01-comments/index.html#assignment-1-comments",
            "text": "",
            "title": "Assignment 1: Comments"
        },
        {
            "location": "/as01-comments/index.html#notes-on-marking-schemes",
            "text": "We apply the penalty to each program independently, i.e., the same mistake repeated in the different program get penalized multiple times.     You will receive 0 marks if your program cannot be compiled or is plagiarised from another.    Code that fails all test cases and showing that student does not understand the main concept tested in each question (writing arithmetic expressions in  invest , recursion in  digits , use of functions in  box , and logical expressions and conditionals in  taxi ), receives 0 marks straight away.    For the rest, we start with full marks and start deducting marks for each error.    While the teaching team tries to ensure fair and consistent grading of assignments across all groups, each TA can, at his/her own discretion, and with the approval of Wei Tsang, adjust the grading criteria to align with the messages that they sent to the students in their tutorial group.    The following list includes some of the common mistakes we encountered.",
            "title": "Notes on Marking Schemes"
        },
        {
            "location": "/as01-comments/index.html#general-mistakes",
            "text": "This penalty applies once per program (not per occurrence).   -1 for missing type in function declaration or definition  -1 for using  int / long  instead of  bool  for boolean functions or variables  -1 for using  double  instead of  long  when it is not necessary (does not involve integer division).  For instance, using  double  for  invest.c  during calculation is ok, using  double  for calculating the area of the box is not.  -1 for using of  int  instead of  long .  Using  int  for this assignment is ok only for  day ,  hour , and  minute , where there is an implicit constraint on the range of the value.  -1 for failing to use parenthesis (e.g.,  a && b || c )  -1 for unnecessary/unused parameters passed into a function  -1 for unnecessary/unused variables declared  -1 for not including @author/@group  -1 for global variables  -1 for unreachable code / return  -1 for using  ==  to compare real numbers",
            "title": "General Mistakes"
        },
        {
            "location": "/as01-comments/index.html#logical-mistakes-bugs",
            "text": "In general, -1 for each bug.   -1 for each incorrect logical expression  -1 for each incorrect arithmetic expression  -1 for each incorrect use of  if - else  -1 for each uninitialized variables causing incorrect output.  -1 if program prints extra text / newline  -1 if the program returns non-zero from  main  even if the program exits successfully.",
            "title": "Logical Mistakes (bugs)"
        },
        {
            "location": "/as01-comments/index.html#answer-keys",
            "text": "",
            "title": "Answer Keys"
        },
        {
            "location": "/as01-comments/index.html#invest",
            "text": "This problem assesses if students know how to use arithmetic operations, parenthesis, and math library properly.  Most common mistakes include using  float  and  int  as data type, which would lead to loss of precision and overflow.  Suppose someone has $2.6 billion in his bank account, using  int  would cause an overflow.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27 /**   * CS1010 Semester 1 AY18/19   * Assignment 1: Invest   *   * Read in three positive integer corresponding to the principal, the   * interest rate, and the number of years.  Print the resulting amount   * after the given num of years to the standard output.   *   * @file: invest.c   * @author: XXX (Group YYY)   */  #include   \"cs1010.h\"  #include   <math.h>  int   main ()  { \n   long   principal   =   cs1010_read_long (); \n   long   rate   =   cs1010_read_long (); \n   long   num_of_years   =   cs1010_read_long (); \n\n   double   r   =   rate / 100.0 ; \n   double   result   =   principal * ( 1   -   pow ( r ,   num_of_years   +   1 )) / ( 1   -   r ); \n\n   cs1010_println_double ( result );  }",
            "title": "Invest"
        },
        {
            "location": "/as01-comments/index.html#box",
            "text": "This problem tests if students know how to write and reuse functions.    Some students wrote different versions of  area_of_rectangle :  1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14 long   area_of_rectangle1 ( long   width ,   long   height )  { \n   return   width   *   height ;  }  long   area_of_rectangle2 ( long   width ,   long   base )  { \n   return   width   *   base ;  }  long   area_of_rectangle3 ( long   base ,   long   height )  { \n   return   base   *   height ;  }    demonstrating that they do not understand how functions can be reused by passing in different parameters.  This problem also demonstrates how functions written for another problem (calculating the hypotenuse of a triangle in class) can be used to solve a different problem (diagonal of the box).  The  hypotenuse_of  function written in class, however, takes in  long  instead of  double , so we have to change that.  Some of you also change the  hypotenuse_of  method to take in three parameters so that it calculates the diagonal directly.  This solution is fine as well.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56 /**   * CS1010 Semester 1 AY18/19   * Assignment 1: Box   *   * Read in three positive integer corresponding to the width,   * height, and length of a box from the standard input, and   * print the total surface area and the length of the diagonal   * to the standard output.   *   * @file: box.c   * @author: XXX (Group YYY)   */  #include   \"cs1010.h\"  #include   <math.h>  /**   * Calculate the hypotenuse of a triangle.   *   * @param[in] base The base of the triangle.   * @param[in] height The height of the triangle.   * @return The hypotenuse of the triangle.   */  double   hypotenuse_of ( double   base ,   double   height )  { \n   return   sqrt ( base * base   +   height * height );  }  /**   * Calculate the area of a rectangle.   *   * @param[in] width The width of the rectangle.   * @param[in] height The height of the rectangle.   * @return The surface area of the rectangle.   */  long   area_of_rectangle ( long   width ,   long   height )  { \n   return   width   *   height ;  }  int   main ()  { \n   long   width   =   cs1010_read_long (); \n   long   height   =   cs1010_read_long (); \n   long   length   =   cs1010_read_long (); \n\n   long   surface_area   =   2 * area_of_rectangle ( width ,   height )   + \n     2 * area_of_rectangle ( width ,   length )   + \n     2 * area_of_rectangle ( length ,   height ); \n   cs1010_print_long ( surface_area ); \n\n   cs1010_print_string ( \" \" ); \n\n   double   hypotenuse   =   hypotenuse_of ( hypotenuse_of ( width ,   height ),   length ); \n   cs1010_println_double ( hypotenuse );  }",
            "title": "Box"
        },
        {
            "location": "/as01-comments/index.html#digits",
            "text": "Most students who solve this correctly (without a loop and without segmentation fault) are able to get the idea of how recursion can be used here.  The most common error we see if a mismatch of types, where students use  int  leading to failure when we test with a large integer beyond the range of  int .     1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34 /**   * CS1010 Semester 1 AY18/19   * Assignment 1: Digits   *   * Read in a positive integer from the standard input and print   * the sum of all digits in the integer to the standard output.   *   * @file: digits.c   * @author: XXX (Group YYY)   */  #include   \"cs1010.h\"  /**   * Sum the digits in input.   *   * @param[in] input The integer whose digits we are summing.   * @return The sum of digits in the parameter input.   */  long   sum_of_digits ( long   input )  { \n   if   ( input   <   10 )   { \n     return   input ; \n   } \n   long   last_digit   =   input   %   10 ; \n   long   rest   =   input   /   10 ; \n   return   last_digit   +   sum_of_digits ( rest );  }  int   main ()  { \n   long   input   =   cs1010_read_long (); \n   cs1010_println_long ( sum_of_digits ( input ));  }",
            "title": "Digits"
        },
        {
            "location": "/as01-comments/index.html#taxi",
            "text": "This is a more complex problem.  We hope that students, when thinking about the solution of this problem, can appreciate the importance of breaking down the problem into simpler subproblems so that you can think, solve, and test the sub-solutions, independently, before combining them to solve the larger problem.    Another objective of this question is to get students to think about what parameters and variables are needed to solve a subproblem.  Students who think through this should realize that to calculate the metered fare only the distance is needed and to calculate the surcharge, only the day and time is needed.  Further, to determine evening peak and midnight peak, only the hour is needed (not minutes nor day).  Some common mistakes include being careless in checking for the peak hour surcharge (bug in logical expressions).    Some students use  ceil  to calculate the metered fare, which is fine (simpler than the sample code below).  But a few students incorrectly use  round  instead.      1\n  2\n  3\n  4\n  5\n  6\n  7\n  8\n  9\n 10\n 11\n 12\n 13\n 14\n 15\n 16\n 17\n 18\n 19\n 20\n 21\n 22\n 23\n 24\n 25\n 26\n 27\n 28\n 29\n 30\n 31\n 32\n 33\n 34\n 35\n 36\n 37\n 38\n 39\n 40\n 41\n 42\n 43\n 44\n 45\n 46\n 47\n 48\n 49\n 50\n 51\n 52\n 53\n 54\n 55\n 56\n 57\n 58\n 59\n 60\n 61\n 62\n 63\n 64\n 65\n 66\n 67\n 68\n 69\n 70\n 71\n 72\n 73\n 74\n 75\n 76\n 77\n 78\n 79\n 80\n 81\n 82\n 83\n 84\n 85\n 86\n 87\n 88\n 89\n 90\n 91\n 92\n 93\n 94\n 95\n 96\n 97\n 98\n 99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147 /**   * CS1010 Semester 1 AY18/19   * Assignment 1: Taxi   *   * Read in four positive integer corresponding to the day of the week,   * the hour and minute of boarding, and the distance traveled.  Print   * to the standard output, the fare of the taxi.   * height, and length of a box from the standard input, and   * print the total surface area and the length of the diagonal   * to the standard output.   *   * @file: taxi.c   * @author: XXX (Group YYY)   */  #include   \"cs1010.h\"  #include   <stdbool.h>  /**   * Check if a given day is a weekday.   *   * @param[in] day The day of the week (1 for Monday, 7 for Sunday).   * @return true if the day is a weekday, false otherwise.   */  bool   is_weekday ( long   day )  { \n   return   ( day   >=   1   &&   day   <=   5 );  }  /**   * Check if a given time falls under morning peak hour (6am to 9:29am)   *   * @param[in] hour The given hour.   * @param[in] minute The given minute.   * @return true if the given time falls under morning peak hour.     *         false otherwise.   */  bool   is_morning_peak ( long   hour ,   long   minute )  { \n   return   ( hour   >=   6   &&   hour   <   9 )   ||   ( hour   ==   9   &&   minute   <=   29 );  }  /**   * Check if a given time falls under evening peak hour (6pm to 11:59pm).   *   * @param[in] hour The given hour.   * @return true if the given time falls under morning peak hour.     *         false otherwise.   */  bool   is_evening_peak ( long   hour )  { \n   return   ( hour   >=   18   &&   hour   <=   23 );  }  /**   * Check if a given time falls under midnight peak hour (0:00 to 5:59am).   *   * @param[in] hour The given hour.   * @return true if the given time falls under midnight peak hour.     *         false otherwise.   */  bool   is_midnight_peak ( long   hour )  { \n   return   ( hour   >=   0   &&   hour   <   6 );  }  /**   * Check if surchange should be applied given day and time.   *   * @param[in] day Day of the taxi trip   * @param[in] hour Hour of boarding time.   * @param[in] minute Minute of boarding time   * @return The surchage applied (1.0 if no surcharge)).   */  double   surcharge ( long   day ,   long   hour ,   long   minute )  { \n   if   ( is_weekday ( day )   &&   is_morning_peak ( hour ,   minute ))   { \n     return   1.25 ; \n   } \n   if   ( is_evening_peak ( hour ))   { \n     return   1.25 ; \n   } \n   if   ( is_midnight_peak ( hour ))   { \n     return   1.5 ; \n   } \n   return   1.0 ;  }  /**   * Calculate the metered fare for a taxi trip (before surcharge).   *   * @param[in] distance The distance travelled.   */  double   metered_fare ( long   distance )  { \n   double   fare   =   3.40 ; \n\n   distance   -=   1000 ; \n   if   ( distance   <=   0 )   { \n     return   fare ; \n   } \n\n   if   ( distance   <=   9200 )   { \n     fare   +=   0.22   *   ( distance   /   400 ); \n     if   ( distance   %   400   >   0 )   { \n       fare   +=   0.22 ; \n     } \n   }   else   { \n     fare   +=   0.22   *   ( 9200   /   400 ); \n   } \n\n   distance   -=   9200 ; \n   if   ( distance   <=   0 )   { \n     return   fare ; \n   } \n\n   fare   +=   0.22   *   ( distance   /   350 ); \n   if   ( distance   %   350   >   0 )   { \n     fare   +=   0.22 ; \n   } \n\n   return   fare ;  }  /**   * Calculate the fare for a taxi trip (including surcharge).   *   * @param[in] day Day of the taxi trip   * @param[in] hour Hour of boarding time   * @param[in] minute Minute of boarding time   * @param[in] distance The distance travelled   */  double   fare ( long   day ,   long   hour ,   long   minute ,   long   distance )  { \n   return   metered_fare ( distance )   *   surcharge ( day ,   hour ,   minute );  }  int   main ()  { \n   long   day   =   cs1010_read_long (); \n   long   start_hour   =   cs1010_read_long (); \n   long   start_minute   =   cs1010_read_long (); \n   long   distance   =   cs1010_read_long (); \n\n   cs1010_println_double ( fare ( day ,   start_hour ,   start_minute ,   distance ));  }",
            "title": "Taxi"
        },
        {
            "location": "/as02/index.html",
            "text": "Assignment 2: Collatz, Weekday, Circle, Pattern\n\n\nDeadline\n\n\n21 September, 2018 (Friday), 6:00pm.\n\n\nPrerequisite\n\n\n\n\nYou are able to access the \nCS1010 programming environment\n.\n\n\nYou are familiar with \nbasic UNIX CLI\n and using terminal-based editor \nvim\n.\n\n\nYou have gone through Exercise 1 and have already set up your \n.gitconfig\n.\n\n\nYou are familiar with the steps of accepting, downloading, and submitting your exercise and assignment.\n\n\nYou are familiar with the directory structure and the common files included in your assignment skeleton.\n\n\n\n\nLearning Outcomes\n\n\n\n\nBe comfortable writing simple C programs that involve arithmetic operations, \nlong\n, \ndouble\n, and \nbool\n types, conditional \nif\n/\nelse\n statements, and loops with \nwhile\n/\nfor\n/\ndo-while\n statements.\n\n\nBe comfortable breaking down a problem into smaller subproblems which can be resolved using functions, including reusing existing functions written for other programs (with a tweak), writing a function that calls itself, designing what should the inputs and return values/types of a function be.\n\n\n\n\nSetup\n\n\n\n\nClick on this link\n to accept the assignment.\n\n\nLogin to one of the hosts of \nCS1010 programming environment\n\n\nRun:\n\n\n\n\n1\n~cs1010/get-as02\n\n\n\n\n\n\n\n\nYou should see the folder \nas02-<github id>\n in your home directory with the assignment skeleton inside.\n\n\n\n\nSolving The Assignments\n\n\n\n\nEdit the files \ncollatz.c\n, \nweekday.c\n, \ncircle.c\n, and \npattern.c\n to solve the corresponding question as described below.\n\n\nYou should break down the problem into smaller subproblems, and write one function for each of the subproblem to solve the problem.  \n\n\nTo compile and run tests with the sample inputs and outputs:\n\n\n\n\n1\nmake\n\n\n\n\n\n\n\n\nThe test cases are given in the \ninputs\n and \noutputs\n subdirectory.  You can use \ncat\n or \nless\n to look at the content of these test cases.  You can add more test cases or edit the given ones if needed.\n\n\n\n\nSubmission\n\n\nWhen you are ready, run the following command to submit:\n\n\n1\n~cs1010/submit-as02\n\n\n\n\n\n\nThe four files \ncollatz.c\n, \nweekday.c\n, \ncircle.c\n, and \npattern.c\n will be uploaded to GitHub.  You can submit multiple times, but only the last submission will be graded.\n\n\n\n\nEditing Your Files in Multiple Locations\n\n\nYou should edit your code only on the CS1010 PE hosts.  If you choose to edit your code in other places, such as directly on Github or in a second location (such as your own laptop), you need to be comfortable with various \ngit\n command to synchronize your code across the different locations, possibly needing to resolve synchronization conflicts.  \n\n\n\n\nOnly the four C files listed above will be submitted.  You can create additional C files for testing different solutions, but eventually, you must put your solution into the corresponding C file provided as the skeleton.\n\n\nIdentifying Yourself\n\n\nIn every C file that you submit to CS1010, you need to identify yourself by writing your name and tutorial group. Marks will be deducted if you fail to do so. You need to edit the line:\n\n\n1\n@author XXXX (Group YYYY)\n\n\n\n\n\n\nand change it to something like:\n\n\n1\n@author Elsa of Arendelle (Group 9)\n\n\n\n\n\n\nGrading\n\n\nThis assignment contributes towards 3% of your final grade.  The total mark for this assignment is 30 marks.  There are two marking criteria: correctness and style.  \n\n\nFor each question, 2 marks are allocated for coding style.  Please refer to the \nCS1010 C Style Guide\n and follow the recommended guideline.\n\n\nThe rest of the marks are allocated to correctness.  Note that passing the tests does not guarantee that your code is correct.  Even if your code produces the correct output all the time, you may still lose marks if you do not write your code properly (e.g., using the most appropriate type, violating the constraints set by the question).\n\n\nQuestion 1: Collatz (6 marks)\n\n\nThe \nCollatz Conjecture\n was introduced by the mathematician Lothar Collatz in 1937.   Also known as the \n3n+1\n3n+1\n conjecture, the problem can be stated very simply but yet no one is able to prove that it is true or false.  The conjecture states the following:\n\n\nConsider the following operation on a positive integer \nn\nn\n: if \nn\nn\n is even, divide it by two; otherwise, triple it and add one.  Suppose we form a sequence of numbers by performing this operation repeatedly, beginning with any positive integer, then this process will eventually reach the number 1, for any initial positive integer \nn\nn\n.\n\n\nFor instance, if \nn = 10\nn = 10\n, then we have the sequence \n10 \\rightarrow 5 \\rightarrow 16 \\rightarrow 8 \\rightarrow 4 \\rightarrow 2 \\rightarrow 1\n10 \\rightarrow 5 \\rightarrow 16 \\rightarrow 8 \\rightarrow 4 \\rightarrow 2 \\rightarrow 1\n.\n\n\nThe smallest number of steps taken by this process for \nn\nn\n to reach 1 is called the \ntotal stopping time\n.  In the example above, the total stopping time for 10 is 6.\n\n\nWrite a program \ncollatz.c\n that reads in a positive integer \nN\nN\n from the standard input and finds out, among the numbers between 1 to \nN\nN\n, inclusive, which one has the largest total stopping time.  If two numbers have the same total stopping time, we break ties by choosing the larger number as the answer.  Your program should print to the standard output, the number with the largest total stopping time and its corresponding total stopping time.\n\n\nSample Run\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\nooiwt@pe114:~/as02-skeleton$ ./collatz\n1\n1\n0\nooiwt@pe114:~/as02-skeleton$ ./collatz\n10\n9\n19\nooiwt@pe114:~/as02-skeleton$ ./collatz\n1000\n871\n178\n\n\n\n\n\n\nQuestion 2: Weekday (6 marks)\n\n\nWrite a program \nweekday.c\n that reads three positive integers representing the year, month, and day of a date respectively, and prints out which day of the week this date is to the standard output.  Possible outputs are \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", and \"Sunday\". The earliest date that can be given as input is January 1, 1900 (which is a Monday).\n\n\nYou may find reusing functions you have written in \nExercise 2\n useful.\n\n\nSample Run\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nooiwt@pe114:~/as02-skeleton$ ./weekday\n1900 1 1\nMonday\nooiwt@pe114:~/as02-skeleton$ ./weekday\n1904 2 29\nMonday\nooiwt@pe114:~/as02-skeleton$ ./weekday\n2018 9 14\nFriday\n\n\n\n\n\n\nQuestion 3: Circle (6 marks)\n\n\nWrite a program \ncircle.c\n that reads in a positive integer \nr\nr\n from the standard input, and prints a circle of radius \nr\nr\n to the standard output.\n\n\nWe can consider this circle as being printed on a canvas of size \n(2r+1) \\times (2r+1)\n(2r+1) \\times (2r+1)\n, with the top left corner being \n(0, 0)\n(0, 0)\n and the center of the circle at the position \n(r, r)\n(r, r)\n.  The figure below shows an example with \nr = 2\nr = 2\n.\n\n\n\n\nFor each location \n(x, y)\n(x, y)\n, let the distance of \n(x, y)\n(x, y)\n to the center be \nd_{x,y}\nd_{x,y}\n.  To print the circle, we print the following for each location \n(x,y)\n(x,y)\n:\n\n\n\n\nif \n|d_{x,y} - r| < 0.1\n|d_{x,y} - r| < 0.1\n, print \n@\n\n\notherwise, if \n|d_{x,y} - r| < 0.3\n|d_{x,y} - r| < 0.3\n, print \nO\n (that's uppercase o, not zero)\n\n\notherwise, if \n|d_{x,y} - r| < 0.5\n|d_{x,y} - r| < 0.5\n, print \n*\n\n\notherwise, if \n|d_{x,y} - r| < 0.7\n|d_{x,y} - r| < 0.7\n, print \n+\n\n\notherwise, print \n (white space)\n\n\n\n\nYour output must contain exactly \n2r+1\n2r+1\n rows, each row exactly \n2r+1\n2r+1\n characters (including the white spaces but excluding the newline).  Note that in the sample runs below, the white spaces are not visible.\n\n\nSample Run\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\nooiwt@pe114:~/as02-skeleton$ ./circle\n1\n*@*\n@ @\n*@*\nooiwt@pe114:~/as02-skeleton$ ./circle\n5\n   *@@@*   \n +@+   +@+\n @       @\n*+       +*\n@         @\n@         @\n@         @\n*+       +*\n @        @\n +@+   +@+\n   *@@@*   \nooiwt@pe114:~/as02-skeleton$ ./circle\n10\n       *O@@@O*       \n     OO+     +OO     \n   +@+         +@+   \n  +O             O+  \n  @               @  \n O+               +O\n O                 O\n*+                 +*\nO                   O\n@                   @\n@                   @\n@                   @\nO                   O\n*+                 +*\n O                 O\n O+               +O\n  @               @  \n  +O             O+  \n   +@+         +@+   \n     OO+     +OO     \n       *O@@@O*       \n\n\n\n\n\n\nQuestion 4: Pattern (12 marks)\n\n\nEven though the sequence of prime numbers appears to be random, mathematicians have found some intriguing patterns related to prime numbers.  In this question, you are asked to write a program to draw a variation of the \n\"Parallax Compression\" pattern discovered by a software engineer, Shaun Gilchrist\n.\n\n\nThe pattern visualizes the distribution of prime number in a triangle, in the following way.  The inputs given are an \ninterval\n \nn\nn\n (\nn \\ge 1\nn \\ge 1\n) and the height of the triangle \nh\nh\n.\n\n\nThe triangle has \nh\nh\n rows.  The first row of the triangle has one cell, the second row has three cells, the third row has five, etc.  The cells are centrally aligned so that visually they form an equilateral triangle.  We call the left-most cell of each row the \nleading cell\n.\n\n\nEach cell in the triangle contains \nn\nn\n integers.  The first cell in the first row contains the numbers 1, 2, ..., \nn\nn\n.  The leading cell of the next row, row 2, contains \nn\nn\n numbers between \nn+1\nn+1\n and \n3n\n3n\n, with increment of 2: i.e., \nn+1, n+3, n+5, .. n+(2n-1)\nn+1, n+3, n+5, .. n+(2n-1)\n.  The leading cell of the next row, row 3, contains the numbers \n3n + 1\n3n + 1\n and \n6n\n6n\n, with increment of 3: i.e., \n3n+1, 3n+4, 3n+7, .. 3n+(3n-2)\n3n+1, 3n+4, 3n+7, .. 3n+(3n-2)\n, etc.  For instance, if \nn\nn\n is 5, the leading cells of the first three rows contain the numbers [1, 2, 3, 4, 5], [6, 8, 10, 12, 14], [16, 19, 22, 25, 28], respectively.\n\n\nThe rest of the cells in each row contains \nn\nn\n numbers where each is one more than a number contained in the cell on its left.  So, in row 2, the numbers in the three cells are [6, 8, 10, 12, 14], [7, 9, 11, 13, 15] and [8, 10, 12, 14, 16].  In row 3, the cells contain [16, 19, 22, 25, 28], [17, 20, 23, 26, 29], [18, 21, 24, 27, 30], [19, 22, 25, 28, 31], and [20, 23, 26, 29, 32].\n\n\nNow, to visualize the distribution of primes, we do the following, for each cell of the triangle that contains \neither 1 or\n at least one prime, we print \n#\n to the standard output at the corresponding position.  Otherwise, we print \n (a white space).\n\n\nYour output must contain exactly \n2r+1\n \nh\nh\n rows, each row exactly \n2r+1\n \n2h-1\n2h-1\n characters (including the white spaces but excluding the newline).  Note that in the sample runs below, the white spaces are not visible.\n\n\nExample 1\n\n\n1\n2\n3\n4\n5\n6\nooiwt@pe114:~/as02-skeleton$ ./pattern\n2 4\n   #   \n  # #  \n ## ##\n# # # #\n\n\n\n\n\n\nSee the figures below:\n\n\n\n\nThe figure above shows the shape of the triangle with height 4.  The shaded locations belong to the triangle.  Each square represents a cell.\n\n\n\n\nThe figure above shows the integers contained in each of the triangle cells with an interval of 2.\n\n\n\n\nThe figure above shows the pattern that emerges if we color each cell that contains at least one prime a darker shade.  In our program, we use \n#\n to represent such a cell.\n\n\nMore Examples\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\nooiwt@pe114:~/as02-skeleton$ ./pattern\n11 11\n          #\n          #\n        ## ##\n       # # # #\n      #### ####\n      # #   # #\n    ###### # ####\n   # # # # # # # #\n  ## ## ## ## ## ##\n  # # # #   # # # #\n###### ### ##########\nooiwt@pe114:~/as02-skeleton$ ./pattern\n100 29\n                            #\n                           # #\n                          ## ##\n                         # # # #\n                        #### ####\n                       #   # #   #\n                      ###### ######\n                     # # # # # # # #\n                    ## ## ## ## ## ##\n                   # #   # # # #   # #\n                  ########## ##########\n                 #   # #   # #   # #   #\n                ############ ############\n               # # #   # # # # # #   # # #\n              ## #  ##  # ## ## #  ##  # ##\n             # # # # # # # # # # # # # # # #\n            ################ ################\n           #   # #   # #   # #   # #   # #   #\n          ################## ##################\n         # #   # # # #   # # # #   # # # #   # #\n        ## ##  # ## #  ## ## ## ##  # ## #  ## ##\n       # # # # #   # # # # # # # # # #   # # # # #\n      ###################### ######################\n     #   # #   # #   # #   # #   # #   # #   # #   #\n    #### #### #### #### #### #### #### #### #### ####\n   # # # # # #   # # # # # # # # # # # #   # # # # # #\n  ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ##\n # # #   # # # # # #   # # # # # #   # # # # # #   # # #\n############################ ############################",
            "title": "2. Collatz, Weekday, Circle, Pattern"
        },
        {
            "location": "/as02/index.html#assignment-2-collatz-weekday-circle-pattern",
            "text": "",
            "title": "Assignment 2: Collatz, Weekday, Circle, Pattern"
        },
        {
            "location": "/as02/index.html#deadline",
            "text": "21 September, 2018 (Friday), 6:00pm.",
            "title": "Deadline"
        },
        {
            "location": "/as02/index.html#prerequisite",
            "text": "You are able to access the  CS1010 programming environment .  You are familiar with  basic UNIX CLI  and using terminal-based editor  vim .  You have gone through Exercise 1 and have already set up your  .gitconfig .  You are familiar with the steps of accepting, downloading, and submitting your exercise and assignment.  You are familiar with the directory structure and the common files included in your assignment skeleton.",
            "title": "Prerequisite"
        },
        {
            "location": "/as02/index.html#learning-outcomes",
            "text": "Be comfortable writing simple C programs that involve arithmetic operations,  long ,  double , and  bool  types, conditional  if / else  statements, and loops with  while / for / do-while  statements.  Be comfortable breaking down a problem into smaller subproblems which can be resolved using functions, including reusing existing functions written for other programs (with a tweak), writing a function that calls itself, designing what should the inputs and return values/types of a function be.",
            "title": "Learning Outcomes"
        },
        {
            "location": "/as02/index.html#setup",
            "text": "Click on this link  to accept the assignment.  Login to one of the hosts of  CS1010 programming environment  Run:   1 ~cs1010/get-as02    You should see the folder  as02-<github id>  in your home directory with the assignment skeleton inside.",
            "title": "Setup"
        },
        {
            "location": "/as02/index.html#solving-the-assignments",
            "text": "Edit the files  collatz.c ,  weekday.c ,  circle.c , and  pattern.c  to solve the corresponding question as described below.  You should break down the problem into smaller subproblems, and write one function for each of the subproblem to solve the problem.    To compile and run tests with the sample inputs and outputs:   1 make    The test cases are given in the  inputs  and  outputs  subdirectory.  You can use  cat  or  less  to look at the content of these test cases.  You can add more test cases or edit the given ones if needed.",
            "title": "Solving The Assignments"
        },
        {
            "location": "/as02/index.html#submission",
            "text": "When you are ready, run the following command to submit:  1 ~cs1010/submit-as02   The four files  collatz.c ,  weekday.c ,  circle.c , and  pattern.c  will be uploaded to GitHub.  You can submit multiple times, but only the last submission will be graded.   Editing Your Files in Multiple Locations  You should edit your code only on the CS1010 PE hosts.  If you choose to edit your code in other places, such as directly on Github or in a second location (such as your own laptop), you need to be comfortable with various  git  command to synchronize your code across the different locations, possibly needing to resolve synchronization conflicts.     Only the four C files listed above will be submitted.  You can create additional C files for testing different solutions, but eventually, you must put your solution into the corresponding C file provided as the skeleton.",
            "title": "Submission"
        },
        {
            "location": "/as02/index.html#identifying-yourself",
            "text": "In every C file that you submit to CS1010, you need to identify yourself by writing your name and tutorial group. Marks will be deducted if you fail to do so. You need to edit the line:  1 @author XXXX (Group YYYY)   and change it to something like:  1 @author Elsa of Arendelle (Group 9)",
            "title": "Identifying Yourself"
        },
        {
            "location": "/as02/index.html#grading",
            "text": "This assignment contributes towards 3% of your final grade.  The total mark for this assignment is 30 marks.  There are two marking criteria: correctness and style.    For each question, 2 marks are allocated for coding style.  Please refer to the  CS1010 C Style Guide  and follow the recommended guideline.  The rest of the marks are allocated to correctness.  Note that passing the tests does not guarantee that your code is correct.  Even if your code produces the correct output all the time, you may still lose marks if you do not write your code properly (e.g., using the most appropriate type, violating the constraints set by the question).",
            "title": "Grading"
        },
        {
            "location": "/as02/index.html#question-1-collatz-6-marks",
            "text": "The  Collatz Conjecture  was introduced by the mathematician Lothar Collatz in 1937.   Also known as the  3n+1 3n+1  conjecture, the problem can be stated very simply but yet no one is able to prove that it is true or false.  The conjecture states the following:  Consider the following operation on a positive integer  n n : if  n n  is even, divide it by two; otherwise, triple it and add one.  Suppose we form a sequence of numbers by performing this operation repeatedly, beginning with any positive integer, then this process will eventually reach the number 1, for any initial positive integer  n n .  For instance, if  n = 10 n = 10 , then we have the sequence  10 \\rightarrow 5 \\rightarrow 16 \\rightarrow 8 \\rightarrow 4 \\rightarrow 2 \\rightarrow 1 10 \\rightarrow 5 \\rightarrow 16 \\rightarrow 8 \\rightarrow 4 \\rightarrow 2 \\rightarrow 1 .  The smallest number of steps taken by this process for  n n  to reach 1 is called the  total stopping time .  In the example above, the total stopping time for 10 is 6.  Write a program  collatz.c  that reads in a positive integer  N N  from the standard input and finds out, among the numbers between 1 to  N N , inclusive, which one has the largest total stopping time.  If two numbers have the same total stopping time, we break ties by choosing the larger number as the answer.  Your program should print to the standard output, the number with the largest total stopping time and its corresponding total stopping time.",
            "title": "Question 1: Collatz (6 marks)"
        },
        {
            "location": "/as02/index.html#sample-run",
            "text": "1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12 ooiwt@pe114:~/as02-skeleton$ ./collatz\n1\n1\n0\nooiwt@pe114:~/as02-skeleton$ ./collatz\n10\n9\n19\nooiwt@pe114:~/as02-skeleton$ ./collatz\n1000\n871\n178",
            "title": "Sample Run"
        },
        {
            "location": "/as02/index.html#question-2-weekday-6-marks",
            "text": "Write a program  weekday.c  that reads three positive integers representing the year, month, and day of a date respectively, and prints out which day of the week this date is to the standard output.  Possible outputs are \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", and \"Sunday\". The earliest date that can be given as input is January 1, 1900 (which is a Monday).  You may find reusing functions you have written in  Exercise 2  useful.",
            "title": "Question 2: Weekday (6 marks)"
        },
        {
            "location": "/as02/index.html#sample-run_1",
            "text": "1\n2\n3\n4\n5\n6\n7\n8\n9 ooiwt@pe114:~/as02-skeleton$ ./weekday\n1900 1 1\nMonday\nooiwt@pe114:~/as02-skeleton$ ./weekday\n1904 2 29\nMonday\nooiwt@pe114:~/as02-skeleton$ ./weekday\n2018 9 14\nFriday",
            "title": "Sample Run"
        },
        {
            "location": "/as02/index.html#question-3-circle-6-marks",
            "text": "Write a program  circle.c  that reads in a positive integer  r r  from the standard input, and prints a circle of radius  r r  to the standard output.  We can consider this circle as being printed on a canvas of size  (2r+1) \\times (2r+1) (2r+1) \\times (2r+1) , with the top left corner being  (0, 0) (0, 0)  and the center of the circle at the position  (r, r) (r, r) .  The figure below shows an example with  r = 2 r = 2 .   For each location  (x, y) (x, y) , let the distance of  (x, y) (x, y)  to the center be  d_{x,y} d_{x,y} .  To print the circle, we print the following for each location  (x,y) (x,y) :   if  |d_{x,y} - r| < 0.1 |d_{x,y} - r| < 0.1 , print  @  otherwise, if  |d_{x,y} - r| < 0.3 |d_{x,y} - r| < 0.3 , print  O  (that's uppercase o, not zero)  otherwise, if  |d_{x,y} - r| < 0.5 |d_{x,y} - r| < 0.5 , print  *  otherwise, if  |d_{x,y} - r| < 0.7 |d_{x,y} - r| < 0.7 , print  +  otherwise, print   (white space)   Your output must contain exactly  2r+1 2r+1  rows, each row exactly  2r+1 2r+1  characters (including the white spaces but excluding the newline).  Note that in the sample runs below, the white spaces are not visible.",
            "title": "Question 3: Circle (6 marks)"
        },
        {
            "location": "/as02/index.html#sample-run_2",
            "text": "1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41 ooiwt@pe114:~/as02-skeleton$ ./circle\n1\n*@*\n@ @\n*@*\nooiwt@pe114:~/as02-skeleton$ ./circle\n5\n   *@@@*   \n +@+   +@+\n @       @\n*+       +*\n@         @\n@         @\n@         @\n*+       +*\n @        @\n +@+   +@+\n   *@@@*   \nooiwt@pe114:~/as02-skeleton$ ./circle\n10\n       *O@@@O*       \n     OO+     +OO     \n   +@+         +@+   \n  +O             O+  \n  @               @  \n O+               +O\n O                 O\n*+                 +*\nO                   O\n@                   @\n@                   @\n@                   @\nO                   O\n*+                 +*\n O                 O\n O+               +O\n  @               @  \n  +O             O+  \n   +@+         +@+   \n     OO+     +OO     \n       *O@@@O*",
            "title": "Sample Run"
        },
        {
            "location": "/as02/index.html#question-4-pattern-12-marks",
            "text": "Even though the sequence of prime numbers appears to be random, mathematicians have found some intriguing patterns related to prime numbers.  In this question, you are asked to write a program to draw a variation of the  \"Parallax Compression\" pattern discovered by a software engineer, Shaun Gilchrist .  The pattern visualizes the distribution of prime number in a triangle, in the following way.  The inputs given are an  interval   n n  ( n \\ge 1 n \\ge 1 ) and the height of the triangle  h h .  The triangle has  h h  rows.  The first row of the triangle has one cell, the second row has three cells, the third row has five, etc.  The cells are centrally aligned so that visually they form an equilateral triangle.  We call the left-most cell of each row the  leading cell .  Each cell in the triangle contains  n n  integers.  The first cell in the first row contains the numbers 1, 2, ...,  n n .  The leading cell of the next row, row 2, contains  n n  numbers between  n+1 n+1  and  3n 3n , with increment of 2: i.e.,  n+1, n+3, n+5, .. n+(2n-1) n+1, n+3, n+5, .. n+(2n-1) .  The leading cell of the next row, row 3, contains the numbers  3n + 1 3n + 1  and  6n 6n , with increment of 3: i.e.,  3n+1, 3n+4, 3n+7, .. 3n+(3n-2) 3n+1, 3n+4, 3n+7, .. 3n+(3n-2) , etc.  For instance, if  n n  is 5, the leading cells of the first three rows contain the numbers [1, 2, 3, 4, 5], [6, 8, 10, 12, 14], [16, 19, 22, 25, 28], respectively.  The rest of the cells in each row contains  n n  numbers where each is one more than a number contained in the cell on its left.  So, in row 2, the numbers in the three cells are [6, 8, 10, 12, 14], [7, 9, 11, 13, 15] and [8, 10, 12, 14, 16].  In row 3, the cells contain [16, 19, 22, 25, 28], [17, 20, 23, 26, 29], [18, 21, 24, 27, 30], [19, 22, 25, 28, 31], and [20, 23, 26, 29, 32].  Now, to visualize the distribution of primes, we do the following, for each cell of the triangle that contains  either 1 or  at least one prime, we print  #  to the standard output at the corresponding position.  Otherwise, we print   (a white space).  Your output must contain exactly  2r+1   h h  rows, each row exactly  2r+1   2h-1 2h-1  characters (including the white spaces but excluding the newline).  Note that in the sample runs below, the white spaces are not visible.",
            "title": "Question 4: Pattern (12 marks)"
        },
        {
            "location": "/as02/index.html#example-1",
            "text": "1\n2\n3\n4\n5\n6 ooiwt@pe114:~/as02-skeleton$ ./pattern\n2 4\n   #   \n  # #  \n ## ##\n# # # #   See the figures below:   The figure above shows the shape of the triangle with height 4.  The shaded locations belong to the triangle.  Each square represents a cell.   The figure above shows the integers contained in each of the triangle cells with an interval of 2.   The figure above shows the pattern that emerges if we color each cell that contains at least one prime a darker shade.  In our program, we use  #  to represent such a cell.",
            "title": "Example 1"
        },
        {
            "location": "/as02/index.html#more-examples",
            "text": "1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44 ooiwt@pe114:~/as02-skeleton$ ./pattern\n11 11\n          #\n          #\n        ## ##\n       # # # #\n      #### ####\n      # #   # #\n    ###### # ####\n   # # # # # # # #\n  ## ## ## ## ## ##\n  # # # #   # # # #\n###### ### ##########\nooiwt@pe114:~/as02-skeleton$ ./pattern\n100 29\n                            #\n                           # #\n                          ## ##\n                         # # # #\n                        #### ####\n                       #   # #   #\n                      ###### ######\n                     # # # # # # # #\n                    ## ## ## ## ## ##\n                   # #   # # # #   # #\n                  ########## ##########\n                 #   # #   # #   # #   #\n                ############ ############\n               # # #   # # # # # #   # # #\n              ## #  ##  # ## ## #  ##  # ##\n             # # # # # # # # # # # # # # # #\n            ################ ################\n           #   # #   # #   # #   # #   # #   #\n          ################## ##################\n         # #   # # # #   # # # #   # # # #   # #\n        ## ##  # ## #  ## ## ## ##  # ## #  ## ##\n       # # # # #   # # # # # # # # # #   # # # # #\n      ###################### ######################\n     #   # #   # #   # #   # #   # #   # #   # #   #\n    #### #### #### #### #### #### #### #### #### ####\n   # # # # # #   # # # # # # # # # # # #   # # # # # #\n  ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ##\n # # #   # # # # # #   # # # # # #   # # # # # #   # # #\n############################ ############################",
            "title": "More Examples"
        },
        {
            "location": "/as03/index.html",
            "text": "Assignment 3: Kendall, Histogram, CountingSort\n\n\nDeadline\n\n\n5 October, 2018 (Friday), 6:00pm.\n\n\nPrerequisite\n\n\n\n\nYou are able to access the \nCS1010 programming environment\n.\n\n\nYou are familiar with \nbasic UNIX CLI\n and using terminal-based editor \nvim\n.\n\n\nYou have gone through Exercise 1 and have already set up your \n.gitconfig\n.\n\n\nYou are familiar with the steps of accepting, downloading, and submitting your exercise and assignment.\n\n\nYou are familiar with the directory structure and the common files included in your assignment skeleton.\n\n\n\n\nLearning Outcomes\n\n\n\n\nBe comfortable writing C programs that involve arithmetic operations, \nlong\n, \ndouble\n, \nbool\n, and \nchar\n types, conditional \nif\n/\nelse\n statements, loops with \nwhile\n/\nfor\n/\ndo-while\n statements, and arrays.\n\n\nBe comfortable breaking down a problem into smaller subproblems which can be resolved using functions, including reusing existing functions written for other programs (with a tweak), writing a function that calls itself, designing what should the inputs and return values/types of a function be.\n\n\n\n\nSetup\n\n\n\n\nClick on this link\n to accept the assignment.\n\n\nLogin to one of the hosts of \nCS1010 programming environment\n\n\nRun:\n\n\n\n\n1\n~cs1010/get-as03\n\n\n\n\n\n\n\n\nYou should see the folder \nas03-<github id>\n in your home directory with the assignment skeleton inside.\n\n\n\n\nSolving The Assignments\n\n\n\n\nEdit the files \nkandall.c\n, \nhistogram.c\n, \ncountingsort.c\n, and \nmastermind.c\n to solve the corresponding question as described below.\n\n\nYou should break down the problem into smaller subproblems, and write one function for each of the subproblem to solve the problem.  \n\n\nTo compile and run tests with the sample inputs and outputs:\n\n\n\n\n1\nmake\n\n\n\n\n\n\n\n\nThe test cases are given in the \ninputs\n and \noutputs\n subdirectory.  You can use \ncat\n or \nless\n to look at the content of these test cases.  You can add more test cases or edit the given ones if needed.\n\n\n\n\nSubmission\n\n\nWhen you are ready, run the following command to submit:\n\n\n1\n~cs1010/submit-as03\n\n\n\n\n\n\nThe four files \nkendall.c\n, \nhistogram.c\n, \ncountingsort.c\n, and \nmastermind.c\n will be uploaded to GitHub.  You can submit multiple times, but only the last submission will be graded.\n\n\n\n\nEditing Your Files in Multiple Locations\n\n\nYou should edit your code only on the CS1010 PE hosts.  If you choose to edit your code in other places, such as directly on Github or in a second location (such as your own laptop), you need to be comfortable with various \ngit\n command to synchronize your code across the different locations, possibly needing to resolve synchronization conflicts.  \n\n\n\n\nOnly the four C files listed above will be submitted.  You can create additional C files for testing different solutions, but eventually, you must put your solution into the corresponding C file provided as the skeleton.\n\n\nIdentifying Yourself\n\n\nIn every C file that you submit to CS1010, you need to identify yourself by writing your name and tutorial group. Marks will be deducted if you fail to do so. You need to edit the line:\n\n\n1\n@author XXXX (Group YYYY)\n\n\n\n\n\n\nand change it to something like:\n\n\n1\n@author Peter Parker (Group 9)\n\n\n\n\n\n\nGrading\n\n\nThis assignment contributes towards 3% of your final grade.  The total mark for this assignment is 30 marks.  There are two marking criteria: correctness and style.  \n\n\nFor each question, 2 marks are allocated for coding style.  Please refer to the \nCS1010 C Style Guide\n and follow the recommended guideline.\n\n\nThe rest of the marks are allocated to correctness.  Note that passing the tests does not guarantee that your code is correct.  Even if your code produces the correct output all the time, you may still lose marks if you do not write your code properly (e.g., using the most appropriate type, violating the constraints set by the question).\n\n\nWe reserve the right to penalize students for using banned C syntax in the assignments.  In addition, each grader at his or her own discretion can penalze students for repeating mistakes / bad practices from the student's past assignments (even if it was just a warning with no marks deducted in the earlier assignments).\n\n\nQuestion 1: Kendall (10 marks)\n\n\nSuppose that we are given a set of items and we ask two different parties to rank the items according to some order.  We may get two different order of the items.  How do we measure how similar (or dissimilar) the two rankings are?\n\n\nFor example, consider a search engine that returns a list of web pages ranked by their relevance to the search query.  A user may not always agree with the ranking of the search engine and may judge the relevance of the search result differently, i.e., the user may have his or her own ranking.  This measurement of similarity between the ranking by the search engine and the ranking by the user gives us a metric on how good the search engine result is.  The more similar it is to the ranking of the user, the better the search engine is in ranking in the search results.\n\n\nOne way to measure the similarity of two rankings is the \nKendall tau distance\n.  You will write a program \nkendall\n that calculates the \nnormalized\n Kendall tau distance for this question.\n\n\nWe will represent a ranking by the order of the items.  The first item is ranked 1, second is ranked 2, and so on.  To simplify the problem, we take one of the ranking that we want to calculate the Kendall tau distance on, and label the items sequentially, as the sequence 1, 2, 3, 4, 5, ...\nn\nn\n, where \nn\nn\n is the number of items.  We call this the \nbase\n ranking.  The other ranking will then be a permutation of the numbers 1 to \nn\nn\n.\n\n\nFor example, suppost we have three items A, B, C. the first ranking ranks the items as B, C, A.  The second ranking ranks the items C, A, B.  After relabelling the first ranking as 1, 2, 3, the second ranking becomes 2, 3, 1.\n\n\nThe Kendall tau distance counts the number of pairs of items in one ranking that are ranked in different order in the other ranking.  In the example above, we have three possible pairs:\n\n\n\n\n\n\n\n\nPair\n\n\nRanking 1\n\n\nRanking 2\n\n\n\n\n\n\n\n\n\n\nA-B\n\n\nB then A\n\n\nA then B\n\n\n\n\n\n\nA-C\n\n\nC then A\n\n\nC then A\n\n\n\n\n\n\nB-C\n\n\nB then C\n\n\nC then B\n\n\n\n\n\n\n\n\nOut of the three pairs, the pair A-B and B-C are ordered differently in the two rankings, so that Kendall tau distance is 2.\n\n\nThe normalized Kendall tau distance is the ratio of the number of pairs ranked in different order to all possible number of pairs.\n\n\nIn the example above, the \nnormalized\n Kendall distance is \u2154 = 0.6666.\n\n\nYour program should read the following from the standard input:\n\n\n\n\nThe first positive integer, \nn\nn\n, is the number of items (\nn > 1\nn > 1\n).\n\n\nThe next \nn\nn\n numbers is a permutation of integers between 1 to \nn\nn\n. This corresponds to the ranking of the items from 1 to \nn\nn\n.  \n\n\n\n\nYour program should print the normalized Kendall tau distance between the ranking read above and the base ranking (1, 2, 3, .. \nn\nn\n) to the standard output.\n\n\nSample Run\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\nooiwt@pe118:~/as03-skeleton$ ./kendall\n3\n2 3 1\n0.6666\nooiwt@pe118:~/as03-skeleton$ ./kendall\n10\n1 2 3 4 5 6 7 8 9 10\n0.0000\nooiwt@pe118:~/as03-skeleton$ ./kendall\n6\n6 5 4 3 2 1\n1.0000\n\n\n\n\n\n\nQuestion 2: Histogram (10 marks)\n\n\nIt is often useful to visualize the distribution of numerical data using a histogram.  In this question, you will write a program called \nhistogram\n that plots the histogram for real numbers ranged between 0 and 100 (inclusive). \n\n\nOur histogram will have 10 buckets, \nb_0, b_1, ... b_9\nb_0, b_1, ... b_9\n.  The bucket \nb_i\nb_i\n corresponds to the interval [\n10i, 10(i+1)\n10i, 10(i+1)\n) (includes \n10i\n10i\n, but excludes \n10(i+1)\n10(i+1)\n), \nexcept \nb_9\nb_9\n, which includes 100\n.  \n\n\nTo plot the histogram, we count how many percent of the data falls into each bucket.  Let the percentage of data that falls into bucket \nb_i\nb_i\n be \nk_i\nk_i\n%.  We set the length of each bar in histogram to be at most 10 characters, so we scale down \nk_i\nk_i\n by 10 to get the length \nl_i\nl_i\n.\n\n\nWe then draw on the screen using character \"\u2588\" and \"\u258c\", according to the following rules:\n\n\n\n\nIf \nl_i\nl_i\n is an integer, then we draw \"\u2588\" \nl_i\nl_i\n times.  \n\n\nOtherwise, if \nx < l_i \\le x + 0.5\nx < l_i \\le x + 0.5\n for some integer \nx\nx\n, then we draw \"\u2588\" \nx\nx\n times followed by a \"\u258c\".\n\n\nOtherwise, if \nx + 0.5 < l_i < x + 1\nx + 0.5 < l_i < x + 1\n for some integer \nx\nx\n, then we draw \"\u2588\" \nx+1\nx+1\n times.\n\n\n\n\nYour program should read the following from the standard input:\n\n\n\n\na positive integer \nn\nn\n, followed by\n\n\nn\nn\n real numbers, corresponding to data to plot the histogram with.\n\n\n\n\nYour program should print the axis and labels, as well as the bars for the histogram as shown in the same run.\nThe code to print both axis and labels are already given in the skeleton \nhistogram.c\n.  The string that corresponding to \"\u2588\" and \"\u258c\" are also given in the code, defined as \nBLOCK\n and \nHALF_BLOCK\n.\n\n\nSample Run\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\nooiwt@pe118:~/as03-skeleton$ ./histogram\n10\n25 35 35 45 45 45 45 55 55 65\n          \u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\n  0 - 10  \n 10 - 20  \n 20 - 30  \u2588\n 30 - 40  \u2588\u2588\n 40 - 50  \u2588\u2588\u2588\u2588\n 50 - 60  \u2588\u2588\n 60 - 70  \u2588\n 70 - 80  \n 80 - 90  \n 90 - 100 \nooiwt@pe118:~/as03-skeleton$ ./histogram\n1\n100\n          \u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\n  0 - 10\n 10 - 20\n 20 - 30\n 30 - 40\n 40 - 50\n 50 - 60\n 60 - 70\n 70 - 80\n 80 - 90\n 90 - 100 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\nooiwt@pe118:~/as03-skeleton$ ./histogram < inputs/histogram.5.in\n          \u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\n  0 - 10  \u258c\n 10 - 20  \u258c\n 20 - 30\n 30 - 40  \u258c\n 40 - 50\n 50 - 60  \u258c\n 60 - 70  \u2588\n 70 - 80  \u2588\u2588\n 80 - 90  \u2588\u2588\u2588\u2588\u2588\u258c\n 90 - 100 \u2588\u2588\n\n\n\n\n\n\nThe last histogram above plots the actual data from your Assignment 1 marks (scaled up 3x to have the range of 0 - 90).\n\n\nQuestion 3: CountingSort (10 marks)\n\n\nSorting is a fundamental computational problem: given a list of items, we want to rearrange the items in some order.\n\n\nIn this question, you will write you first sorting algorithm, called \ncounting sort\n.  This is an extremely fast algorithm for sorting positive integers if the range of the integers are limited.\n\n\nThe idea of counting sort is that, given the list of integers (each guranteed to be between 1 to \nk\nk\n) to sort, we count how many times 1 appear in the list, how many times 2 appears in the list, etc.  Finally, we print out each number between 1 to \nk\nk\n according to how many times they appear in the list, skipping those numbers who do not appear.\n\n\nFor instance, suppose we have 6 integers between 1 to 9: \n5 5 3 2 8 2\n.  We first count how many times each number appears.  Then we print the sorted list the following way: \n2\n appears twice, so we print \n\n1\n2\n2\n2\n\n\n\n\n\nThe number 3 appears once, we print\n\n1\n3\n\n\n\n\n\nThe number 5 appears twice, we print \n\n1\n2\n5\n5\n\n\n\n\n\nFinally 8 appears once, we print \n\n1\n8\n\n\n\n\n\nThe printed output is thus \n\n1\n2\n3\n4\n5\n6\n2\n2\n3\n5\n5\n8\n\n\n\n\n\nwhich is the numbers sorted in increasing order.  \n\n\nWrite a program \ncountingsort.c\n that reads the following in order from the standard input:\n\n\n\n\nn\nn\n the number of integers to sort\n\n\nk\nk\n the maximum value of the integers to sort\n\n\nThe next \nn\nn\n numbers are the integers to be sorted, each guaranteed to be between 1 and \nk\nk\n.\n\n\n\n\nSort the integers using the algorithms above and print them in increasing order to the standard output, one integer on each line.  Note that if you use any other algorithms to sort the numbers, you will be penalized heavily.\n\n\nInput Validation:\n For this question, you need to validate that the numbers are actually ranged between 1 and \nk\nk\n.  Any inputs that are not in this range must be omitted in the output.\n\n\nSample Run\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\nooiwt@pe118:~/as03-skeleton$ ./countingsort\n6 9 \n5 5 3 2 8 2\n2\n2\n3\n5\n5\n8\nooiwt@pe118:~/as03-skeleton$ ./countingsort\n3 1000 \n256 872 112\n112\n256\n872\nooiwt@pe118:~/as03-skeleton$ ./countingsort\n4 3\n3 2 -3 2\n2\n2\n3",
            "title": "3. Kendall, Histogram, CountingSort"
        },
        {
            "location": "/as03/index.html#assignment-3-kendall-histogram-countingsort",
            "text": "",
            "title": "Assignment 3: Kendall, Histogram, CountingSort"
        },
        {
            "location": "/as03/index.html#deadline",
            "text": "5 October, 2018 (Friday), 6:00pm.",
            "title": "Deadline"
        },
        {
            "location": "/as03/index.html#prerequisite",
            "text": "You are able to access the  CS1010 programming environment .  You are familiar with  basic UNIX CLI  and using terminal-based editor  vim .  You have gone through Exercise 1 and have already set up your  .gitconfig .  You are familiar with the steps of accepting, downloading, and submitting your exercise and assignment.  You are familiar with the directory structure and the common files included in your assignment skeleton.",
            "title": "Prerequisite"
        },
        {
            "location": "/as03/index.html#learning-outcomes",
            "text": "Be comfortable writing C programs that involve arithmetic operations,  long ,  double ,  bool , and  char  types, conditional  if / else  statements, loops with  while / for / do-while  statements, and arrays.  Be comfortable breaking down a problem into smaller subproblems which can be resolved using functions, including reusing existing functions written for other programs (with a tweak), writing a function that calls itself, designing what should the inputs and return values/types of a function be.",
            "title": "Learning Outcomes"
        },
        {
            "location": "/as03/index.html#setup",
            "text": "Click on this link  to accept the assignment.  Login to one of the hosts of  CS1010 programming environment  Run:   1 ~cs1010/get-as03    You should see the folder  as03-<github id>  in your home directory with the assignment skeleton inside.",
            "title": "Setup"
        },
        {
            "location": "/as03/index.html#solving-the-assignments",
            "text": "Edit the files  kandall.c ,  histogram.c ,  countingsort.c , and  mastermind.c  to solve the corresponding question as described below.  You should break down the problem into smaller subproblems, and write one function for each of the subproblem to solve the problem.    To compile and run tests with the sample inputs and outputs:   1 make    The test cases are given in the  inputs  and  outputs  subdirectory.  You can use  cat  or  less  to look at the content of these test cases.  You can add more test cases or edit the given ones if needed.",
            "title": "Solving The Assignments"
        },
        {
            "location": "/as03/index.html#submission",
            "text": "When you are ready, run the following command to submit:  1 ~cs1010/submit-as03   The four files  kendall.c ,  histogram.c ,  countingsort.c , and  mastermind.c  will be uploaded to GitHub.  You can submit multiple times, but only the last submission will be graded.   Editing Your Files in Multiple Locations  You should edit your code only on the CS1010 PE hosts.  If you choose to edit your code in other places, such as directly on Github or in a second location (such as your own laptop), you need to be comfortable with various  git  command to synchronize your code across the different locations, possibly needing to resolve synchronization conflicts.     Only the four C files listed above will be submitted.  You can create additional C files for testing different solutions, but eventually, you must put your solution into the corresponding C file provided as the skeleton.",
            "title": "Submission"
        },
        {
            "location": "/as03/index.html#identifying-yourself",
            "text": "In every C file that you submit to CS1010, you need to identify yourself by writing your name and tutorial group. Marks will be deducted if you fail to do so. You need to edit the line:  1 @author XXXX (Group YYYY)   and change it to something like:  1 @author Peter Parker (Group 9)",
            "title": "Identifying Yourself"
        },
        {
            "location": "/as03/index.html#grading",
            "text": "This assignment contributes towards 3% of your final grade.  The total mark for this assignment is 30 marks.  There are two marking criteria: correctness and style.    For each question, 2 marks are allocated for coding style.  Please refer to the  CS1010 C Style Guide  and follow the recommended guideline.  The rest of the marks are allocated to correctness.  Note that passing the tests does not guarantee that your code is correct.  Even if your code produces the correct output all the time, you may still lose marks if you do not write your code properly (e.g., using the most appropriate type, violating the constraints set by the question).  We reserve the right to penalize students for using banned C syntax in the assignments.  In addition, each grader at his or her own discretion can penalze students for repeating mistakes / bad practices from the student's past assignments (even if it was just a warning with no marks deducted in the earlier assignments).",
            "title": "Grading"
        },
        {
            "location": "/as03/index.html#question-1-kendall-10-marks",
            "text": "Suppose that we are given a set of items and we ask two different parties to rank the items according to some order.  We may get two different order of the items.  How do we measure how similar (or dissimilar) the two rankings are?  For example, consider a search engine that returns a list of web pages ranked by their relevance to the search query.  A user may not always agree with the ranking of the search engine and may judge the relevance of the search result differently, i.e., the user may have his or her own ranking.  This measurement of similarity between the ranking by the search engine and the ranking by the user gives us a metric on how good the search engine result is.  The more similar it is to the ranking of the user, the better the search engine is in ranking in the search results.  One way to measure the similarity of two rankings is the  Kendall tau distance .  You will write a program  kendall  that calculates the  normalized  Kendall tau distance for this question.  We will represent a ranking by the order of the items.  The first item is ranked 1, second is ranked 2, and so on.  To simplify the problem, we take one of the ranking that we want to calculate the Kendall tau distance on, and label the items sequentially, as the sequence 1, 2, 3, 4, 5, ... n n , where  n n  is the number of items.  We call this the  base  ranking.  The other ranking will then be a permutation of the numbers 1 to  n n .  For example, suppost we have three items A, B, C. the first ranking ranks the items as B, C, A.  The second ranking ranks the items C, A, B.  After relabelling the first ranking as 1, 2, 3, the second ranking becomes 2, 3, 1.  The Kendall tau distance counts the number of pairs of items in one ranking that are ranked in different order in the other ranking.  In the example above, we have three possible pairs:     Pair  Ranking 1  Ranking 2      A-B  B then A  A then B    A-C  C then A  C then A    B-C  B then C  C then B     Out of the three pairs, the pair A-B and B-C are ordered differently in the two rankings, so that Kendall tau distance is 2.  The normalized Kendall tau distance is the ratio of the number of pairs ranked in different order to all possible number of pairs.  In the example above, the  normalized  Kendall distance is \u2154 = 0.6666.  Your program should read the following from the standard input:   The first positive integer,  n n , is the number of items ( n > 1 n > 1 ).  The next  n n  numbers is a permutation of integers between 1 to  n n . This corresponds to the ranking of the items from 1 to  n n .     Your program should print the normalized Kendall tau distance between the ranking read above and the base ranking (1, 2, 3, ..  n n ) to the standard output.",
            "title": "Question 1: Kendall (10 marks)"
        },
        {
            "location": "/as03/index.html#sample-run",
            "text": "1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12 ooiwt@pe118:~/as03-skeleton$ ./kendall\n3\n2 3 1\n0.6666\nooiwt@pe118:~/as03-skeleton$ ./kendall\n10\n1 2 3 4 5 6 7 8 9 10\n0.0000\nooiwt@pe118:~/as03-skeleton$ ./kendall\n6\n6 5 4 3 2 1\n1.0000",
            "title": "Sample Run"
        },
        {
            "location": "/as03/index.html#question-2-histogram-10-marks",
            "text": "It is often useful to visualize the distribution of numerical data using a histogram.  In this question, you will write a program called  histogram  that plots the histogram for real numbers ranged between 0 and 100 (inclusive).   Our histogram will have 10 buckets,  b_0, b_1, ... b_9 b_0, b_1, ... b_9 .  The bucket  b_i b_i  corresponds to the interval [ 10i, 10(i+1) 10i, 10(i+1) ) (includes  10i 10i , but excludes  10(i+1) 10(i+1) ),  except  b_9 b_9 , which includes 100 .    To plot the histogram, we count how many percent of the data falls into each bucket.  Let the percentage of data that falls into bucket  b_i b_i  be  k_i k_i %.  We set the length of each bar in histogram to be at most 10 characters, so we scale down  k_i k_i  by 10 to get the length  l_i l_i .  We then draw on the screen using character \"\u2588\" and \"\u258c\", according to the following rules:   If  l_i l_i  is an integer, then we draw \"\u2588\"  l_i l_i  times.    Otherwise, if  x < l_i \\le x + 0.5 x < l_i \\le x + 0.5  for some integer  x x , then we draw \"\u2588\"  x x  times followed by a \"\u258c\".  Otherwise, if  x + 0.5 < l_i < x + 1 x + 0.5 < l_i < x + 1  for some integer  x x , then we draw \"\u2588\"  x+1 x+1  times.   Your program should read the following from the standard input:   a positive integer  n n , followed by  n n  real numbers, corresponding to data to plot the histogram with.   Your program should print the axis and labels, as well as the bars for the histogram as shown in the same run.\nThe code to print both axis and labels are already given in the skeleton  histogram.c .  The string that corresponding to \"\u2588\" and \"\u258c\" are also given in the code, defined as  BLOCK  and  HALF_BLOCK .",
            "title": "Question 2: Histogram (10 marks)"
        },
        {
            "location": "/as03/index.html#sample-run_1",
            "text": "1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40 ooiwt@pe118:~/as03-skeleton$ ./histogram\n10\n25 35 35 45 45 45 45 55 55 65\n          \u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\n  0 - 10  \n 10 - 20  \n 20 - 30  \u2588\n 30 - 40  \u2588\u2588\n 40 - 50  \u2588\u2588\u2588\u2588\n 50 - 60  \u2588\u2588\n 60 - 70  \u2588\n 70 - 80  \n 80 - 90  \n 90 - 100 \nooiwt@pe118:~/as03-skeleton$ ./histogram\n1\n100\n          \u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\n  0 - 10\n 10 - 20\n 20 - 30\n 30 - 40\n 40 - 50\n 50 - 60\n 60 - 70\n 70 - 80\n 80 - 90\n 90 - 100 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\nooiwt@pe118:~/as03-skeleton$ ./histogram < inputs/histogram.5.in\n          \u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\n  0 - 10  \u258c\n 10 - 20  \u258c\n 20 - 30\n 30 - 40  \u258c\n 40 - 50\n 50 - 60  \u258c\n 60 - 70  \u2588\n 70 - 80  \u2588\u2588\n 80 - 90  \u2588\u2588\u2588\u2588\u2588\u258c\n 90 - 100 \u2588\u2588   The last histogram above plots the actual data from your Assignment 1 marks (scaled up 3x to have the range of 0 - 90).",
            "title": "Sample Run"
        },
        {
            "location": "/as03/index.html#question-3-countingsort-10-marks",
            "text": "Sorting is a fundamental computational problem: given a list of items, we want to rearrange the items in some order.  In this question, you will write you first sorting algorithm, called  counting sort .  This is an extremely fast algorithm for sorting positive integers if the range of the integers are limited.  The idea of counting sort is that, given the list of integers (each guranteed to be between 1 to  k k ) to sort, we count how many times 1 appear in the list, how many times 2 appears in the list, etc.  Finally, we print out each number between 1 to  k k  according to how many times they appear in the list, skipping those numbers who do not appear.  For instance, suppose we have 6 integers between 1 to 9:  5 5 3 2 8 2 .  We first count how many times each number appears.  Then we print the sorted list the following way:  2  appears twice, so we print  1\n2 2\n2   The number 3 appears once, we print 1 3   The number 5 appears twice, we print  1\n2 5\n5   Finally 8 appears once, we print  1 8   The printed output is thus  1\n2\n3\n4\n5\n6 2\n2\n3\n5\n5\n8   which is the numbers sorted in increasing order.    Write a program  countingsort.c  that reads the following in order from the standard input:   n n  the number of integers to sort  k k  the maximum value of the integers to sort  The next  n n  numbers are the integers to be sorted, each guaranteed to be between 1 and  k k .   Sort the integers using the algorithms above and print them in increasing order to the standard output, one integer on each line.  Note that if you use any other algorithms to sort the numbers, you will be penalized heavily.  Input Validation:  For this question, you need to validate that the numbers are actually ranged between 1 and  k k .  Any inputs that are not in this range must be omitted in the output.",
            "title": "Question 3: CountingSort (10 marks)"
        },
        {
            "location": "/as03/index.html#sample-run_2",
            "text": "1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21 ooiwt@pe118:~/as03-skeleton$ ./countingsort\n6 9 \n5 5 3 2 8 2\n2\n2\n3\n5\n5\n8\nooiwt@pe118:~/as03-skeleton$ ./countingsort\n3 1000 \n256 872 112\n112\n256\n872\nooiwt@pe118:~/as03-skeleton$ ./countingsort\n4 3\n3 2 -3 2\n2\n2\n3",
            "title": "Sample Run"
        },
        {
            "location": "/quiz/index.html",
            "text": "Quizzes\n\n\nWe have setup some quizzes to help you check for yourself how much you know about the topics we cover in CS1010.\n\n\nThere are two types of quizzes: (a) in-class Kahoot! quizzes, and (b) out-of-class Google Form quizzes.  The quizzes are linked here:\n\n\nKahoot! Quizzes\n\n\nWeek 4: Flow Charts\n (3 September 2018)\n\n\nGoogle Form Quizzes\n\n\nQuiz 1: Using PE and UNIX\n\n\nQuiz 2: Compiling Your Code",
            "title": "Quizzes"
        },
        {
            "location": "/quiz/index.html#quizzes",
            "text": "We have setup some quizzes to help you check for yourself how much you know about the topics we cover in CS1010.  There are two types of quizzes: (a) in-class Kahoot! quizzes, and (b) out-of-class Google Form quizzes.  The quizzes are linked here:",
            "title": "Quizzes"
        },
        {
            "location": "/quiz/index.html#kahoot-quizzes",
            "text": "",
            "title": "Kahoot! Quizzes"
        },
        {
            "location": "/quiz/index.html#week-4-flow-charts-3-september-2018",
            "text": "",
            "title": "Week 4: Flow Charts (3 September 2018)"
        },
        {
            "location": "/quiz/index.html#google-form-quizzes",
            "text": "",
            "title": "Google Form Quizzes"
        },
        {
            "location": "/quiz/index.html#quiz-1-using-pe-and-unix",
            "text": "",
            "title": "Quiz 1: Using PE and UNIX"
        },
        {
            "location": "/quiz/index.html#quiz-2-compiling-your-code",
            "text": "",
            "title": "Quiz 2: Compiling Your Code"
        },
        {
            "location": "/kahoot01/index.html",
            "text": "Kahoot Quiz 1\n\n\n3 September 2018 (Week 4)\n\n\nQuestion 1\n\n\nWhat is the output of the algorithm in the flowchart below if the input L is 10, 7, 1?\n\n\n\n\n\n\nA. 18\n\n\nB. 27\n\n\nC. 8\n\n\nD. 17\n\n\n\n\n(Answer: B)\n\n\nQuestion 2\n\n\nWhat is the output of the algorithm in the flowchart below if the input L is 5, 6, 10?\n\n\n\n\n\n\nA. 5\n\n\nB. 6\n\n\nC. 10\n\n\nD. No output\n\n\n\n\n(Answer: B)\n\n\nQuestion 3\n\n\nRefer to the flowchart in Question 2.  What is the output of the algorithm if L is 1, 2, 3, 4?\n\n\n\n\nA. 2\n\n\nB. 3\n\n\nC. 4\n\n\nD. No output\n\n\n\n\n(Answer: D)",
            "title": "Flow Charts"
        },
        {
            "location": "/kahoot01/index.html#kahoot-quiz-1",
            "text": "3 September 2018 (Week 4)",
            "title": "Kahoot Quiz 1"
        },
        {
            "location": "/kahoot01/index.html#question-1",
            "text": "What is the output of the algorithm in the flowchart below if the input L is 10, 7, 1?    A. 18  B. 27  C. 8  D. 17   (Answer: B)",
            "title": "Question 1"
        },
        {
            "location": "/kahoot01/index.html#question-2",
            "text": "What is the output of the algorithm in the flowchart below if the input L is 5, 6, 10?    A. 5  B. 6  C. 10  D. No output   (Answer: B)",
            "title": "Question 2"
        },
        {
            "location": "/kahoot01/index.html#question-3",
            "text": "Refer to the flowchart in Question 2.  What is the output of the algorithm if L is 1, 2, 3, 4?   A. 2  B. 3  C. 4  D. No output   (Answer: D)",
            "title": "Question 3"
        },
        {
            "location": "/c-in-cs1010/index.html",
            "text": "C in CS1010\n\n\nC is a simple and flexible language, providing programmers with many different ways to achieve the same thing.\n\n\nSome of these features that C provides, however, could be bug prone.  Wei Tsang has written enough buggy programs himself and seen enough buggy programs from students.  He feels that some of these features from C are not useful for beginners (or even seasoned programmers).\n\n\nFurthermore, some features in C simply encourages bad programming habits that are widely frowned upon.  Some would lead to insecure programs.  \n\n\nAs such, in CS1010, we \nban\n and \ndiscourage\n the use of certain operators, functions, constructs, and features in C.\n\n\nThis article summarizes this list.  This is a work in progress article. As we learn more about C, we will amend this list.\n\n\nBanned in CS1010\n\n\nThe banned items should not be used in CS1010.  Students should use the alternatives.  The teaching staff reserves the right to apply a penalty while grading the assignments and practical exams if these banned features are used.\n\n\n1. The \n++\n and \n--\n operators.\n\n\nWhy?\n\n\n\n\nThese operators lead to potential undefined behavior.  E.g., \ni = i++;\n\n\nThe potential confusion caused by the difference between \ni++\n and \n++i\n.\n\n\n\n\nWhat should be used instead?\n\n\n\n\nUse \ni += 1\n or \ni -= 1\n instead of \ni++\n or \ni--\n\n\n\n\n2. Skipping of curly braces for single statement conditional or loop body\n\n\nWhy?\n\n\n\n\nCould lead to dangling \nelse\n confusion\n\n\nEasy to forget to put back the \n{}\n pair if the body is modified beyond a single statements\n\n\n\n\nWhat should be used instead?\n\n\n\n\nAlways use \n{}\n even if the conditional or loop body contains only a single statement.\n\n\n\n\n3. Nested conditional operator \n?:\n\n\nWhy?\n\n\n\n\nCan get difficult to read, understand, and modify.  Example:\n\n\n\n\n1\na = (x > y) ? ((y > z) ? y : z) : ((x > z) ? x : z);\n\n\n\n\n\n\nWhat should be used\n\n\n\n\nUse nested \nif-else\n loop\n\n\n\n\n4. Global variables\n\n\nWhy?\n\n\n\n\nIt makes the code hard to reason about and trace, as you have no idea who will modify these variables.  For instance,  if \nx\n is not a global variable, we can safely assert that \nx\n is still 1 after calling \nf()\n.  If \nx\n is a global variable, we can no longer assert anything about \nx\n.\n\n\n\n\n1\n2\n3\nx\n \n=\n \n1\n;\n\n\nf\n();\n\n\n// { x == 1 }\n\n\n\n\n\n\n\nWhat should be used instead\n\n\n\n\nDeclare the variables as local, automatic variables, and pass them around.\n\n\n\n\n5. The type \nint\n and \nshort\n\n\nWhy?\n\n\n\n\nC standard guaratees that both \nshort\n and \nint\n are at least 16 bits, which limits its guaranteed range to only -32,768 to 32,767.  This is too small many purposes.\n\n\nWe are not concerned about memory usage in CS1010.  If we do want to have precise control over memory, we should be anyway using the types from \nstdint.h\n.\n\n\n\n\nWhat should be used instead\n\n\n\n\nlong\n, which is guaranteed to be at least 32 bits.\n\n\n\n\nException\n\n\n\n\nIf a function from C library calls for the use of \nint\n and offers no \nlong\n alternative, then we have to use \nint\n.\n\n\n\n\n6. The type \nfloat\n\n\nWhy?\n\n\n\n\nNot enough precision and will cause floating point errors.\n\n\n\n\nWhat should be used instead\n\n\n\n\ndouble\n\n\n\n\nException\n\n\n\n\nIf a function from C library calls for the use of \nfloat\n and offers no \ndouble\n alternative, then we have to use \nfloat\n.\n\n\n\n\n7. Using integer values for true / false\n\n\nWhy?\n\n\n\n\nConfusing and error prone\n\n\n\n\nWhat should be used instead\n\n\n\n\nUse the \nbool\n type, and the values \ntrue\n and \nfalse\n.\n\n\n\n\n8. \ngoto\n\n\nWhy?\n\n\n\n\nmakes the logical flow of the code hard to follow and trace\n\n\n\n\nWhat should be used instead\n\n\n\n\ncombinations of conditionals and loops\n\n\n\n\n\n\nDiscouraged in CS1010\n\n\nThese are things that are not strictly banned, but their usage is discouraged.  Students should really use them only if they know very well what they are doing.  Use at own perils.\n\n\n1. \nprintf\n and \nscanf\n Functions\n\n\nWhy?\n\n\n\n\nUsing the wrong format modifier for \nprintf\n could lead to strange results\n\n\nUsing the wrong format modifier for \nscanf\n could lead to memory corruption\n\n\nNeed to look up what is the right format modifier to use\n\n\nNeed to preallocate memory for \nscanf\n of strings\n\n\nscanf\n is not secure\n\n\nscanf\n is not a pure function.  Prefers students to learn about the concept of pure functions first.\n\n\netc. etc.\n\n\n\n\nWhat should be used instead\n\n\n\n\nThe CS1010 I/O library\n\n\n\n\n2. \nswitch\n Statements\n\n\nWhy?\n\n\n\n\nBug prone (missing \nbreak\n would cause the case to fall through)\n\n\nOnly works on ordinal types.\n\n\n\n\nWhat should be used instead\n\n\n\n\nif\n-\nelse\n statements\n\n\n\n\n3. \nbreak\n and \ncontinue\n Statements\n\n\nWhy?\n\n\n\n\nUsing \nbreak\n and \ncontinue\n complicates the flow of a loop, marks it harder to reason about the correctness of the loop, and is, therefore, bug-prone.  \n\n\n\n\nWhat should be used instead\n\n\n\n\nSimple loops with a single entry and a single exit point.  Use flag variables to indicate special conditions to exit or continue with the loop.\n\n\n\n\n4. Skipping parenthesis\n\n\nWhy?\n\n\n\n\nParenthesis makes it clear to the reader the order of evaluation of arithmetic operations / logical operations.  We should add parenthesis to make sure the intention of the code is clear.\n\n\n\n\nWhy should be used instead\n\n\n\n\nParenthesis",
            "title": "C in CS1010"
        },
        {
            "location": "/c-in-cs1010/index.html#c-in-cs1010",
            "text": "C is a simple and flexible language, providing programmers with many different ways to achieve the same thing.  Some of these features that C provides, however, could be bug prone.  Wei Tsang has written enough buggy programs himself and seen enough buggy programs from students.  He feels that some of these features from C are not useful for beginners (or even seasoned programmers).  Furthermore, some features in C simply encourages bad programming habits that are widely frowned upon.  Some would lead to insecure programs.    As such, in CS1010, we  ban  and  discourage  the use of certain operators, functions, constructs, and features in C.  This article summarizes this list.  This is a work in progress article. As we learn more about C, we will amend this list.",
            "title": "C in CS1010"
        },
        {
            "location": "/c-in-cs1010/index.html#banned-in-cs1010",
            "text": "The banned items should not be used in CS1010.  Students should use the alternatives.  The teaching staff reserves the right to apply a penalty while grading the assignments and practical exams if these banned features are used.",
            "title": "Banned in CS1010"
        },
        {
            "location": "/c-in-cs1010/index.html#1-the-and-operators",
            "text": "",
            "title": "1. The ++ and -- operators."
        },
        {
            "location": "/c-in-cs1010/index.html#why",
            "text": "These operators lead to potential undefined behavior.  E.g.,  i = i++;  The potential confusion caused by the difference between  i++  and  ++i .",
            "title": "Why?"
        },
        {
            "location": "/c-in-cs1010/index.html#what-should-be-used-instead",
            "text": "Use  i += 1  or  i -= 1  instead of  i++  or  i--",
            "title": "What should be used instead?"
        },
        {
            "location": "/c-in-cs1010/index.html#2-skipping-of-curly-braces-for-single-statement-conditional-or-loop-body",
            "text": "",
            "title": "2. Skipping of curly braces for single statement conditional or loop body"
        },
        {
            "location": "/c-in-cs1010/index.html#why_1",
            "text": "Could lead to dangling  else  confusion  Easy to forget to put back the  {}  pair if the body is modified beyond a single statements",
            "title": "Why?"
        },
        {
            "location": "/c-in-cs1010/index.html#what-should-be-used-instead_1",
            "text": "Always use  {}  even if the conditional or loop body contains only a single statement.",
            "title": "What should be used instead?"
        },
        {
            "location": "/c-in-cs1010/index.html#3-nested-conditional-operator",
            "text": "",
            "title": "3. Nested conditional operator ?:"
        },
        {
            "location": "/c-in-cs1010/index.html#why_2",
            "text": "Can get difficult to read, understand, and modify.  Example:   1 a = (x > y) ? ((y > z) ? y : z) : ((x > z) ? x : z);",
            "title": "Why?"
        },
        {
            "location": "/c-in-cs1010/index.html#what-should-be-used",
            "text": "Use nested  if-else  loop",
            "title": "What should be used"
        },
        {
            "location": "/c-in-cs1010/index.html#4-global-variables",
            "text": "",
            "title": "4. Global variables"
        },
        {
            "location": "/c-in-cs1010/index.html#why_3",
            "text": "It makes the code hard to reason about and trace, as you have no idea who will modify these variables.  For instance,  if  x  is not a global variable, we can safely assert that  x  is still 1 after calling  f() .  If  x  is a global variable, we can no longer assert anything about  x .   1\n2\n3 x   =   1 ;  f ();  // { x == 1 }",
            "title": "Why?"
        },
        {
            "location": "/c-in-cs1010/index.html#what-should-be-used-instead_2",
            "text": "Declare the variables as local, automatic variables, and pass them around.",
            "title": "What should be used instead"
        },
        {
            "location": "/c-in-cs1010/index.html#5-the-type-int-and-short",
            "text": "",
            "title": "5. The type int and short"
        },
        {
            "location": "/c-in-cs1010/index.html#why_4",
            "text": "C standard guaratees that both  short  and  int  are at least 16 bits, which limits its guaranteed range to only -32,768 to 32,767.  This is too small many purposes.  We are not concerned about memory usage in CS1010.  If we do want to have precise control over memory, we should be anyway using the types from  stdint.h .",
            "title": "Why?"
        },
        {
            "location": "/c-in-cs1010/index.html#what-should-be-used-instead_3",
            "text": "long , which is guaranteed to be at least 32 bits.",
            "title": "What should be used instead"
        },
        {
            "location": "/c-in-cs1010/index.html#exception",
            "text": "If a function from C library calls for the use of  int  and offers no  long  alternative, then we have to use  int .",
            "title": "Exception"
        },
        {
            "location": "/c-in-cs1010/index.html#6-the-type-float",
            "text": "",
            "title": "6. The type float"
        },
        {
            "location": "/c-in-cs1010/index.html#why_5",
            "text": "Not enough precision and will cause floating point errors.",
            "title": "Why?"
        },
        {
            "location": "/c-in-cs1010/index.html#what-should-be-used-instead_4",
            "text": "double",
            "title": "What should be used instead"
        },
        {
            "location": "/c-in-cs1010/index.html#exception_1",
            "text": "If a function from C library calls for the use of  float  and offers no  double  alternative, then we have to use  float .",
            "title": "Exception"
        },
        {
            "location": "/c-in-cs1010/index.html#7-using-integer-values-for-true-false",
            "text": "",
            "title": "7. Using integer values for true / false"
        },
        {
            "location": "/c-in-cs1010/index.html#why_6",
            "text": "Confusing and error prone",
            "title": "Why?"
        },
        {
            "location": "/c-in-cs1010/index.html#what-should-be-used-instead_5",
            "text": "Use the  bool  type, and the values  true  and  false .",
            "title": "What should be used instead"
        },
        {
            "location": "/c-in-cs1010/index.html#8-goto",
            "text": "",
            "title": "8. goto"
        },
        {
            "location": "/c-in-cs1010/index.html#why_7",
            "text": "makes the logical flow of the code hard to follow and trace",
            "title": "Why?"
        },
        {
            "location": "/c-in-cs1010/index.html#what-should-be-used-instead_6",
            "text": "combinations of conditionals and loops",
            "title": "What should be used instead"
        },
        {
            "location": "/c-in-cs1010/index.html#discouraged-in-cs1010",
            "text": "These are things that are not strictly banned, but their usage is discouraged.  Students should really use them only if they know very well what they are doing.  Use at own perils.",
            "title": "Discouraged in CS1010"
        },
        {
            "location": "/c-in-cs1010/index.html#1-printf-and-scanf-functions",
            "text": "",
            "title": "1. printf and scanf Functions"
        },
        {
            "location": "/c-in-cs1010/index.html#why_8",
            "text": "Using the wrong format modifier for  printf  could lead to strange results  Using the wrong format modifier for  scanf  could lead to memory corruption  Need to look up what is the right format modifier to use  Need to preallocate memory for  scanf  of strings  scanf  is not secure  scanf  is not a pure function.  Prefers students to learn about the concept of pure functions first.  etc. etc.",
            "title": "Why?"
        },
        {
            "location": "/c-in-cs1010/index.html#what-should-be-used-instead_7",
            "text": "The CS1010 I/O library",
            "title": "What should be used instead"
        },
        {
            "location": "/c-in-cs1010/index.html#2-switch-statements",
            "text": "",
            "title": "2. switch Statements"
        },
        {
            "location": "/c-in-cs1010/index.html#why_9",
            "text": "Bug prone (missing  break  would cause the case to fall through)  Only works on ordinal types.",
            "title": "Why?"
        },
        {
            "location": "/c-in-cs1010/index.html#what-should-be-used-instead_8",
            "text": "if - else  statements",
            "title": "What should be used instead"
        },
        {
            "location": "/c-in-cs1010/index.html#3-break-and-continue-statements",
            "text": "",
            "title": "3. break and continue Statements"
        },
        {
            "location": "/c-in-cs1010/index.html#why_10",
            "text": "Using  break  and  continue  complicates the flow of a loop, marks it harder to reason about the correctness of the loop, and is, therefore, bug-prone.",
            "title": "Why?"
        },
        {
            "location": "/c-in-cs1010/index.html#what-should-be-used-instead_9",
            "text": "Simple loops with a single entry and a single exit point.  Use flag variables to indicate special conditions to exit or continue with the loop.",
            "title": "What should be used instead"
        },
        {
            "location": "/c-in-cs1010/index.html#4-skipping-parenthesis",
            "text": "",
            "title": "4. Skipping parenthesis"
        },
        {
            "location": "/c-in-cs1010/index.html#why_11",
            "text": "Parenthesis makes it clear to the reader the order of evaluation of arithmetic operations / logical operations.  We should add parenthesis to make sure the intention of the code is clear.",
            "title": "Why?"
        },
        {
            "location": "/c-in-cs1010/index.html#why-should-be-used-instead",
            "text": "Parenthesis",
            "title": "Why should be used instead"
        },
        {
            "location": "/style/index.html",
            "text": "CS1010 C Style\n\n\nIn CS1010, you should following the following style guide when you write your code for your graded homework and practical exams.  We typically allocate a few marks for coding style (each assignment/exam may have different allocation).  You will lose marks for violation of style.\n\n\nThis guide is modified from past CS1010 style guide by Aaron Tan.\n\n\nWhy Coding Style is Important\n\n\nQuote\n\n\n\"It is not merely a matter of aesthetics that programs should be written in a particular style. Rather there is a psychological basis for writing programs in a conventional manner: programmers have strong expectations that other programmers will follow these discourse rules. If the rules are violated, then the utility afforded by the expectations that programmers have built up over time is effectively nullified. The results from the experiments with novice and advanced student programmers and with professional programmers described in this paper provide clear support for these claims.\"\n\n\nElliot Soloway and Kate Ehrlich. \"Empirical studies of programming knowledge.\" IEEE Transactions on Software Engineering 5 (1984): 595-609.\n\n\n1. Variable Declaration\n\n\nEach variable should be declared in its own line.\n\n\n1\n2\ndouble\n \nweight\n;\n  \n// The weight of the baby\n\n\ndouble\n \nheight\n;\n  \n// The height of the baby\n\n\n\n\n\n\n\nAvoid\n\n\n1\ndouble\n \nweight\n,\n \nheight\n;\n   \n// Weight and height of the baby\n\n\n\n\n\n\n\n2. Give Variables Descriptive Names\n\n\nThis is the most important rule to follow.  The name of a type, variable, function, constant should inform us of its purpose clearly without the readers having to guess or look up its meaning.\n\n\nFor example, \nint number_of_coins;\n is an appropriate variable but not \nint c;\n. Avoid using a single character for variable names.\n\n\nThere are some exceptions, however, as shown below:\n\n\n\n\nIf the variable is the problem size and it is given in the task statement. For example, a problem dealing with n values, hence the variable may be called n (preferably with a comment to explain).\n\n\nIf the variable is a transient/temporary variable whose purpose is clear.\n-If the variable is a loop variable whose purpose is clear.\n\n\n\n\n3. Shorten Variable Names with Naming Conventions\n\n\nDespite the recommendation for descriptive names, identifiers can be short yet descriptive by using abbreviations and/or common naming conventions. For example, \nMAX_LEN\n, \nnum_of_elems\n, \npcurr\n, \ntable_num\n.\n\n\nHowever, do not invent your own abbreviation. For instance, names like \nnm_elemnts\n should be avoided.\n\n\n4. Avoid Negated Variable or Function Names\n\n\nNegated variables often result in hard-to-read double-negatives in an expression like \n!is_not_err\n.\n\n\nSo, avoid \nis_not_error\n, \nis_not_found\n, \nis_not_valid\n, \ncannot_open_file\n.  Instead, we prefer \nis_error\n, \nis_found\n, \nis_valid\n, \ncan_open_file\n etc.\n\n\n5. Use \n#define\n to Define Constants for Magic Numbers\n\n\nAvoid direct use of magic numbers. Constant literals which have special meanings should be named and its named identifier should be used in its place. For example:\n\n\nAvoid:\n\n1\n2\n3\nfor\n \n(\ni\n \n=\n \n0\n;\n \ni\n \n<\n \n100\n;\n \ni\n \n+=\n \n1\n)\n \n{\n\n    \n:\n\n\n}\n\n\n\n\n\n\nPrefer:\n\n1\n2\n3\n4\n5\n#define MAX_LEN 100\n :\nfor (i = 0; i < MAX_LEN; i += 1) {\n    :\n}\n\n\n\n\n\n6. Naming Conventions\n\n\nConstants\n\n\nAll constant identifiers must be written in all caps and separated by an underscore \n_\n.  For instance \nMAX_ITERATIONS\n, \nMAX_LEN\n, \nGOLDEN_RATIO\n, \nCOLOR_DEFAULT\n, \nPI\n.\n\n\nVariables and Functions\n\n\nUse lower case letters for variable names and function names, with multiple words separated by underscore \n_\n.  Example, \ncs1010_read_long\n, \nis_prime\n. \n\n\n7. Use Consistent Indentation to Emphasize Block Structure\n\n\nThe code should be properly and neatly indented to emphasize the nested logical structure of the program. An indentation of 2 or 4 spaces is recommended (8 is too wide).\n\n\nEvery block that follows a \nfor\n, \nwhile\n, \nif-else\n, \ndo-while\n statement must be indented from its enclosing block.\n\n\nComments within a block should follow the indentation level of its enclosing block. For example,\n\n\n1\n2\n3\n4\n5\n6\n7\nfor\n \n(\ni\n \n=\n \n0\n;\n \ni\n \n<\n \n3\n;\n \ni\n \n+=\n \n1\n)\n \n{\n   \n    \n// Comments should be indented too\n\n    \nwhile\n \n(\nj\n \n!=\n \ni\n)\n \n{\n\n        \n// More indented comments\n\n        \nprintf\n(\n\"Hello\n\\n\n\"\n);\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nThe following are the wrong ways to indent the comments.\n\n\n1\n2\n3\n4\n5\n6\n7\nfor\n \n(\ni\n \n=\n \n0\n;\n \ni\n \n<\n \n3\n;\n \ni\n \n+=\n \n1\n)\n \n{\n\n\n// This comment should be indented and aligned with the while statement.\n\n    \nwhile\n \n(\nj\n \n!=\n \ni\n)\n \n{\n\n    \n// This comment should be aligned with the printf statement.\n\n        \nprintf\n(\n\"Hello\n\\n\n\"\n);\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\n8. Don't Mix Tabs and Spaces\n\n\nYou must use only spaces in your code.  Do not use tabs.\n\n\nYou can add the configuration \nset expandtab\n to automatically expand any tab that you enter into spaces.\n\n\n9. Spaces in \nif\n, \nelse\n, \nfor\n, \nwhile\n, \ndo\n-\nwhile\n Statements\n\n\nAdd a single space between the keywords \nif\n,\nelse\n, \nfor\n, \nwhile\n and the following parentheses and between the parentheses and next curly bracket.  For instance:\n\n\n1\n2\n3\nfor( ... ) { // not good\nfor( ... ){ // not good\nfor ( ... ) { // good\n\n\n\n\n\n\n10. Spaces in Assignments\n\n\nAdd a single space before and after \n=\n.\n\n\n1\n2\n3\na= b; // no\na =b; // no\na = b; // OK!\n\n\n\n\n\n\n11. Positions of Open and Close Braces\n\n\nThere are two camps on the position of open braces. The following shows the \"trailing open braces\":\n\n\n1\n2\n3\n4\n5\nfor\n \n(\ni\n \n=\n \n0\n;\n \ni\n \n<\n \n3\n;\n \ni\n \n+=\n \n1\n)\n \n{\n\n    \nwhile\n \n(\nj\n \n!=\n \ni\n)\n \n{\n\n        \nprintf\n(\n\"Hello\n\\n\n\"\n);\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nThe following shows the \"leading open braces\". The leading open brace must be aligned with the block of the construct it is in:\n\n\n1\n2\n3\n4\n5\n6\n7\nfor\n \n(\ni\n \n=\n \n0\n;\n \ni\n \n<\n \n3\n;\n \ni\n \n+=\n \n1\n)\n \n\n{\n\n    \nwhile\n \n(\nj\n \n!=\n \ni\n)\n \n    \n{\n\n        \nprintf\n(\n\"Hello\n\\n\n\"\n);\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nBoth styles are acceptable, but you should be consistent and should not mix both styles in a single program.\n\n\nFor close braces, they should be leading close braces aligned with the block of the construct. Close braces should NOT be trailing as that would make it hard to spot them.\n\n\n12. Comment Major Code Segments Adequately\n\n\nMajor segments of code should have explanatory comments. A major segment may be a loop block or a function block.\n\n\nYou should comment on complicated logic, expressions, or algorithms, explaining what you are doing in the code, including why and how.\n\n\nAn \"if\" block with a complex condition or an expression that is hard to understand should have explanatory comments.  For example,\n\n\n1\n2\n3\n4\n// Check and reject out-of-bounds indices\n\n\nif\n \n(\nk\n \n<\n \n0\n \n||\n \nk\n \n>=\n \nMAX_LEN\n)\n \n{\n\n    \nreturn\n \n-\n1\n;\n\n\n}\n\n\n\n\n\n\n\n13. Avoid Superfluous Comments\n\n\nA comment such as:\n\n\n1\ni\n \n+=\n \n1\n \n// add one to i\n\n\n\n\n\n\n\nserves no purpose, adds clutter to a program and does more harm than good.\n\n\n14. Blank Lines\n\n\nIt is good to add a blank line between two functions, or two long segments of code for readability.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n// This function ...\n\n\nint\n \nf\n(\nint\n \nx\n)\n \n{\n\n    \n// body\n\n\n}\n\n\n\n// This function ...\n\n\nint\n \ng\n(\ndouble\n \ny\n)\n \n{\n\n    \n// body\n\n\n}\n\n\n\n\n\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n// Statements 1 to 10 belong to a sub-task\n\n\nstatement1\n;\n\n\nstatement2\n;\n\n   \n:\n\n\nstatement10\n;\n\n\n\n// Leave a blank line for readability\n\n\nstatement11\n;\n\n\nstatement12\n;\n\n   \n:\n\n\n\n\n\n\n\nHowever, guard against the use of excessive blank lines. Double blank lines and triply blank lines, or more, should not be present.\n\n\n15. Long Lines\n\n\nIf a line (be it a statement or a comment) is too long (more than 80 characters), do not let it run through the screen and wrap around. Instead, split it into a few lines.\n\n\n1\nif\n \n((\nhas_cs2010\n \n||\n \nhas_cs2020\n \n||\n \nhas_cs2040\n \n||\n \nhas_cs2040C\n)\n \n&&\n \n(\nhas_st1232\n \n||\n \nhas_st2131\n \n||\n \nhas_st2132\n \n||\n \nhas_st2334\n)\n \n&&\n \n(\nhas_ma1102R\n \n||\n \nhas_ma1505\n \n||\n \n(\nhas_ma1511\n \n&&\n \nhas_ma1512\n)\n \n||\n \nhas_ma1521\n)\n \n&&\n \n(\nhas_ma1101R\n \n||\n \nhas_ma1311\n \n||\n \nhas_ma1506\n \n||\n \nhas_ma1508E\n))\n \n\n\n\n\nis bad\n\n\n1\n2\n3\n4\nif\n \n((\nhas_cs2010\n \n||\n \nhas_cs2020\n \n||\n \nhas_cs2040\n \n||\n \nhas_cs2040c\n)\n \n&&\n \n   \n(\nhas_st1232\n \n||\n \nhas_st2131\n \n||\n  \nhas_st2132\n \n||\n \nhas_st2334\n)\n \n&&\n \n   \n(\nhas_ma1102r\n \n||\n \nhas_ma1505\n \n||\n \n(\nhas_ma1511\n \n&&\n \nhas_ma1512\n)\n \n||\n \nhas_ma1521\n)\n \n&&\n    \n   \n(\nhas_ma1101r\n \n||\n \nhas_ma1311\n \n||\n \nhas_ma1506\n \n||\n \nhas_ma1508e\n))\n \n\n\n\n\nis better.",
            "title": "Style Guide"
        },
        {
            "location": "/style/index.html#cs1010-c-style",
            "text": "In CS1010, you should following the following style guide when you write your code for your graded homework and practical exams.  We typically allocate a few marks for coding style (each assignment/exam may have different allocation).  You will lose marks for violation of style.  This guide is modified from past CS1010 style guide by Aaron Tan.",
            "title": "CS1010 C Style"
        },
        {
            "location": "/style/index.html#why-coding-style-is-important",
            "text": "Quote  \"It is not merely a matter of aesthetics that programs should be written in a particular style. Rather there is a psychological basis for writing programs in a conventional manner: programmers have strong expectations that other programmers will follow these discourse rules. If the rules are violated, then the utility afforded by the expectations that programmers have built up over time is effectively nullified. The results from the experiments with novice and advanced student programmers and with professional programmers described in this paper provide clear support for these claims.\"  Elliot Soloway and Kate Ehrlich. \"Empirical studies of programming knowledge.\" IEEE Transactions on Software Engineering 5 (1984): 595-609.",
            "title": "Why Coding Style is Important"
        },
        {
            "location": "/style/index.html#1-variable-declaration",
            "text": "Each variable should be declared in its own line.  1\n2 double   weight ;    // The weight of the baby  double   height ;    // The height of the baby    Avoid  1 double   weight ,   height ;     // Weight and height of the baby",
            "title": "1. Variable Declaration"
        },
        {
            "location": "/style/index.html#2-give-variables-descriptive-names",
            "text": "This is the most important rule to follow.  The name of a type, variable, function, constant should inform us of its purpose clearly without the readers having to guess or look up its meaning.  For example,  int number_of_coins;  is an appropriate variable but not  int c; . Avoid using a single character for variable names.  There are some exceptions, however, as shown below:   If the variable is the problem size and it is given in the task statement. For example, a problem dealing with n values, hence the variable may be called n (preferably with a comment to explain).  If the variable is a transient/temporary variable whose purpose is clear.\n-If the variable is a loop variable whose purpose is clear.",
            "title": "2. Give Variables Descriptive Names"
        },
        {
            "location": "/style/index.html#3-shorten-variable-names-with-naming-conventions",
            "text": "Despite the recommendation for descriptive names, identifiers can be short yet descriptive by using abbreviations and/or common naming conventions. For example,  MAX_LEN ,  num_of_elems ,  pcurr ,  table_num .  However, do not invent your own abbreviation. For instance, names like  nm_elemnts  should be avoided.",
            "title": "3. Shorten Variable Names with Naming Conventions"
        },
        {
            "location": "/style/index.html#4-avoid-negated-variable-or-function-names",
            "text": "Negated variables often result in hard-to-read double-negatives in an expression like  !is_not_err .  So, avoid  is_not_error ,  is_not_found ,  is_not_valid ,  cannot_open_file .  Instead, we prefer  is_error ,  is_found ,  is_valid ,  can_open_file  etc.",
            "title": "4. Avoid Negated Variable or Function Names"
        },
        {
            "location": "/style/index.html#5-use-define-to-define-constants-for-magic-numbers",
            "text": "Avoid direct use of magic numbers. Constant literals which have special meanings should be named and its named identifier should be used in its place. For example:  Avoid: 1\n2\n3 for   ( i   =   0 ;   i   <   100 ;   i   +=   1 )   { \n     :  }    Prefer: 1\n2\n3\n4\n5 #define MAX_LEN 100\n :\nfor (i = 0; i < MAX_LEN; i += 1) {\n    :\n}",
            "title": "5. Use #define to Define Constants for Magic Numbers"
        },
        {
            "location": "/style/index.html#6-naming-conventions",
            "text": "",
            "title": "6. Naming Conventions"
        },
        {
            "location": "/style/index.html#constants",
            "text": "All constant identifiers must be written in all caps and separated by an underscore  _ .  For instance  MAX_ITERATIONS ,  MAX_LEN ,  GOLDEN_RATIO ,  COLOR_DEFAULT ,  PI .",
            "title": "Constants"
        },
        {
            "location": "/style/index.html#variables-and-functions",
            "text": "Use lower case letters for variable names and function names, with multiple words separated by underscore  _ .  Example,  cs1010_read_long ,  is_prime .",
            "title": "Variables and Functions"
        },
        {
            "location": "/style/index.html#7-use-consistent-indentation-to-emphasize-block-structure",
            "text": "The code should be properly and neatly indented to emphasize the nested logical structure of the program. An indentation of 2 or 4 spaces is recommended (8 is too wide).  Every block that follows a  for ,  while ,  if-else ,  do-while  statement must be indented from its enclosing block.  Comments within a block should follow the indentation level of its enclosing block. For example,  1\n2\n3\n4\n5\n6\n7 for   ( i   =   0 ;   i   <   3 ;   i   +=   1 )   {    \n     // Comments should be indented too \n     while   ( j   !=   i )   { \n         // More indented comments \n         printf ( \"Hello \\n \" ); \n     }  }    The following are the wrong ways to indent the comments.  1\n2\n3\n4\n5\n6\n7 for   ( i   =   0 ;   i   <   3 ;   i   +=   1 )   {  // This comment should be indented and aligned with the while statement. \n     while   ( j   !=   i )   { \n     // This comment should be aligned with the printf statement. \n         printf ( \"Hello \\n \" ); \n     }  }",
            "title": "7. Use Consistent Indentation to Emphasize Block Structure"
        },
        {
            "location": "/style/index.html#8-dont-mix-tabs-and-spaces",
            "text": "You must use only spaces in your code.  Do not use tabs.  You can add the configuration  set expandtab  to automatically expand any tab that you enter into spaces.",
            "title": "8. Don't Mix Tabs and Spaces"
        },
        {
            "location": "/style/index.html#9-spaces-in-if-else-for-while-do-while-statements",
            "text": "Add a single space between the keywords  if , else ,  for ,  while  and the following parentheses and between the parentheses and next curly bracket.  For instance:  1\n2\n3 for( ... ) { // not good\nfor( ... ){ // not good\nfor ( ... ) { // good",
            "title": "9. Spaces in if, else, for, while, do-while Statements"
        },
        {
            "location": "/style/index.html#10-spaces-in-assignments",
            "text": "Add a single space before and after  = .  1\n2\n3 a= b; // no\na =b; // no\na = b; // OK!",
            "title": "10. Spaces in Assignments"
        },
        {
            "location": "/style/index.html#11-positions-of-open-and-close-braces",
            "text": "There are two camps on the position of open braces. The following shows the \"trailing open braces\":  1\n2\n3\n4\n5 for   ( i   =   0 ;   i   <   3 ;   i   +=   1 )   { \n     while   ( j   !=   i )   { \n         printf ( \"Hello \\n \" ); \n     }  }    The following shows the \"leading open braces\". The leading open brace must be aligned with the block of the construct it is in:  1\n2\n3\n4\n5\n6\n7 for   ( i   =   0 ;   i   <   3 ;   i   +=   1 )   { \n     while   ( j   !=   i )  \n     { \n         printf ( \"Hello \\n \" ); \n     }  }    Both styles are acceptable, but you should be consistent and should not mix both styles in a single program.  For close braces, they should be leading close braces aligned with the block of the construct. Close braces should NOT be trailing as that would make it hard to spot them.",
            "title": "11. Positions of Open and Close Braces"
        },
        {
            "location": "/style/index.html#12-comment-major-code-segments-adequately",
            "text": "Major segments of code should have explanatory comments. A major segment may be a loop block or a function block.  You should comment on complicated logic, expressions, or algorithms, explaining what you are doing in the code, including why and how.  An \"if\" block with a complex condition or an expression that is hard to understand should have explanatory comments.  For example,  1\n2\n3\n4 // Check and reject out-of-bounds indices  if   ( k   <   0   ||   k   >=   MAX_LEN )   { \n     return   - 1 ;  }",
            "title": "12. Comment Major Code Segments Adequately"
        },
        {
            "location": "/style/index.html#13-avoid-superfluous-comments",
            "text": "A comment such as:  1 i   +=   1   // add one to i    serves no purpose, adds clutter to a program and does more harm than good.",
            "title": "13. Avoid Superfluous Comments"
        },
        {
            "location": "/style/index.html#14-blank-lines",
            "text": "It is good to add a blank line between two functions, or two long segments of code for readability.  1\n2\n3\n4\n5\n6\n7\n8\n9 // This function ...  int   f ( int   x )   { \n     // body  }  // This function ...  int   g ( double   y )   { \n     // body  }     1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10 // Statements 1 to 10 belong to a sub-task  statement1 ;  statement2 ; \n    :  statement10 ;  // Leave a blank line for readability  statement11 ;  statement12 ; \n    :    However, guard against the use of excessive blank lines. Double blank lines and triply blank lines, or more, should not be present.",
            "title": "14. Blank Lines"
        },
        {
            "location": "/style/index.html#15-long-lines",
            "text": "If a line (be it a statement or a comment) is too long (more than 80 characters), do not let it run through the screen and wrap around. Instead, split it into a few lines.  1 if   (( has_cs2010   ||   has_cs2020   ||   has_cs2040   ||   has_cs2040C )   &&   ( has_st1232   ||   has_st2131   ||   has_st2132   ||   has_st2334 )   &&   ( has_ma1102R   ||   has_ma1505   ||   ( has_ma1511   &&   has_ma1512 )   ||   has_ma1521 )   &&   ( has_ma1101R   ||   has_ma1311   ||   has_ma1506   ||   has_ma1508E ))    \nis bad  1\n2\n3\n4 if   (( has_cs2010   ||   has_cs2020   ||   has_cs2040   ||   has_cs2040c )   &&  \n    ( has_st1232   ||   has_st2131   ||    has_st2132   ||   has_st2334 )   &&  \n    ( has_ma1102r   ||   has_ma1505   ||   ( has_ma1511   &&   has_ma1512 )   ||   has_ma1521 )   &&     \n    ( has_ma1101r   ||   has_ma1311   ||   has_ma1506   ||   has_ma1508e ))    \nis better.",
            "title": "15. Long Lines"
        },
        {
            "location": "/readings/index.html",
            "text": "Readings\n\n\nMust Read\n\n\n\n\nHow NOT to Go About a Programming Assignment\n, by Agustin Cernuda del Rio. \nComputer programming students invariably fall into more than one bad habit. It can be extremely difficult to eradicate them (and many lecturers and professional programmers keep succumbing to them time and again)..\n\n\nBest Teacher I Ever Had\n, by David Owen.  \nMr. Whitson taught sixth-grade science. On the first day of class, he gave us a lecture about a creature called the cattywampus, ..\n\n\n\n\nWhy C?\n\n\n\n\nLearn C programming and the rest will come, by Marty Jacobs\n\n\nThe Resurgence of C Programming, by Mark Barlow\n\n\nYou Can't Dig Upwards, by Evan Miller\n\n\n\n\nVim\n\n\n\n\n\n\nTime to Drop Emacs and Vi?\n on StackOverflow.  \"\nProgrammers are notorious for using the tools that helps them get the job done in the most efficient way possible. These editors are ancient yet still being used because they are good, solid editors, proven by time. If they get the job done and get the job done well, why should we drop them in favor of something else?\n\"\n\n\n\n\n\n\nWhat are the benefits of learning Vim?\n on Stack Overflow.  \"\nUsually vim's killer features are considered: A) that it's available on pretty much every Unix you'll ever encounter and B) your fingers very rarely have to leave the home row, which means you'll be able to edit text very, very quickly. It's also usually very fast and lightweight even when editing huge files.\n\"\n\n\n\n\n\n\nLearn \nvim\n Progressively\n \"\nI suggest you teach yourself Vim in 4 steps: 1. Survive. 2.  Feel comfortable. 3.  Feel Better, Stronger, Faster. 4.  Use superpowers of vim\n\"\n\n\n\n\n\n\nWhere Vim Came From\n -- from TwoBitHistory.  \"\nPerhaps more importantly, while we\u2019re asking questions, why does exiting Vim involve typing :wq? Sure, it\u2019s a \u201cwrite\u201d operation followed by a \u201cquit\u201d operation, but that is not a particularly intuitive convention. Who decided that copying text should instead be called \u201cyanking\u201d? Why is :%s/foo/bar/gc short for \u201cfind and replace\u201d? Vim\u2019s idiosyncrasies seem too arbitrary to have been made up, but then where did they come from?\"\n\n\n\n\n\n\nVim's Big Idea\n - by Mike Kozlowski. \n\"This philosophy of minimalist commands that can be composed together is the fundamental originating philosophy of Unix, and Vim exemplifies it like no other editor.\"\n\n\n\n\n\n\nVIM Pays Excellent Dividends\n - by John Bjorn Nelson.  \n\"Being conservative, let\u2019s say it makes you 5% more productive. More specifically\u200a\u2014\u200aonce your brain maps the keystrokes to muscle memory\u200a\u2014\u200ait makes you 5% faster at completing the mundane tasks\u2026the ones which dominate programming. That added productivity snowballs. It\u2019s an extra twenty minutes a day to build or explore (or learn), that used to go to copy/paste-like operations.\"\n\n\n\n\n\n\nThe Powers of VIM\n - by Artem Dudarev\n\n\n\n\n\n\nThe 11 Steps to Learning Vim\n - by \ndamassi\n. \n\"Regardless of the initial confusion and difficulty in getting started, you're making your future developer self immensely more productive by diving in and taking the plunge. Seriously. I'm just a few weeks in right now and I can positively say that learning Vim has been the best work-related decision of my life. It's fun, and in the strangest of ways it makes you think better.\"\n\n\n\n\n\n\nVim for People Who Think Things like Vim and Weird and Hard\n - by \nHarry Roberts\n. \n\"the fact that, yes, people still use an editor that is over 20 years old (in turn based on a tool from the 70s), and those people number in the hundreds of thousands, perhaps they might be onto something.\"\n\n\n\n\n\n\nWhy I use Vim\n - Pascal Precht. \"_once I was able to do some basic operations in Vim and actually started working again, I made almost as twice as much progress at work in about half the time. I know that sounds kind of crazy but I\u2019m serious. And that convinced me that I made the right choice.\n\n\n\n\n\n\nSo, do yourself a favor and climb that mountain. Just remember that you can slide down afterwards._\"\n\n\nVim Video Tutorial (from Aaron Tan)\n\n\n\n\nLesson 1\n\n\nLesson 2\n\n\nLesson 3\n\n\nLesson 4",
            "title": "Readings"
        },
        {
            "location": "/readings/index.html#readings",
            "text": "",
            "title": "Readings"
        },
        {
            "location": "/readings/index.html#must-read",
            "text": "How NOT to Go About a Programming Assignment , by Agustin Cernuda del Rio.  Computer programming students invariably fall into more than one bad habit. It can be extremely difficult to eradicate them (and many lecturers and professional programmers keep succumbing to them time and again)..  Best Teacher I Ever Had , by David Owen.   Mr. Whitson taught sixth-grade science. On the first day of class, he gave us a lecture about a creature called the cattywampus, ..",
            "title": "Must Read"
        },
        {
            "location": "/readings/index.html#why-c",
            "text": "Learn C programming and the rest will come, by Marty Jacobs  The Resurgence of C Programming, by Mark Barlow  You Can't Dig Upwards, by Evan Miller",
            "title": "Why C?"
        },
        {
            "location": "/readings/index.html#vim",
            "text": "Time to Drop Emacs and Vi?  on StackOverflow.  \" Programmers are notorious for using the tools that helps them get the job done in the most efficient way possible. These editors are ancient yet still being used because they are good, solid editors, proven by time. If they get the job done and get the job done well, why should we drop them in favor of something else? \"    What are the benefits of learning Vim?  on Stack Overflow.  \" Usually vim's killer features are considered: A) that it's available on pretty much every Unix you'll ever encounter and B) your fingers very rarely have to leave the home row, which means you'll be able to edit text very, very quickly. It's also usually very fast and lightweight even when editing huge files. \"    Learn  vim  Progressively  \" I suggest you teach yourself Vim in 4 steps: 1. Survive. 2.  Feel comfortable. 3.  Feel Better, Stronger, Faster. 4.  Use superpowers of vim \"    Where Vim Came From  -- from TwoBitHistory.  \" Perhaps more importantly, while we\u2019re asking questions, why does exiting Vim involve typing :wq? Sure, it\u2019s a \u201cwrite\u201d operation followed by a \u201cquit\u201d operation, but that is not a particularly intuitive convention. Who decided that copying text should instead be called \u201cyanking\u201d? Why is :%s/foo/bar/gc short for \u201cfind and replace\u201d? Vim\u2019s idiosyncrasies seem too arbitrary to have been made up, but then where did they come from?\"    Vim's Big Idea  - by Mike Kozlowski.  \"This philosophy of minimalist commands that can be composed together is the fundamental originating philosophy of Unix, and Vim exemplifies it like no other editor.\"    VIM Pays Excellent Dividends  - by John Bjorn Nelson.   \"Being conservative, let\u2019s say it makes you 5% more productive. More specifically\u200a\u2014\u200aonce your brain maps the keystrokes to muscle memory\u200a\u2014\u200ait makes you 5% faster at completing the mundane tasks\u2026the ones which dominate programming. That added productivity snowballs. It\u2019s an extra twenty minutes a day to build or explore (or learn), that used to go to copy/paste-like operations.\"    The Powers of VIM  - by Artem Dudarev    The 11 Steps to Learning Vim  - by  damassi .  \"Regardless of the initial confusion and difficulty in getting started, you're making your future developer self immensely more productive by diving in and taking the plunge. Seriously. I'm just a few weeks in right now and I can positively say that learning Vim has been the best work-related decision of my life. It's fun, and in the strangest of ways it makes you think better.\"    Vim for People Who Think Things like Vim and Weird and Hard  - by  Harry Roberts .  \"the fact that, yes, people still use an editor that is over 20 years old (in turn based on a tool from the 70s), and those people number in the hundreds of thousands, perhaps they might be onto something.\"    Why I use Vim  - Pascal Precht. \"_once I was able to do some basic operations in Vim and actually started working again, I made almost as twice as much progress at work in about half the time. I know that sounds kind of crazy but I\u2019m serious. And that convinced me that I made the right choice.    So, do yourself a favor and climb that mountain. Just remember that you can slide down afterwards._\"",
            "title": "Vim"
        },
        {
            "location": "/readings/index.html#vim-video-tutorial-from-aaron-tan",
            "text": "Lesson 1  Lesson 2  Lesson 3  Lesson 4",
            "title": "Vim Video Tutorial (from Aaron Tan)"
        },
        {
            "location": "/environments/index.html",
            "text": "The CS1010 Programming Environment\n\n\nC is a common programming language and you can find different implementations of C compiler on many platforms.  Wikipedia \nlists more than 40 different C compilers\n.  These different compilers support different processor architecture, operating system, may behave slightly differently, and may support different features of C standards.  It is therefore important for CS1010 to stick to a single platform and single compiler.\n\n\nOur platform of choice is \nUbuntu 16.04 (or later)\n using the \nclang\n compiler (\nversion 3.4.2 or later\n).\n\n\nThe school has provided a list of computing servers for you to use.  You can access them remotely via \nssh\n, or secure shell.  The hosts are named \npe111\n, \npe112\n, ..., \npe120\n.  (\npe\n stands for \"programming environment\").\n\n\nYou can choose which of the 10 hosts to use.  You share the same home directory across all 10 hosts (this home directory, however, is different from that of \nsunfire\n).\n\n\nFor simplicity, the following guide uses \npe111\n in all examples.  Do keep in mind that you can use other hosts for CS1010 to spread out the load.\n\n\nWhile it is possible for you to complete the programming assignments on your own computers, the practical exams are done in a controlled environment using the desktop PCs in the programming labs.  It is therefore advisable for you to familiarize with accessing remote computing servers via \nssh\n and edit your program with either \nvim\n or \nmacro\n.\n\n\nBasic Requirements\n\n\n\n\n\n\nYou need to have an SoC UNIX account.  If you do not have one, you can \napply for one online\n.\n\n\n\n\n\n\nOnce you have an account, you need to [activate your access to the PE hosts] (\nhttps://mysoc.nus.edu.sg/~myacct/services.cgi\n), which is part of the SoC computer clusters.\n\n\n\n\n\n\nYou need an \nssh\n client.  MacOS and Linux users should already have it installed by default.  Windows 10 users should install \nthe Windows Subsystem for Linux\n and use Linux.\n\n\n\n\n\n\nFor older versions of Windows, such as those used in the SoC's programming labs, you can check out \nXShell 6\n (free for home/school use), or \nPuTTY\n.  These are GUI-based programs so the command lines instructions below do not apply.\n\n\nThe Command to SSH\n\n\nRun:\n\n1\nssh <username>@pe111.comp.nus.edu.sg\n\n\n\n\n\nReplace \n<username>\n with your SoC UNIX username, for instance, I would do:\n\n1\nssh ooiwt@pe111.comp.nus.edu.sg\n\n\n\n\n\nAfter the command above, following the instructions on the screen.  The first time you ever connect to \npe111.comp.nus.edu.sg\n, you will be warned that you are connecting to a previously unknown host.  Say \nyes\n, and you will be prompted with your SoC UNIX password.\n\n\nAccessing The PE Hosts from Outside SoC\n\n\nThe PE hosts can only be accessed from within the School of Computing networks.  If you want to access it from outside, there are two ways.\n\n\nUsing SoC VPN\n\n\nOne way is to set up a Virtual Private Network (VPN) (See \ninstruction here\n).  The staff at \nhelpdesk@comp.nus.edu.sg\n or the IT helpdesk in COM1, Level 1, will be able to help with you setting up if needed.\n\n\nTunneling through Sunfire\n\n\nThe alternative is to use ssh tunnels.\n\n\nSoC's Sunfire (\nsunfire.comp.nus.edu.sg\n) is configured to allow your connection if it's originating from a local telco. (See \nmore details here\n.)  Since \nsunfire\n is situated within the School of Computing network, \nsunfire\n is able to access the VM.  This opens the possibility of connecting from your device (using an Internet connection from a local telco) to \nsunfire\n, and then from \nsunfire\n to the VM.\n\n\nThere are two ways to achieve this, and in both ways it appears to the PE hosts that Sunfire is the client.\n\n\nSSH Using Sunfire's Terminal\n\n\nConnect to Sunfire at \nsunfire.comp.nus.edu.sg\n via your favorite SSH client.  After logging in, run the command \nssh pe111\n to connect to the programming environment.  This effectively starts an SSH session to the programming environment from within your existing SSH session to Sunfire.  Refer to instructions below on how to connect via SSH.\n\n\nSSH Port Forwarding\n\n\nSSH has built-in support for local and remote port forwarding, and local port forwarding can be used to connect to the programming environments.  Local port forwarding means that a port of the SSH client (your machine) is forwarded to the SSH server (\nsunfire\n), which opens a connection to a preset destination server (e.g., \npe111\n).  This method causes the host to seem as if it is hosted on a local port, e.g. \nlocalhost\n:\n1010\n, allowing you to use your favorite SCP program (e.g. \nFileZilla\n) to access the PE host.\n\n\nTo use local port forwarding (from local port \n1010\n), connect to \nsunfire\n using\n\n1\nssh -L 1010:pe111.comp.nus.edu.sg:22 <username>@sunfire.comp.nus.edu.sg\n\n\n\n\nThis command opens an SSH tunnel from port \n1010\n of your machine to port \n22\n (the default SSH port) of \npe111.comp.nus.edu.sg\n via \nsunfire\n.  After successful login, open a separate SSH (or SCP) connection from your machine to \nlocalhost\n at port \n1010\n to access the PE host:\n\n\n1\nssh <username>@localhost -p 1000\n\n\n\n\n\n\nPuTTY\n supports SSH port forwarding, so this setup can also be used on Windows.\n\n\nSetting up SSH Keys\n\n\nOnce you are comfortable with UNIX, you can set up a pair of public/private keys for authentication.  \n\n\nYou can use\n\n1\nssh-keygen -t rsa\n\n\n\n\n\nto generate a pair of keys on your local computer.  Keep the private key \nid_rsa\n on your local machine in the hidden \n~/.ssh\n directory, and copy the public key \nid_rsa.pub\n to your home directory on PE \npe111\n.  On \npe111\n, run\n\n1\ncat id_rsa.pub >> ~/.ssh/authorized_keys\n\n\n\n\n\nMake sure that the permission for \n.ssh\n both on local machine and on PE is set to \n700\n and the files \nid_rsa\n on local machine and \nauthorized_keys\n on remote machine is set to \n600\n.  Once setup, you need not enter your password every time you run \nssh\n or \nscp\n.",
            "title": "Programming Environments"
        },
        {
            "location": "/environments/index.html#the-cs1010-programming-environment",
            "text": "C is a common programming language and you can find different implementations of C compiler on many platforms.  Wikipedia  lists more than 40 different C compilers .  These different compilers support different processor architecture, operating system, may behave slightly differently, and may support different features of C standards.  It is therefore important for CS1010 to stick to a single platform and single compiler.  Our platform of choice is  Ubuntu 16.04 (or later)  using the  clang  compiler ( version 3.4.2 or later ).  The school has provided a list of computing servers for you to use.  You can access them remotely via  ssh , or secure shell.  The hosts are named  pe111 ,  pe112 , ...,  pe120 .  ( pe  stands for \"programming environment\").  You can choose which of the 10 hosts to use.  You share the same home directory across all 10 hosts (this home directory, however, is different from that of  sunfire ).  For simplicity, the following guide uses  pe111  in all examples.  Do keep in mind that you can use other hosts for CS1010 to spread out the load.  While it is possible for you to complete the programming assignments on your own computers, the practical exams are done in a controlled environment using the desktop PCs in the programming labs.  It is therefore advisable for you to familiarize with accessing remote computing servers via  ssh  and edit your program with either  vim  or  macro .",
            "title": "The CS1010 Programming Environment"
        },
        {
            "location": "/environments/index.html#basic-requirements",
            "text": "You need to have an SoC UNIX account.  If you do not have one, you can  apply for one online .    Once you have an account, you need to [activate your access to the PE hosts] ( https://mysoc.nus.edu.sg/~myacct/services.cgi ), which is part of the SoC computer clusters.    You need an  ssh  client.  MacOS and Linux users should already have it installed by default.  Windows 10 users should install  the Windows Subsystem for Linux  and use Linux.    For older versions of Windows, such as those used in the SoC's programming labs, you can check out  XShell 6  (free for home/school use), or  PuTTY .  These are GUI-based programs so the command lines instructions below do not apply.",
            "title": "Basic Requirements"
        },
        {
            "location": "/environments/index.html#the-command-to-ssh",
            "text": "Run: 1 ssh <username>@pe111.comp.nus.edu.sg   Replace  <username>  with your SoC UNIX username, for instance, I would do: 1 ssh ooiwt@pe111.comp.nus.edu.sg   After the command above, following the instructions on the screen.  The first time you ever connect to  pe111.comp.nus.edu.sg , you will be warned that you are connecting to a previously unknown host.  Say  yes , and you will be prompted with your SoC UNIX password.",
            "title": "The Command to SSH"
        },
        {
            "location": "/environments/index.html#accessing-the-pe-hosts-from-outside-soc",
            "text": "The PE hosts can only be accessed from within the School of Computing networks.  If you want to access it from outside, there are two ways.",
            "title": "Accessing The PE Hosts from Outside SoC"
        },
        {
            "location": "/environments/index.html#using-soc-vpn",
            "text": "One way is to set up a Virtual Private Network (VPN) (See  instruction here ).  The staff at  helpdesk@comp.nus.edu.sg  or the IT helpdesk in COM1, Level 1, will be able to help with you setting up if needed.",
            "title": "Using SoC VPN"
        },
        {
            "location": "/environments/index.html#tunneling-through-sunfire",
            "text": "The alternative is to use ssh tunnels.  SoC's Sunfire ( sunfire.comp.nus.edu.sg ) is configured to allow your connection if it's originating from a local telco. (See  more details here .)  Since  sunfire  is situated within the School of Computing network,  sunfire  is able to access the VM.  This opens the possibility of connecting from your device (using an Internet connection from a local telco) to  sunfire , and then from  sunfire  to the VM.  There are two ways to achieve this, and in both ways it appears to the PE hosts that Sunfire is the client.",
            "title": "Tunneling through Sunfire"
        },
        {
            "location": "/environments/index.html#ssh-using-sunfires-terminal",
            "text": "Connect to Sunfire at  sunfire.comp.nus.edu.sg  via your favorite SSH client.  After logging in, run the command  ssh pe111  to connect to the programming environment.  This effectively starts an SSH session to the programming environment from within your existing SSH session to Sunfire.  Refer to instructions below on how to connect via SSH.",
            "title": "SSH Using Sunfire's Terminal"
        },
        {
            "location": "/environments/index.html#ssh-port-forwarding",
            "text": "SSH has built-in support for local and remote port forwarding, and local port forwarding can be used to connect to the programming environments.  Local port forwarding means that a port of the SSH client (your machine) is forwarded to the SSH server ( sunfire ), which opens a connection to a preset destination server (e.g.,  pe111 ).  This method causes the host to seem as if it is hosted on a local port, e.g.  localhost : 1010 , allowing you to use your favorite SCP program (e.g.  FileZilla ) to access the PE host.  To use local port forwarding (from local port  1010 ), connect to  sunfire  using 1 ssh -L 1010:pe111.comp.nus.edu.sg:22 <username>@sunfire.comp.nus.edu.sg  \nThis command opens an SSH tunnel from port  1010  of your machine to port  22  (the default SSH port) of  pe111.comp.nus.edu.sg  via  sunfire .  After successful login, open a separate SSH (or SCP) connection from your machine to  localhost  at port  1010  to access the PE host:  1 ssh <username>@localhost -p 1000   PuTTY  supports SSH port forwarding, so this setup can also be used on Windows.",
            "title": "SSH Port Forwarding"
        },
        {
            "location": "/environments/index.html#setting-up-ssh-keys",
            "text": "Once you are comfortable with UNIX, you can set up a pair of public/private keys for authentication.    You can use 1 ssh-keygen -t rsa   to generate a pair of keys on your local computer.  Keep the private key  id_rsa  on your local machine in the hidden  ~/.ssh  directory, and copy the public key  id_rsa.pub  to your home directory on PE  pe111 .  On  pe111 , run 1 cat id_rsa.pub >> ~/.ssh/authorized_keys   Make sure that the permission for  .ssh  both on local machine and on PE is set to  700  and the files  id_rsa  on local machine and  authorized_keys  on remote machine is set to  600 .  Once setup, you need not enter your password every time you run  ssh  or  scp .",
            "title": "Setting up SSH Keys"
        },
        {
            "location": "/unix/index.html",
            "text": "Basic UNIX Commands\n\n\nUNIX-based operating systems provide a command line to interact with the system: to create directory, to manipulate files, to run certain applications.  While these tasks can be done through a GUI interface, a command line is still useful because (i) it provides a simple way to interacting with a remote system (only text are exchanged between the local and remote hosts instead of graphics); (ii) it is extremely flexible and provides many customization options; (iii) you can easily automate the sequence of commands to issue for repetitive tasks; and (iv) it is faster.  \n\n\nConnect to the Programming Environment (PE)\n\n\nIf you would like to follow the following examples, you should first \nssh\n into one of the PE hosts provided.  We will use \npe111\n in the following example.  But feel free to use \npe112\n up to \npe120\n for your practice.  You should read \nthis guide\n to see how to access and connect to the environment.\n\n\nOnce you are connected, you should see a prompt like this.\n\n\n1\nooiwt@pe111:~$\n\n\n\n\n\n\nThis interface is provided by a UNIX bash -- this shell sits in a loop and wait for users to enter a command, then it interprets and executes the command.  There are many versions of shells, the default shell for our PE is \nbash\n1\n.\n\n\nThe following is adapted for CS1010 from \nthe instructions created by Aaron Tan\n. Bugs are mine.\n  \n\n\nThe power of UNIX stems from the many commands it offers. The following are a few commonly used commands. This list is by no means exhaustive and you are urged to explore on your own. Note that UNIX commands are \ncase-sensitive\n.\n\n\nAll commands are to be entered after the UNIX prompt of the form\n\n\n1\nooiwt@pe111:~$\n\n\n\n\n\n\n~\n indicates that you are currently in your home directory.  The following examples assumes that user \nooiwt\n is logged into \npe111\n.\n\n\nIt might be good to understand the directory structure in UNIX, a multi-user system. The directory tree is shown below:\n\n\n\n\nEach user has his/her own home directory, which is where he/she will be automatically placed when he/she logs into the system. The above figure shows where the home directory of user \nooiwt\n resides in the directory tree. The user \nooiwt\n may create files or directories in his/her home directory, but not elsewhere unless permission is given.\n\n\npwd\n: Print Current Working directory\n\n\npwd\n shows you which directory you are currently in\n\n1\n2\nooiwt@pe111:~$ pwd\n/home/o/ooiwt\n\n\n\n\n\nUNIX uses forward slash \n/\n to deliminate different parts of the directory structure.  This is the same notation as URLs so you should already be familiar with it.\n\n\nls\n: LiSt files\n\n\nThe \nls\n list the files in the current working directory.\n\n\n1\n2\nooiwt@pe111:~$ ls\nooiwt@pe111:~$\n\n\n\n\n\n\nIf you do not have any regular files in your home directory, as you should when you first login, you should immediately return to the bash prompt.  \n\n\n\n\nRule of Silence\n\n\nUNIX follows the \nrule of silence\n: programs should not print unnecessary output, to allow other programs and users to easily parse the output from one program.  So, if \nls\n has nothing to list, it will list nothing (as oppose to, say, printing \"This is an empty directory.\")\n\n\n\n\nmkdir\n: MaKe a subDIRectory\n\n\nThe \nmkdir\n command creates a subdirectory with the given name in the current directory.\n\n\n1\n2\n3\n4\n5\nooiwt@pe111:~$ mkdir tut01\nooiwt@pe111:~$ ls\ntut01\nooiwt@pe111:~$ ls -F\ntut01/\n\n\n\n\n\n\nHere, you create a directory called \ntut01\n.  Now, when you \nls\n, you can see the directory listed.\n\n\nYou may also use \nls -F\n for more information (\n-F\n is one of the many \noptions\n/\nflags\n available for the \nls\n command. To see a complete list of the options, refer to the man pages, i.e., \nman ls\n.)\n\n\nThe slash \n/\n beside the filename tells you that the file is a directory (aka folder in Windows lingo). A normal file does not have a slash beside its name when \"ls -F\" is used.\n\n\nYou may also use the \nls -l\n command (hyphen el, not hyphen one) to display almost all the file information, include the size of the file and the date of modification.\n\n\n\n\nUse Up Arrow for Command History\n\n\nUNIX maintains a history of your previously executed UNIX commands, and you may use the up and down arrows to go through it. Press the up arrow until you find a previously executed UNIX command. You may then press Enter to execute it, or edit the command before executing it. This is handy when you need to repeatedly executed a long UNIX command.\n\n\n\n\ncd\n: Change Directory\n\n\nTo navigate in the directory tree, changing the current working directory from to another, we use the \ncd\n command.\n\n\n1\n2\nooiwt@pe111:~$ cd tut01\nooiwt@pe111:~/tut01$\n\n\n\n\nNote that the prompt changes to \n~/tut01\n to indicate that you are now in the \ntut01\n directory below your \nHOME\n directory.\n\n\nEntering \ncd\n alone brings you back to your \nHOME\n directory, i.e., the directory in which you started with when you first logged into the system.\n\n1\n2\nooiwt@pe111:~/tut01$ cd\nooiwt@pe111:~$\n\n\n\n\n\nTwo dots \n..\n refers to the parent directory.  So, alternatively, for the case above, since we are only one level down from the \nHOME\n, to return to home, we can alternatively use \ncd ..\n.\n\n\n1\n2\nooiwt@pe111:~/tut01$ cd ..\nooiwt@pe111:~$\n\n\n\n\n\n\nrmdir\n: ReMove a subDIRectory\n\n\nrmdir\n removes a subDIRectory in current directory -- note that a directory must be empty before it can be removed.\n\n\n1\n2\n3\n4\n5\nooiwt@pe111:~$ rmdir tut01\nooiwt@pe111:~$ ls -F\nooiwt@pe111:~$ mkdir tut01\nooiwt@pe111:~$ ls -F\ntut01/\n\n\n\n\n\n\ncp\n: CoPy files\n\n\n1\n2\n3\nooiwt@pe111:~/tut01$ cp ~cs1010/tut01/hello.c .\nooiwt@pe111:~/tut01$ ls\nhello.c\n\n\n\n\nThe command above copies the file \nhello.c\n from the HOME of user \ncs1010\n, under directory \ntut01\n, to the current directory.\n\n\nIf you want to copy the whole directory, use \n-r\n flag, where \nr\n stands for recursive copy.\n\n\n1\nooiwt@pe111:~/tut01$ cp -r ~cs1010/tut01 .\n\n\n\n\n\n\nIn the last command above, the single \n.\n refers to the current directory.  \n\n\nThe directory \ntut01\n and everything under it will be copied to the current directory.\n\n\nmv\n: MoVe or rename files\n\n\nmv\n can move files from one directory to another.\n\n\n1\n2\n3\n4\n5\n6\n7\nooiwt@pe111:~/tut01$ ls\nhello.c\nooiwt@pe111:~/tut01$ mv hello.c ..\nooiwt@pe111:~/tut01$ ls\nooiwt@pe111:~/tut01$ ls ..\nhello.c\nooiwt@pe111:~/tut01$ mv ../hello.c .\n\n\n\n\n\n\nHere, we tell \nmv\n to copy a file \nhello.c\n from the parent directory to the current directory.\n\n\nmv\n can also be used to rename files.\n\n\n1\n2\n3\nooiwt@pe111:~/tut01$ mv hello.c hello_world.c\nooiwt@pe111:~/tut01$ ls\nhello_world.c\n\n\n\n\n\n\n\n\nUse TAB for Name Completion\n\n\nIf you have a very long file name, you may use UNIX's filename completion feature to reduce typing. For instance, you may type:\n\n1\nooiwt@pe111:~/tut01$ mv h\n\n\n\n\nand press the tab key, and UNIX will complete the filename for you if there is only one filename with the prefix \"h\". Otherwise, it will fill up the filename up to point where you need to type in more characters for disambiguation.\nThe tab key can also complete the name of command.\n\n\n\n\nrm\n: ReMove files\n\n\nBe careful with this command -- files deleted cannot be restored.  There is no trash or recycled bin like in Mac or Windows.\n\n\n1\n2\n3\nooiwt@pe111:~/tut01$ rm hello.c\nooiwt@pe111:~/tut01$ ls\nooiwt@pe111:~/tut01$\n\n\n\n\n\n\n\n\nrm -rf *\n\n\nWhile UNIX command line provides lots of flexibility and power, with great power comes great responsibility.  Some of the commands are extremely dangerous.  \nrm -rf *\n is the most famous one.  The notation \n*\n refers to all files, and the flag \n-f\n means forceful deletion (no question asked!) and \n-r\n means remove recursively everything under the current directory tree.  Accidentally running this command has ruined many files.  \nRead more here\n\n\n\n\nrm\n comes with a \n-i\n flag that interactively ask you if you are sure if you want to delete a file.  It is a good idea to always run \nrm -i\n.  On \npe111\n, we have configured everyone's account so that \nrm\n is aliased to \nrm -i\n by default.  So when you run \nrm hello.c\n, it actually runs \nrm -i hello.c\n.  \n\n\n1\n2\nooiwt@pe111:~/tut01$ rm hello.c\nrm: remove regular file \n'hello.c'\n? \n\n\n\n\n\n\nType \ny\n or \nn\n to answer yes or no respectively.\n\n\nIf you setup your own UNIX OS, you should add this alias \n\n\n1\nalias\n \nrm\n=\n\"rm -i\"\n\n\n\n\n\n\n\nto your \n.bashrc\n (Google to find out how).  Other useful aliases to avoid accidentally overwriting existing files are:\n\n\n1\n2\nalias\n \nmv\n=\n\"mv -i\"\n\n\nalias\n \ncp\n=\n\"cp -i\"\n\n\n\n\n\n\n\ncat\n: CATenate file content to screen\n\n\n1\nooiwt@pe111:~/tut01$ cat hello.c\n\n\n\n\n\n\nless\n is variant of \ncat\n that includes features to read each page leisurely)\n\n1\nooiwt@pe111:~/tut01$ less hello.c\n\n\n\n\n\nIn \nless\n, use \n<space>\n to move down one page, \nb\n to move Back up one page, and \nq\n to Quit.\n\n\nman\n: Online MANual\n\n\nAn online help facility is available in UNIX via the \nman\n command (\nman\n stands for MANual). To look for more information about any UNIX command, for example, \nls\n, type \nman ls\n. Type \nman man\n and refer to Man Pages to find out more about the facility. To exit \nman\n, press \nq\n.\n\n\nNow that you are familiar with how the UNIX bash works, I won't show the command prompt any more in the rest of this article.\n\n\nchmod\n: Changing UNIX File Permission\n\n\nIt is important to guide our files properly on a multi-user system where users share the same file system.  UNIX has a simple mechanism to for ensuring that: every file and directory has nine bits of access permission, corresponds to three access operations, read (\nr\n), write (\nw\n), and execute (\nx\n), for four classes of users, the user who owns of the file (\nu\n), users in the same group as the owner (\ng\n), all other users (\no\n), and all users (\na\n) (union of all three classes before)\n\n\nWhen you run \nls -l\n, you will see the permission encoded as strings that look like \n-rw-------\n or \ndrwx--x--x\n besides other file information.   \n\n\n\n\nThe first character indicates if the file is a directory (\nd\n) or not (\n-\n).  \n\n\nThe next three characters are the permission for the owner.  \nrwx\n means that the owner can do all three: reading, writing, and executing, \nrw-\n means that the owner can read and write, but cannot execute.\n\n\nThe next three characters are the permission for the users in the same group.\n\n\nThe last three characters are the permission for the users in the other groups.\n\n\n\n\nTo change permission, we use the \nchmod\n command.  Let's say that we want to remove the read and write permission from all other users in the group.  You can run:\n\n\n1\nchmod g-rw <file>\n\n\n\n\n\n\nwhere \n<file>\n is the name of the file whose permission you want to change.  This would change the permission from \n-rw-rw-rw-\n to \n-rw----rw-\n, or from \n-rwxr--r--\n to \n-rwx---r--\n.\n\n\nTo add executable permission to everyone, you can run:\n\n\n1\nchmod a+x <file>\n\n\n\n\n\n\nThis would change the permission from \n-rw-rw-rw-\n to \n-rwx--xrwx\n \n-rwxrwxrwx\n, or from \n-rwxr--r--\n to \n-rwx--xr-x\n \n-rwxr-xr-x\n, and so on.  You get the idea.\n\n\nAnother way to change the permission is set the permission directly, instead of adding with \n+\n and removing with \n-\n.  To do this, one convenient way is to treat the permission for each class of user as a 3-bit binary number between 0 to 7.  So, \nrwx\n is 7, \nrw-\n is 6, \n-w-\n is 2, \n---\n is 0, etc.  \n\n\nTo set the permission of a file to \n-r--r--r--\n (readable by everyone), run:\n\n\n1\nchmod \n444\n <file>\n\n\n\n\n\n\nTo set the permission to \n-rw-------\n, run:\n\n\n1\nchmod \n600\n <file>\n\n\n\n\n\n\nand so on.\n\n\nIt is important to ensure that your code is not readable and writable by other students, especially for graded lab exercises.\n\n\nscp\n: Secure Copy\n\n\nSecure copy, or \nscp\n, is one way to transfer files from the programming environments to your local computer for archiving or storage.  Let's say you want to transfer a set of C files from the directory \na01\n to your local computer, then, on your local computer, run:\n\n\n1\nooiwt@macbook:~$ scp ooiwt@pe111:~/a01/*.c .\n\n\n\n\n\n\n\n\nWarning\n\n\nIf you have files with the same name in the remote directory, the files will be overwritten without warning.  I have lost my code a few times due to \nscp\n.  \n\n\n\n\nThe expression \n*.c\n is a \nregular expression\n that means all files with filename ending with \n.c\n.  You can copy specific files as well.  For instance,\n\n\n1\nooiwt@macbook:~$ scp ooiwt@pe111:~/a01/hello.c .\n\n\n\n\n\n\nscp\n supports \n-r\n (recursive copy) as well.\n\n\nSpecifying A Path in UNIX\n\n\nIn any command above, when we need to refer to a directory or a file, we need to specify an \nunambiguous location\n of the directory or the file.  The most precise way to specify the location is to use the full path, or the \nabsolute path\n.  For instance:\n\n\n1\ncp /home/o/ooiwt/tut01/hello.c /home/o/ooiwt/tut01/hello_world.c\n\n\n\n\n\n\nThat's a lot of characters to type.  We could shorten it in a few ways.  \n\n\n\n\nWe could specify the location with respect to the home directory using \n~\n.  \n~ooiwt\n refers to the home directory of user \nooiwt\n.  \n\n\n\n\n1\ncp ~ooiwt/tut01/hello.c ~ooiwt/tut01/hello_world.c\n\n\n\n\n\n\nIf you are \nooiwt\n, then you can omit \nooiwt\n, since \n~\n without any username refers to your home directory.\n\n\n1\ncp ~/tut01/hello.c ~/tut01/hello_world.c\n\n\n\n\n\n\n\n\nOr we could specify the location with respect to the current directory.  Suppose the current working directory is \n~/tut01\n (i.e., we have \ncd\n into \n~/tut01\n), then we could say this:\n\n\n\n\n1\ncp ./hello.c ./hello_world.c\n\n\n\n\n\n\nRecall that a single dot \n.\n refers to the current directory.\n\n\nThe \n./\n however is redundant unless you are executing a command.  Since, by specifying a file name or a directory without a path (i.e., not using any \n/\n), the bash looks for the file or directory in the current directory.  So, we could just do:\n\n\n1\ncp hello.c hello_world.c\n\n\n\n\n\n\nAnother important short form for relative location is \n..\n.  Recall that this refers to the parent directory.  Suppose that the current directory is in \n~/tut02\n.  Then, to copy the files in \n~/tut01\n, you can run:\n\n\n1\ncp ../tut01/hello.c ../tut01/hello_world.c\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nI run \nfish\n on my macOS, as you might have noticed during the in-class demos.  You can use any bash you like, if you know what you are doing.  Otherwise, \nbash\n is a popular one.\u00a0\n\u21a9",
            "title": "UNIX"
        },
        {
            "location": "/unix/index.html#basic-unix-commands",
            "text": "UNIX-based operating systems provide a command line to interact with the system: to create directory, to manipulate files, to run certain applications.  While these tasks can be done through a GUI interface, a command line is still useful because (i) it provides a simple way to interacting with a remote system (only text are exchanged between the local and remote hosts instead of graphics); (ii) it is extremely flexible and provides many customization options; (iii) you can easily automate the sequence of commands to issue for repetitive tasks; and (iv) it is faster.",
            "title": "Basic UNIX Commands"
        },
        {
            "location": "/unix/index.html#connect-to-the-programming-environment-pe",
            "text": "If you would like to follow the following examples, you should first  ssh  into one of the PE hosts provided.  We will use  pe111  in the following example.  But feel free to use  pe112  up to  pe120  for your practice.  You should read  this guide  to see how to access and connect to the environment.  Once you are connected, you should see a prompt like this.  1 ooiwt@pe111:~$   This interface is provided by a UNIX bash -- this shell sits in a loop and wait for users to enter a command, then it interprets and executes the command.  There are many versions of shells, the default shell for our PE is  bash 1 .  The following is adapted for CS1010 from  the instructions created by Aaron Tan . Bugs are mine.     The power of UNIX stems from the many commands it offers. The following are a few commonly used commands. This list is by no means exhaustive and you are urged to explore on your own. Note that UNIX commands are  case-sensitive .  All commands are to be entered after the UNIX prompt of the form  1 ooiwt@pe111:~$   ~  indicates that you are currently in your home directory.  The following examples assumes that user  ooiwt  is logged into  pe111 .  It might be good to understand the directory structure in UNIX, a multi-user system. The directory tree is shown below:   Each user has his/her own home directory, which is where he/she will be automatically placed when he/she logs into the system. The above figure shows where the home directory of user  ooiwt  resides in the directory tree. The user  ooiwt  may create files or directories in his/her home directory, but not elsewhere unless permission is given.",
            "title": "Connect to the Programming Environment (PE)"
        },
        {
            "location": "/unix/index.html#pwd-print-current-working-directory",
            "text": "pwd  shows you which directory you are currently in 1\n2 ooiwt@pe111:~$ pwd\n/home/o/ooiwt   UNIX uses forward slash  /  to deliminate different parts of the directory structure.  This is the same notation as URLs so you should already be familiar with it.",
            "title": "pwd: Print Current Working directory"
        },
        {
            "location": "/unix/index.html#ls-list-files",
            "text": "The  ls  list the files in the current working directory.  1\n2 ooiwt@pe111:~$ ls\nooiwt@pe111:~$   If you do not have any regular files in your home directory, as you should when you first login, you should immediately return to the bash prompt.     Rule of Silence  UNIX follows the  rule of silence : programs should not print unnecessary output, to allow other programs and users to easily parse the output from one program.  So, if  ls  has nothing to list, it will list nothing (as oppose to, say, printing \"This is an empty directory.\")",
            "title": "ls: LiSt files"
        },
        {
            "location": "/unix/index.html#mkdir-make-a-subdirectory",
            "text": "The  mkdir  command creates a subdirectory with the given name in the current directory.  1\n2\n3\n4\n5 ooiwt@pe111:~$ mkdir tut01\nooiwt@pe111:~$ ls\ntut01\nooiwt@pe111:~$ ls -F\ntut01/   Here, you create a directory called  tut01 .  Now, when you  ls , you can see the directory listed.  You may also use  ls -F  for more information ( -F  is one of the many  options / flags  available for the  ls  command. To see a complete list of the options, refer to the man pages, i.e.,  man ls .)  The slash  /  beside the filename tells you that the file is a directory (aka folder in Windows lingo). A normal file does not have a slash beside its name when \"ls -F\" is used.  You may also use the  ls -l  command (hyphen el, not hyphen one) to display almost all the file information, include the size of the file and the date of modification.   Use Up Arrow for Command History  UNIX maintains a history of your previously executed UNIX commands, and you may use the up and down arrows to go through it. Press the up arrow until you find a previously executed UNIX command. You may then press Enter to execute it, or edit the command before executing it. This is handy when you need to repeatedly executed a long UNIX command.",
            "title": "mkdir: MaKe a subDIRectory"
        },
        {
            "location": "/unix/index.html#cd-change-directory",
            "text": "To navigate in the directory tree, changing the current working directory from to another, we use the  cd  command.  1\n2 ooiwt@pe111:~$ cd tut01\nooiwt@pe111:~/tut01$  \nNote that the prompt changes to  ~/tut01  to indicate that you are now in the  tut01  directory below your  HOME  directory.  Entering  cd  alone brings you back to your  HOME  directory, i.e., the directory in which you started with when you first logged into the system. 1\n2 ooiwt@pe111:~/tut01$ cd\nooiwt@pe111:~$   Two dots  ..  refers to the parent directory.  So, alternatively, for the case above, since we are only one level down from the  HOME , to return to home, we can alternatively use  cd .. .  1\n2 ooiwt@pe111:~/tut01$ cd ..\nooiwt@pe111:~$",
            "title": "cd: Change Directory"
        },
        {
            "location": "/unix/index.html#rmdir-remove-a-subdirectory",
            "text": "rmdir  removes a subDIRectory in current directory -- note that a directory must be empty before it can be removed.  1\n2\n3\n4\n5 ooiwt@pe111:~$ rmdir tut01\nooiwt@pe111:~$ ls -F\nooiwt@pe111:~$ mkdir tut01\nooiwt@pe111:~$ ls -F\ntut01/",
            "title": "rmdir: ReMove a subDIRectory"
        },
        {
            "location": "/unix/index.html#cp-copy-files",
            "text": "1\n2\n3 ooiwt@pe111:~/tut01$ cp ~cs1010/tut01/hello.c .\nooiwt@pe111:~/tut01$ ls\nhello.c  \nThe command above copies the file  hello.c  from the HOME of user  cs1010 , under directory  tut01 , to the current directory.  If you want to copy the whole directory, use  -r  flag, where  r  stands for recursive copy.  1 ooiwt@pe111:~/tut01$ cp -r ~cs1010/tut01 .   In the last command above, the single  .  refers to the current directory.    The directory  tut01  and everything under it will be copied to the current directory.",
            "title": "cp: CoPy files"
        },
        {
            "location": "/unix/index.html#mv-move-or-rename-files",
            "text": "mv  can move files from one directory to another.  1\n2\n3\n4\n5\n6\n7 ooiwt@pe111:~/tut01$ ls\nhello.c\nooiwt@pe111:~/tut01$ mv hello.c ..\nooiwt@pe111:~/tut01$ ls\nooiwt@pe111:~/tut01$ ls ..\nhello.c\nooiwt@pe111:~/tut01$ mv ../hello.c .   Here, we tell  mv  to copy a file  hello.c  from the parent directory to the current directory.  mv  can also be used to rename files.  1\n2\n3 ooiwt@pe111:~/tut01$ mv hello.c hello_world.c\nooiwt@pe111:~/tut01$ ls\nhello_world.c    Use TAB for Name Completion  If you have a very long file name, you may use UNIX's filename completion feature to reduce typing. For instance, you may type: 1 ooiwt@pe111:~/tut01$ mv h  \nand press the tab key, and UNIX will complete the filename for you if there is only one filename with the prefix \"h\". Otherwise, it will fill up the filename up to point where you need to type in more characters for disambiguation.\nThe tab key can also complete the name of command.",
            "title": "mv: MoVe or rename files"
        },
        {
            "location": "/unix/index.html#rm-remove-files",
            "text": "Be careful with this command -- files deleted cannot be restored.  There is no trash or recycled bin like in Mac or Windows.  1\n2\n3 ooiwt@pe111:~/tut01$ rm hello.c\nooiwt@pe111:~/tut01$ ls\nooiwt@pe111:~/tut01$    rm -rf *  While UNIX command line provides lots of flexibility and power, with great power comes great responsibility.  Some of the commands are extremely dangerous.   rm -rf *  is the most famous one.  The notation  *  refers to all files, and the flag  -f  means forceful deletion (no question asked!) and  -r  means remove recursively everything under the current directory tree.  Accidentally running this command has ruined many files.   Read more here   rm  comes with a  -i  flag that interactively ask you if you are sure if you want to delete a file.  It is a good idea to always run  rm -i .  On  pe111 , we have configured everyone's account so that  rm  is aliased to  rm -i  by default.  So when you run  rm hello.c , it actually runs  rm -i hello.c .    1\n2 ooiwt@pe111:~/tut01$ rm hello.c\nrm: remove regular file  'hello.c' ?    Type  y  or  n  to answer yes or no respectively.  If you setup your own UNIX OS, you should add this alias   1 alias   rm = \"rm -i\"    to your  .bashrc  (Google to find out how).  Other useful aliases to avoid accidentally overwriting existing files are:  1\n2 alias   mv = \"mv -i\"  alias   cp = \"cp -i\"",
            "title": "rm: ReMove files"
        },
        {
            "location": "/unix/index.html#cat-catenate-file-content-to-screen",
            "text": "1 ooiwt@pe111:~/tut01$ cat hello.c   less  is variant of  cat  that includes features to read each page leisurely) 1 ooiwt@pe111:~/tut01$ less hello.c   In  less , use  <space>  to move down one page,  b  to move Back up one page, and  q  to Quit.",
            "title": "cat: CATenate file content to screen"
        },
        {
            "location": "/unix/index.html#man-online-manual",
            "text": "An online help facility is available in UNIX via the  man  command ( man  stands for MANual). To look for more information about any UNIX command, for example,  ls , type  man ls . Type  man man  and refer to Man Pages to find out more about the facility. To exit  man , press  q .  Now that you are familiar with how the UNIX bash works, I won't show the command prompt any more in the rest of this article.",
            "title": "man: Online MANual"
        },
        {
            "location": "/unix/index.html#chmod-changing-unix-file-permission",
            "text": "It is important to guide our files properly on a multi-user system where users share the same file system.  UNIX has a simple mechanism to for ensuring that: every file and directory has nine bits of access permission, corresponds to three access operations, read ( r ), write ( w ), and execute ( x ), for four classes of users, the user who owns of the file ( u ), users in the same group as the owner ( g ), all other users ( o ), and all users ( a ) (union of all three classes before)  When you run  ls -l , you will see the permission encoded as strings that look like  -rw-------  or  drwx--x--x  besides other file information.      The first character indicates if the file is a directory ( d ) or not ( - ).    The next three characters are the permission for the owner.   rwx  means that the owner can do all three: reading, writing, and executing,  rw-  means that the owner can read and write, but cannot execute.  The next three characters are the permission for the users in the same group.  The last three characters are the permission for the users in the other groups.   To change permission, we use the  chmod  command.  Let's say that we want to remove the read and write permission from all other users in the group.  You can run:  1 chmod g-rw <file>   where  <file>  is the name of the file whose permission you want to change.  This would change the permission from  -rw-rw-rw-  to  -rw----rw- , or from  -rwxr--r--  to  -rwx---r-- .  To add executable permission to everyone, you can run:  1 chmod a+x <file>   This would change the permission from  -rw-rw-rw-  to  -rwx--xrwx   -rwxrwxrwx , or from  -rwxr--r--  to  -rwx--xr-x   -rwxr-xr-x , and so on.  You get the idea.  Another way to change the permission is set the permission directly, instead of adding with  +  and removing with  - .  To do this, one convenient way is to treat the permission for each class of user as a 3-bit binary number between 0 to 7.  So,  rwx  is 7,  rw-  is 6,  -w-  is 2,  ---  is 0, etc.    To set the permission of a file to  -r--r--r--  (readable by everyone), run:  1 chmod  444  <file>   To set the permission to  -rw------- , run:  1 chmod  600  <file>   and so on.  It is important to ensure that your code is not readable and writable by other students, especially for graded lab exercises.",
            "title": "chmod: Changing UNIX File Permission"
        },
        {
            "location": "/unix/index.html#scp-secure-copy",
            "text": "Secure copy, or  scp , is one way to transfer files from the programming environments to your local computer for archiving or storage.  Let's say you want to transfer a set of C files from the directory  a01  to your local computer, then, on your local computer, run:  1 ooiwt@macbook:~$ scp ooiwt@pe111:~/a01/*.c .    Warning  If you have files with the same name in the remote directory, the files will be overwritten without warning.  I have lost my code a few times due to  scp .     The expression  *.c  is a  regular expression  that means all files with filename ending with  .c .  You can copy specific files as well.  For instance,  1 ooiwt@macbook:~$ scp ooiwt@pe111:~/a01/hello.c .   scp  supports  -r  (recursive copy) as well.",
            "title": "scp: Secure Copy"
        },
        {
            "location": "/unix/index.html#specifying-a-path-in-unix",
            "text": "In any command above, when we need to refer to a directory or a file, we need to specify an  unambiguous location  of the directory or the file.  The most precise way to specify the location is to use the full path, or the  absolute path .  For instance:  1 cp /home/o/ooiwt/tut01/hello.c /home/o/ooiwt/tut01/hello_world.c   That's a lot of characters to type.  We could shorten it in a few ways.     We could specify the location with respect to the home directory using  ~ .   ~ooiwt  refers to the home directory of user  ooiwt .     1 cp ~ooiwt/tut01/hello.c ~ooiwt/tut01/hello_world.c   If you are  ooiwt , then you can omit  ooiwt , since  ~  without any username refers to your home directory.  1 cp ~/tut01/hello.c ~/tut01/hello_world.c    Or we could specify the location with respect to the current directory.  Suppose the current working directory is  ~/tut01  (i.e., we have  cd  into  ~/tut01 ), then we could say this:   1 cp ./hello.c ./hello_world.c   Recall that a single dot  .  refers to the current directory.  The  ./  however is redundant unless you are executing a command.  Since, by specifying a file name or a directory without a path (i.e., not using any  / ), the bash looks for the file or directory in the current directory.  So, we could just do:  1 cp hello.c hello_world.c   Another important short form for relative location is  .. .  Recall that this refers to the parent directory.  Suppose that the current directory is in  ~/tut02 .  Then, to copy the files in  ~/tut01 , you can run:  1 cp ../tut01/hello.c ../tut01/hello_world.c       I run  fish  on my macOS, as you might have noticed during the in-class demos.  You can use any bash you like, if you know what you are doing.  Otherwise,  bash  is a popular one.\u00a0 \u21a9",
            "title": "Specifying A Path in UNIX"
        },
        {
            "location": "/clang/index.html",
            "text": "CS1010 Compilation Guide\n\n\n1. Compile a standalone C program\n\n\nSuppose we have a standalone C program \nteh.c\n that does not use any external libraries.  We can compile the program using the command\n\n\n1\nooiwt@pe118:~$ clang teh.c\n\n\n\n\n\n\nThis command should create an executable called \na.out\n in the current directory, which you can then run with:\n\n\n1\nooiwt@pe118:~$ ./a.out\n\n\n\n\n\n\n2. Renaming executable file\n\n\nThe name \na.out\n is an abbreviation for \nassembler output\n, a name that many compilers kept as the default output name since the 60s.  We should, however, give our executable more descriptive name, by using the \n-o\n flag.  (\no\n is the mnemonic for output).\n\n\n1\nooiwt@pe118:~$ clang teh.c -o teh\n\n\n\n\n\n\nor\n\n\n1\nooiwt@pe118:~$ clang -o teh teh.c\n\n\n\n\n\n\nThe command above would create an executable called \nteh\n.\n\n\n\n\nBeware of the order\n\n\nIf you are not careful and run the following command instead:\n\n1\nooiwt@pe118:~$ clang -o teh.c teh\n\n\n\n\n\nclang\n would overwrite your code \nteh.c\n -- all your hard work will be gone!!\n\n\n\n\n3. Warning for possible bugs.\n\n\nThe \nclang\n checks for syntax errors in your C files -- i.e., things that violate the C syntax rules.  The compiler, however, is smart enough to identify possible bugs -- errors that will cause your program to behave incorrectly, even if the syntax follows C's rules.  You can ask \nclang\n to warn you about this, using the \n-W\n flag (\nW\n is the mnemonic for warning -- note the capital W).  The manual for \nclang\n lists different types of warnings that \nclang\n can warn you about.  For simplicity, we will ask \nclang\n to warn us about everything, by enabling \nall\n warnings.  The command to do so is:\n\n\n1\nooiwt@pe118:~$ clang -Wall teh.c -o teh\n\n\n\n\n\n\nFor beginners, it is \nhighly recommended\n that you \nalways\n compile with \n-Wall\n flag.\n\n\n4. Generating additional information for debugging.\n\n\nIn order to use the debugger \nlldb\n to trace through and debug your program, \nclang\n needs to generate additional information and store them in the executable file.  We can instruct \nclang\n to generate them with the flag \n-g\n (\ng\n for generate).  \n\n\n1\nooiwt@pe118:~$ clang -Wall -g teh.c -o teh\n\n\n\n\n\n\nIt is recommended that you always compile with \n-g\n flags during development phase.  If you need to measure the performance (e.g., how fast it runs) of your program or when you are releasing the program to the public, you can remove the \n-g\n flag and compile with the optimization flags (e.g., \n-O\n) instead.  \n\n\n5. Linking with standard library.\n\n\nTo link with a standard library, we use the \n-l\n flag to specify the name of the library to link.  For instance, to link with the C standard math library (abbreviated \nm\n), you issue the command:\n\n\n1\nooiwt@pe118:~$ clang -Wall -g teh.c -o teh -lm\n\n\n\n\n\n\n6. Linking with 3\nrd\n party library\n\n\nBy default, \nclang\n looks for headers and libraries in the systems directories (\n/usr/include\n, \n/usr/lib\n, etc) and the current working directory.  \n\n\nIf you use a third party library, you usually need to tell \nclang\n where to look for the corresponding headers and libraries.  You can use the \n-I\n flag and the \n-L\n flag for these purposes. For instance, if you have a library installed under your home called \ncitadel\n, and the file \ncitadel.h\n can be found under \n~/citadel/include\n and the file \nlibcitadel.a\n can be found under \n~/citadel/lib\n, to tell \nclang\n where to find these files, you can compile with:\n\n\n1\nooiwt@pe118:~$ clang -Wall -g -I ~/citadel/include -L ~/citadel/lib teh.c -o teh -lm -lcitadel",
            "title": "CLang"
        },
        {
            "location": "/clang/index.html#cs1010-compilation-guide",
            "text": "",
            "title": "CS1010 Compilation Guide"
        },
        {
            "location": "/clang/index.html#1-compile-a-standalone-c-program",
            "text": "Suppose we have a standalone C program  teh.c  that does not use any external libraries.  We can compile the program using the command  1 ooiwt@pe118:~$ clang teh.c   This command should create an executable called  a.out  in the current directory, which you can then run with:  1 ooiwt@pe118:~$ ./a.out",
            "title": "1. Compile a standalone C program"
        },
        {
            "location": "/clang/index.html#2-renaming-executable-file",
            "text": "The name  a.out  is an abbreviation for  assembler output , a name that many compilers kept as the default output name since the 60s.  We should, however, give our executable more descriptive name, by using the  -o  flag.  ( o  is the mnemonic for output).  1 ooiwt@pe118:~$ clang teh.c -o teh   or  1 ooiwt@pe118:~$ clang -o teh teh.c   The command above would create an executable called  teh .   Beware of the order  If you are not careful and run the following command instead: 1 ooiwt@pe118:~$ clang -o teh.c teh   clang  would overwrite your code  teh.c  -- all your hard work will be gone!!",
            "title": "2. Renaming executable file"
        },
        {
            "location": "/clang/index.html#3-warning-for-possible-bugs",
            "text": "The  clang  checks for syntax errors in your C files -- i.e., things that violate the C syntax rules.  The compiler, however, is smart enough to identify possible bugs -- errors that will cause your program to behave incorrectly, even if the syntax follows C's rules.  You can ask  clang  to warn you about this, using the  -W  flag ( W  is the mnemonic for warning -- note the capital W).  The manual for  clang  lists different types of warnings that  clang  can warn you about.  For simplicity, we will ask  clang  to warn us about everything, by enabling  all  warnings.  The command to do so is:  1 ooiwt@pe118:~$ clang -Wall teh.c -o teh   For beginners, it is  highly recommended  that you  always  compile with  -Wall  flag.",
            "title": "3. Warning for possible bugs."
        },
        {
            "location": "/clang/index.html#4-generating-additional-information-for-debugging",
            "text": "In order to use the debugger  lldb  to trace through and debug your program,  clang  needs to generate additional information and store them in the executable file.  We can instruct  clang  to generate them with the flag  -g  ( g  for generate).    1 ooiwt@pe118:~$ clang -Wall -g teh.c -o teh   It is recommended that you always compile with  -g  flags during development phase.  If you need to measure the performance (e.g., how fast it runs) of your program or when you are releasing the program to the public, you can remove the  -g  flag and compile with the optimization flags (e.g.,  -O ) instead.",
            "title": "4. Generating additional information for debugging."
        },
        {
            "location": "/clang/index.html#5-linking-with-standard-library",
            "text": "To link with a standard library, we use the  -l  flag to specify the name of the library to link.  For instance, to link with the C standard math library (abbreviated  m ), you issue the command:  1 ooiwt@pe118:~$ clang -Wall -g teh.c -o teh -lm",
            "title": "5. Linking with standard library."
        },
        {
            "location": "/clang/index.html#6-linking-with-3rd-party-library",
            "text": "By default,  clang  looks for headers and libraries in the systems directories ( /usr/include ,  /usr/lib , etc) and the current working directory.    If you use a third party library, you usually need to tell  clang  where to look for the corresponding headers and libraries.  You can use the  -I  flag and the  -L  flag for these purposes. For instance, if you have a library installed under your home called  citadel , and the file  citadel.h  can be found under  ~/citadel/include  and the file  libcitadel.a  can be found under  ~/citadel/lib , to tell  clang  where to find these files, you can compile with:  1 ooiwt@pe118:~$ clang -Wall -g -I ~/citadel/include -L ~/citadel/lib teh.c -o teh -lm -lcitadel",
            "title": "6. Linking with 3rd party library"
        },
        {
            "location": "/vim/index.html",
            "text": "Vim Tips\n\n\nI collected below some tips on \nvim\n that I find helpful.  If you are new to \nvim\n, please try out the command \nvimtutor\n on any machine where \nvim\n is installed, and check out the nice article \nLearn vim Progressively\n.  \n\n\n1. Useful Configuration\n\n\nYou can configure your \nvim\n by putting your configuration options and scripts in the \n~/.vimrc\n file (a hidden file named \n.vimrc\n in your home directory).  This file will be loaded whenever you starts \nvim\n.\n\n\nYou can copy a sample \n.vimrc\n file from \n~cs1010/.vimrc\n to your home directory. \nYou can edit this file \n~/.vimrc\n just like any other file, using \nvim\n.\n\n\nHelp\n\n\nIn \nvim,\n the command \n:help <topic>\n shows help about a particular topic in \nvim\n.  Example, \n:help backup\n.\n\n\nBackup Files\n\n\nYou can ask \nvim\n to automatically backup files that you edit.  This has been a life saver for me in multiple  occasions.\n\n\nIn your \n~/.vimrc\n file, \n\n\n1\nset backup\n\n\n\n\n\n\nwill cause a copy of your file to be save with suffix \n~\n appended to its name everytime you save.\n\n\nI prefer not to clutter my working directory, so I set\n\n\n1\nset backupdir=~/.backup\n\n\n\n\n\n\nand create a directory named \n~/.backup\n to store my backup files.\n\n\nSo if you made changes to a file that you regreted, or if you accidentally deleted a file, you can check under \n~/.backup\n to see if the backup can save you.\n\n\nSyntax Highlighting\n\n\nIf for some reasons, syntax highlighting is not on by default, add this to your \n~/.vimrc\n:\n\n\n1\nsyntax on\n\n\n\n\n\n\nRuler and Numbers\n\n\nIf you prefer to show the line number you are on and the column number you are on, adding the commands to \n~/.vimrc\n\n\n1\nset ruler\n\n\n\n\n\n\nwill display the line number and the column number on the lower right corner.  \n\n\nYou can also add\n\n1\nset number\n\n\n\n\n\nto label each line with a line number.\n\n\nAuto Indentation \n(new)\n\n\nProper indentation is important to make your code readable (to yourself and others).  You should enable this in \nvim\n with:\n\n\n1\n2\nset autoindent \nset smartindent\n\n\n\n\n\n\nAutoindent will cause the next line to have the same indentation as the previous line; while smartindent has some understanding of C-like syntax (such as recognizing \n{\n and \n}\n) and indent your code accordingly.  The size of the indentation is based on the setting \nshiftwidth\n.  For CS1010, please set it to either \n2\n or \n4\n:\n\n\n1\nset shiftwidth=2\n\n\n\n\n\n\n2. Navigation\n\n\nBasic Navigation\n\n\nUse \nk\n and \nj\n keys to move up and down (just like Gmail and Facebook!).  \nh\n and \nl\n to move left and right.\n\n\nOther shortcuts (no need to memorize them now, just refer back when you feel like you are typing too many \nhjkl\n to see how you can navigate faster).\n\n\n\n\nw\n   jump to the beginning of the next word\n\n\nb\n   jump to the beginning of the previous word (reverse of \nw\n)\n\n\ne\n   jump to the end of the word (or next word when pressed again)\n\n\nf\n + char: search forward in the line and sit on the next matching char\n\n\nt\n + char:  search forward in the line and sit on one space before the matching char\n\n\n$\n jump to end of line\n\n\n0\n jump to the beginning of the line\n\n\n^\n jump to the first non-blank character of the line\n\n\n%\n jump between matching parentheses\n\n\nCTRL-\nd\n jump forward (Down) half page\n\n\nCTRL-\nf\n jump Forward one page\n\n\nCTRL-\nu\n jump backward (Up) half page\n\n\nCTRL-\nb\n jump Backward half page\n\n\n\n\nJumping to a Line\n\n\nIf the compiler tells you there is an error on Line \nx\nx\n, you can issue \n:<x>\n to jump to Line \nx\nx\n.  For instance, \n:40\n will go to Line 40.\n\n\n3. Editing Operations\n\n\nUndo\n\n\nSince we are on the topic of correcting mistakes, \nu\n in command mode undo your changes.  Prefix it with a number \nn\nn\n to undo \nn\nn\n times.  If you want to undo your undo, \n<CTRL-R>\n will redo.\n\n\nNavigation + Editing\n\n\nvim\n is powerful because you can combine \noperations\n with \nnavigation\n.  For instance \nc\n to change, \nd\n to delete, \ny\n to yank (copy).  Since \nw\n is the navigation command to move over the current word, combining them we get:\n\n\n\n\ncw\n change the current word (delete the current word and enter insert mode)\n\n\ndw\n delete the current word\n\n\nyw\n yank the current word (copy word into buffer)\n\n\n\n\nCan you guess what \ndf)\n, \ndt)\n, \nc$\n, \ny0\n do?\n\n\nIf you repeat the operation \nc\n, \nd\n, and \ny\n, it applies to the whole line, so:\n\n\n\n\ncc\n change the whole line\n\n\ndd\n delete the whole line\n\n\nyy\n yank the whole line\n\n\n\n\nYou can add a number before an operation to specify how many times you want to repeat an operation.  So \n5dd\n deletes 5 lines, \n5dw\n deletes 5 words, etc.\n\n\nSee the article \nOperator, the True Power of \nVim\n for more details.\n\n\nSwapping Lines\n\n\nSometimes you want to swap the order of two lines of code, in command mode, \nddp\n will do the trick.  \ndd\n deletes the current line, \np\n paste it after the current line, in effect swapping the order of the two lines.\n\n\nCommenting blocks of code\n\n\nSometimes we need to comment out a whole block of code in C for testing purposes. There are several ways to do it in \nvim\n:\n\n\n\n\nPlace the cursor on the first line of the block of code you want to comment.\n\n\n0\n to jump to the beginning of the line\n\n\nV\n enter visual mode\n\n\nUse arrow key to select the block of code you want to comment. \n\n\nI\n to insert at the beginning of the line (here, since we already selected the block, we will insert at the beginning of every selected)\n\n\n//\n to insert the Java comment character (you will see it inserted in the current line, but don't worry)\n\n\n to escape from the visual code.\n\n\n\n\nTo uncomment, \n\n\n\n\nPlace the cursor on the first line of the block of code you want to comment.\n\n\n0\n to jump to the beginning of the line\n\n\n<CTRL-v>\n enter block visual mode\n\n\nUse arrow key to select the columns of text containing \n//\n\n\nx\n to delete them\n\n\n\n\n4. Other Advanced Features\n\n\nSearch and Replace in \nvim\n\n\n1\n:%s/oldWord/newWord/gc \n\n\n\n\n\n\n:\n enters the command mode.  \n%\n means apply to the whole document, \ns\n means substitute, \ng\n means global (otherwise, only the first occurance of each line is replaced). \nc\n is optional -- adding it cause \nvim\n to confirm with you before each replacement  \n\n\nShell Command\n\n\nIf you need to issue a shell command quickly, you don't have to exit \nvim\n, run the command, and launch \nvim\n again.  You can use \n!\n, \n\n\n1\n:!<command>\n\n\n\n\n\n\nwill issue the command to shell.  E.g.,\n\n\n1\n:!ls\n\n\n\n\n\n\nYou can use this to compile your current file, without exiting \nvim\n.\n\n\n1\n:!make\n\n\n\n\n\n\nmake\n is actually a builtin command for \nvim\n so you can also simply run\n\n\n1\n:make\n\n\n\n\n\n\nAbbreviation\n\n\nYou can use the command \nab\n to abbreviate frequently typed commands.  E.g., in your \n~/.vimrc\n, \n\n\n1\nab pl cs1010_print_long(\n\n\n\n\n\n\nNow, when you type \npl\n, it will be expanded into \ncs1010_print_long(\n\n\nAuto-Completion\n\n\nYou can \n<CTRL-P>\n to auto-complete.  By default, the auto-complete dictionary is based on text in your current editing buffers.  This is a very useful keystroke saver for long function and variable names.\n\n\nAuto-Indent the Whole File\n\n\nYou can \ngg=G\n in command mode to auto-indent the whole file.  \ngg\n is the command to go to the beginning of the file.  \n=\n is the command to indent.  \nG\n is the command to go to the end of the file.  \n\n\nSplitting \nvim\n's Viewport\n\n\n\n\n:sp file.c\n splits the \nvim\n window horizontally\n\n\n:vsp file.c\n splits the \nvim\n window vertically\n\n\nCtrl-w Ctrl-w\n moves between the different \nvim\n viewports\n\n\n\n\n5. Plugins\n\n\nSyntax and Style Checker\n\n\nI use \nsyntastic\n to check for style and syntax whenever I save a file.  \nsyntastic\n is a \nvim\n plugin. \n\n\nMy \n.vimrc\n configuration file contains the following:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\"For syntastic\nset laststatus=2\nset statusline+=%#warningmsg#\nset statusline+=%{SyntasticStatuslineFlag()}\nset statusline+=%*\n\nlet g:syntastic_error_symbol = '\u2717'\nlet g:syntastic_warning_symbol = '\u26a0'\nlet g:syntastic_always_populate_loc_list = 1\nlet g:syntastic_auto_loc_list = 1\nlet g:syntastic_check_on_open = 1\nlet g:syntastic_check_on_wq = 0\n\nlet g:syntastic_c_checkers = [ 'clang_tidy', 'clang' ]\nlet g:syntastic_c_compiler = 'clang'\nlet g:syntastic_c_clang_args = '-Wall -Werror -Wextra -Iinclude'\nlet g:syntastic_c_clang_tidy_args = '-checks=*'\nlet g:syntastic_c_compiler_options = '-Wall -Iinclude'\nlet g:syntastic_c_include_dirs = [ '../include', 'include' ]\nlet g:syntastic_c_clang_tidy_post_args = \"\"\n\n\n\n\n\n\nNew Addition:\n By default, \nclang-tidy\n does not know where to find the header files.  So if you include non-standard C headers, it will complain that it cannot find headers.  To resolve this, we need to tell \nclang-tidy\n the compilation flags that we use when compiling our program.  \n\n\nWe can do this by creating a file named \ncompile_flags.txt\n in your working directory (where your C files are located), containing one compilation flag per line.  For instance, if the header files are located in \n/home/course/cs1010/include\n, your \ncompile_flags.txt\n should contain the following two lines:\n\n\n1\n2\n-Wall\n-I/home/course/cs1010/include",
            "title": "Vim"
        },
        {
            "location": "/vim/index.html#vim-tips",
            "text": "I collected below some tips on  vim  that I find helpful.  If you are new to  vim , please try out the command  vimtutor  on any machine where  vim  is installed, and check out the nice article  Learn vim Progressively .",
            "title": "Vim Tips"
        },
        {
            "location": "/vim/index.html#1-useful-configuration",
            "text": "You can configure your  vim  by putting your configuration options and scripts in the  ~/.vimrc  file (a hidden file named  .vimrc  in your home directory).  This file will be loaded whenever you starts  vim .  You can copy a sample  .vimrc  file from  ~cs1010/.vimrc  to your home directory. \nYou can edit this file  ~/.vimrc  just like any other file, using  vim .",
            "title": "1. Useful Configuration"
        },
        {
            "location": "/vim/index.html#help",
            "text": "In  vim,  the command  :help <topic>  shows help about a particular topic in  vim .  Example,  :help backup .",
            "title": "Help"
        },
        {
            "location": "/vim/index.html#backup-files",
            "text": "You can ask  vim  to automatically backup files that you edit.  This has been a life saver for me in multiple  occasions.  In your  ~/.vimrc  file,   1 set backup   will cause a copy of your file to be save with suffix  ~  appended to its name everytime you save.  I prefer not to clutter my working directory, so I set  1 set backupdir=~/.backup   and create a directory named  ~/.backup  to store my backup files.  So if you made changes to a file that you regreted, or if you accidentally deleted a file, you can check under  ~/.backup  to see if the backup can save you.",
            "title": "Backup Files"
        },
        {
            "location": "/vim/index.html#syntax-highlighting",
            "text": "If for some reasons, syntax highlighting is not on by default, add this to your  ~/.vimrc :  1 syntax on",
            "title": "Syntax Highlighting"
        },
        {
            "location": "/vim/index.html#ruler-and-numbers",
            "text": "If you prefer to show the line number you are on and the column number you are on, adding the commands to  ~/.vimrc  1 set ruler   will display the line number and the column number on the lower right corner.    You can also add 1 set number   to label each line with a line number.",
            "title": "Ruler and Numbers"
        },
        {
            "location": "/vim/index.html#auto-indentation-czjqqkd0newczjqqkd1",
            "text": "Proper indentation is important to make your code readable (to yourself and others).  You should enable this in  vim  with:  1\n2 set autoindent \nset smartindent   Autoindent will cause the next line to have the same indentation as the previous line; while smartindent has some understanding of C-like syntax (such as recognizing  {  and  } ) and indent your code accordingly.  The size of the indentation is based on the setting  shiftwidth .  For CS1010, please set it to either  2  or  4 :  1 set shiftwidth=2",
            "title": "Auto Indentation (new)"
        },
        {
            "location": "/vim/index.html#2-navigation",
            "text": "",
            "title": "2. Navigation"
        },
        {
            "location": "/vim/index.html#basic-navigation",
            "text": "Use  k  and  j  keys to move up and down (just like Gmail and Facebook!).   h  and  l  to move left and right.  Other shortcuts (no need to memorize them now, just refer back when you feel like you are typing too many  hjkl  to see how you can navigate faster).   w    jump to the beginning of the next word  b    jump to the beginning of the previous word (reverse of  w )  e    jump to the end of the word (or next word when pressed again)  f  + char: search forward in the line and sit on the next matching char  t  + char:  search forward in the line and sit on one space before the matching char  $  jump to end of line  0  jump to the beginning of the line  ^  jump to the first non-blank character of the line  %  jump between matching parentheses  CTRL- d  jump forward (Down) half page  CTRL- f  jump Forward one page  CTRL- u  jump backward (Up) half page  CTRL- b  jump Backward half page",
            "title": "Basic Navigation"
        },
        {
            "location": "/vim/index.html#jumping-to-a-line",
            "text": "If the compiler tells you there is an error on Line  x x , you can issue  :<x>  to jump to Line  x x .  For instance,  :40  will go to Line 40.",
            "title": "Jumping to a Line"
        },
        {
            "location": "/vim/index.html#3-editing-operations",
            "text": "",
            "title": "3. Editing Operations"
        },
        {
            "location": "/vim/index.html#undo",
            "text": "Since we are on the topic of correcting mistakes,  u  in command mode undo your changes.  Prefix it with a number  n n  to undo  n n  times.  If you want to undo your undo,  <CTRL-R>  will redo.",
            "title": "Undo"
        },
        {
            "location": "/vim/index.html#navigation-editing",
            "text": "vim  is powerful because you can combine  operations  with  navigation .  For instance  c  to change,  d  to delete,  y  to yank (copy).  Since  w  is the navigation command to move over the current word, combining them we get:   cw  change the current word (delete the current word and enter insert mode)  dw  delete the current word  yw  yank the current word (copy word into buffer)   Can you guess what  df) ,  dt) ,  c$ ,  y0  do?  If you repeat the operation  c ,  d , and  y , it applies to the whole line, so:   cc  change the whole line  dd  delete the whole line  yy  yank the whole line   You can add a number before an operation to specify how many times you want to repeat an operation.  So  5dd  deletes 5 lines,  5dw  deletes 5 words, etc.  See the article  Operator, the True Power of  Vim  for more details.",
            "title": "Navigation + Editing"
        },
        {
            "location": "/vim/index.html#swapping-lines",
            "text": "Sometimes you want to swap the order of two lines of code, in command mode,  ddp  will do the trick.   dd  deletes the current line,  p  paste it after the current line, in effect swapping the order of the two lines.",
            "title": "Swapping Lines"
        },
        {
            "location": "/vim/index.html#commenting-blocks-of-code",
            "text": "Sometimes we need to comment out a whole block of code in C for testing purposes. There are several ways to do it in  vim :   Place the cursor on the first line of the block of code you want to comment.  0  to jump to the beginning of the line  V  enter visual mode  Use arrow key to select the block of code you want to comment.   I  to insert at the beginning of the line (here, since we already selected the block, we will insert at the beginning of every selected)  //  to insert the Java comment character (you will see it inserted in the current line, but don't worry)   to escape from the visual code.   To uncomment,    Place the cursor on the first line of the block of code you want to comment.  0  to jump to the beginning of the line  <CTRL-v>  enter block visual mode  Use arrow key to select the columns of text containing  //  x  to delete them",
            "title": "Commenting blocks of code"
        },
        {
            "location": "/vim/index.html#4-other-advanced-features",
            "text": "",
            "title": "4. Other Advanced Features"
        },
        {
            "location": "/vim/index.html#search-and-replace-in-vim",
            "text": "1 :%s/oldWord/newWord/gc    :  enters the command mode.   %  means apply to the whole document,  s  means substitute,  g  means global (otherwise, only the first occurance of each line is replaced).  c  is optional -- adding it cause  vim  to confirm with you before each replacement",
            "title": "Search and Replace in vim"
        },
        {
            "location": "/vim/index.html#shell-command",
            "text": "If you need to issue a shell command quickly, you don't have to exit  vim , run the command, and launch  vim  again.  You can use  ! ,   1 :!<command>   will issue the command to shell.  E.g.,  1 :!ls   You can use this to compile your current file, without exiting  vim .  1 :!make   make  is actually a builtin command for  vim  so you can also simply run  1 :make",
            "title": "Shell Command"
        },
        {
            "location": "/vim/index.html#abbreviation",
            "text": "You can use the command  ab  to abbreviate frequently typed commands.  E.g., in your  ~/.vimrc ,   1 ab pl cs1010_print_long(   Now, when you type  pl , it will be expanded into  cs1010_print_long(",
            "title": "Abbreviation"
        },
        {
            "location": "/vim/index.html#auto-completion",
            "text": "You can  <CTRL-P>  to auto-complete.  By default, the auto-complete dictionary is based on text in your current editing buffers.  This is a very useful keystroke saver for long function and variable names.",
            "title": "Auto-Completion"
        },
        {
            "location": "/vim/index.html#auto-indent-the-whole-file",
            "text": "You can  gg=G  in command mode to auto-indent the whole file.   gg  is the command to go to the beginning of the file.   =  is the command to indent.   G  is the command to go to the end of the file.",
            "title": "Auto-Indent the Whole File"
        },
        {
            "location": "/vim/index.html#splitting-vims-viewport",
            "text": ":sp file.c  splits the  vim  window horizontally  :vsp file.c  splits the  vim  window vertically  Ctrl-w Ctrl-w  moves between the different  vim  viewports",
            "title": "Splitting vim's Viewport"
        },
        {
            "location": "/vim/index.html#5-plugins",
            "text": "",
            "title": "5. Plugins"
        },
        {
            "location": "/vim/index.html#syntax-and-style-checker",
            "text": "I use  syntastic  to check for style and syntax whenever I save a file.   syntastic  is a  vim  plugin.   My  .vimrc  configuration file contains the following:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20 \"For syntastic\nset laststatus=2\nset statusline+=%#warningmsg#\nset statusline+=%{SyntasticStatuslineFlag()}\nset statusline+=%*\n\nlet g:syntastic_error_symbol = '\u2717'\nlet g:syntastic_warning_symbol = '\u26a0'\nlet g:syntastic_always_populate_loc_list = 1\nlet g:syntastic_auto_loc_list = 1\nlet g:syntastic_check_on_open = 1\nlet g:syntastic_check_on_wq = 0\n\nlet g:syntastic_c_checkers = [ 'clang_tidy', 'clang' ]\nlet g:syntastic_c_compiler = 'clang'\nlet g:syntastic_c_clang_args = '-Wall -Werror -Wextra -Iinclude'\nlet g:syntastic_c_clang_tidy_args = '-checks=*'\nlet g:syntastic_c_compiler_options = '-Wall -Iinclude'\nlet g:syntastic_c_include_dirs = [ '../include', 'include' ]\nlet g:syntastic_c_clang_tidy_post_args = \"\"   New Addition:  By default,  clang-tidy  does not know where to find the header files.  So if you include non-standard C headers, it will complain that it cannot find headers.  To resolve this, we need to tell  clang-tidy  the compilation flags that we use when compiling our program.    We can do this by creating a file named  compile_flags.txt  in your working directory (where your C files are located), containing one compilation flag per line.  For instance, if the header files are located in  /home/course/cs1010/include , your  compile_flags.txt  should contain the following two lines:  1\n2 -Wall\n-I/home/course/cs1010/include",
            "title": "Syntax and Style Checker"
        },
        {
            "location": "/library/index.html",
            "text": "The CS1010 I/O Library\n\n\nTo help students get started with C programming without worrying too much about the details and pitfalls of using \nprintf\n and \nscanf\n, we provide a simple-to-use library to read and write integers, floating point numbers, and strings.  \n\n\nThe libraries are pre-installed in \nCS1010 programming environments\n, with \ncs1010.h\n located under \n~cs1010/include\n and \nlibcs1010.a\n located under \n~cs1010/lib\n.\n\n\nInstalling the Library\n\n\nIf you want to install the libraries on your own version of Ubuntu, do the following:\n\n\n\n\nTo get an updated copy of the library, clone it from its git repo on GitHub with the command:\n\n\n\n\n1\ngit clone https://github.com/nus-cs1010-1819-s1/libcs1010.git\n\n\n\n\n\n\nIt is recommended you do this in your home directory.\n\n\nYou should see an output similar to:\n\n1\n2\n3\n4\n5\nCloning into 'libcs1010'...\nremote: Counting objects: 6, done.\nremote: Compressing objects: 100% (3/3), done.\nremote: Total 6 (delta 0), reused 0 (delta 0), pack-reused 0\nUnpacking objects: 100% (6/6), done.\n\n\n\n\n\nAfter that, you should see a subdirectory \nlibcs1010\n created in your current directory.  Inside, there should be a file called \nMakefile\n, and two subdirectories called \ninclude\n and \nsrc\n.  \n\n\n\n\nTo compile the library, run\n\n\n\n\n1\nmake\n\n\n\n\n\n\nThis should compile the file \nsrc/cs1010.c\n and create a static C library named \nlibcs1010.a\n under the \nlib\n directory.\n\n\nUsing the Library\n\n\nHeader\n\n\nTo use the CS1010 I/O library, you should \n#include\n the file \ncs1010.h\n, like this:\n\n\n1\n#include\n \n\"cs1010.h\"\n\n\n\n\n\n\n\nat the top of your C program.\n\n\nLinking\n\n\nThe CS1010 I/O library is provided as the file \nlibcs1010.a\n.  To link to the library, you need to compile with \n-lcs1010\n.  Usually, you need to specify where you can find \ncs1010.h\n with the \n-I\n flag, and \nlibcs1010.a\n with the \n-L\n flag.  Assuming that you are compiling in another subdirectory under your home and \nlibcs1010\n are located under your home directory, the header file and the library file are in \n../libcs1010/include\n and \n../libcs1010/lib\n respectively.\n\n\nSo you compile using the command line:\n\n\n1\nclang -I../libcs1010/include -L../libcs1010/lib hello.c -lcs1010\n\n\n\n\n\n\n\nOf course if your header and library files are located in another directory that is not \n../libcs1010/include\n and \n../libcs1010/lib\n, you should change the command above accordingly.\n\n\nAlthough it is a long string to type, you should type it once and use up arrow in bash to go back to this command over-and-over again.   For advanced students, we suggest that you put this in a shell script so that you just need to run the shell script to compile the program.  We have also automate this for you for your assignments and exercises using the \nmake\n command.\n\n\n\nReading of a Single Value\n\n\nThe CS1010 library supports reading of \nlong\n value, \ndouble\n value, and strings (both space-separated words and newline-separated lines) from the standard input.  For \nlong\n and \ndouble\n. The relevant methods are:\n\n\n\n\n\n\nlong cs1010_read_long()\n\nReturns a \nlong\n value from the standard input.  An error message will be printed (to \nstderr\n) if the input sequence is not a valid \nlong\n value -- in which case the value \nLONG_MAX\n will be returned.  Example:\n\n1\nlong\n \nyear\n \n=\n \ncs1010_read_long\n();\n\n\n\n\n\n\n\n\n\n\ndouble cs1010_read_double()\n\nReturns a \ndouble\n value from the standard input.  An error message will be printed (to \nstderr\n) if the input sequence is not a valid \ndouble\n value -- in which case the value \nDBL_MAX\n will be returned. Example:\n\n1\ndouble\n \ncap\n \n=\n \ncs1010_read_double\n();\n\n\n\n\n\n\n\n\n\n\nchar* cs1010_read_word()\n\nReturns a \nchar *\n pointing to the next white-space-separated string from the standard input.  A white-space character is defined based on the standard C function \nisspace()\n and includes the space \n, tab \n\\t\n, and newline \n\\n\n character.  Returns NULL if there is an error.  If the returned value is non-NULL, the caller is responsible for freeing the memory allocated by calling \nfree\n.\n\n\n1\n2\n3\n4\n5\nchar\n*\n \nword\n \n=\n \ncs1010_read_word\n();\n\n\n// use word to do something\n\n \n:\n\n \n:\n\n\nfree\n(\nword\n);\n\n\n\n\n\n\n\n\n\n\nchar* cs1010_read_line()\n\nReturns a \nchar *\n pointing to the next new-line-separated string from the standard input.   The string returns from \ncs1010_read_line()\n includes the newline character (if one is found).\nReturns NULL if there is an error.  If the returned value is non-NULL, the caller is responsible for freeing the memory allocated by calling \nfree\n.\n\n1\n2\n3\n4\n5\nchar\n*\n \nline\n \n=\n \ncs1010_read_line\n();\n\n\n// use line to do something\n\n \n:\n\n \n:\n\n\nfree\n(\nline\n);\n\n\n\n\n\n\n\n\n\n\nReading of Multiple Values\n\n\nThe CS1010 library also supports reading of multiple values.  \n\n\n\n\n\n\nlong* cs1010_read_long_array(int k)\n\nReturns \nk\n numbers of \nlong\n values read from the standard input stored in an array.  An error message will be printed (to \nstderr\n) for each input that is not a valid \nlong\n value -- in which case the value \nLONG_MAX\n will be populated in the corresponding array element.  Returns NULL if there is a memory allocation error.  If the returned value is non-NULL, the caller is responsible for freeing the memory allocated by calling \nfree\n.\n\n1\n2\n3\n4\n5\n6\n7\nlong\n*\n \nvalues\n \n=\n \ncs1010_read_long_array\n(\n10\n);\n\n\nif\n \n(\nvalues\n \n!=\n \nNULL\n)\n \n{\n\n  \n// Do something with array values\n\n   \n:\n\n   \n:\n\n  \nfree\n(\nvalues\n);\n\n\n}\n\n\n\n\n\n\n\n\n\n\ndouble* cs1010_read_double_array(int k)\n\nReturns \nk\n numbers of \ndouble\n values read from the standard input stored in an array.  An error message will be printed (to \nstderr\n) for each input that is not a valid \ndouble\n value -- in which case the value \nDBL_MAX\n will be populated in the corresponding array element.\n\nReturns NULL if there is a memory allocation error.  If the returned value is non-NULL, the caller is responsible for freeing the memory allocated by calling \nfree\n.\n\n1\n2\n3\n4\n5\n6\n7\ndouble\n*\n \nvalues\n \n=\n \ncs1010_read_double_array\n(\n10\n);\n\n\nif\n \n(\nvalues\n \n!=\n \nNULL\n)\n \n{\n\n  \n// Do something with array values\n\n   \n:\n\n   \n:\n\n  \nfree\n(\nvalues\n);\n\n\n}\n\n\n\n\n\n\n\n\n\n\nchar** cs1010_read_word_array(int k)\n\nReturns \nk\n white-space-separated words read from the standard input stored in an array.  The notion of \"word\" is the same to \ncs1010_read_word()\n.\n\nReturns NULL if there is a memory allocation error.  If the returned value is non-NULL, the caller is responsible for freeing the memory allocated for each word and for the whole array by calling \nfree\n.\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\nchar\n**\n \nwords\n \n=\n \ncs1010_read_word_array\n(\n10\n);\n\n\nif\n \n(\nwords\n \n!=\n \nNULL\n)\n \n{\n\n  \n// Do something with array words\n\n   \n:\n\n   \n:\n\n  \nfor\n \n(\nlong\n \ni\n \n=\n \n0\n;\n \ni\n \n<\n \n10\n;\n \ni\n \n+=\n \n1\n)\n \n{\n\n    \nfree\n(\nwords\n[\ni\n]);\n\n  \n}\n\n  \nfree\n(\nwords\n);\n\n\n}\n\n\n\n\n\n\n\n\n\n\nchar** cs1010_read_line_array(int k)\n\nReturns \nk\n new-line-separated words read from the standard input stored in an array.  The notion of line is the same to \ncs1010_read_line()\n.\n\nReturns NULL if there is a memory allocation error.  If the returned value is non-NULL, the caller is responsible for freeing the memory allocated for each line and for the whole array by calling \nfree\n.\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\nchar\n**\n \nlines\n \n=\n \ncs1010_read_line_array\n(\n10\n);\n\n\nif\n \n(\nlines\n \n!=\n \nNULL\n)\n \n{\n\n  \n// Do something with array lines\n\n   \n:\n\n   \n:\n\n  \nfor\n \n(\nlong\n \ni\n \n=\n \n0\n;\n \ni\n \n<\n \n10\n;\n \ni\n \n+=\n \n1\n)\n \n{\n\n    \nfree\n(\nlines\n[\ni\n]);\n\n  \n}\n\n  \nfree\n(\nlines\n);\n\n\n}\n\n\n\n\n\n\n\n\n\n\nPrinting of a Single Value\n\n\nThe CS1010 library provides a few convenince functions to format and print \nlong\n and \ndouble\n values to the standard output.\n\n\n\n\n\n\nvoid cs1010_print_long(long value)\n and \nvoid cs1010_println_long(long value)\n\nPrint \nvalue\n to the standard output (with printf format \n%ld\n).\n\nThe \ncs1010_println_long\n version prints a newline after the value.\n\n1\n2\n3\n  \nlong\n \nx\n;\n\n    \n:\n\n  \ncs1010_print_long\n(\nx\n);\n\n\n\n\n\n\n\n\n\n\nvoid cs1010_print_double(double value)\n and \nvoid cs1010_println_double(double value)\n\nPrint \nvalue\n to the standard output (with printf format \n%.4f\n).\nThe \ncs1010_println_double\n version prints a newline after the value.\n\n1\n2\n3\n  \ndouble\n \nx\n;\n\n    \n:\n\n  \ncs1010_println_double\n(\nx\n);\n\n\n\n\n\n\n\n\n\n\nvoid cs1010_print_string(char *str)\n and \nvoid cs1010_println_string(char *str)\n\nPrint a given string \nstr\n to the standard output.  These functions are provided for completeness and is a simple wrapper around \nprintf(str)\n and \nprintf(\"%s\\n\", str)\n repsectively.\n\n1\n  \ncs1010_println_string\n(\n\"hello world!\"\n);",
            "title": "CS1010 I/O"
        },
        {
            "location": "/library/index.html#the-cs1010-io-library",
            "text": "To help students get started with C programming without worrying too much about the details and pitfalls of using  printf  and  scanf , we provide a simple-to-use library to read and write integers, floating point numbers, and strings.    The libraries are pre-installed in  CS1010 programming environments , with  cs1010.h  located under  ~cs1010/include  and  libcs1010.a  located under  ~cs1010/lib .",
            "title": "The CS1010 I/O Library"
        },
        {
            "location": "/library/index.html#installing-the-library",
            "text": "If you want to install the libraries on your own version of Ubuntu, do the following:   To get an updated copy of the library, clone it from its git repo on GitHub with the command:   1 git clone https://github.com/nus-cs1010-1819-s1/libcs1010.git   It is recommended you do this in your home directory.  You should see an output similar to: 1\n2\n3\n4\n5 Cloning into 'libcs1010'...\nremote: Counting objects: 6, done.\nremote: Compressing objects: 100% (3/3), done.\nremote: Total 6 (delta 0), reused 0 (delta 0), pack-reused 0\nUnpacking objects: 100% (6/6), done.   After that, you should see a subdirectory  libcs1010  created in your current directory.  Inside, there should be a file called  Makefile , and two subdirectories called  include  and  src .     To compile the library, run   1 make   This should compile the file  src/cs1010.c  and create a static C library named  libcs1010.a  under the  lib  directory.",
            "title": "Installing the Library"
        },
        {
            "location": "/library/index.html#using-the-library",
            "text": "",
            "title": "Using the Library"
        },
        {
            "location": "/library/index.html#header",
            "text": "To use the CS1010 I/O library, you should  #include  the file  cs1010.h , like this:  1 #include   \"cs1010.h\"    at the top of your C program.",
            "title": "Header"
        },
        {
            "location": "/library/index.html#linking",
            "text": "The CS1010 I/O library is provided as the file  libcs1010.a .  To link to the library, you need to compile with  -lcs1010 .  Usually, you need to specify where you can find  cs1010.h  with the  -I  flag, and  libcs1010.a  with the  -L  flag.  Assuming that you are compiling in another subdirectory under your home and  libcs1010  are located under your home directory, the header file and the library file are in  ../libcs1010/include  and  ../libcs1010/lib  respectively.  So you compile using the command line:  1 clang -I../libcs1010/include -L../libcs1010/lib hello.c -lcs1010   \nOf course if your header and library files are located in another directory that is not  ../libcs1010/include  and  ../libcs1010/lib , you should change the command above accordingly.  Although it is a long string to type, you should type it once and use up arrow in bash to go back to this command over-and-over again.   For advanced students, we suggest that you put this in a shell script so that you just need to run the shell script to compile the program.  We have also automate this for you for your assignments and exercises using the  make  command.",
            "title": "Linking"
        },
        {
            "location": "/library/index.html#reading-of-a-single-value",
            "text": "The CS1010 library supports reading of  long  value,  double  value, and strings (both space-separated words and newline-separated lines) from the standard input.  For  long  and  double . The relevant methods are:    long cs1010_read_long() \nReturns a  long  value from the standard input.  An error message will be printed (to  stderr ) if the input sequence is not a valid  long  value -- in which case the value  LONG_MAX  will be returned.  Example: 1 long   year   =   cs1010_read_long ();      double cs1010_read_double() \nReturns a  double  value from the standard input.  An error message will be printed (to  stderr ) if the input sequence is not a valid  double  value -- in which case the value  DBL_MAX  will be returned. Example: 1 double   cap   =   cs1010_read_double ();      char* cs1010_read_word() \nReturns a  char *  pointing to the next white-space-separated string from the standard input.  A white-space character is defined based on the standard C function  isspace()  and includes the space  , tab  \\t , and newline  \\n  character.  Returns NULL if there is an error.  If the returned value is non-NULL, the caller is responsible for freeing the memory allocated by calling  free .  1\n2\n3\n4\n5 char *   word   =   cs1010_read_word ();  // use word to do something \n  : \n  :  free ( word );      char* cs1010_read_line() \nReturns a  char *  pointing to the next new-line-separated string from the standard input.   The string returns from  cs1010_read_line()  includes the newline character (if one is found).\nReturns NULL if there is an error.  If the returned value is non-NULL, the caller is responsible for freeing the memory allocated by calling  free . 1\n2\n3\n4\n5 char *   line   =   cs1010_read_line ();  // use line to do something \n  : \n  :  free ( line );",
            "title": "Reading of a Single Value"
        },
        {
            "location": "/library/index.html#reading-of-multiple-values",
            "text": "The CS1010 library also supports reading of multiple values.      long* cs1010_read_long_array(int k) \nReturns  k  numbers of  long  values read from the standard input stored in an array.  An error message will be printed (to  stderr ) for each input that is not a valid  long  value -- in which case the value  LONG_MAX  will be populated in the corresponding array element.  Returns NULL if there is a memory allocation error.  If the returned value is non-NULL, the caller is responsible for freeing the memory allocated by calling  free . 1\n2\n3\n4\n5\n6\n7 long *   values   =   cs1010_read_long_array ( 10 );  if   ( values   !=   NULL )   { \n   // Do something with array values \n    : \n    : \n   free ( values );  }      double* cs1010_read_double_array(int k) \nReturns  k  numbers of  double  values read from the standard input stored in an array.  An error message will be printed (to  stderr ) for each input that is not a valid  double  value -- in which case the value  DBL_MAX  will be populated in the corresponding array element. \nReturns NULL if there is a memory allocation error.  If the returned value is non-NULL, the caller is responsible for freeing the memory allocated by calling  free . 1\n2\n3\n4\n5\n6\n7 double *   values   =   cs1010_read_double_array ( 10 );  if   ( values   !=   NULL )   { \n   // Do something with array values \n    : \n    : \n   free ( values );  }      char** cs1010_read_word_array(int k) \nReturns  k  white-space-separated words read from the standard input stored in an array.  The notion of \"word\" is the same to  cs1010_read_word() . \nReturns NULL if there is a memory allocation error.  If the returned value is non-NULL, the caller is responsible for freeing the memory allocated for each word and for the whole array by calling  free .  1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10 char **   words   =   cs1010_read_word_array ( 10 );  if   ( words   !=   NULL )   { \n   // Do something with array words \n    : \n    : \n   for   ( long   i   =   0 ;   i   <   10 ;   i   +=   1 )   { \n     free ( words [ i ]); \n   } \n   free ( words );  }      char** cs1010_read_line_array(int k) \nReturns  k  new-line-separated words read from the standard input stored in an array.  The notion of line is the same to  cs1010_read_line() . \nReturns NULL if there is a memory allocation error.  If the returned value is non-NULL, the caller is responsible for freeing the memory allocated for each line and for the whole array by calling  free .  1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10 char **   lines   =   cs1010_read_line_array ( 10 );  if   ( lines   !=   NULL )   { \n   // Do something with array lines \n    : \n    : \n   for   ( long   i   =   0 ;   i   <   10 ;   i   +=   1 )   { \n     free ( lines [ i ]); \n   } \n   free ( lines );  }",
            "title": "Reading of Multiple Values"
        },
        {
            "location": "/library/index.html#printing-of-a-single-value",
            "text": "The CS1010 library provides a few convenince functions to format and print  long  and  double  values to the standard output.    void cs1010_print_long(long value)  and  void cs1010_println_long(long value) \nPrint  value  to the standard output (with printf format  %ld ). \nThe  cs1010_println_long  version prints a newline after the value. 1\n2\n3    long   x ; \n     : \n   cs1010_print_long ( x );      void cs1010_print_double(double value)  and  void cs1010_println_double(double value) \nPrint  value  to the standard output (with printf format  %.4f ).\nThe  cs1010_println_double  version prints a newline after the value. 1\n2\n3    double   x ; \n     : \n   cs1010_println_double ( x );      void cs1010_print_string(char *str)  and  void cs1010_println_string(char *str) \nPrint a given string  str  to the standard output.  These functions are provided for completeness and is a simple wrapper around  printf(str)  and  printf(\"%s\\n\", str)  repsectively. 1    cs1010_println_string ( \"hello world!\" );",
            "title": "Printing of a Single Value"
        }
    ]
}