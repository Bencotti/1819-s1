{
    "docs": [
        {
            "location": "/index.html",
            "text": "CS1010\n\n\nPiazza Q&A\n \n\n\nPiazza is the Q&A site for students and instructors to ask questions and discuss among each other on all matters related to CS1010.\n\n\n\n\nProgramming Exercises\n\n\nExercises are ungraded programming questions for practicing on your own.\n\n\nExercise 3: Binary, Rectangle, Fibonacci, Prime\n\n\nReleased 13 September 2018\n\n\nExercise 2: Leap, Suffix, Days\n\n\nReleased 6 September 2018\n\n\nExercise 1: Freezer\n\n\nReleased 3 September 2018\n\n\n\n\nProgramming Assignments\n\n\nAssignment 1: Invest, Box, Digits, and Taxi\n\n\nReleased 7 September 2018, Due 14 September 2018, 6pm.\n\n\n\n\nNotes and Lectures \n\n\nLecture 5\n\n\nIn this lecture, we will talk about how to write loops, followed by using assertions to reason about the behavior and logic of our programs.\n\n\nUnits covered are Units \n10 Assertions\n, \n11 Loops\n, and \n12 Reasoning About Loops\n.\n\n\nLecture 4\n\n\n\n\nSlides\n | \nScreencast\n | \nKahoot Quiz\n\n\n\n\nIn this lecture, we learned how to write programs that involve branching execution paths, using \nif\n-\nelse\n statements and logical expressions.  \nUnit 8 If-Else\n, \nUnit 9 Logical Expression\n were covered.\n\n\nLecture 3\n\n\n\n\nSlides\n | \nScreencast\n\n\n\n\nWe covered \nUnit 5: First C Program\n, \nUnit 6: CS1010 I/O Library\n and \nUnit 7: Arithmetic Operations\n.\n\n\nIn this lecture, we got started with writing simple C programs that read inputs, perform some calculations, and display the result.\n\n\nLecture 2\n\n\n\n\nSlides\n | \nScreencast\n\n\n\n\nWe covered \nUnit 3: functions\n and \nUnit 4: types\n.\n\n\nIn this lecture, we learned the concepts of functions, with which we can build up a more complex algorithm from smaller building blocks, such as finding the maximum.  We also learned about the concept of types.\n\n\nLecture 1\n\n\n\n\nSlides\n | \nScreencast\n (password posted on Piazza)\n\n\n\n\nAfter some admin matters, we introduced what is a program, what is meant by programming, and what is computational problem solving.\n\n\nWe covered \nUnit 1: What is a Program?\n and \nUnit 2: Computational Problems and Algorithms\n in the first lecture.",
            "title": "Home"
        },
        {
            "location": "/index.html#cs1010",
            "text": "",
            "title": "CS1010"
        },
        {
            "location": "/index.html#piazza-qa",
            "text": "Piazza is the Q&A site for students and instructors to ask questions and discuss among each other on all matters related to CS1010.",
            "title": "Piazza Q&amp;A"
        },
        {
            "location": "/index.html#programming-exercises",
            "text": "Exercises are ungraded programming questions for practicing on your own.",
            "title": "Programming Exercises"
        },
        {
            "location": "/index.html#exercise-3-binary-rectangle-fibonacci-prime",
            "text": "Released 13 September 2018",
            "title": "Exercise 3: Binary, Rectangle, Fibonacci, Prime"
        },
        {
            "location": "/index.html#exercise-2-leap-suffix-days",
            "text": "Released 6 September 2018",
            "title": "Exercise 2: Leap, Suffix, Days"
        },
        {
            "location": "/index.html#exercise-1-freezer",
            "text": "Released 3 September 2018",
            "title": "Exercise 1: Freezer"
        },
        {
            "location": "/index.html#programming-assignments",
            "text": "",
            "title": "Programming Assignments"
        },
        {
            "location": "/index.html#assignment-1-invest-box-digits-and-taxi",
            "text": "Released 7 September 2018, Due 14 September 2018, 6pm.",
            "title": "Assignment 1: Invest, Box, Digits, and Taxi"
        },
        {
            "location": "/index.html#notes-and-lectures",
            "text": "",
            "title": "Notes and Lectures"
        },
        {
            "location": "/index.html#lecture-5",
            "text": "In this lecture, we will talk about how to write loops, followed by using assertions to reason about the behavior and logic of our programs.  Units covered are Units  10 Assertions ,  11 Loops , and  12 Reasoning About Loops .",
            "title": "Lecture 5"
        },
        {
            "location": "/index.html#lecture-4",
            "text": "Slides  |  Screencast  |  Kahoot Quiz   In this lecture, we learned how to write programs that involve branching execution paths, using  if - else  statements and logical expressions.   Unit 8 If-Else ,  Unit 9 Logical Expression  were covered.",
            "title": "Lecture 4"
        },
        {
            "location": "/index.html#lecture-3",
            "text": "Slides  |  Screencast   We covered  Unit 5: First C Program ,  Unit 6: CS1010 I/O Library  and  Unit 7: Arithmetic Operations .  In this lecture, we got started with writing simple C programs that read inputs, perform some calculations, and display the result.",
            "title": "Lecture 3"
        },
        {
            "location": "/index.html#lecture-2",
            "text": "Slides  |  Screencast   We covered  Unit 3: functions  and  Unit 4: types .  In this lecture, we learned the concepts of functions, with which we can build up a more complex algorithm from smaller building blocks, such as finding the maximum.  We also learned about the concept of types.",
            "title": "Lecture 2"
        },
        {
            "location": "/index.html#lecture-1",
            "text": "Slides  |  Screencast  (password posted on Piazza)   After some admin matters, we introduced what is a program, what is meant by programming, and what is computational problem solving.  We covered  Unit 1: What is a Program?  and  Unit 2: Computational Problems and Algorithms  in the first lecture.",
            "title": "Lecture 1"
        },
        {
            "location": "/about/index.html",
            "text": "About CS1010\n\n\nModule Description\n\n\nThis module introduces the fundamental concepts of problem solving by computing and programming using an imperative programming language. It is the first and foremost introductory course to computing. It is also the first part of a three-part series on introductory programming and problem solving by computing, which also includes CS2030 and CS2040. Topics covered include problem solving by computing, writing pseudo-codes, basic problem formulation and problem solving, program development, coding, testing and debugging, fundamental programming constructs (variables, types, expressions, assignments, functions, control structures, etc.), fundamental data structures: arrays, strings and structures, simple file processing, and basic recursion. This module is appropriate for SoC students.\n\n\nWho/Where/When\n\n\n\n\nInstructor\n: Ooi Wei Tsang\n\n\nLecture Venue\n: \nI^3\nI^3\n Auditorium\n\n\nLecture Time\n: Every Tuesday, 4pm - 6pm\n\n\nOffice Hour\n: Every Wednesday, 4pm - 5pm\n\n\n\n\nTeaching Assistants\n:\n\n\n\n\nWu Biao\n\n\nYu Xiao Liang\n\n\nDou Rengan\n\n\n\n\n\n\n\n\nUndergraduate Discussion Leaders\n:\n\n\n\n\nArchana Pradeep\n\n\nAu Liang Jun\n\n\nChai Jie Feng (Jack)\n\n\nChua Jun Hui\n\n\nD David Livingston\n\n\nEvan Tay\n\n\nGu Wangfan\n\n\nHo Boon Wee Addison\n\n\nJeffery Kwoh Ji Hui\n\n\nJiang Qinhua\n\n\nJoanne Ong Cui FanG\n\n\nKerryn Eer\n\n\nKyle Timothy Ng Chu\n\n\nLim Heng Guang\n\n\nLin Si Jie\n\n\nNguyen Trong Truong Thanh\n\n\nOng Shu Peng (Metta)\n\n\nOng You Sheng Aaron\n\n\nQuek Shui Herng\n\n\nZhang Tianyang\n\n\n\n\n\n\n\n\nImportant Dates\n\n\n\n\nMidterm Assessment\n: Tuesday, 2 October, 2018 (4pm - 6pm), \nMPSH 1B\n\n\nFinal Assessment\n: Tuesday, 27 Nov, 2018 (9am - 11am)\n\n\nPractical Exam 1\n: Saturday, 6 October, 2018 (9am - 12noon)\n\n\nPractical Exam 2\n: Saturday, 10 November, 2018 \n(9am - 12noon)\n (1pm - 4pm)\n\n\n\n\nAssessment Weightage\n\n\n\n\nProgramming Assignments\n: 30%\n\n\nFinal Assessment\n: 30%\n\n\nMidterm Assessment\n: 15%\n\n\nPractical Exam 1\n: 10%\n\n\nPractical Exam 2\n: 15%",
            "title": "About CS1010"
        },
        {
            "location": "/about/index.html#about-cs1010",
            "text": "",
            "title": "About CS1010"
        },
        {
            "location": "/about/index.html#module-description",
            "text": "This module introduces the fundamental concepts of problem solving by computing and programming using an imperative programming language. It is the first and foremost introductory course to computing. It is also the first part of a three-part series on introductory programming and problem solving by computing, which also includes CS2030 and CS2040. Topics covered include problem solving by computing, writing pseudo-codes, basic problem formulation and problem solving, program development, coding, testing and debugging, fundamental programming constructs (variables, types, expressions, assignments, functions, control structures, etc.), fundamental data structures: arrays, strings and structures, simple file processing, and basic recursion. This module is appropriate for SoC students.",
            "title": "Module Description"
        },
        {
            "location": "/about/index.html#whowherewhen",
            "text": "Instructor : Ooi Wei Tsang  Lecture Venue :  I^3 I^3  Auditorium  Lecture Time : Every Tuesday, 4pm - 6pm  Office Hour : Every Wednesday, 4pm - 5pm   Teaching Assistants :   Wu Biao  Yu Xiao Liang  Dou Rengan     Undergraduate Discussion Leaders :   Archana Pradeep  Au Liang Jun  Chai Jie Feng (Jack)  Chua Jun Hui  D David Livingston  Evan Tay  Gu Wangfan  Ho Boon Wee Addison  Jeffery Kwoh Ji Hui  Jiang Qinhua  Joanne Ong Cui FanG  Kerryn Eer  Kyle Timothy Ng Chu  Lim Heng Guang  Lin Si Jie  Nguyen Trong Truong Thanh  Ong Shu Peng (Metta)  Ong You Sheng Aaron  Quek Shui Herng  Zhang Tianyang",
            "title": "Who/Where/When"
        },
        {
            "location": "/about/index.html#important-dates",
            "text": "Midterm Assessment : Tuesday, 2 October, 2018 (4pm - 6pm),  MPSH 1B  Final Assessment : Tuesday, 27 Nov, 2018 (9am - 11am)  Practical Exam 1 : Saturday, 6 October, 2018 (9am - 12noon)  Practical Exam 2 : Saturday, 10 November, 2018  (9am - 12noon)  (1pm - 4pm)",
            "title": "Important Dates"
        },
        {
            "location": "/about/index.html#assessment-weightage",
            "text": "Programming Assignments : 30%  Final Assessment : 30%  Midterm Assessment : 15%  Practical Exam 1 : 10%  Practical Exam 2 : 15%",
            "title": "Assessment Weightage"
        },
        {
            "location": "/outcomes/index.html",
            "text": "After taking CS1010, students should\n\n\n\n\nbe familiar with fundamental  programming concepts and methodology (variables, assignments, conditions, branches, loops, functions, recursions, structures);\n\n\nbe familiar with and appreciate good programming practice, and apply it to follow-up courses;\n\n\nbe able to apply problem-solving knowledge and skills to write small, well-documented, effective C programs;\n\n\nbe able to appreciate the use of simple data structure such as array, know their limitations to pave way for more complex data structures in the next course;\n\n\nknow the responsibilities of an ethical programmer;\n\n\nbe able to write simple programs in the corresponding programming language to solve a task, given the constraints on the inputs;\n\n\nbe able to manually trace through a program to identify logical errors;\n\n\nbe able to differentiate between logical errors, syntax errors, and run-time errors;\n\n\nbe exposed informally to the concept of code specification in the form of comments in the code, explaining what are the expected inputs and outputs and what are the assumptions;\n\n\nknow about what are some insecure functions to avoid;\n\n\nbe able to generate test cases on their own, with a focus on boundary/special cases;\n\n\nbe able to debug with printf or equivalent functions;\n\n\nbe aware of common strategies and good practices of debugging with printf or equivalent functions;\n\n\nbe able to identify opportunities to, and write, modularized code;\n\n\nbe exposed to a debugger;\n\n\nbe able to write code following good programming style (clear comments, naming convention, indentation, etc.);\n\n\nunderstand the different data types and that there exists a representation of each in the memory, as well as the limitation of the representations due to the limited number of bits;\n\n\ndevelop a simple mental model of how a program is executed (CPU runs the code on data that is stored in memory, function call leads to the creation of call frames, which can explain recursion and variable scoping, etc).  For interpreted language, understand the role of virtual machine/interpreter;\n\n\nbe able to understand at a high level the compilation process (from pre-processing to compiling to linking), where applicable;\n\n\nunderstand the concept of reusability and how a software application can be built on top of software libraries/packages (standard or third parties);\n\n\nbe able to implement bubble sort and insertion sort;\n\n\nbe able to implement linear search and binary search (both iterative and recursive versions);",
            "title": "Learning Outcomes"
        },
        {
            "location": "/schedule/index.html",
            "text": "Schedule\n\n\nThis is a tentative schedule for CS1010.\n\n\nLecture Schedule (Tentative)\n\n\n\n\n\n\n\n\nWeek\n\n\nStarting..\n\n\nTopics\n\n\nTutorial\n\n\nAssignment\n\n\n\n\n\n\n\n\n\n\n1\n\n\n2018-08-13\n\n\nUnits 1-2: Computational Problem Solving\n\n\n\n\n\n\n\n\n\n\n2\n\n\n2018-08-20\n\n\nUnits 3-4: Functions & Types\n\n\n\n\n\n\n\n\n\n\n3\n\n\n2018-08-27\n\n\nUnits 5-7: Basic C programs\n\n\nPS 1; Unix\n\n\n\n\n\n\n\n\n4\n\n\n2018-09-03\n\n\nUnits 8-10: Conditionals\n\n\nPS 3-5; Vim; Exercise 1\n\n\nAssignment 1 Released\n\n\n\n\n\n\n5\n\n\n2018-09-10\n\n\nArrays and Loops\n\n\nPS 8-10\n\n\nAssignment 2 Released\n\n\n\n\n\n\n6\n\n\n2018-09-17\n\n\nPointers and Strings\n\n\n\n\nAssignment 3 Released\n\n\n\n\n\n\n-\n\n\n2018-09-24\n\n\nBreak\n\n\n\n\n\n\n\n\n\n\n7\n\n\n2018-10-01\n\n\nMidterm\n\n\nPractical Exam 1\n\n\nPA4 Released\n\n\n\n\n\n\n8\n\n\n2018-10-08\n\n\nSorting\n\n\n\n\nPA5 Released\n\n\n\n\n\n\n9\n\n\n2018-10-15\n\n\nSearching\n\n\n\n\nPA6 Released\n\n\n\n\n\n\n10\n\n\n2018-10-22\n\n\nComposite Data Type\n\n\n\n\nPA7 Released\n\n\n\n\n\n\n11\n\n\n2018-10-29\n\n\nI/O\n\n\n\n\nPA 8 Released\n\n\n\n\n\n\n12\n\n\n2018-11-05\n\n\nModular C programming\n\n\nPractical Exam 2\n\n\nPA9 Released\n\n\n\n\n\n\n13\n\n\n2018-11-12\n\n\nRecap\n\n\n\n\n\n\n\n\n\n\n\n\nTutorial Time / Venue\n\n\n(scroll horizontally to see the full table)\n\n\n\n\n\n\n\n\nDay/Time\n\n\nCOM1\nB108\n\n\nCOM1\nB109\n\n\nCOM1\nB111\n\n\nCOM1\nB112\n\n\nCOM1\n0120\n\n\nI3\n0336\n\n\nI3\n0338\n\n\nAS6\n0421\n\n\n\n\n\n\n\n\n\n\nMon\n1000\n\n\nC10\nJoanne\n\n\n\n\n\n\n\n\nC09\nEvan\n\n\n\n\n\n\n\n\n\n\n\n\nMon\n1400\n\n\n\n\n\n\n\n\nC1A\nXiao Liang\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTue\n1200\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n03\nAddison\n\n\n\n\n\n\n\n\nTue\n1400\n\n\n\n\n\n\n\n\n\n\n\n\nC03\nKyle\n\n\nC02\nThanh\n\n\n\n\n\n\n\n\nWed\n1000\n\n\nC07\nJun Hui\n\n\n\n\nC08\nShui Herng\n\n\n\n\n\n\n\n\nC06\nShu Peng\n\n\n11\nRengan\n\n\n\n\n\n\nWed\n1200\n\n\n\n\n\n\n\n\n\n\n\n\n10\nDavid\n\n\n07\nAaron\n\n\n\n\n\n\n\n\nWed\n1400\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n08\nTian Yang\n\n\n\n\n\n\n\n\nThu\n1000\n\n\n\n\n\n\n\n\n05\nJeffrey\n\n\n\n\n01\nSi Jie\n\n\n\n\n\n\n\n\n\n\nThu\n1200\n\n\n\n\n\n\nC11\nKerryn\n\n\nC04\nJiefeng\n\n\nC05\nQinhua\n\n\n\n\n\n\n12\nHeng Guang\n\n\n\n\n\n\nThu\n1400\n\n\n\n\n\n\n\n\n06\nArchana\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFri\n1200\n\n\n\n\n\n\n\n\n02\nLiang Jun\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFri\n1400\n\n\n\n\n\n\n\n\n04\nWangfan",
            "title": "Schedule"
        },
        {
            "location": "/schedule/index.html#schedule",
            "text": "This is a tentative schedule for CS1010.",
            "title": "Schedule"
        },
        {
            "location": "/schedule/index.html#lecture-schedule-tentative",
            "text": "Week  Starting..  Topics  Tutorial  Assignment      1  2018-08-13  Units 1-2: Computational Problem Solving      2  2018-08-20  Units 3-4: Functions & Types      3  2018-08-27  Units 5-7: Basic C programs  PS 1; Unix     4  2018-09-03  Units 8-10: Conditionals  PS 3-5; Vim; Exercise 1  Assignment 1 Released    5  2018-09-10  Arrays and Loops  PS 8-10  Assignment 2 Released    6  2018-09-17  Pointers and Strings   Assignment 3 Released    -  2018-09-24  Break      7  2018-10-01  Midterm  Practical Exam 1  PA4 Released    8  2018-10-08  Sorting   PA5 Released    9  2018-10-15  Searching   PA6 Released    10  2018-10-22  Composite Data Type   PA7 Released    11  2018-10-29  I/O   PA 8 Released    12  2018-11-05  Modular C programming  Practical Exam 2  PA9 Released    13  2018-11-12  Recap",
            "title": "Lecture Schedule (Tentative)"
        },
        {
            "location": "/schedule/index.html#tutorial-time-venue",
            "text": "(scroll horizontally to see the full table)     Day/Time  COM1 B108  COM1 B109  COM1 B111  COM1 B112  COM1 0120  I3 0336  I3 0338  AS6 0421      Mon 1000  C10 Joanne     C09 Evan       Mon 1400     C1A Xiao Liang        Tue 1200        03 Addison     Tue 1400       C03 Kyle  C02 Thanh     Wed 1000  C07 Jun Hui   C08 Shui Herng     C06 Shu Peng  11 Rengan    Wed 1200       10 David  07 Aaron     Wed 1400        08 Tian Yang     Thu 1000     05 Jeffrey   01 Si Jie      Thu 1200    C11 Kerryn  C04 Jiefeng  C05 Qinhua    12 Heng Guang    Thu 1400     06 Archana        Fri 1200     02 Liang Jun        Fri 1400     04 Wangfan",
            "title": "Tutorial Time / Venue"
        },
        {
            "location": "/accounts/index.html",
            "text": "CS1010 Accounts\n\n\nWe will be using a variety of services for CS1010.  To take CS1010, please make sure you have the following accounts:\n\n\nSoC UNIX Account\n\n\nYou can get one here: \nhttps://mysoc.nus.edu.sg/~newacct/\n\n\nThis account allows you to access SoC UNIX resources, including the main computing host running Solaris, \nsunfire\n, and computer clusters running Ubuntu / CentOS.  We will be using the compute clusters for CS1010 (details coming soon).\n\n\nGitHub Account\n\n\nCS1010 uses GitHub Classroom for programming assignment submissions and grading.  You should \nregister for a GitHub account\n if you do not have one. \n\n\nPiazza Account\n\n\nCS1010 uses Piazza for Q&A and discussion.  You should receive an email to register for Piazza.",
            "title": "Accounts"
        },
        {
            "location": "/accounts/index.html#cs1010-accounts",
            "text": "We will be using a variety of services for CS1010.  To take CS1010, please make sure you have the following accounts:",
            "title": "CS1010 Accounts"
        },
        {
            "location": "/accounts/index.html#soc-unix-account",
            "text": "You can get one here:  https://mysoc.nus.edu.sg/~newacct/  This account allows you to access SoC UNIX resources, including the main computing host running Solaris,  sunfire , and computer clusters running Ubuntu / CentOS.  We will be using the compute clusters for CS1010 (details coming soon).",
            "title": "SoC UNIX Account"
        },
        {
            "location": "/accounts/index.html#github-account",
            "text": "CS1010 uses GitHub Classroom for programming assignment submissions and grading.  You should  register for a GitHub account  if you do not have one.",
            "title": "GitHub Account"
        },
        {
            "location": "/accounts/index.html#piazza-account",
            "text": "CS1010 uses Piazza for Q&A and discussion.  You should receive an email to register for Piazza.",
            "title": "Piazza Account"
        },
        {
            "location": "/policies/index.html",
            "text": "Policies\n\n\nEmail Communication\n\n\n\n\n\n\nPlease use only your official NUS email for communication with the teaching staffs -- either the one with \n@u.nus.edu\n or \n@comp.nus.edu.sg\n.  \n\n\n\n\n\n\nPlease use email only for private matters.  Prefix your email subject with \n[CS1010]\n.\n\n\n\n\n\n\nPlease use \nPiazza\n for other matters related to the module.  If you email us privately and we feel that your questions/answers are useful to the rest of the class, we will publish it on Piazza, with anonymization when appropriate.\n\n\n\n\n\n\nLab Sessions\n\n\n\n\n\n\nAttendance is not compulsory at NUS, but we do take attendance during the tutorial sessions.\n\n\n\n\n\n\nYou should stick to your allocated time slot for tutorials.  If there is a strong reason for your to attend another tutorial session, please inform your undergraduate discussion leaders (UDLs).\n\n\n\n\n\n\nLate Submissions\n\n\n\n\n\n\nAll programming assignments must be submitted on time.  If you need an extension, please ask for one and provide a justification for approval.  Only academic reasons and compassionate reasons can be considered (e.g., representing NUS for a sports event is OK; Attending a wedding is not).\n\n\n\n\n\n\nFor late submission, there is a 1% penalty (of the total assessment grade) for every 5-minutes after the deadline, capped at 80%.  For example, if an assessment which was given 40 marks was submitted 100 minutes after the deadline, the student will get 32 marks instead (20% penalty).  If it is submitted 10 hours after the deadline, the student will get 8 marks (as the cap of 80% penalty has been reached).\n\n\n\n\n\n\nDiscussions and Plagiarism\n\n\n\n\n\n\nWe encourage discussions among students for programming assignments, but each student should be responsible for writing his/her own code and should give credits to others when appropriate.  \n\n\n\n\n\n\nNUS and School of Computing have a high standard on academic honesty and take any violation seriously.  In the context of computing modules, source code plagiarism -- copying code from another source and attributing it as one's own code -- is a serious violation.   Please read the page \nPreventing Plagiarism\n from the school's website to familiarize yourself with the policy.\n\n\n\n\n\n\nI adopt a \"no mercy\" policy when it comes to disciplinary action on plagiarism.  Both parties, the student who copied, and the student who allowed others to copy, will be penalized equally.\n\n\n\n\n\n\nScreencast\n\n\n\n\n\n\nScreencast will be recorded and posted online 3-4 days after the lecture.\nThis will be done on a 'best effort' basis and screencast will not be guaranteed to be available on time or at all.  \n\n\n\n\n\n\nPosting of screencast is meant to help students who attended the lecture to recap the content, or to help those who are not able to attend the lecture due to unexpected circumstances.  It does not mean that you should skip lecture.  \nResearch\n has shown that the effect of over-reliance on screencast is negative.\n\n\n\n\n\n\nModel Solutions and Slides\n\n\n\n\n\n\nSlides will be posted \nafter\n the class.  Note that slides are used as a \nvisual aid\n to assist me during lecture. It is not meant as summary of lectures nor a replacement of lecture notes.\n\n\n\n\n\n\nIn a module like CS1010, there is often not a single correct answer.  Hence, there is no model solution for this module.  Sample solutions may be posted (both good and bad ones) for discussion.  I strongly encourage students to discuss your solution with the teaching team, instead of just comparing your solution with the sample solution.\n\n\n\n\n\n\nGrading\n\n\n\n\nStudents will received the grades they deserve irrespective of how the other students in the class perform (i.e., no bell curve).\n\n\n\n\nOpen Book Assessment\n\n\n\n\n\n\nAll assessment, including practical exams, midterm test, and final assessment, are open book assessment -- you can bring in your notes or other \nanalog\n reference materials.\n\n\n\n\n\n\nThere is \nnothing to memorize\n for this class.",
            "title": "Policies"
        },
        {
            "location": "/policies/index.html#policies",
            "text": "",
            "title": "Policies"
        },
        {
            "location": "/policies/index.html#email-communication",
            "text": "Please use only your official NUS email for communication with the teaching staffs -- either the one with  @u.nus.edu  or  @comp.nus.edu.sg .      Please use email only for private matters.  Prefix your email subject with  [CS1010] .    Please use  Piazza  for other matters related to the module.  If you email us privately and we feel that your questions/answers are useful to the rest of the class, we will publish it on Piazza, with anonymization when appropriate.",
            "title": "Email Communication"
        },
        {
            "location": "/policies/index.html#lab-sessions",
            "text": "Attendance is not compulsory at NUS, but we do take attendance during the tutorial sessions.    You should stick to your allocated time slot for tutorials.  If there is a strong reason for your to attend another tutorial session, please inform your undergraduate discussion leaders (UDLs).",
            "title": "Lab Sessions"
        },
        {
            "location": "/policies/index.html#late-submissions",
            "text": "All programming assignments must be submitted on time.  If you need an extension, please ask for one and provide a justification for approval.  Only academic reasons and compassionate reasons can be considered (e.g., representing NUS for a sports event is OK; Attending a wedding is not).    For late submission, there is a 1% penalty (of the total assessment grade) for every 5-minutes after the deadline, capped at 80%.  For example, if an assessment which was given 40 marks was submitted 100 minutes after the deadline, the student will get 32 marks instead (20% penalty).  If it is submitted 10 hours after the deadline, the student will get 8 marks (as the cap of 80% penalty has been reached).",
            "title": "Late Submissions"
        },
        {
            "location": "/policies/index.html#discussions-and-plagiarism",
            "text": "We encourage discussions among students for programming assignments, but each student should be responsible for writing his/her own code and should give credits to others when appropriate.      NUS and School of Computing have a high standard on academic honesty and take any violation seriously.  In the context of computing modules, source code plagiarism -- copying code from another source and attributing it as one's own code -- is a serious violation.   Please read the page  Preventing Plagiarism  from the school's website to familiarize yourself with the policy.    I adopt a \"no mercy\" policy when it comes to disciplinary action on plagiarism.  Both parties, the student who copied, and the student who allowed others to copy, will be penalized equally.",
            "title": "Discussions and Plagiarism"
        },
        {
            "location": "/policies/index.html#screencast",
            "text": "Screencast will be recorded and posted online 3-4 days after the lecture.\nThis will be done on a 'best effort' basis and screencast will not be guaranteed to be available on time or at all.      Posting of screencast is meant to help students who attended the lecture to recap the content, or to help those who are not able to attend the lecture due to unexpected circumstances.  It does not mean that you should skip lecture.   Research  has shown that the effect of over-reliance on screencast is negative.",
            "title": "Screencast"
        },
        {
            "location": "/policies/index.html#model-solutions-and-slides",
            "text": "Slides will be posted  after  the class.  Note that slides are used as a  visual aid  to assist me during lecture. It is not meant as summary of lectures nor a replacement of lecture notes.    In a module like CS1010, there is often not a single correct answer.  Hence, there is no model solution for this module.  Sample solutions may be posted (both good and bad ones) for discussion.  I strongly encourage students to discuss your solution with the teaching team, instead of just comparing your solution with the sample solution.",
            "title": "Model Solutions and Slides"
        },
        {
            "location": "/policies/index.html#grading",
            "text": "Students will received the grades they deserve irrespective of how the other students in the class perform (i.e., no bell curve).",
            "title": "Grading"
        },
        {
            "location": "/policies/index.html#open-book-assessment",
            "text": "All assessment, including practical exams, midterm test, and final assessment, are open book assessment -- you can bring in your notes or other  analog  reference materials.    There is  nothing to memorize  for this class.",
            "title": "Open Book Assessment"
        },
        {
            "location": "/01-program/index.html",
            "text": "Unit 1: What is a Program?\n\n\nLearning Outcomes\n\n\nAfter this unit, students should:\n\n\n\n\nhave an idea of what is a program and how a program is executed by a computer\n\n\nunderstand the basic terminologies: machine code, assembly language, and higher-level programming languages\n\n\n\n\nWhat is a (computer) program?\n\n\nDespite all the wonderful and amazing things that computers can do, computers are not very smart. In fact, they are pretty dumb. Computers can only follow the instructions given by a human. A computer program is a sequence of step-by-step instructions given to computers to manipulate data in order to perform a certain task.\n\n\nProgramming is the art and science of writing a computer program, and that is what you will learn to do in CS1010.\n\n\nHow computer executes a program\n\n\nIn order to learn how to write a program, it is important to have an overview of how a computer executes a program.  You will learn in details how this is done in CS2100/CS2106 or EE2024/CG2271, but for CS1010, we will take a very simplistic and high-level view of this process.\n\n\nThe two important components of a computer we will discuss for CS1010 is the CPU, or \ncentral processing unit\n and the memory, which is a generalized term for where we store the data to be processed or manipulated by the CPU, as well as the instructions to do so.  A memory location is addressable using a \nmemory address\n.  \n\n\nThe instructions to the CPU comes in the form of \nmachine code\n, a sequence of bits (1s and 0s) that is interpreted and then followed by the CPU to do certain things.  These machine code could instruct the CPU, for instance, to compare if a particular number at a certain memory location is more than 0, to add one number to another, or to execute another instruction at another memory location.  The data stored in the memory is also stored as a sequence of 1s and 0s.\n\n\nFrom Machine Code to High-level Programming Language\n\n\nWhile it is possible for us, human, to write machine code directly, few actually do since it is challenging to do so. Different CPUs understand different sets of machine code; it is tedious to figure out where each piece of data is located in the memory (this is actually determined by the operating system).  The resulting code, even when it is correct and easy to read and understand by the machine, are often hard to decipher for a human.\nSimple operations such as comparing which number is bigger might require several instructions to perform.\n\n\nTo get around the readability problem, programmers can code in \nassembly language\n -- a human-readable form of machine code, where each instruction, instead of represented by 0s and 1s, is represented by a mnemonic (such as \ndecr\n, \nincr\n, \nstore\n, \nadd\n, etc.)\n\n\nWriting assembly code does not address the issues of machine-dependent code and the tediousness of programming.  Early programmers (in the fifties) understood this and designed \nhigh-level programming languages\n, where programmers can describe the operations that they wish to do in a language closer to their intention that is machine independent.  A program written in one of these programming languages is then \ncompiled\n into machine code for a specific CPU for execution using a compiler.\n\n\n\n\nThe first commercially available language is FORTRAN from IBM in the 1950s.  Among many early programming languages, C (birth year 1972) is the only one that is still popular and widely used today,  \nFor many reasons\n, C is the language of choice for CS1010.  \n\n\nThe Goals of CS1010\n\n\nThis brings us to the goals of CS1010.  First, you will learn the most important syntax element of the C programming language.  Second, you will learn how a C program behaves, in relation to how a program is executed and how data are stored and manipulated in memory.  Third, you will learn the various tools and techniques that will help you produce good and correct C programs.\n\n\nThe last, and the most important and challenging goal of CS1010, however, is that you will learn how to write programs to solve computational problems.  Learning to write a program that does what you want it to do is actually not difficult.  \nKnowing what you want your program to do is the more challenging part!",
            "title": "1. What is a Program?"
        },
        {
            "location": "/01-program/index.html#unit-1-what-is-a-program",
            "text": "",
            "title": "Unit 1: What is a Program?"
        },
        {
            "location": "/01-program/index.html#learning-outcomes",
            "text": "After this unit, students should:   have an idea of what is a program and how a program is executed by a computer  understand the basic terminologies: machine code, assembly language, and higher-level programming languages",
            "title": "Learning Outcomes"
        },
        {
            "location": "/01-program/index.html#what-is-a-computer-program",
            "text": "Despite all the wonderful and amazing things that computers can do, computers are not very smart. In fact, they are pretty dumb. Computers can only follow the instructions given by a human. A computer program is a sequence of step-by-step instructions given to computers to manipulate data in order to perform a certain task.  Programming is the art and science of writing a computer program, and that is what you will learn to do in CS1010.",
            "title": "What is a (computer) program?"
        },
        {
            "location": "/01-program/index.html#how-computer-executes-a-program",
            "text": "In order to learn how to write a program, it is important to have an overview of how a computer executes a program.  You will learn in details how this is done in CS2100/CS2106 or EE2024/CG2271, but for CS1010, we will take a very simplistic and high-level view of this process.  The two important components of a computer we will discuss for CS1010 is the CPU, or  central processing unit  and the memory, which is a generalized term for where we store the data to be processed or manipulated by the CPU, as well as the instructions to do so.  A memory location is addressable using a  memory address .    The instructions to the CPU comes in the form of  machine code , a sequence of bits (1s and 0s) that is interpreted and then followed by the CPU to do certain things.  These machine code could instruct the CPU, for instance, to compare if a particular number at a certain memory location is more than 0, to add one number to another, or to execute another instruction at another memory location.  The data stored in the memory is also stored as a sequence of 1s and 0s.",
            "title": "How computer executes a program"
        },
        {
            "location": "/01-program/index.html#from-machine-code-to-high-level-programming-language",
            "text": "While it is possible for us, human, to write machine code directly, few actually do since it is challenging to do so. Different CPUs understand different sets of machine code; it is tedious to figure out where each piece of data is located in the memory (this is actually determined by the operating system).  The resulting code, even when it is correct and easy to read and understand by the machine, are often hard to decipher for a human.\nSimple operations such as comparing which number is bigger might require several instructions to perform.  To get around the readability problem, programmers can code in  assembly language  -- a human-readable form of machine code, where each instruction, instead of represented by 0s and 1s, is represented by a mnemonic (such as  decr ,  incr ,  store ,  add , etc.)  Writing assembly code does not address the issues of machine-dependent code and the tediousness of programming.  Early programmers (in the fifties) understood this and designed  high-level programming languages , where programmers can describe the operations that they wish to do in a language closer to their intention that is machine independent.  A program written in one of these programming languages is then  compiled  into machine code for a specific CPU for execution using a compiler.   The first commercially available language is FORTRAN from IBM in the 1950s.  Among many early programming languages, C (birth year 1972) is the only one that is still popular and widely used today,   For many reasons , C is the language of choice for CS1010.",
            "title": "From Machine Code to High-level Programming Language"
        },
        {
            "location": "/01-program/index.html#the-goals-of-cs1010",
            "text": "This brings us to the goals of CS1010.  First, you will learn the most important syntax element of the C programming language.  Second, you will learn how a C program behaves, in relation to how a program is executed and how data are stored and manipulated in memory.  Third, you will learn the various tools and techniques that will help you produce good and correct C programs.  The last, and the most important and challenging goal of CS1010, however, is that you will learn how to write programs to solve computational problems.  Learning to write a program that does what you want it to do is actually not difficult.   Knowing what you want your program to do is the more challenging part!",
            "title": "The Goals of CS1010"
        },
        {
            "location": "/02-algo/index.html",
            "text": "Unit 2: Computational Problems and Algorithms\n\n\nLearning Outcomes:\n\n\nAfter this unit, students should:\n\n\n\n\nunderstand the basic terminologies: computational problem solving, algorithm, flowchart, debugging, testing, variables, value, assignment\n\n\nbe familiar with the algorithm to find the maximum among a list of numbers\n\n\nbe able to trace through flowcharts and updates of variables, and argue if a given algorithm is correct or incorrect\n\n\n\n\nComputational Problems\n\n\nSo, what is computational problem solving?  Let's start with the question, what is a \ncomputational problem\n?  \n\n\nA computational problem is a problem that can be solved step-by-step with a computer.  These problems usually have a well-defined input, constraints, and conditions that the output must satisfied.  Here are some types of computational problems:\n\n\n\n\n\n\nA \ndecision problem\n is one where the answer is yes or no.  For instance, \"given a number \nn\n, is \nn\n even?\" is a decision problem.  Some decision problems take more steps to solve than others.  For instance, \"given a number \nn\n, is \nn\n prime?\" takes more steps than just checking the parity of a number.\n\n\n\n\n\n\nA \nsearch problem\n is one where the solution consists of one or more values that satisfies a given condition.  For instance, we may want to compute a path from one geographical location to another on a map.\n\n\n\n\n\n\nA \ncounting problem\n is one where the answer is the number of solutions to a search problem.\n\n\n\n\n\n\nAn \noptimization problem\n is one where the solution is the \"best\" possible solution, where the \"best\" can be defined in a different way.  For instance, we may want to compute the fastest route from one location to another.\n\n\n\n\n\n\nQuestions such as \"what is the meaning of life?\" \"do I look good in this outfit?\"\n1\n are not computational problems, because they do not have well-defined input, constraints, and conditions that the output must satisfy.\n\n\nIn CS1010 (followed by CS2040C and CS3230), you will learn how to solve computational problems \ncomputationally\n -- this means that you learn to come up with step-by-step instructions meant for computers that you can translate into computer programs, to solve a given problem. \n\n\nExample: Finding the maximum\n\n\nLet's start with a simple problem.  Given a finite list \nL\nL\n of \nk\nk\n integers (\nk\nk\n > 0), find the integer with the maximum value from the list.\n\n\nFirst, let's consider if this is a computational problem.  The input is very well defined.  We know what an integer is.  We are told we have at least one, and we have a finite number of them\n2\n.\n\n\nSecond, let's consider the output.  What conditions must the output satisfy?  First, it has to be equal or larger than every other integer on the list.  Second, it must be an integer \nin\n the list.  This is well defined by the problem statement, so we can say that it is a computational problem.\n\n\nHere is an example.  Suppose the input consists of:\n\n\n4 1 -4 0 9 9 3 5 8\n\n\nThe output should be \n9\n.\n\n\nNow, you should pause reading and think about how you would solve this step-by-step.  \n\n\nAlgorithm\n\n\nOne way to solve this problem is to check through the integers in the list, one-by-one, and keep track of the maximum value so far.  When you reach the end of the list, your \"maximum value so far\" will also be the maximum for the whole list.  \n\n\nLet's look at an example:\n\n\n\n\n\n\n\n\nIntegers Scanned\n\n\nMaximum So Far\n\n\n\n\n\n\n\n\n\n\n4\n\n\n4\n\n\n\n\n\n\n4 1\n\n\n4\n\n\n\n\n\n\n4 1 -4\n\n\n4\n\n\n\n\n\n\n4 1 -4 0\n\n\n4\n\n\n\n\n\n\n4 1 -4 0 9\n\n\n9\n\n\n\n\n\n\n4 1 -4 0 9 9\n\n\n9\n\n\n\n\n\n\n4 1 -4 0 9 9 3\n\n\n9\n\n\n\n\n\n\n4 1 -4 0 9 9 3 5\n\n\n9\n\n\n\n\n\n\n4 1 -4 0 9 9 3 5 8\n\n\n9\n\n\n\n\n\n\n\n\nThe English description above, however, is not detailed enough for computers to understand.  What is the meaning of \"check one-by-one\"? \"keep track of maximum so far\"?  how to tell if we have reached \"the end of the list\"?\n\n\nLet's work out all the details.\n\n\nFirst, we need a concise way of representing the integers in the list.  Borrowing from mathematical notation, let's say that the list \nL\nL\n contains the integers \n\nl_0, l_1, ..., l_{k-1}\nl_0, l_1, ..., l_{k-1}\n. To \"check one-by-one,\" we introduce another notation \nl_i\nl_i\n, which is the integer currently being \"checked\".  We begin with \ni = 0\ni = 0\n, then \ni = 1\ni = 1\n, then \ni = 2\ni = 2\n, etc, until \ni = k-1\ni = k-1\n.  At every step, we increase \ni\ni\n by 1.\n\n\nSecond, we need a concise way of keeping track of the maximum so far.  We introduce another notation, \nm\nm\n, to represent the maximum value so far.  When \ni = 0\ni = 0\n, \nm = l_0\nm = l_0\n.  Since we only scan a single integer, it has to be the maximum.  When we check another integer \nl_i (i > 0)\nl_i (i > 0)\n, only two things can happen:\n\n\n\n\nif this \nl_i\nl_i\n is larger than \nm\nm\n, then \nl_i\nl_i\n has to be the maximum so far, so we update \nm\nm\n to be \nl_i\nl_i\n.\n\n\nif \nl_i\nl_i\n is equal to or smaller than \nm\nm\n, then \nm\nm\n is still the maximum value so far.\n\n\n\n\nWe keep doing the above and increase \ni\ni\n, until we reach the end of the list when (after increasing \ni\ni\n) we find that \ni\ni\n is \nk\nk\n.\n\n\nNow, we have enough details to describe step-by-step, how to find the maximum value from a list of integers.  Such steps, which the computer can take to solve a problem, is called an \nalgorithm\n.  \n\n\nFlowchart\n\n\nThere are different ways one can describe an algorithm.  The easiest way I find is to use a diagram called a \nflowchart\n.  The flowchart for the algorithm above looks like this.  A diamond box represents a \"question\" that can be true or false (yes or no), and we trace through the \"flow\" step by step, following the corresponding path depending on the answer. \n\n\n\n\nPlease spend some time to trace through the walkthrough above.  The snapshot of the values of the \ni\ni\n, \nl_i\nl_i\n, \nk\nk\n, and \nm\nm\n, at the point after \"is \ni\ni\n equals \nk\nk\n\" is shown in the table below \n(except for the first row, which shows the value just before entering \"is \ni\ni\n equals \nk\nk\n\")\n.\n\n\n\n\n\n\n\n\nIntegers Scanned\n\n\ni\ni\n\n\nl_i\nl_i\n\n\nk\nk\n\n\nMaximum So Far (\nm\nm\n)\n\n\n\n\n\n\n\n\n\n\n4\n\n\n1\n\n\n4\n \n1\n\n\n9\n\n\n4\n\n\n\n\n\n\n4 1\n\n\n1\n\n\n1\n\n\n9\n\n\n4\n\n\n\n\n\n\n4 1 -4\n\n\n2\n\n\n-4\n\n\n9\n\n\n4\n\n\n\n\n\n\n4 1 -4 0\n\n\n3\n\n\n0\n\n\n9\n\n\n4\n\n\n\n\n\n\n4 1 -4 0 9\n\n\n4\n\n\n9\n\n\n9\n\n\n4\n\n\n\n\n\n\n4 1 -4 0 9 9\n\n\n5\n\n\n9\n\n\n9\n\n\n9\n\n\n\n\n\n\n4 1 -4 0 9 9 3\n\n\n6\n\n\n3\n\n\n9\n\n\n9\n\n\n\n\n\n\n4 1 -4 0 9 9 3 5\n\n\n7\n\n\n5\n\n\n9\n\n\n9\n\n\n\n\n\n\n4 1 -4 0 9 9 3 5 8\n\n\n8\n\n\n8\n\n\n9\n\n\n9\n\n\n\n\n\n\n4 1 -4 0 9 9 3 5 8\n\n\n9\n\n\n``\n\n\n9\n\n\n9\n\n\n\n\n\n\n\n\nVariables\n\n\nThere are a few important things to take note here.  \nm\nm\n, \ni\ni\n, \nk\nk\n, and the list \nL\nL\n are what we called \nstates\n or \nvariables\n.  While in the above, we can think of them as mathematical variables which we can assign \nvalues\n to, in a computer program, a variable is a location in the memory which holds a value.  \n\n\nWe can perform two very basic operations on the variables: reading and writing.  In other words, we can set their values and we can retrieve their values. \n\n\nWe can \nassign\n the value of one variable to a constant (e.g., set \ni\ni\n to 1) or to the value of another variable (e.g., set \nm\nm\n to \nl_i\nl_i\n).  In the latter example, we first read the value of \nl_i\nl_i\n, from \nl_i\nl_i\n's memory location and then we write that value to the memory location of \nm\nm\n.  Once written, the value of \nm\nm\n will not change until the next time we update the value of \nm\nm\n.\n\n\nIt is important to note that, when \ni\ni\n changes, \nm\nm\n \ndoes not change automatically\n to the new \nl_i\nl_i\n  This behavior is different from that which you may be familiar with in spreadsheet software -- if you set the value of a cell, say \nA1\n to be \n=B1\n, when the value in cell \nB1\n changes, the value \nA1\n also changes automatically.\n\n\nWe can also compare the values of two variables.  We see two examples above: \"\ni\ni\n equals \nk\nk\n?\"  \"\nl_i > m\nl_i > m\n?\"  When we compare, we read the values of the variables from their memory location and checks their relations.\n\n\nWe can perform arithmetic operations on the variables: addition, subtraction, etc.  We see one example above: \"increment \ni\ni\n\".  This operation is actually an assignment operation in disguise.  We can write it as \"set \ni\ni\n to \ni\ni\n + 1\".  Here, you see that \ni\ni\n is referred to twice.  This operation reads the value from the memory location of \ni\ni\n, adds 1 to it, and then writes the resulting value back to the location of \ni\ni\n.\n\n\nBugs\n\n\nIf you follow the execution of the algorithm above, step-by-step, using the example input \n4 1 -4 0 9 9 3 5\n above, you will obtain the correct maximum value \nm\nm\n of \n9\n.  But does that mean that the algorithm is correct?  The answer is NO.  \n\n\nFor an algorithm to correctly solve the given problem, it has to produce the correct result for all valid inputs to the problem.  If we can find one counterexample, one input where the algorithm does not produce the correct output, then the algorithm is incorrect.  Note that I say \ndoes not produce the correct output\n, which means that either the algorithm  \nproduces the wrong output\n or \ndoes not produce any output at all\n.  \n\n\nIn this case, we say that the algorithm or the program has a \nbug\n.  A bug is a defect that causes the algorithm to behave incorrectly.  As a software developer, you will spend some time finding bugs in your code, a process known as \ndebugging\n.  A \ndebugger\n is a tool that helps programmers find bugs in their code.\n\n\nBefore we even start the process of debugging, we first have to know if our algorithm is correct.  Remember that an algorithm is correct only if it produces the correct output only all possible valid inputs.  So, one way to check if an algorithm is correct is to try it with all possible valid inputs.  For the problem we are solving above, however, even though the list is finite, there are infinitely many possible inputs, and so, it is impossible to try all possible valid inputs.  In practice, we \ncraft\n a smaller set of test inputs to check if the algorithm behaves correctly for these test inputs, and \nhope\n that it is correct for all possible inputs.  With experience, you will choose the right set of test inputs to maximize that chances that you will find a bug in your code.  There are also systematic ways of deriving test cases so that the test cases \ncover\n different paths of execution of the algorithm, but we won't be covering it in CS1010\n3\n.\n\n\nAnother way of checking if an algorithm is correct, is to reason about the behavior of the algorithm.  We will do this rather informally in CS1010, starting in 1-2 lectures from now.  You get to rigorously prove that an algorithm is correct in a higher level module (CS3230 Design and Analysis of Algorithms).\n\n\nFinally, even if an algorithm is correct, the corresponding program might not be.  Recall that an algorithm is a step-by-step process to solve a problem.  It is what you want your program to do.  You still have to write a program (in C, or other languages) to actually have the computer do what you want it to do (in other words, to \nimplement the algorithm\n). This process of translating the algorithm to a computer program, called \ncoding\n may introduce bugs as well.  But we will worry about this later when we learn to program.\n\n\nIn the problem set at the end of this lecture, you will see slight variations of the algorithm above.  You should check through them to see whether they are correct or not.\n\n\nProblem Set\n\n\nProblem 1.1\n\n\nThe following algorithms are slight variations of the one in the notes above.  The differences are highlighted in red.  Do they correctly find the maximum integer from a finite list of \nk\nk\n integers (\nk > 0\nk > 0\n)?  \n\n\nIf an algorithm is buggy, give a counter-example where the output is incorrect.  In addition, give an example input where the algorithm still produces the correct output, where possible.  \n\n\n(a). \n\n\n\n(b). \n\n\n\n\u00a9. \n\n\n\n(d). \n\n\n\n(e). \n\n\n\nProblem 1.2\n\n\nChange the algorithm above to find the minimum value instead of the maximum value from the given list \nL = \\{l_0, ..., l_{k-1}\\}\nL = \\{l_0, ..., l_{k-1}\\}\n. \nYou can also assume that the list \nL\nL\n is finite and \nk > 0\nk > 0\n for this question\n.\n\n\nProblem 1.3\n\n\nDraw the flowchart for an algorithm, that takes in a list of integers \nL = \\{l_0, ..., l_{k-1}\\}, k \\ge 0\nL = \\{l_0, ..., l_{k-1}\\}, k \\ge 0\n, and compute the \nsum\n of all the integers.  Think about what variable(s) do you need.\n\n\n\n\n\n\n\n\n\n\nThe answer is, by the way, always \"Yes.\"\u00a0\n\u21a9\n\n\n\n\n\n\nThink about why it is important to have a finite number of integers in the input.\u00a0\n\u21a9\n\n\n\n\n\n\nSoftware testing is a body of knowledge worthy of an advanced module by itself -- we offer one in CS4218.\u00a0\n\u21a9",
            "title": "2. Computational Problem &amp; Algorithms"
        },
        {
            "location": "/02-algo/index.html#unit-2-computational-problems-and-algorithms",
            "text": "",
            "title": "Unit 2: Computational Problems and Algorithms"
        },
        {
            "location": "/02-algo/index.html#learning-outcomes",
            "text": "After this unit, students should:   understand the basic terminologies: computational problem solving, algorithm, flowchart, debugging, testing, variables, value, assignment  be familiar with the algorithm to find the maximum among a list of numbers  be able to trace through flowcharts and updates of variables, and argue if a given algorithm is correct or incorrect",
            "title": "Learning Outcomes:"
        },
        {
            "location": "/02-algo/index.html#computational-problems",
            "text": "So, what is computational problem solving?  Let's start with the question, what is a  computational problem ?    A computational problem is a problem that can be solved step-by-step with a computer.  These problems usually have a well-defined input, constraints, and conditions that the output must satisfied.  Here are some types of computational problems:    A  decision problem  is one where the answer is yes or no.  For instance, \"given a number  n , is  n  even?\" is a decision problem.  Some decision problems take more steps to solve than others.  For instance, \"given a number  n , is  n  prime?\" takes more steps than just checking the parity of a number.    A  search problem  is one where the solution consists of one or more values that satisfies a given condition.  For instance, we may want to compute a path from one geographical location to another on a map.    A  counting problem  is one where the answer is the number of solutions to a search problem.    An  optimization problem  is one where the solution is the \"best\" possible solution, where the \"best\" can be defined in a different way.  For instance, we may want to compute the fastest route from one location to another.    Questions such as \"what is the meaning of life?\" \"do I look good in this outfit?\" 1  are not computational problems, because they do not have well-defined input, constraints, and conditions that the output must satisfy.  In CS1010 (followed by CS2040C and CS3230), you will learn how to solve computational problems  computationally  -- this means that you learn to come up with step-by-step instructions meant for computers that you can translate into computer programs, to solve a given problem.",
            "title": "Computational Problems"
        },
        {
            "location": "/02-algo/index.html#example-finding-the-maximum",
            "text": "Let's start with a simple problem.  Given a finite list  L L  of  k k  integers ( k k  > 0), find the integer with the maximum value from the list.  First, let's consider if this is a computational problem.  The input is very well defined.  We know what an integer is.  We are told we have at least one, and we have a finite number of them 2 .  Second, let's consider the output.  What conditions must the output satisfy?  First, it has to be equal or larger than every other integer on the list.  Second, it must be an integer  in  the list.  This is well defined by the problem statement, so we can say that it is a computational problem.  Here is an example.  Suppose the input consists of:  4 1 -4 0 9 9 3 5 8  The output should be  9 .  Now, you should pause reading and think about how you would solve this step-by-step.",
            "title": "Example: Finding the maximum"
        },
        {
            "location": "/02-algo/index.html#algorithm",
            "text": "One way to solve this problem is to check through the integers in the list, one-by-one, and keep track of the maximum value so far.  When you reach the end of the list, your \"maximum value so far\" will also be the maximum for the whole list.    Let's look at an example:     Integers Scanned  Maximum So Far      4  4    4 1  4    4 1 -4  4    4 1 -4 0  4    4 1 -4 0 9  9    4 1 -4 0 9 9  9    4 1 -4 0 9 9 3  9    4 1 -4 0 9 9 3 5  9    4 1 -4 0 9 9 3 5 8  9     The English description above, however, is not detailed enough for computers to understand.  What is the meaning of \"check one-by-one\"? \"keep track of maximum so far\"?  how to tell if we have reached \"the end of the list\"?  Let's work out all the details.  First, we need a concise way of representing the integers in the list.  Borrowing from mathematical notation, let's say that the list  L L  contains the integers  l_0, l_1, ..., l_{k-1} l_0, l_1, ..., l_{k-1} . To \"check one-by-one,\" we introduce another notation  l_i l_i , which is the integer currently being \"checked\".  We begin with  i = 0 i = 0 , then  i = 1 i = 1 , then  i = 2 i = 2 , etc, until  i = k-1 i = k-1 .  At every step, we increase  i i  by 1.  Second, we need a concise way of keeping track of the maximum so far.  We introduce another notation,  m m , to represent the maximum value so far.  When  i = 0 i = 0 ,  m = l_0 m = l_0 .  Since we only scan a single integer, it has to be the maximum.  When we check another integer  l_i (i > 0) l_i (i > 0) , only two things can happen:   if this  l_i l_i  is larger than  m m , then  l_i l_i  has to be the maximum so far, so we update  m m  to be  l_i l_i .  if  l_i l_i  is equal to or smaller than  m m , then  m m  is still the maximum value so far.   We keep doing the above and increase  i i , until we reach the end of the list when (after increasing  i i ) we find that  i i  is  k k .  Now, we have enough details to describe step-by-step, how to find the maximum value from a list of integers.  Such steps, which the computer can take to solve a problem, is called an  algorithm .",
            "title": "Algorithm"
        },
        {
            "location": "/02-algo/index.html#flowchart",
            "text": "There are different ways one can describe an algorithm.  The easiest way I find is to use a diagram called a  flowchart .  The flowchart for the algorithm above looks like this.  A diamond box represents a \"question\" that can be true or false (yes or no), and we trace through the \"flow\" step by step, following the corresponding path depending on the answer.    Please spend some time to trace through the walkthrough above.  The snapshot of the values of the  i i ,  l_i l_i ,  k k , and  m m , at the point after \"is  i i  equals  k k \" is shown in the table below  (except for the first row, which shows the value just before entering \"is  i i  equals  k k \") .     Integers Scanned  i i  l_i l_i  k k  Maximum So Far ( m m )      4  1  4   1  9  4    4 1  1  1  9  4    4 1 -4  2  -4  9  4    4 1 -4 0  3  0  9  4    4 1 -4 0 9  4  9  9  4    4 1 -4 0 9 9  5  9  9  9    4 1 -4 0 9 9 3  6  3  9  9    4 1 -4 0 9 9 3 5  7  5  9  9    4 1 -4 0 9 9 3 5 8  8  8  9  9    4 1 -4 0 9 9 3 5 8  9  ``  9  9",
            "title": "Flowchart"
        },
        {
            "location": "/02-algo/index.html#variables",
            "text": "There are a few important things to take note here.   m m ,  i i ,  k k , and the list  L L  are what we called  states  or  variables .  While in the above, we can think of them as mathematical variables which we can assign  values  to, in a computer program, a variable is a location in the memory which holds a value.    We can perform two very basic operations on the variables: reading and writing.  In other words, we can set their values and we can retrieve their values.   We can  assign  the value of one variable to a constant (e.g., set  i i  to 1) or to the value of another variable (e.g., set  m m  to  l_i l_i ).  In the latter example, we first read the value of  l_i l_i , from  l_i l_i 's memory location and then we write that value to the memory location of  m m .  Once written, the value of  m m  will not change until the next time we update the value of  m m .  It is important to note that, when  i i  changes,  m m   does not change automatically  to the new  l_i l_i   This behavior is different from that which you may be familiar with in spreadsheet software -- if you set the value of a cell, say  A1  to be  =B1 , when the value in cell  B1  changes, the value  A1  also changes automatically.  We can also compare the values of two variables.  We see two examples above: \" i i  equals  k k ?\"  \" l_i > m l_i > m ?\"  When we compare, we read the values of the variables from their memory location and checks their relations.  We can perform arithmetic operations on the variables: addition, subtraction, etc.  We see one example above: \"increment  i i \".  This operation is actually an assignment operation in disguise.  We can write it as \"set  i i  to  i i  + 1\".  Here, you see that  i i  is referred to twice.  This operation reads the value from the memory location of  i i , adds 1 to it, and then writes the resulting value back to the location of  i i .",
            "title": "Variables"
        },
        {
            "location": "/02-algo/index.html#bugs",
            "text": "If you follow the execution of the algorithm above, step-by-step, using the example input  4 1 -4 0 9 9 3 5  above, you will obtain the correct maximum value  m m  of  9 .  But does that mean that the algorithm is correct?  The answer is NO.    For an algorithm to correctly solve the given problem, it has to produce the correct result for all valid inputs to the problem.  If we can find one counterexample, one input where the algorithm does not produce the correct output, then the algorithm is incorrect.  Note that I say  does not produce the correct output , which means that either the algorithm   produces the wrong output  or  does not produce any output at all .    In this case, we say that the algorithm or the program has a  bug .  A bug is a defect that causes the algorithm to behave incorrectly.  As a software developer, you will spend some time finding bugs in your code, a process known as  debugging .  A  debugger  is a tool that helps programmers find bugs in their code.  Before we even start the process of debugging, we first have to know if our algorithm is correct.  Remember that an algorithm is correct only if it produces the correct output only all possible valid inputs.  So, one way to check if an algorithm is correct is to try it with all possible valid inputs.  For the problem we are solving above, however, even though the list is finite, there are infinitely many possible inputs, and so, it is impossible to try all possible valid inputs.  In practice, we  craft  a smaller set of test inputs to check if the algorithm behaves correctly for these test inputs, and  hope  that it is correct for all possible inputs.  With experience, you will choose the right set of test inputs to maximize that chances that you will find a bug in your code.  There are also systematic ways of deriving test cases so that the test cases  cover  different paths of execution of the algorithm, but we won't be covering it in CS1010 3 .  Another way of checking if an algorithm is correct, is to reason about the behavior of the algorithm.  We will do this rather informally in CS1010, starting in 1-2 lectures from now.  You get to rigorously prove that an algorithm is correct in a higher level module (CS3230 Design and Analysis of Algorithms).  Finally, even if an algorithm is correct, the corresponding program might not be.  Recall that an algorithm is a step-by-step process to solve a problem.  It is what you want your program to do.  You still have to write a program (in C, or other languages) to actually have the computer do what you want it to do (in other words, to  implement the algorithm ). This process of translating the algorithm to a computer program, called  coding  may introduce bugs as well.  But we will worry about this later when we learn to program.  In the problem set at the end of this lecture, you will see slight variations of the algorithm above.  You should check through them to see whether they are correct or not.",
            "title": "Bugs"
        },
        {
            "location": "/02-algo/index.html#problem-set",
            "text": "",
            "title": "Problem Set"
        },
        {
            "location": "/02-algo/index.html#problem-11",
            "text": "The following algorithms are slight variations of the one in the notes above.  The differences are highlighted in red.  Do they correctly find the maximum integer from a finite list of  k k  integers ( k > 0 k > 0 )?    If an algorithm is buggy, give a counter-example where the output is incorrect.  In addition, give an example input where the algorithm still produces the correct output, where possible.    (a).   (b).   \u00a9.   (d).   (e).",
            "title": "Problem 1.1"
        },
        {
            "location": "/02-algo/index.html#problem-12",
            "text": "Change the algorithm above to find the minimum value instead of the maximum value from the given list  L = \\{l_0, ..., l_{k-1}\\} L = \\{l_0, ..., l_{k-1}\\} .  You can also assume that the list  L L  is finite and  k > 0 k > 0  for this question .",
            "title": "Problem 1.2"
        },
        {
            "location": "/02-algo/index.html#problem-13",
            "text": "Draw the flowchart for an algorithm, that takes in a list of integers  L = \\{l_0, ..., l_{k-1}\\}, k \\ge 0 L = \\{l_0, ..., l_{k-1}\\}, k \\ge 0 , and compute the  sum  of all the integers.  Think about what variable(s) do you need.      The answer is, by the way, always \"Yes.\"\u00a0 \u21a9    Think about why it is important to have a finite number of integers in the input.\u00a0 \u21a9    Software testing is a body of knowledge worthy of an advanced module by itself -- we offer one in CS4218.\u00a0 \u21a9",
            "title": "Problem 1.3"
        },
        {
            "location": "/03-func/index.html",
            "text": "Unit 3: Functions\n\n\nLet's start with another problem.\n\n\nProblem: Finding the Range\n\n\nThe \nrange\n of a finite list of at least one integers \nL\nL\n is defined as the difference between the maximum and the minimum.  For example, the range for \n4 1 -4 0 9 9 3 5 8\n is \n13\n.  How do we find the range of a given list? \n\n\nTo find the range of a list, we can break the solution down into three subtasks: first find the maximum, then find the minimum, and finally, find the difference between the two.  \n\n\nFrom the previous lecture, you already know how to find the maximum and the minimum (from Problem 1.2)!  So, in expressing the algorithm to find the range, \nwe can refer to a previous solution to a sub-problem, which we assume we already know how to solve\n.  \n\n\nLet's call our solution to find the maximum value from a given list \nL\nL\n as \nmax\nmax\n.  \nmax\nmax\n takes as input (i) a list \nL\nL\n and (ii) \nk\nk\n, the number of integers in \nL\nL\n.  It produces, or \nreturns\n, the maximum value among the integers in \nL\nL\n.  Borrowing from mathematical notation, we use the notation \nmax(L, k)\nmax(L, k)\n to represent the maximum value of \nL\nL\n.  \n\n\nSuppose that \nmin(L,k)\nmin(L,k)\n returns the minimum value among the integers in \nL\nL\n, then, the algorithm to find the range of \nL\nL\n can be written in a single line: \n\n\n\n\nmax(L, k) - min(L, k)\n\n\nmax(L, k) - min(L, k)\n\n\n\n\nFunctions\n\n\nmax\nmax\n and \nmin\nmin\n are examples of a powerful and important concept with many names: \nfunction\n, \nprocedure\n, \nsubroutine\n, \nmethod\n, \nsubprogram\n.  In the context of CS1010, we will use the term \nfunction\n.  Functions allow us to solve a problem by thinking about the solution at a higher level.  For instance, in the example above, we no longer have to think about checking through the items in the list one-by-one and maintaining the maximum so far, or the minimum so far.  We just have to think about how to compute the range, assuming that we already know how to compute the maximum and the minimum value.\n\n\nSuch an assumption, that we already know how to solve a subproblem, is known as \nwishful thinking\n.  Sometimes, it is useful to solve a problem assuming that you know how to solve the subproblem first, then worry about solving the subproblem later.  \n\n\nFor instance, consider the following problem: Given a finite list of \nk\nk\n integers (\nk > 0\nk > 0\n), find the mean.  \n\n\nThe algorithm again, can be written in one line:\n\n\n\n\nsum(L, k) / k\n\n\nsum(L, k) / k\n\n\n\n\nif we assume that we have a function \nsum\nsum\n that can help us find the total of all \nk\nk\n integers.  It turns out, in this case, that you should also know how to solve the subproblem \nsum\nsum\n, since it is Problem 1.3 from last week.\n\n\nWe can then make this into a function itself, \nmean(L, k)\nmean(L, k)\n, which we can now use to solve other more complex problems.\n\n\nThinking in terms of functions also have another advantage: given a function, we only need to worry about \nwhat\n it does, but not \nhow\n it is done.   We can treat a function as a black box -- given an input, it will produce an output satisfying certain conditions.  Many programming languages, including C which we will be using in CS1010, come with a rich set of predefined functions that we can use to help us solve computational problems.  In CS1010, we will also provide you with some functions to help you with your lab assignments.  You will also define your own functions when solving problems with C.  In fact, a C program is just a collection of functions calling each other.\n\n\nProblem: Finding Standard Deviation\n\n\nLet's look at another problem: Given \nL\nL\n, a finite list of at least one integers, find the standard deviation of the integers in \nL\nL\n.  \n\n\nFirst, recall that the (population) standard deviation is given by \n\n\n\n\n\\sqrt{\\frac{\\sum_{i=0}^{k-1} (l_i - \\mu)^2}{k}}\n\n\n\\sqrt{\\frac{\\sum_{i=0}^{k-1} (l_i - \\mu)^2}{k}}\n\n\n\n\nwhere \n\\mu\n\\mu\n is the mean of the integers in \nL\nL\n.\n\n\nTo compute the standard deviation, we first need to compute \n\\mu\n\\mu\n, the mean.   We already know how to do that: \nmean(L, k)\nmean(L, k)\n.  Then, we need to compute \n\\sum_{i=0}^{k-1} (l_i - \\mu)^2\n\\sum_{i=0}^{k-1} (l_i - \\mu)^2\n.  We can break it down into two subproblems:\n\n\n\n\nGiven a list \nL\nL\n and a constant value \nx\nx\n, subtract \nx\nx\n from every number in \nL\nL\n, giving us a new list.\n\n\nGiven a list, square every number in the list, giving us a new list.\n\n\n\n\nFor now, let's apply wishful thinking and assume that we know how to compute the above two steps with functions \nsubstract(L, k, x)\nsubstract(L, k, x)\n and \nsquare(L, k)\nsquare(L, k)\n, then, the formula \n\\sum_{i=0}^{k-1} (l_i - \\mu)^2\n\\sum_{i=0}^{k-1} (l_i - \\mu)^2\n can be computed by the following steps:\n\n\n\n\nset \n\\mu\n\\mu\n to \nmean(L, k)\nmean(L, k)\n\n\nset \nL'\nL'\n to \nsubstract(L, k, \\mu)\nsubstract(L, k, \\mu)\n\n\nset \nL''\nL''\n to \nsquare(L', k)\nsquare(L', k)\n\n\nset \ntotal\ntotal\n to \nsum(L'', k)\nsum(L'', k)\n.\n\n\n\n\nWe can also write it in one line:\n\n\n\n\nset \ntotal\ntotal\n to \nsum(square(substract(L, k, mean(L, k)), k), k)\nsum(square(substract(L, k, mean(L, k)), k), k)\n\n\n\n\nNow, to compute the standard deviation, we need to divide \ntotal\ntotal\n by \nk\nk\n and find the square root.  But, finding \ntotal\ntotal\n and dividing the result by \nk\nk\n is just \nmean\nmean\n.  To compute square root, we again apply wishful thinking and assume that there is a function \nsqrt\nsqrt\n to do so.\n\n\nWe can now compute the standard deviation with one line: \n\n\n\n\nsqrt(mean(square(substract(L, k, mean(L, k)), k), k))\n\n\nsqrt(mean(square(substract(L, k, mean(L, k)), k), k))\n\n\n\n\nUsing functions, we can easily pass the output from one function as input to another, essentially chain the functions together, like Lego blocks, to solve problems.  We also see an example of \nreuse\n here -- \nmean\nmean\n is used twice with different inputs.\n\n\n\n\nReturning a list\n\n\nWhile the above one-liner is an elegant solution, when we actually implement this in C later, it will not so simple and elegant.  Let's worry about that later.\n\n\n\n\nNow that we have seen how to compute standard deviation by breaking it down the four subproblems, \nsqrt\nsqrt\n, \nmean\nmean\n, \nsquare\nsquare\n, and \nsubstract\nsubstract\n, we have to make sure that things we wish can be done can actually be done.  The C library, and many programming languages, provide a pre-defined method to compute \nsqrt\nsqrt\n.  We already know how to compute \nmean\nmean\n.  Computing \nsquare\nsquare\n can be done as follows:\n\n\n\n\nThe implementation for \nsubstract\nsubstract\n is similar.\n\n\nAnother Solution for Finding Maximum\n\n\nIn the previous lecture, you have seen an algorithm to find the maximum value from a list of integers, which involves checking the elements one-by-one and keeping track of the maximum value so far.\n\n\nNow that we have seen what a function is, we can use the concept of wishful thinking to help us solve this problem in a different way and more elegant way.\n\n\nLet's suppose that we have a function \nmax'(L, i, j)\nmax'(L, i, j)\n, that finds the maximum integer among the elements \nl_i, l_{i+1}, ... l_j\nl_i, l_{i+1}, ... l_j\n.  The function \nmax(L, k)\nmax(L, k)\n, which finds the maximum among all elements of \nL\nL\n, is therefore the same as \nmax'(L, 0, k-1)\nmax'(L, 0, k-1)\n.\n\n\nDo we know how to solve \nmax'(L, i, j)\nmax'(L, i, j)\n without checking the integers in \nL\nL\n one-by-one?  Well, if \ni\ni\n equals to \nj\nj\n, i.e., there is only one element in the range of \nl_i, ..., l_j\nl_i, ..., l_j\n, then yes, the function should return the value of \nl_i\nl_i\n.  But, what if there are multiple elements in the range? (i.e., \ni < j\ni < j\n)?  By wishful thinking, we assume that we already know how to solve smaller (as in a shorter list) problem -- \nmax'(L, i+1, j)\nmax'(L, i+1, j)\n, so the maximum value for the range of \nl_i, ..., l_j\nl_i, ..., l_j\n is the larger of the two: either \nl_i\nl_i\n, or \nmax'(L, i+1, j)\nmax'(L, i+1, j)\n.  We can express this algorithm as follows:\n\n\n\n\nLet's trace through the algorithm above, using our previous example: \n4 1 -4 0 9 9 3 5 8\n.  Given this list, we compare the first element, \n4\n, with the maximum of the rest of the list \n1 -4 0 9 9 3 5 8\n.  Since with wishful thinking, we know how to solve this already, we get \n9\n as maximum value of \n1 -4 0 9 9 3 5 8\n.  Comparing \n4\n and \n9\n, \n9\n is larger. Thus, the maximum value for the whole list is \n9\n.\n\n\nExample: Finding a Factorial\n\n\nLet us look at another example of a function before we move on to another topic.  Suppose we want to write a function \nfactorial(n)\nfactorial(n)\n for an integer \nn\nn\n (\nn \\ge 0\nn \\ge 0\n) that computes \nn!\nn!\n. Recall that \nn! = n \\times n - 1 \\times n - 2 \\times ... 2 \\times 1 = n \\times (n-1)!\nn! = n \\times n - 1 \\times n - 2 \\times ... 2 \\times 1 = n \\times (n-1)!\n.  As a special case, \n0!\n0!\n is defined to be \n1\n1\n.\n\n\nThe algorithm to do this can be expressed by the following diagram:\n\n\n\n\nLet's look at an example.  Let's say we want to compute \nfactorial(4)\nfactorial(4)\n.  We assume we know how to solve this for a smaller problem --  \nfactorial(3)\nfactorial(3)\n, which is 6.  \nfactorial(4)\nfactorial(4)\n is thus 4 \n\\times\n\\times\n 6, i.e., 24.\n\n\nRecursion: Function Calling Itself\n\n\nmax'\nmax'\n and \nfactorial\nfactorial\n are examples of functions which calls itself to solve a simpler version of the problem.  This is known as \nrecursion\n.  We will revisit this concept in much greater detail in the later part of CS1010.\n\n\nProblem Set\n\n\nProblem 3.1 : Getting MAD\n\n\nThe mean absolute deviation, or MAD, of a set of integers measures how spread out a set of data is.  The \nabsolute deviation\n is the absolute difference between an element in the list with the mean of values of the list.  The mean absolute deviation is the mean of all the absolute difference.  In other words, given \nL = \\{l_0, ... l_{k-1}\\}\nL = \\{l_0, ... l_{k-1}\\}\n, the MAD of \nL\nL\n is:\n\n\n\n\n\\frac{\\sum_{i=0}^{k-1} |l_i - \\mu|}{k}\n\n\n\\frac{\\sum_{i=0}^{k-1} |l_i - \\mu|}{k}\n\n\n\n\nHow do you find MAD by composing various functions we have seen?  Do you need a new function?\n\n\nProblem 3.2 : Ownself calls ownself\n\n\n(a) Give an algorithm for finding the sum of all the integers in the list \nL\nL\n with \nk\nk\n integers (\nk > 0\nk > 0\n) that is recursive.\n\n\n(b) The function \npow(i, j)\npow(i, j)\n computes \ni^j\ni^j\n.  Give an algorithm to compute \npow(i, j)\npow(i, j)\n recursively.",
            "title": "3. Functions"
        },
        {
            "location": "/03-func/index.html#unit-3-functions",
            "text": "Let's start with another problem.",
            "title": "Unit 3: Functions"
        },
        {
            "location": "/03-func/index.html#problem-finding-the-range",
            "text": "The  range  of a finite list of at least one integers  L L  is defined as the difference between the maximum and the minimum.  For example, the range for  4 1 -4 0 9 9 3 5 8  is  13 .  How do we find the range of a given list?   To find the range of a list, we can break the solution down into three subtasks: first find the maximum, then find the minimum, and finally, find the difference between the two.    From the previous lecture, you already know how to find the maximum and the minimum (from Problem 1.2)!  So, in expressing the algorithm to find the range,  we can refer to a previous solution to a sub-problem, which we assume we already know how to solve .    Let's call our solution to find the maximum value from a given list  L L  as  max max .   max max  takes as input (i) a list  L L  and (ii)  k k , the number of integers in  L L .  It produces, or  returns , the maximum value among the integers in  L L .  Borrowing from mathematical notation, we use the notation  max(L, k) max(L, k)  to represent the maximum value of  L L .    Suppose that  min(L,k) min(L,k)  returns the minimum value among the integers in  L L , then, the algorithm to find the range of  L L  can be written in a single line:    max(L, k) - min(L, k)  max(L, k) - min(L, k)",
            "title": "Problem: Finding the Range"
        },
        {
            "location": "/03-func/index.html#functions",
            "text": "max max  and  min min  are examples of a powerful and important concept with many names:  function ,  procedure ,  subroutine ,  method ,  subprogram .  In the context of CS1010, we will use the term  function .  Functions allow us to solve a problem by thinking about the solution at a higher level.  For instance, in the example above, we no longer have to think about checking through the items in the list one-by-one and maintaining the maximum so far, or the minimum so far.  We just have to think about how to compute the range, assuming that we already know how to compute the maximum and the minimum value.  Such an assumption, that we already know how to solve a subproblem, is known as  wishful thinking .  Sometimes, it is useful to solve a problem assuming that you know how to solve the subproblem first, then worry about solving the subproblem later.    For instance, consider the following problem: Given a finite list of  k k  integers ( k > 0 k > 0 ), find the mean.    The algorithm again, can be written in one line:   sum(L, k) / k  sum(L, k) / k   if we assume that we have a function  sum sum  that can help us find the total of all  k k  integers.  It turns out, in this case, that you should also know how to solve the subproblem  sum sum , since it is Problem 1.3 from last week.  We can then make this into a function itself,  mean(L, k) mean(L, k) , which we can now use to solve other more complex problems.  Thinking in terms of functions also have another advantage: given a function, we only need to worry about  what  it does, but not  how  it is done.   We can treat a function as a black box -- given an input, it will produce an output satisfying certain conditions.  Many programming languages, including C which we will be using in CS1010, come with a rich set of predefined functions that we can use to help us solve computational problems.  In CS1010, we will also provide you with some functions to help you with your lab assignments.  You will also define your own functions when solving problems with C.  In fact, a C program is just a collection of functions calling each other.",
            "title": "Functions"
        },
        {
            "location": "/03-func/index.html#problem-finding-standard-deviation",
            "text": "Let's look at another problem: Given  L L , a finite list of at least one integers, find the standard deviation of the integers in  L L .    First, recall that the (population) standard deviation is given by    \\sqrt{\\frac{\\sum_{i=0}^{k-1} (l_i - \\mu)^2}{k}}  \\sqrt{\\frac{\\sum_{i=0}^{k-1} (l_i - \\mu)^2}{k}}   where  \\mu \\mu  is the mean of the integers in  L L .  To compute the standard deviation, we first need to compute  \\mu \\mu , the mean.   We already know how to do that:  mean(L, k) mean(L, k) .  Then, we need to compute  \\sum_{i=0}^{k-1} (l_i - \\mu)^2 \\sum_{i=0}^{k-1} (l_i - \\mu)^2 .  We can break it down into two subproblems:   Given a list  L L  and a constant value  x x , subtract  x x  from every number in  L L , giving us a new list.  Given a list, square every number in the list, giving us a new list.   For now, let's apply wishful thinking and assume that we know how to compute the above two steps with functions  substract(L, k, x) substract(L, k, x)  and  square(L, k) square(L, k) , then, the formula  \\sum_{i=0}^{k-1} (l_i - \\mu)^2 \\sum_{i=0}^{k-1} (l_i - \\mu)^2  can be computed by the following steps:   set  \\mu \\mu  to  mean(L, k) mean(L, k)  set  L' L'  to  substract(L, k, \\mu) substract(L, k, \\mu)  set  L'' L''  to  square(L', k) square(L', k)  set  total total  to  sum(L'', k) sum(L'', k) .   We can also write it in one line:   set  total total  to  sum(square(substract(L, k, mean(L, k)), k), k) sum(square(substract(L, k, mean(L, k)), k), k)   Now, to compute the standard deviation, we need to divide  total total  by  k k  and find the square root.  But, finding  total total  and dividing the result by  k k  is just  mean mean .  To compute square root, we again apply wishful thinking and assume that there is a function  sqrt sqrt  to do so.  We can now compute the standard deviation with one line:    sqrt(mean(square(substract(L, k, mean(L, k)), k), k))  sqrt(mean(square(substract(L, k, mean(L, k)), k), k))   Using functions, we can easily pass the output from one function as input to another, essentially chain the functions together, like Lego blocks, to solve problems.  We also see an example of  reuse  here --  mean mean  is used twice with different inputs.   Returning a list  While the above one-liner is an elegant solution, when we actually implement this in C later, it will not so simple and elegant.  Let's worry about that later.   Now that we have seen how to compute standard deviation by breaking it down the four subproblems,  sqrt sqrt ,  mean mean ,  square square , and  substract substract , we have to make sure that things we wish can be done can actually be done.  The C library, and many programming languages, provide a pre-defined method to compute  sqrt sqrt .  We already know how to compute  mean mean .  Computing  square square  can be done as follows:   The implementation for  substract substract  is similar.",
            "title": "Problem: Finding Standard Deviation"
        },
        {
            "location": "/03-func/index.html#another-solution-for-finding-maximum",
            "text": "In the previous lecture, you have seen an algorithm to find the maximum value from a list of integers, which involves checking the elements one-by-one and keeping track of the maximum value so far.  Now that we have seen what a function is, we can use the concept of wishful thinking to help us solve this problem in a different way and more elegant way.  Let's suppose that we have a function  max'(L, i, j) max'(L, i, j) , that finds the maximum integer among the elements  l_i, l_{i+1}, ... l_j l_i, l_{i+1}, ... l_j .  The function  max(L, k) max(L, k) , which finds the maximum among all elements of  L L , is therefore the same as  max'(L, 0, k-1) max'(L, 0, k-1) .  Do we know how to solve  max'(L, i, j) max'(L, i, j)  without checking the integers in  L L  one-by-one?  Well, if  i i  equals to  j j , i.e., there is only one element in the range of  l_i, ..., l_j l_i, ..., l_j , then yes, the function should return the value of  l_i l_i .  But, what if there are multiple elements in the range? (i.e.,  i < j i < j )?  By wishful thinking, we assume that we already know how to solve smaller (as in a shorter list) problem --  max'(L, i+1, j) max'(L, i+1, j) , so the maximum value for the range of  l_i, ..., l_j l_i, ..., l_j  is the larger of the two: either  l_i l_i , or  max'(L, i+1, j) max'(L, i+1, j) .  We can express this algorithm as follows:   Let's trace through the algorithm above, using our previous example:  4 1 -4 0 9 9 3 5 8 .  Given this list, we compare the first element,  4 , with the maximum of the rest of the list  1 -4 0 9 9 3 5 8 .  Since with wishful thinking, we know how to solve this already, we get  9  as maximum value of  1 -4 0 9 9 3 5 8 .  Comparing  4  and  9 ,  9  is larger. Thus, the maximum value for the whole list is  9 .",
            "title": "Another Solution for Finding Maximum"
        },
        {
            "location": "/03-func/index.html#example-finding-a-factorial",
            "text": "Let us look at another example of a function before we move on to another topic.  Suppose we want to write a function  factorial(n) factorial(n)  for an integer  n n  ( n \\ge 0 n \\ge 0 ) that computes  n! n! . Recall that  n! = n \\times n - 1 \\times n - 2 \\times ... 2 \\times 1 = n \\times (n-1)! n! = n \\times n - 1 \\times n - 2 \\times ... 2 \\times 1 = n \\times (n-1)! .  As a special case,  0! 0!  is defined to be  1 1 .  The algorithm to do this can be expressed by the following diagram:   Let's look at an example.  Let's say we want to compute  factorial(4) factorial(4) .  We assume we know how to solve this for a smaller problem --   factorial(3) factorial(3) , which is 6.   factorial(4) factorial(4)  is thus 4  \\times \\times  6, i.e., 24.",
            "title": "Example: Finding a Factorial"
        },
        {
            "location": "/03-func/index.html#recursion-function-calling-itself",
            "text": "max' max'  and  factorial factorial  are examples of functions which calls itself to solve a simpler version of the problem.  This is known as  recursion .  We will revisit this concept in much greater detail in the later part of CS1010.",
            "title": "Recursion: Function Calling Itself"
        },
        {
            "location": "/03-func/index.html#problem-set",
            "text": "",
            "title": "Problem Set"
        },
        {
            "location": "/03-func/index.html#problem-31-getting-mad",
            "text": "The mean absolute deviation, or MAD, of a set of integers measures how spread out a set of data is.  The  absolute deviation  is the absolute difference between an element in the list with the mean of values of the list.  The mean absolute deviation is the mean of all the absolute difference.  In other words, given  L = \\{l_0, ... l_{k-1}\\} L = \\{l_0, ... l_{k-1}\\} , the MAD of  L L  is:   \\frac{\\sum_{i=0}^{k-1} |l_i - \\mu|}{k}  \\frac{\\sum_{i=0}^{k-1} |l_i - \\mu|}{k}   How do you find MAD by composing various functions we have seen?  Do you need a new function?",
            "title": "Problem 3.1 : Getting MAD"
        },
        {
            "location": "/03-func/index.html#problem-32-ownself-calls-ownself",
            "text": "(a) Give an algorithm for finding the sum of all the integers in the list  L L  with  k k  integers ( k > 0 k > 0 ) that is recursive.  (b) The function  pow(i, j) pow(i, j)  computes  i^j i^j .  Give an algorithm to compute  pow(i, j) pow(i, j)  recursively.",
            "title": "Problem 3.2 : Ownself calls ownself"
        },
        {
            "location": "/04-type/index.html",
            "text": "Unit 4: Types\n\n\nRecall from Unit 1 that machine code and data manipulated by machine code are all stored as a sequence of 1s and 0s in the memory.  Each unit of either 1 or 0 is known as a \nbit\n.  8 bits form a \nbyte\n.\n\n\nRemember from Unit 2 that a variable is a memory location that stores a value, as a sequence of bits.  The bits stored in the memory has no meaning by itself.  It has to be interpreted by the machine code.  Does a sequence of 1s and 0s represent an integer?  A pixel of an image?  A sound sample in an audio clip?  A month?   As a programmer, we have to tag the variable with its \ntype\n, so that the machine code knows how to interpret the sequence of bits.  In addition, the type also tells the machine code, how many bits \"belong\" to this variable.  The number of bits of a type is also known as the \nsize\n of a type.\n\n\nThe size of a type determines how many different values a variable of that type can hold.  For instance, a type of one bit can only hold two possible values (e.g., \n0\n or \n1\n, \ntrue\n or \nfalse\n, \nblack\n or \nwhite\n).  A type of two bits can hold four values, represented as \n00\n, \n01\n, \n10\n, \n11\n.  In general, a type of \nk\nk\n bits can hold \n2^k\n2^k\n values.\n\n\nIntegers\n\n\nTo represent integers, a type of 8 bits can represent 256 different values.  If the type only represents non-negative integers (called \nunsigned\n), then it can hold any value between 0 to 255.  If it represents both positive and negative integers (called \nsigned\n), it can hold any value between -128 to 127.  Depending on the needs (how much memory we have, how big is the number we need to represent), programmers have to decide on the size of the type used for a variable in their programs.  With 64 bits, a signed integer can store any value between -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807.  This might look big enough for you -- but we can't even fit the results from \nfactorial(21)\nfactorial(21)\n here!\n\nWe have to go to 128 bits to represent larger integers.\n\n\nCharacters\n\n\nTo represent a character (i.e., a symbol representing a letter, number, punctuation, etc), we use 8 bits for English characters.  The ASCII standard maps 127 binary sequences to common characters you can type on your keyboard (including 0-9, A-Z, a-z, all sorts of punctuations: <>?:\"{}!@#$%^&*()_+-=[]\\';/., and special characters like return and escape).  The unicode standard uses up to 32 bits per character, allowing many non-English letter characters (e.g., \nEmoticons\n, \nBraille\n, \nMahjong Tiles\n) to be represented.\n\n\nReal Numbers\n\n\nFor real numbers, because we need to represent a huge number of possible values, we normally use 32 bits or 64 bits.  In CS1231, you will learn that there are uncountably many possible real numbers.  But, no matter how many bits we use, we can only represent a finite number of possible values for real numbers.  Here, we run into a limit of digitizing information into 0s and 1s -- we can never represent all possible real numbers in a computer!  Because of this, programs that manipulate real numbers leads to weird answers (such as 0.1 + 0.2 is not exactly the same as 0.3) and so, we have to take special care when dealing with real numbers when writing programs (not just in C, but in many other languages as well).  Hence, if we only expect a variable to hold an integer, we should not choose a type that represents real numbers.\n\n\nThe details of how a sequence of bits can represent integers and real numbers (both positive and negative numbers) are covered in CS2100. \n\n\nYou should have also noticed that in the discussion above, we talk about types that are 8, 16, 32, 64, 128 bits -- all power of twos.  We do not have a type of size, say, 41 bits.  The reason for this has to do with how memory location is addressed.  This will again be explained in CS2100.\n\n\nType Declaration\n\n\nIn C, which we will use in CS1010, we have to associate \nevery\n variable with a type, and once a variable is \ndeclared\n with a type, the type cannot be changed\n1\n.\n\n\nWhen we write a function, we have to declare the types of each of the parameters and the return value as well.  \n\n\nTake the function \nmean(L, k)\nmean(L, k)\n as an example.  We have said that \nL\nL\n is a list\n2\n of integers.  So each element in \nL\nL\n should have an integer type (how many bits to use will depend on the range of numbers we want the program to possibly handle and how frugal we are about memory usage).  What about \nk\nk\n?  \nk\nk\n refers to the number of elements in \nL\nL\n, so it has to be an integer.  As for the value returned by \nmean(L, k)\nmean(L, k)\n, even when the inputs are all integers (and thus, the sum is an integer), the mean value can be a real number.  So we should choose a type that represents a real number for the return value.  \n\n\n\n\nImportance of Type\n\n\nChoosing a wrong type to represent a variable can lead to buggy code.  Suppose we say that \nmean(L, k)\nmean(L, k)\n returns an integer, then when we call \nmean\nmean\n on the input \n1 2 3 4\n, we will get \n2\n as the answer, instead of \n2.5\n as it should.\n\n\n\n\n\n\n\n\n\n\n\n\nThis behavior is known as static typing.  Some programming languages, such as Javascript and Python, are dynamically typed.  The type of a variable may change depending on the value the variable is assigned to.\u00a0\n\u21a9\n\n\n\n\n\n\nWe have not talked about how to represent a list yet.  I will do that in a later unit.\u00a0\n\u21a9",
            "title": "4. Types"
        },
        {
            "location": "/04-type/index.html#unit-4-types",
            "text": "Recall from Unit 1 that machine code and data manipulated by machine code are all stored as a sequence of 1s and 0s in the memory.  Each unit of either 1 or 0 is known as a  bit .  8 bits form a  byte .  Remember from Unit 2 that a variable is a memory location that stores a value, as a sequence of bits.  The bits stored in the memory has no meaning by itself.  It has to be interpreted by the machine code.  Does a sequence of 1s and 0s represent an integer?  A pixel of an image?  A sound sample in an audio clip?  A month?   As a programmer, we have to tag the variable with its  type , so that the machine code knows how to interpret the sequence of bits.  In addition, the type also tells the machine code, how many bits \"belong\" to this variable.  The number of bits of a type is also known as the  size  of a type.  The size of a type determines how many different values a variable of that type can hold.  For instance, a type of one bit can only hold two possible values (e.g.,  0  or  1 ,  true  or  false ,  black  or  white ).  A type of two bits can hold four values, represented as  00 ,  01 ,  10 ,  11 .  In general, a type of  k k  bits can hold  2^k 2^k  values.",
            "title": "Unit 4: Types"
        },
        {
            "location": "/04-type/index.html#integers",
            "text": "To represent integers, a type of 8 bits can represent 256 different values.  If the type only represents non-negative integers (called  unsigned ), then it can hold any value between 0 to 255.  If it represents both positive and negative integers (called  signed ), it can hold any value between -128 to 127.  Depending on the needs (how much memory we have, how big is the number we need to represent), programmers have to decide on the size of the type used for a variable in their programs.  With 64 bits, a signed integer can store any value between -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807.  This might look big enough for you -- but we can't even fit the results from  factorial(21) factorial(21)  here! \nWe have to go to 128 bits to represent larger integers.",
            "title": "Integers"
        },
        {
            "location": "/04-type/index.html#characters",
            "text": "To represent a character (i.e., a symbol representing a letter, number, punctuation, etc), we use 8 bits for English characters.  The ASCII standard maps 127 binary sequences to common characters you can type on your keyboard (including 0-9, A-Z, a-z, all sorts of punctuations: <>?:\"{}!@#$%^&*()_+-=[]\\';/., and special characters like return and escape).  The unicode standard uses up to 32 bits per character, allowing many non-English letter characters (e.g.,  Emoticons ,  Braille ,  Mahjong Tiles ) to be represented.",
            "title": "Characters"
        },
        {
            "location": "/04-type/index.html#real-numbers",
            "text": "For real numbers, because we need to represent a huge number of possible values, we normally use 32 bits or 64 bits.  In CS1231, you will learn that there are uncountably many possible real numbers.  But, no matter how many bits we use, we can only represent a finite number of possible values for real numbers.  Here, we run into a limit of digitizing information into 0s and 1s -- we can never represent all possible real numbers in a computer!  Because of this, programs that manipulate real numbers leads to weird answers (such as 0.1 + 0.2 is not exactly the same as 0.3) and so, we have to take special care when dealing with real numbers when writing programs (not just in C, but in many other languages as well).  Hence, if we only expect a variable to hold an integer, we should not choose a type that represents real numbers.  The details of how a sequence of bits can represent integers and real numbers (both positive and negative numbers) are covered in CS2100.   You should have also noticed that in the discussion above, we talk about types that are 8, 16, 32, 64, 128 bits -- all power of twos.  We do not have a type of size, say, 41 bits.  The reason for this has to do with how memory location is addressed.  This will again be explained in CS2100.",
            "title": "Real Numbers"
        },
        {
            "location": "/04-type/index.html#type-declaration",
            "text": "In C, which we will use in CS1010, we have to associate  every  variable with a type, and once a variable is  declared  with a type, the type cannot be changed 1 .  When we write a function, we have to declare the types of each of the parameters and the return value as well.    Take the function  mean(L, k) mean(L, k)  as an example.  We have said that  L L  is a list 2  of integers.  So each element in  L L  should have an integer type (how many bits to use will depend on the range of numbers we want the program to possibly handle and how frugal we are about memory usage).  What about  k k ?   k k  refers to the number of elements in  L L , so it has to be an integer.  As for the value returned by  mean(L, k) mean(L, k) , even when the inputs are all integers (and thus, the sum is an integer), the mean value can be a real number.  So we should choose a type that represents a real number for the return value.     Importance of Type  Choosing a wrong type to represent a variable can lead to buggy code.  Suppose we say that  mean(L, k) mean(L, k)  returns an integer, then when we call  mean mean  on the input  1 2 3 4 , we will get  2  as the answer, instead of  2.5  as it should.       This behavior is known as static typing.  Some programming languages, such as Javascript and Python, are dynamically typed.  The type of a variable may change depending on the value the variable is assigned to.\u00a0 \u21a9    We have not talked about how to represent a list yet.  I will do that in a later unit.\u00a0 \u21a9",
            "title": "Type Declaration"
        },
        {
            "location": "/05-first-c/index.html",
            "text": "Unit 5: First C Program\n\n\nIn this unit, we will write and compile your first C program.  You have already learned, conceptually, what is a variable, what is a type and what is a function.  Let's see how we apply these concepts to C.\n\n\nTo start, let's look at a simple snippet of C code:\n\n\n1\n2\n3\n4\nint\n \nsquare\n(\nint\n \nx\n)\n \n\n{\n\n  \nreturn\n \nx\n*\nx\n;\n\n\n}\n\n\n\n\n\n\n\nThe code above defines a function named \nsquare\n.  The word \nint\n appears \nbefore\n the name \nsquare\n.  \nint\n is used to signify an integer type.  Appearing before the name \nsquare\n tells the compiler that \nsquare\n is returning a value of type \nint\n.\n\n\nAfter the word \nsquare\n, we write the parameters to the function in parenthesis \n(\n and \n)\n.  In between \n(\n and \n)\n is \nint x\n: \nx\n is the name of the parameter, \nint\n is the type of that parameter.  \n\n\nTo summarize, in Line 1, \nint square(int x)\n defines a function named \nsquare\n that takes in an integer parameter \nx\n and is returning a value which is also an integer.\n\n\nThe next three lines are written in between curly brackets \n{\n and \n}\n.  You will see these used a lot in C and other programming languages with C-like syntaxes, such as Javascript, C++, and Java.  These curly brackets group a \nblock\n of \nstatements\n together.  In this example, this block defines how the function \nsquare\n computes the square of \nx\n, and what it returns.  This is sometimes called the \nbody of a function\n.\n\n\nIn this function body, there is only one statement \nreturn x*x;\n  within the block.  A \nstatement\n is a unit in a programming language that expresses either a command to be executed or declares a new variable or function.  The word \nreturn\n says that this function \nsquare\n should return the following value, computed as \nx*x\n (\nx\n multiply by \nx\n).  This statement is terminated by a semicolon \n;\n.\n\n\nYou also see that the line that starts with \nreturn\n is indented.  We use indentation extensively to indicate the body of a block.  Since we can have nested blocks, indentation makes our code easier to read and understand.\n\n\nThe words \nint\n and \nreturn\n that appear above are \nkeywords\n defined in the C programming language, and they are reserved for the special meaning that they represent (a type and a command to return a value from a function).  We cannot repurpose keywords in C.  For instance, we cannot introduce a variable called \nint\n.\n\n\nWe are now ready to write our first C program.  The first program computes the square of the hypotenuse of a right-angled triangle with a base of 4 and height of 3.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\nint\n \nsquare\n(\nint\n \nx\n)\n \n\n{\n\n  \nreturn\n \nx\n*\nx\n;\n\n\n}\n\n\n\nint\n \nmain\n()\n \n\n{\n\n  \nint\n \nhypotenuse_square\n;\n\n\n  \nhypotenuse_square\n \n=\n \nsquare\n(\n3\n)\n \n+\n \nsquare\n(\n4\n);\n\n  \nreturn\n \n0\n;\n\n\n}\n\n\n\n\n\n\n\nRemember that a C program consists of a bunch of functions, calling each other.  The most important function is called \nmain\n, and it is the \nentry point\n to the program.  It is where the operating system will begin to execute the program.  Every program must define \nexactly one function\n called \nmain\n.\n\n\n1\n2\n3\n4\nint\n \nmain\n()\n \n\n{\n\n  \n:\n\n\n}\n\n\n\n\n\n\n\nmain\n returns an integer to the operating system, to signal to the operating system whether the program exits successfully or not.  In this case, we always return \n0\n (success) assuming that nothing goes wrong for simplicity.  This is the second example where you see the keyword \nreturn\n in action.\n\n\nIn modern C, the main always return 0 when it exits.  So, we will skip this statement \nreturn 0;\n from now on.\n\n\nVariable Declaration\n\n\nIn the example above, you also see the lines\n\n\n1\nint\n \nhypotenuse_square\n;\n\n\n\n\n\n\n\nThis is declaration statement (terminated with a semicolon, again).  Each statement declares a variable with its corresponding type (\nint\n here).  We gave each variable a name, here we call the variable \nhypotenuse_square\n.\n\n\nRemember that \nall variables must be declared with its corresponding type before used in C\n.\n\n\nIn C, a function must be either defined or declared before used as well.  In the example above, we define \nsquare\n before \nmain\n.  If we switch the order of the two, the compiler will complain.  Unless we declare the function first.  Declaring a function means that we simply state the return type, the name, and the parameters, \nwithout\n the body.  Here is an example:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\nint\n \nsquare\n(\nint\n \nx\n);\n \n// declaring the function square\n\n\n\nint\n \nmain\n()\n \n\n{\n\n  \nint\n \nhypotenuse_square\n;\n\n\n  \nhypotenuse_square\n \n=\n \nsquare\n(\n3\n)\n \n+\n \nsquare\n(\n4\n);\n\n  \nreturn\n \n0\n;\n\n\n}\n\n\n\nint\n \nsquare\n(\nint\n \nx\n)\n  \n// defining the function square\n\n\n{\n\n  \nreturn\n \nx\n*\nx\n;\n\n\n}\n\n\n\n\n\n\n\nAssignment Statement\n\n\nThe next line of the code shows an example of an assignment statement.  \n\n\n1\n  \nhypotenuse_square\n \n=\n \nsquare\n(\n3\n)\n \n+\n \nsquare\n(\n4\n);\n\n\n\n\n\n\n\nAn assignment operator takes the form of:\n\n\n1\n  \nleft_hand_side\n \n=\n \nright_hand_side\n;\n\n\n\n\n\n\n\nThe \nleft_hand_side\n must be the name of a variable.  We first evaluate the \nright_hand_side\n of the assignment statement, find its value, then put the value into the variable named on the \nleft_hand_side\n.\n\n\nHere, on the right-hand side, we call the function \nsquare\n, which we defined earlier.  We call \nsquare\n with \narguments\n \n3\n and \n4\n respectively.   We use the operator \n+\n to add the two results together.  The right-hand side should give the value 25, which we then assign to the variable \nhypotenuse_square\n.\n\n\nNote that we use \n=\n equal sign for assignment, NOT for checking equality.  The C notation for checking for equality is \n==\n (we will come back to this later).\n\n\nRecap\n\n\nBefore we move on, let's recap some concepts:\n\n\n\n\nA C program consists of functions, invoking each other.\n\n\nEach function is defined by its returned type, followed by its name, its parameter(s) (within a pair of parenthesis) and its body (within a pair of curly brackets).  \n\n\nEach function must be defined or declared before it is used.  \n\n\nThe function body consists of one or more statements.  We have seen assignment statements (using the \n=\n operator) and return statements, using \nreturn\n as the keyword.\n\n\nEach variable must be declared before it is used.  A declaration starts with its type followed by its name.\n\n\n\n\nExample 2\n\n\nLet's change the program slightly, so that instead of computing the square of the hypotenuse, we compute the hypotenuse itself.  Recall that we said C provides a bunch of predefined functions, include \nsqrt\n, which computes the square root of a given number.  Since a square root of a number is not necessarily an integer, we need to use a variable with a type that can store a real number.  \n\n\nTo represent real numbers, we commonly use the type \nfloat\n (which is short for a floating point number -- named so due to how a real number is represented in bits).  A \nfloat\n type can store 32 bits.  To double the precision (64 bits), we can use the type \ndouble\n.  A \nlong double\n type can store either 80-bits or 128-bits, depending on the implementation.\n\n\nBut which one does \nsqrt\n returns?  To find out the exact \nspecification\n of a pre-defined function, we can consult the manual (or \nman\n for short) pages for the function.  \n\n\nIf you type \nman sqrt\n on the command line (or place the cursor on \nsqrt\n in \nvim\n and type \nK\n in command mode), you will see that the \nsqrt\n method has the following specification:\n\n\n1\ndouble\n \nsqrt\n(\ndouble\n \nx\n);\n\n\n\n\n\n\n\nThe \nsqrt\n function returns a \ndouble\n precision real number.  We can now modify the program above to the following:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\ndouble\n \nsqrt\n(\ndouble\n \nx\n);\n \n// not recommended\n\n\n\nlong\n \nsquare\n(\nlong\n \nx\n)\n \n\n{\n\n  \nreturn\n \nx\n*\nx\n;\n\n\n}\n\n\n\ndouble\n \nhypotenuse_of\n(\nlong\n \nbase\n,\n \nlong\n \nheight\n)\n \n\n{\n\n  \nreturn\n \nsqrt\n(\nsquare\n(\nbase\n)\n \n+\n \nsquare\n(\nheight\n));\n\n\n}\n\n\n\nint\n \nmain\n()\n \n\n{\n\n  \nhypotenuse_of\n(\n3\n,\n \n4\n);\n\n\n}\n\n\n\n\n\n\n\nNote that the first line declares the function \nsqrt\n, because we need to declare a function before it is used.  Since \nsqrt\n is pre-defined elsewhere, we do not have to supply the function body here.  Such practice of declaring a predefined function ourselves, however, is not recommended.  Different platform, compilers, libraries, may provide a different specification for the same function.  As such, it is better to use the declaration from the library that provides the predefined function itself.  A library usually provides one or more \nheader files\n, a set of files that contain function declarations, type definitions, and constant definitions.  In the case of \nsqrt\n, its declaration is contained in a header file called \nmath.h\n (which we found out through consulting the \nman\n pages).  To include this file, you add the line \n#include\n \n<math.h>\n at the top of the program.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n#include\n \n<math.h>\n\n\n\nlong\n \nsquare\n(\nlong\n \nx\n)\n \n\n{\n\n  \nreturn\n \nx\n*\nx\n;\n\n\n}\n\n\n\ndouble\n \nhypotenuse_of\n(\nlong\n \nbase\n,\n \nlong\n \nheight\n)\n \n\n{\n\n  \nreturn\n \nsqrt\n(\nsquare\n(\nbase\n)\n \n+\n \nsquare\n(\nheight\n));\n\n\n}\n\n\n\nint\n \nmain\n()\n \n\n{\n\n  \nhypotenuse_of\n(\n3\n,\n \n4\n);\n\n\n}\n\n\n\n\n\n\n\nYou might notice the same line appear in the man page for \nsqrt\n.  Thus, the man pages tell us which header file to include if you want to use a certain function.\n\n\n\n\nFile Extension\n\n\nThe convention for file extension for a C program is \n.c\n and for a C header file is \n.h\n.  Even though you are allowed to name the files with any extension you like, you should stick to the convention so that it is clear to other tools/programmers what is the purpose of each file.\n\n\n\n\nOther Types in C\n\n\nAn \nint\n variable is usually 32-bits long.  If we only need 16 bits, we use the type \nshort int\n, or just \nshort\n.  If we only need 8-bits, we use the type \nchar\n (short for character).\n\n\nNote that in the above, I said an \nint\n is \nusually\n 32 bits.  Remember (from \nUnit 1\n that a C program gets compiled into machine code for a specific CPU architecture.  The C standard only guarantees that an \nint\n is at least 16 bits.  Although most C compilers compile \nint\n to 32 bits, there is no guarantee!    \n\n\nIf we need something more than an \nint\n, we can use \nlong int\n, or just \nlong\n.  The C standard guarantees that a \nlong\n is at least 32 bits.  Depending on the implementation, it sometimes compiled to 32-bits, sometimes 64-bits.  To get even longer, we can use the type \nlong long int\n, or just \nlong long\n, which is guaranteed to be at least 64 bits\n1\n.\n\n\nSigned vs. Unsigned\n\n\nWe have seen earlier that the same sequence of bits, if interpreted as signed or unsigned, would result in a different value.  By default, all types in C refer to signed types.  If you want a variable that holds only non-negative integers, you can add the keyword \nunsigned\n to the front of the type.  Doing so would mean that the range of values you can store in the variable is doubled, without adding more bits (since the bit used to present the + or - sign is no longer needed).  \n\n\nFor instance, since we know that \nsquare\n can only return a non-zero integer, we can actually declare it as:\n\n\n1\n2\n3\n4\nunsigned\n \nlong\n \nsquare\n(\nlong\n \nx\n)\n \n\n{\n\n  \nreturn\n \nx\n*\nx\n;\n\n\n}\n\n\n\n\n\n\n\nFor most practical purposes in CS1010, a (signed) \nlong\n suffices.  We introduce the notion of \nsigned\n vs. \nunsigned\n for your information so that you know what they are when you come across them in others source code.  Mixing \nsigned\n and \nunsigned\n can lead to subtle bugs in your code.  As such, \nwe will only use signed \nlong\n for CS1010\n.  You may choose to use them appropriately in another context, especially for embedded system or low-level programming.\n\n\n\n\nUnsigned Real Numbers?\n\n\nThere are no \nunsigned\n versions of \nfloat\n and \ndouble\n.  To understand the reason, we have to go further into how floating points numbers are represented in bits.  That is a topic for another module.\n\n\n\n\nstdint.h\n\n\nSince the number of bits for \nint\n, \nlong\n, and \nlong long\n could differ, in order to write a C program that is portable (i.e., works on different platforms, architecture, operating systems), we have two options:\n\n\n\n\nDo not write a program that assumes a specific number of bits is used for a certain type, or\n\n\nUse the type defined in the header file \nstdint.h\n: \nint8_t\n, \nuint8_t\n, \nint16_t\n, \nuint16_t\n, \nint32_t\n, \nuint32_t\n, \nint64_t\n, \nuint64_t\n.  The suffix \n_t\n is a convention to indicate that this is a customized type (more on this in later units).  The prefix \nu\n indicates that the type is an unsigned type.  The numbers \n8\n, \n16\n, \n32\n, and \n64\n indicate the number of bits for each type.  Thus, \nuint32_t\n is guaranteed to be of size 32 bits, and can hold unsigned integer values from \n0\n0\n to \n2^{32}-1\n2^{32}-1\n.\n\n\n\n\nProblem Set 5\n\n\nProblem 5.1\n\n\nIn the example above, \nsqrt\n is declared to take in a parameter of type \ndouble\n .  But the argument that we pass in is the sum of two \nint\n, which is also an \nint\n.   Would this result in an error?  \n\n\nProblem 5.2\n\n\nConsider the following alternative definition of \nsquare\n\n\n1\n2\n3\n???\n \nsquare\n(\nuint16_t\n \nx\n)\n \n{\n\n    \nreturn\n \nx\n*\nx\n;\n\n\n}\n\n\n\n\n\n\n\nWhat should the return type of this \nsquare\n be, in order for the return type to be big enough to store all possible value for \nx*x\n?\n\n\n\n\n\n\n\n\n\n\nAdding more \nlong\n does not make the integer longer, i.e., there is no \nlong long long int\n.\u00a0\n\u21a9",
            "title": "5. First C Program"
        },
        {
            "location": "/05-first-c/index.html#unit-5-first-c-program",
            "text": "In this unit, we will write and compile your first C program.  You have already learned, conceptually, what is a variable, what is a type and what is a function.  Let's see how we apply these concepts to C.  To start, let's look at a simple snippet of C code:  1\n2\n3\n4 int   square ( int   x )   { \n   return   x * x ;  }    The code above defines a function named  square .  The word  int  appears  before  the name  square .   int  is used to signify an integer type.  Appearing before the name  square  tells the compiler that  square  is returning a value of type  int .  After the word  square , we write the parameters to the function in parenthesis  (  and  ) .  In between  (  and  )  is  int x :  x  is the name of the parameter,  int  is the type of that parameter.    To summarize, in Line 1,  int square(int x)  defines a function named  square  that takes in an integer parameter  x  and is returning a value which is also an integer.  The next three lines are written in between curly brackets  {  and  } .  You will see these used a lot in C and other programming languages with C-like syntaxes, such as Javascript, C++, and Java.  These curly brackets group a  block  of  statements  together.  In this example, this block defines how the function  square  computes the square of  x , and what it returns.  This is sometimes called the  body of a function .  In this function body, there is only one statement  return x*x;   within the block.  A  statement  is a unit in a programming language that expresses either a command to be executed or declares a new variable or function.  The word  return  says that this function  square  should return the following value, computed as  x*x  ( x  multiply by  x ).  This statement is terminated by a semicolon  ; .  You also see that the line that starts with  return  is indented.  We use indentation extensively to indicate the body of a block.  Since we can have nested blocks, indentation makes our code easier to read and understand.  The words  int  and  return  that appear above are  keywords  defined in the C programming language, and they are reserved for the special meaning that they represent (a type and a command to return a value from a function).  We cannot repurpose keywords in C.  For instance, we cannot introduce a variable called  int .  We are now ready to write our first C program.  The first program computes the square of the hypotenuse of a right-angled triangle with a base of 4 and height of 3.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12 int   square ( int   x )   { \n   return   x * x ;  }  int   main ()   { \n   int   hypotenuse_square ; \n\n   hypotenuse_square   =   square ( 3 )   +   square ( 4 ); \n   return   0 ;  }    Remember that a C program consists of a bunch of functions, calling each other.  The most important function is called  main , and it is the  entry point  to the program.  It is where the operating system will begin to execute the program.  Every program must define  exactly one function  called  main .  1\n2\n3\n4 int   main ()   { \n   :  }    main  returns an integer to the operating system, to signal to the operating system whether the program exits successfully or not.  In this case, we always return  0  (success) assuming that nothing goes wrong for simplicity.  This is the second example where you see the keyword  return  in action.  In modern C, the main always return 0 when it exits.  So, we will skip this statement  return 0;  from now on.",
            "title": "Unit 5: First C Program"
        },
        {
            "location": "/05-first-c/index.html#variable-declaration",
            "text": "In the example above, you also see the lines  1 int   hypotenuse_square ;    This is declaration statement (terminated with a semicolon, again).  Each statement declares a variable with its corresponding type ( int  here).  We gave each variable a name, here we call the variable  hypotenuse_square .  Remember that  all variables must be declared with its corresponding type before used in C .  In C, a function must be either defined or declared before used as well.  In the example above, we define  square  before  main .  If we switch the order of the two, the compiler will complain.  Unless we declare the function first.  Declaring a function means that we simply state the return type, the name, and the parameters,  without  the body.  Here is an example:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14 int   square ( int   x );   // declaring the function square  int   main ()   { \n   int   hypotenuse_square ; \n\n   hypotenuse_square   =   square ( 3 )   +   square ( 4 ); \n   return   0 ;  }  int   square ( int   x )    // defining the function square  { \n   return   x * x ;  }",
            "title": "Variable Declaration"
        },
        {
            "location": "/05-first-c/index.html#assignment-statement",
            "text": "The next line of the code shows an example of an assignment statement.    1    hypotenuse_square   =   square ( 3 )   +   square ( 4 );    An assignment operator takes the form of:  1    left_hand_side   =   right_hand_side ;    The  left_hand_side  must be the name of a variable.  We first evaluate the  right_hand_side  of the assignment statement, find its value, then put the value into the variable named on the  left_hand_side .  Here, on the right-hand side, we call the function  square , which we defined earlier.  We call  square  with  arguments   3  and  4  respectively.   We use the operator  +  to add the two results together.  The right-hand side should give the value 25, which we then assign to the variable  hypotenuse_square .  Note that we use  =  equal sign for assignment, NOT for checking equality.  The C notation for checking for equality is  ==  (we will come back to this later).",
            "title": "Assignment Statement"
        },
        {
            "location": "/05-first-c/index.html#recap",
            "text": "Before we move on, let's recap some concepts:   A C program consists of functions, invoking each other.  Each function is defined by its returned type, followed by its name, its parameter(s) (within a pair of parenthesis) and its body (within a pair of curly brackets).    Each function must be defined or declared before it is used.    The function body consists of one or more statements.  We have seen assignment statements (using the  =  operator) and return statements, using  return  as the keyword.  Each variable must be declared before it is used.  A declaration starts with its type followed by its name.",
            "title": "Recap"
        },
        {
            "location": "/05-first-c/index.html#example-2",
            "text": "Let's change the program slightly, so that instead of computing the square of the hypotenuse, we compute the hypotenuse itself.  Recall that we said C provides a bunch of predefined functions, include  sqrt , which computes the square root of a given number.  Since a square root of a number is not necessarily an integer, we need to use a variable with a type that can store a real number.    To represent real numbers, we commonly use the type  float  (which is short for a floating point number -- named so due to how a real number is represented in bits).  A  float  type can store 32 bits.  To double the precision (64 bits), we can use the type  double .  A  long double  type can store either 80-bits or 128-bits, depending on the implementation.  But which one does  sqrt  returns?  To find out the exact  specification  of a pre-defined function, we can consult the manual (or  man  for short) pages for the function.    If you type  man sqrt  on the command line (or place the cursor on  sqrt  in  vim  and type  K  in command mode), you will see that the  sqrt  method has the following specification:  1 double   sqrt ( double   x );    The  sqrt  function returns a  double  precision real number.  We can now modify the program above to the following:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16 double   sqrt ( double   x );   // not recommended  long   square ( long   x )   { \n   return   x * x ;  }  double   hypotenuse_of ( long   base ,   long   height )   { \n   return   sqrt ( square ( base )   +   square ( height ));  }  int   main ()   { \n   hypotenuse_of ( 3 ,   4 );  }    Note that the first line declares the function  sqrt , because we need to declare a function before it is used.  Since  sqrt  is pre-defined elsewhere, we do not have to supply the function body here.  Such practice of declaring a predefined function ourselves, however, is not recommended.  Different platform, compilers, libraries, may provide a different specification for the same function.  As such, it is better to use the declaration from the library that provides the predefined function itself.  A library usually provides one or more  header files , a set of files that contain function declarations, type definitions, and constant definitions.  In the case of  sqrt , its declaration is contained in a header file called  math.h  (which we found out through consulting the  man  pages).  To include this file, you add the line  #include   <math.h>  at the top of the program.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16 #include   <math.h>  long   square ( long   x )   { \n   return   x * x ;  }  double   hypotenuse_of ( long   base ,   long   height )   { \n   return   sqrt ( square ( base )   +   square ( height ));  }  int   main ()   { \n   hypotenuse_of ( 3 ,   4 );  }    You might notice the same line appear in the man page for  sqrt .  Thus, the man pages tell us which header file to include if you want to use a certain function.   File Extension  The convention for file extension for a C program is  .c  and for a C header file is  .h .  Even though you are allowed to name the files with any extension you like, you should stick to the convention so that it is clear to other tools/programmers what is the purpose of each file.",
            "title": "Example 2"
        },
        {
            "location": "/05-first-c/index.html#other-types-in-c",
            "text": "An  int  variable is usually 32-bits long.  If we only need 16 bits, we use the type  short int , or just  short .  If we only need 8-bits, we use the type  char  (short for character).  Note that in the above, I said an  int  is  usually  32 bits.  Remember (from  Unit 1  that a C program gets compiled into machine code for a specific CPU architecture.  The C standard only guarantees that an  int  is at least 16 bits.  Although most C compilers compile  int  to 32 bits, there is no guarantee!      If we need something more than an  int , we can use  long int , or just  long .  The C standard guarantees that a  long  is at least 32 bits.  Depending on the implementation, it sometimes compiled to 32-bits, sometimes 64-bits.  To get even longer, we can use the type  long long int , or just  long long , which is guaranteed to be at least 64 bits 1 .",
            "title": "Other Types in C"
        },
        {
            "location": "/05-first-c/index.html#signed-vs-unsigned",
            "text": "We have seen earlier that the same sequence of bits, if interpreted as signed or unsigned, would result in a different value.  By default, all types in C refer to signed types.  If you want a variable that holds only non-negative integers, you can add the keyword  unsigned  to the front of the type.  Doing so would mean that the range of values you can store in the variable is doubled, without adding more bits (since the bit used to present the + or - sign is no longer needed).    For instance, since we know that  square  can only return a non-zero integer, we can actually declare it as:  1\n2\n3\n4 unsigned   long   square ( long   x )   { \n   return   x * x ;  }    For most practical purposes in CS1010, a (signed)  long  suffices.  We introduce the notion of  signed  vs.  unsigned  for your information so that you know what they are when you come across them in others source code.  Mixing  signed  and  unsigned  can lead to subtle bugs in your code.  As such,  we will only use signed  long  for CS1010 .  You may choose to use them appropriately in another context, especially for embedded system or low-level programming.   Unsigned Real Numbers?  There are no  unsigned  versions of  float  and  double .  To understand the reason, we have to go further into how floating points numbers are represented in bits.  That is a topic for another module.",
            "title": "Signed vs. Unsigned"
        },
        {
            "location": "/05-first-c/index.html#stdinth",
            "text": "Since the number of bits for  int ,  long , and  long long  could differ, in order to write a C program that is portable (i.e., works on different platforms, architecture, operating systems), we have two options:   Do not write a program that assumes a specific number of bits is used for a certain type, or  Use the type defined in the header file  stdint.h :  int8_t ,  uint8_t ,  int16_t ,  uint16_t ,  int32_t ,  uint32_t ,  int64_t ,  uint64_t .  The suffix  _t  is a convention to indicate that this is a customized type (more on this in later units).  The prefix  u  indicates that the type is an unsigned type.  The numbers  8 ,  16 ,  32 , and  64  indicate the number of bits for each type.  Thus,  uint32_t  is guaranteed to be of size 32 bits, and can hold unsigned integer values from  0 0  to  2^{32}-1 2^{32}-1 .",
            "title": "stdint.h"
        },
        {
            "location": "/05-first-c/index.html#problem-set-5",
            "text": "",
            "title": "Problem Set 5"
        },
        {
            "location": "/05-first-c/index.html#problem-51",
            "text": "In the example above,  sqrt  is declared to take in a parameter of type  double  .  But the argument that we pass in is the sum of two  int , which is also an  int .   Would this result in an error?",
            "title": "Problem 5.1"
        },
        {
            "location": "/05-first-c/index.html#problem-52",
            "text": "Consider the following alternative definition of  square  1\n2\n3 ???   square ( uint16_t   x )   { \n     return   x * x ;  }    What should the return type of this  square  be, in order for the return type to be big enough to store all possible value for  x*x ?      Adding more  long  does not make the integer longer, i.e., there is no  long long long int .\u00a0 \u21a9",
            "title": "Problem 5.2"
        },
        {
            "location": "/06-cs1010-io/index.html",
            "text": "Unit 6: The CS1010 I/O Library\n\n\nOur first C program that computes the hypotenuse doesn't do much -- it simply computes \n\\sqrt(3^2 + 4^2)\n\\sqrt(3^2 + 4^2)\n.  The value to be computed is hard-coded, and the result computed is not displayed.\n\n\nTo make this program more general and useful, first, we need to compute the hypotenuse for any length of the base and the height of a right-angled triangle.  We cannot hardcode the length in the program.   We should read these values from the users.  Second, we need to output the result of the computation to the users.  In other words, to make the program more general and useful, we need to add input and output, or I/O, functions.\n\n\nStandard Input and Standard Output\n\n\nBefore we talk about how to read the input values and display the output values, we have to first talk about where an input comes from and where an output goes to.\n\n\nIn UNIX-flavored operating systems, an input is read from an abstract channel called the \nstandard input\n, or \nstdin\n for short, and an output is sent to an abstract channel called the \nstandard output\n, or \nstdout\n for short.  \n\n\nThe fact that these channels are abstract is a powerful concept -- when we write our code, we do not have to worry about where the inputs come from and where the outputs go to.  It will depend on how the user runs our program.  Thus, it allows the users of our program the flexibility to control where the data comes from or goes to.\n\n\nFor instance, the standard input, by default, reads from the keyboard.  But the user can choose to read from a file, using the redirection \n<\n operator \nfrom the command line\n or from the output of another process, using the pipe \n|\n operator \nfrom the command line\n.  Similarly, the standard output, by default, writes to the terminal.  But the user can choose to write to a file using the redirection \n>\n operator \non the command line\n or to the input of another process, using the pipe \n|\n operator, again, on the command line when invoking the program.  You will see how cool these are later.  But for the purpose of C programming, it suffices to know for now that we only need to read from \nstdin\n and write to \nstdout\n in our code, and we let the users decide where they come from / go to.\n\n\nNo \nprintf\n and \nscanf\n (yet)\n\n\nIn almost all articles and textbooks on C that I have seen, the \nscanf\n and \nprintf\n functions are taught as the standard C library functions to perform the input and output respectively.  The function \nscanf\n, however, is tricky to use correctly and securely.  The function \nprintf\n comes with many nuances, such as remembering the different conversion specifiers and modifiers.  I would rather not teach you \nscanf\n and \nprintf\n at this stage.  As such, CS1010 is providing you a library to perform I/O -- the library provides a small set of essential functions to read and write \nlong\n values, \ndouble\n values, space-separated words, and lines of text. \n\n\nYou can find the \ndocumentation for the CS1010 I/O Library here\n.  We will see how to use the library to improve our hypotenuse computation program here.\n\n\nUsing the CS1010 I/O Library\n\n\nLet's modify our earlier program to now read the base and height from \nstdin\n, compute the hypotenuse, and print the results out to \nstdout\n.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n#include\n \n<math.h>\n\n\n#include\n \n\"cs1010.h\"\n\n\n\nlong\n \nsquare\n(\nlong\n \nx\n)\n \n\n{\n\n  \nreturn\n \nx\n*\nx\n;\n\n\n}\n\n\n\ndouble\n \nhypotenuse_of\n(\nlong\n \nbase\n,\n \nlong\n \nheight\n)\n \n\n{\n\n  \nreturn\n \nsqrt\n(\nsquare\n(\nbase\n)\n \n+\n \nsquare\n(\nheight\n));\n\n\n}\n\n\n\nint\n \nmain\n()\n \n\n{\n\n  \ndouble\n \nhypotenuse\n;\n\n  \nlong\n \nbase\n \n=\n \ncs1010_read_long\n();\n\n  \nlong\n \nheight\n \n=\n \ncs1010_read_long\n();\n\n  \nhypotenuse\n \n=\n \nhypotenuse_of\n(\nbase\n,\n \nheight\n);\n\n  \ncs1010_println_double\n(\nhypotenuse\n);\n\n\n}\n\n\n\n\n\n\n\nThe first change you see (on Line 2) is to include the file \ncs1010.h\n, which includes the declaration of functions provided by the library.  On Lines 17 and 18, we introduce two new \nlong\n variables named \nbase\n and \nheight\n, which we initialized with the returned value from \ncs1010_read_long()\n.  The function \ncs1010_read_long\n reads a \nlong\n value from \nstdin\n and returns the value.  For now, we assume that the inputs are correctly passed to the program.\n\n\nFinally, on Line 20, we print the resulting hypotenuse to \nstdout\n using the library function \ncs1010_println_double\n.  Note that there are two versions of functions to print a \ndouble\n value: \ncs1010_println_double\n and \ncs1010_print_double\n.  The one with \nprintln\n prints a new line character so that the text that got printed after appears in the next line.\n\n\nRefer to \nCS1010 Compilation Guide\n on how to compile a program that uses the CS1010 I/O library.\n\n\nNote that the \nmain\n function above can be written as a single statement without any state and assignment.  The resulting code, however, is not necessarily easier to understand.\n\n1\n2\n3\n4\nint\n \nmain\n()\n \n\n{\n\n  \ncs1010_println_double\n(\nhypotenuse_of\n(\ncs1010_read_long\n(),\n \ncs1010_read_long\n()));\n\n\n}",
            "title": "6. CS1010 I/O Library"
        },
        {
            "location": "/06-cs1010-io/index.html#unit-6-the-cs1010-io-library",
            "text": "Our first C program that computes the hypotenuse doesn't do much -- it simply computes  \\sqrt(3^2 + 4^2) \\sqrt(3^2 + 4^2) .  The value to be computed is hard-coded, and the result computed is not displayed.  To make this program more general and useful, first, we need to compute the hypotenuse for any length of the base and the height of a right-angled triangle.  We cannot hardcode the length in the program.   We should read these values from the users.  Second, we need to output the result of the computation to the users.  In other words, to make the program more general and useful, we need to add input and output, or I/O, functions.",
            "title": "Unit 6: The CS1010 I/O Library"
        },
        {
            "location": "/06-cs1010-io/index.html#standard-input-and-standard-output",
            "text": "Before we talk about how to read the input values and display the output values, we have to first talk about where an input comes from and where an output goes to.  In UNIX-flavored operating systems, an input is read from an abstract channel called the  standard input , or  stdin  for short, and an output is sent to an abstract channel called the  standard output , or  stdout  for short.    The fact that these channels are abstract is a powerful concept -- when we write our code, we do not have to worry about where the inputs come from and where the outputs go to.  It will depend on how the user runs our program.  Thus, it allows the users of our program the flexibility to control where the data comes from or goes to.  For instance, the standard input, by default, reads from the keyboard.  But the user can choose to read from a file, using the redirection  <  operator  from the command line  or from the output of another process, using the pipe  |  operator  from the command line .  Similarly, the standard output, by default, writes to the terminal.  But the user can choose to write to a file using the redirection  >  operator  on the command line  or to the input of another process, using the pipe  |  operator, again, on the command line when invoking the program.  You will see how cool these are later.  But for the purpose of C programming, it suffices to know for now that we only need to read from  stdin  and write to  stdout  in our code, and we let the users decide where they come from / go to.",
            "title": "Standard Input and Standard Output"
        },
        {
            "location": "/06-cs1010-io/index.html#no-printf-and-scanf-yet",
            "text": "In almost all articles and textbooks on C that I have seen, the  scanf  and  printf  functions are taught as the standard C library functions to perform the input and output respectively.  The function  scanf , however, is tricky to use correctly and securely.  The function  printf  comes with many nuances, such as remembering the different conversion specifiers and modifiers.  I would rather not teach you  scanf  and  printf  at this stage.  As such, CS1010 is providing you a library to perform I/O -- the library provides a small set of essential functions to read and write  long  values,  double  values, space-separated words, and lines of text.   You can find the  documentation for the CS1010 I/O Library here .  We will see how to use the library to improve our hypotenuse computation program here.",
            "title": "No printf and scanf (yet)"
        },
        {
            "location": "/06-cs1010-io/index.html#using-the-cs1010-io-library",
            "text": "Let's modify our earlier program to now read the base and height from  stdin , compute the hypotenuse, and print the results out to  stdout .   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21 #include   <math.h>  #include   \"cs1010.h\"  long   square ( long   x )   { \n   return   x * x ;  }  double   hypotenuse_of ( long   base ,   long   height )   { \n   return   sqrt ( square ( base )   +   square ( height ));  }  int   main ()   { \n   double   hypotenuse ; \n   long   base   =   cs1010_read_long (); \n   long   height   =   cs1010_read_long (); \n   hypotenuse   =   hypotenuse_of ( base ,   height ); \n   cs1010_println_double ( hypotenuse );  }    The first change you see (on Line 2) is to include the file  cs1010.h , which includes the declaration of functions provided by the library.  On Lines 17 and 18, we introduce two new  long  variables named  base  and  height , which we initialized with the returned value from  cs1010_read_long() .  The function  cs1010_read_long  reads a  long  value from  stdin  and returns the value.  For now, we assume that the inputs are correctly passed to the program.  Finally, on Line 20, we print the resulting hypotenuse to  stdout  using the library function  cs1010_println_double .  Note that there are two versions of functions to print a  double  value:  cs1010_println_double  and  cs1010_print_double .  The one with  println  prints a new line character so that the text that got printed after appears in the next line.  Refer to  CS1010 Compilation Guide  on how to compile a program that uses the CS1010 I/O library.  Note that the  main  function above can be written as a single statement without any state and assignment.  The resulting code, however, is not necessarily easier to understand. 1\n2\n3\n4 int   main ()   { \n   cs1010_println_double ( hypotenuse_of ( cs1010_read_long (),   cs1010_read_long ()));  }",
            "title": "Using the CS1010 I/O Library"
        },
        {
            "location": "/07-arithmetic-ops/index.html",
            "text": "Unit 7: Arithmetic Operations\n\n\nYou have seen the \n+\n operator in the previous units.  You can use \n+\n to add two variables, a value and a variable, or two values:\n\n\n1\n2\n3\n4\n5\n6\nlong\n \na\n \n=\n \n1\n;\n\n\nlong\n \nb\n \n=\n \n2\n;\n\n\nlong\n \nc\n \n=\n \n3\n;\n\n\na\n \n=\n \nb\n \n+\n \nc\n;\n \n// add two variables\n\n\nb\n \n=\n \na\n \n+\n \n4\n;\n \n// add a variable to a value\n\n\nc\n \n=\n \n5\n \n+\n \n6\n;\n \n// add two values\n\n\n\n\n\n\n\nYou can also use \n+\n on values returned by functions:\n\n\n1\nhypotenuse\n \n=\n \nsqrt\n(\nsquare\n(\nbase\n)\n \n+\n \nsquare\n(\nheight\n));\n\n\n\n\n\n\n\nYou have also seen the multiplication operator \n*\n.  It can be used in the same way as the \n+\n operator.  Three other useful operators are:\n\n\n\n\n/\n - division (e.g., \ndouble half_x = x / 2;\n)\n\n\n-\n - subtraction (e.g., \nlong deducted = income - 100\n)\n\n\n%\n - modulo (e.g, \nlong last_digit = number % 10\n);\n\n\n\n\nThe \n+\n, \n-\n, \n*\n, and \n/\n operators work on both integer types (\nchar\n, \nshort\n, \nint\n, \nlong\n, \nlong long\n) and real numbers (\nfloat\n, \ndouble\n).  The module operator \n%\n works only on integer types.\n\n\nOperator Precedence\n\n\nWe can chain the operations together to form expressions such as:\n\n\n1\n2\n3\nlong\n \nb\n \n=\n \n10\n;\n\n\nlong\n \nc\n \n=\n \n2\n;\n\n\nlong\n \na\n \n=\n \nb\n \n+\n \n2\n \n*\n \nc\n \n/\n \n4\n;\n\n\n\n\n\n\n\nWhen we have multiple operations appearing, however, it becomes harder to trace the sequence of evaluation.  What is the value of \na\n after the three lines above are executed?\n\n\nC actually has well-defined rules to the order of evaluation for the operators: \n*\n, \n/\n, and \n%\n take precedence over \n+\n and \n-\n, and the operators are evaluated from left to right.  \n\n\nThus, in the example above, \na\n will be 11 instead of 6 after the execution.\n\n\nTo change the order of execution, we can add parenthesis to the expression.  For instance:\n\n\n1\n2\nlong\n \na\n \n=\n \n(\nb\n \n+\n \n2\n)\n \n*\n \nc\n \n/\n \n4\n;\n \n// 6\n\n\nlong\n \na\n \n=\n \nb\n \n+\n \n(\n2\n \n*\n \nc\n \n/\n \n4\n);\n \n// 11\n\n\n\n\n\n\n\nThe expression in the parenthesis will be evaluated first.  To make your code easier to understand, \nyou should add parenthesis even if the order of evaluation is from left to right\n to make the order of evaluation explicit.\n\n\nCompound Operators\n\n\nIt is common to modify the value of a variable and store new value back to the same variable.  For example,\n\n\n1\n2\nindex\n \n=\n \nindex\n \n+\n \n1\n;\n  \n// increment the variable index\n\n\nage\n \n=\n \nage\n \n*\n \n2\n;\n  \n// double the variable age\n\n\n\n\n\n\n\nC provides \ncompound operators\n that simplify the expressions above.  For example,\n\n\n1\n2\nindex\n \n+=\n \n1\n;\n\n\nage\n \n*=\n \n2\n;\n\n\n\n\n\n\n\nThe syntax for a compound operator is \nop=\n, where \nop\n can be \n+\n, \n-\n, \n*\n, \n/\n, \n%\n, or other binary operators.  The statement:\n\n\n1\na op= b;\n\n\n\n\n\n\nmodifies \na\n the same way as:\n\n\n1\na = a op b\n\n\n\n\n\n\nCommon Mistakes Using Arithmetic Operations\n\n\nIt is important to remember that, when arithmetic operations in C is performed on a sequence of bits, where the value that it can represent is limited and is determined by its type.  A common mistake for beginner programmers is to forget this fact and treat the arithmetic operations as the same as the ones seen in mathematics.  \n\n\nLet's look at two common gotchas.\n\n\nOverflow\n\n\nConsider the following code:\n\n\n1\n2\nuint8_t\n \nc\n \n=\n \n255\n;\n\n\nc\n \n+=\n \n1\n;\n\n\n\n\n\n\n\nWhat is the value of variable \nc\n after the operation above?\n\n\nHere, we are adding one to the value 255, so \nc\n must store the value 256, right?\n\n\nIt turns out that after the execution above, \nc\n contains the value 0.  The variable \nc\n is of the type \nuint8_t\n, which is the unsigned 8-bit integer.  Being 8-bit, the variable can store values from 0 to 255.  When we add 1 to 255, even though we get the result 256, mathematically, we cannot store 256 in \nc\n -- there is not enough bits!  In this case, the value stored is \"wrap around\", and we get the value 0 instead.\n\n\nThe variable \nc\n above is unsigned. It gets trickier if \nc\n is signed.  In the case of overflowing signed integer, the behavior depends on the compiler and is undefined in the C standard.\n\n\nInteger Division\n\n\nNow, let's consider the following code:\n\n\n1\ndouble\n \nhalf\n \n=\n \n3\n/\n2\n;\n\n\n\n\n\n\n\nWhat is the value of variable \nhalf\n after the operation above?\n\n\nIt got to be 1.5, right?  \n\n\nIt turns out that, after executing the code above, the value of \nhalf\n is 1.0.  \n\n\nTo understand this, first, let's see what happen when we assign a floating point number to an integer type:\n\n\n1\nint\n \nx\n \n=\n \n1.5\n;\n\n\n\n\n\n\n\nC truncates the floating number and only stores the integer part of the value, 1 in this case, in \nx\n.\n\n\nSecond, when we perform an arithmetic operation, the resulting value will be an integer if both values are integer types.  If one of the operands is a floating point number, the result will be a floating point number\n1\n.\n\n\nSince 3 and 2 are both integers, the resulting value 1.5 are stored in an integer, which causes it to become 1.  We then store 1 into a \ndouble\n variable, causing the value of \nhalf\n to become \n1.0\n.\n\n\nBecause of this limitation, the operation \n/\n is sometimes also known as integer division when both operands are integers.  \n\n\nIn order to get the result 1.5 as expected, we can write either:\n\n1\ndouble\n \nhalf\n \n=\n \n3\n/\n2.0\n;\n\n\n\n\n\n\nor \n\n\n1\ndouble\n \nhalf\n \n=\n \n3\n/\n(\ndouble\n)\n2\n;\n\n\n\n\n\n\n\nThe second fix above explicitly convert the type, or \ncast\n the type of value 2 into a \ndouble\n.\n\n\nAvoid Increment / Decrement Operator\n\n\nIf you read C code in other places, you will certainly come across the increment or decrement operator, \n++\n or \n--\n.  The operators add one and minus one from the operand respectively.  So, the statement\n\n\n1\nindex\n \n+=\n \n1\n;\n\n\n\n\n\n\n\ncan be further shortened into \n\n\n1\nindex++;\n\n\n\n\n\n\nand the statement\n\n\n1\nindex\n \n-=\n \n1\n;\n\n\n\n\n\n\n\ncan be further shorten into \n\n\n1\nindex--;\n\n\n\n\n\n\nUsing these two operators only shorten your code by two characters per statement, but introduces several issues.  As such, we \nban the use of both increment and decrement operator in CS1010\n.\n\n\nSo, why aren't \n++\n and \n--\n welcomed in CS1010?  The \n++\n and \n--\n operators not only modify the value of the operand, it also returns a value.  We can write \nj = i++;\n to both increment \ni\n and assign the pre-incremented value of \ni\n to \nj\n.  In C, we can also write \nj = ++i;\n, which again, increment \ni\n, and assign the post-incremented value of \ni\n to \nj\n.  Things get tricky, when we write \ni = i++;\n, it is not clear how to interpret this.  The C standard leaves this behavior undefined and leaves it to the compiler to define its behavior.  Wei Tsang thinks that introducing all these complexities just to save two characters is not warranted.\n\n\n\n\n\n\n\n\n\n\nThe actual rules used by C, called \ninteger promotion\n and \nusual arithmetic conversion\n, are much more complex and are outside the scope of CS1010.  You should take a note of this, however, and in a later part of your study or career, if you need to delve deeper into writing or debugging C code, take a look at \nthis\n.\u00a0\n\u21a9",
            "title": "7. Arithmetic Operations"
        },
        {
            "location": "/07-arithmetic-ops/index.html#unit-7-arithmetic-operations",
            "text": "You have seen the  +  operator in the previous units.  You can use  +  to add two variables, a value and a variable, or two values:  1\n2\n3\n4\n5\n6 long   a   =   1 ;  long   b   =   2 ;  long   c   =   3 ;  a   =   b   +   c ;   // add two variables  b   =   a   +   4 ;   // add a variable to a value  c   =   5   +   6 ;   // add two values    You can also use  +  on values returned by functions:  1 hypotenuse   =   sqrt ( square ( base )   +   square ( height ));    You have also seen the multiplication operator  * .  It can be used in the same way as the  +  operator.  Three other useful operators are:   /  - division (e.g.,  double half_x = x / 2; )  -  - subtraction (e.g.,  long deducted = income - 100 )  %  - modulo (e.g,  long last_digit = number % 10 );   The  + ,  - ,  * , and  /  operators work on both integer types ( char ,  short ,  int ,  long ,  long long ) and real numbers ( float ,  double ).  The module operator  %  works only on integer types.",
            "title": "Unit 7: Arithmetic Operations"
        },
        {
            "location": "/07-arithmetic-ops/index.html#operator-precedence",
            "text": "We can chain the operations together to form expressions such as:  1\n2\n3 long   b   =   10 ;  long   c   =   2 ;  long   a   =   b   +   2   *   c   /   4 ;    When we have multiple operations appearing, however, it becomes harder to trace the sequence of evaluation.  What is the value of  a  after the three lines above are executed?  C actually has well-defined rules to the order of evaluation for the operators:  * ,  / , and  %  take precedence over  +  and  - , and the operators are evaluated from left to right.    Thus, in the example above,  a  will be 11 instead of 6 after the execution.  To change the order of execution, we can add parenthesis to the expression.  For instance:  1\n2 long   a   =   ( b   +   2 )   *   c   /   4 ;   // 6  long   a   =   b   +   ( 2   *   c   /   4 );   // 11    The expression in the parenthesis will be evaluated first.  To make your code easier to understand,  you should add parenthesis even if the order of evaluation is from left to right  to make the order of evaluation explicit.",
            "title": "Operator Precedence"
        },
        {
            "location": "/07-arithmetic-ops/index.html#compound-operators",
            "text": "It is common to modify the value of a variable and store new value back to the same variable.  For example,  1\n2 index   =   index   +   1 ;    // increment the variable index  age   =   age   *   2 ;    // double the variable age    C provides  compound operators  that simplify the expressions above.  For example,  1\n2 index   +=   1 ;  age   *=   2 ;    The syntax for a compound operator is  op= , where  op  can be  + ,  - ,  * ,  / ,  % , or other binary operators.  The statement:  1 a op= b;   modifies  a  the same way as:  1 a = a op b",
            "title": "Compound Operators"
        },
        {
            "location": "/07-arithmetic-ops/index.html#common-mistakes-using-arithmetic-operations",
            "text": "It is important to remember that, when arithmetic operations in C is performed on a sequence of bits, where the value that it can represent is limited and is determined by its type.  A common mistake for beginner programmers is to forget this fact and treat the arithmetic operations as the same as the ones seen in mathematics.    Let's look at two common gotchas.",
            "title": "Common Mistakes Using Arithmetic Operations"
        },
        {
            "location": "/07-arithmetic-ops/index.html#overflow",
            "text": "Consider the following code:  1\n2 uint8_t   c   =   255 ;  c   +=   1 ;    What is the value of variable  c  after the operation above?  Here, we are adding one to the value 255, so  c  must store the value 256, right?  It turns out that after the execution above,  c  contains the value 0.  The variable  c  is of the type  uint8_t , which is the unsigned 8-bit integer.  Being 8-bit, the variable can store values from 0 to 255.  When we add 1 to 255, even though we get the result 256, mathematically, we cannot store 256 in  c  -- there is not enough bits!  In this case, the value stored is \"wrap around\", and we get the value 0 instead.  The variable  c  above is unsigned. It gets trickier if  c  is signed.  In the case of overflowing signed integer, the behavior depends on the compiler and is undefined in the C standard.",
            "title": "Overflow"
        },
        {
            "location": "/07-arithmetic-ops/index.html#integer-division",
            "text": "Now, let's consider the following code:  1 double   half   =   3 / 2 ;    What is the value of variable  half  after the operation above?  It got to be 1.5, right?    It turns out that, after executing the code above, the value of  half  is 1.0.    To understand this, first, let's see what happen when we assign a floating point number to an integer type:  1 int   x   =   1.5 ;    C truncates the floating number and only stores the integer part of the value, 1 in this case, in  x .  Second, when we perform an arithmetic operation, the resulting value will be an integer if both values are integer types.  If one of the operands is a floating point number, the result will be a floating point number 1 .  Since 3 and 2 are both integers, the resulting value 1.5 are stored in an integer, which causes it to become 1.  We then store 1 into a  double  variable, causing the value of  half  to become  1.0 .  Because of this limitation, the operation  /  is sometimes also known as integer division when both operands are integers.    In order to get the result 1.5 as expected, we can write either: 1 double   half   =   3 / 2.0 ;    or   1 double   half   =   3 / ( double ) 2 ;    The second fix above explicitly convert the type, or  cast  the type of value 2 into a  double .",
            "title": "Integer Division"
        },
        {
            "location": "/07-arithmetic-ops/index.html#avoid-increment-decrement-operator",
            "text": "If you read C code in other places, you will certainly come across the increment or decrement operator,  ++  or  -- .  The operators add one and minus one from the operand respectively.  So, the statement  1 index   +=   1 ;    can be further shortened into   1 index++;   and the statement  1 index   -=   1 ;    can be further shorten into   1 index--;   Using these two operators only shorten your code by two characters per statement, but introduces several issues.  As such, we  ban the use of both increment and decrement operator in CS1010 .  So, why aren't  ++  and  --  welcomed in CS1010?  The  ++  and  --  operators not only modify the value of the operand, it also returns a value.  We can write  j = i++;  to both increment  i  and assign the pre-incremented value of  i  to  j .  In C, we can also write  j = ++i; , which again, increment  i , and assign the post-incremented value of  i  to  j .  Things get tricky, when we write  i = i++; , it is not clear how to interpret this.  The C standard leaves this behavior undefined and leaves it to the compiler to define its behavior.  Wei Tsang thinks that introducing all these complexities just to save two characters is not warranted.      The actual rules used by C, called  integer promotion  and  usual arithmetic conversion , are much more complex and are outside the scope of CS1010.  You should take a note of this, however, and in a later part of your study or career, if you need to delve deeper into writing or debugging C code, take a look at  this .\u00a0 \u21a9",
            "title": "Avoid Increment / Decrement Operator"
        },
        {
            "location": "/08-if-else/index.html",
            "text": "Unit 8: Conditional Statement\n\n\nSo far the C programs that we have written has a straightforward \nexecution path\n.  The execution flows from top to bottom in \nmain\n, jumping to a function being called (or \ncallee\n), and back to the caller when the function returns.\n\n\nWe have, however, seen a few examples so far where the execution path can \nbranch\n off to either one of two paths, depends on a condition:\n\n\n\n\nIn the algorithm to compute the \nmax(L, k)\nmax(L, k)\n, we check if \nl_i > m\nl_i > m\n, and update \nm\nm\n only if this is true.  \n\n\nIn the algorithm to compute the \nfactorial(n)\nfactorial(n)\n, we check if \nn\nn\n equals 0, and return 1 if it is true, otherwise, we return \nn \\times factorial(n-1)\nn \\times factorial(n-1)\n.\n\n\n\n\nWe are not ready to write C code that processes a list yet, so let's use the \nfactorial(n)\nfactorial(n)\n function as an example.  In C, the \nfactorial(n)\nfactorial(n)\n would look like this:\n\n\n1\n2\n3\n4\n5\n6\n7\nlong\n \nfactorial\n(\nlong\n \nn\n)\n \n\n{\n\n  \nif\n \n(\nn\n \n==\n \n0\n)\n \n{\n\n    \nreturn\n \n1\n;\n\n  \n}\n\n  \nreturn\n \nn\n \n*\n \nfactorial\n(\nn\n \n-\n \n1\n);\n\n\n}\n\n\n\n\n\n\n\n\n\nIn this example, you see a new C keyword \nif\n.  This keyword is used at the beginning of a conditional block of code.  The general syntax is:\n\n\n1\n2\n3\nif\n \n(\n<\nlogical\n \nexpression\n>\n)\n \n{\n \n  \n\"true block\"\n:\n \nstatements\n \nto\n \nbe\n \nexecuted\n \nif\n \nexpression\n \nevaluates\n \nto\n \ntrue\n\n\n}\n\n\n\n\n\n\n\nThe \nif\n keyword is followed by a \nlogical expression\n in parenthesis.  This is followed by a block of statements (in curly braces \n{\n and \n}\n).  If the logical expression is true, then the statements are executed, otherwise, they are skipped.  For this reason, the group of statements is known as a \ntrue block\n.\n\n\nComparison Operator\n\n\nThe logical expression \nn == 0\n is true if the variable \nn\n holds the value of \n0\n.  \n\n\n\n\n==\n vs \n=\n\n\nNote that use of TWO \n=\n signs.  This is often confused by newbie programmers with a single \n=\n sign, which is used for assignment.  A common bug is to write\n\n\n1\n2\n3\n  \nif\n \n(\nn\n \n=\n \n0\n)\n \n{\n\n     \n:\n\n  \n}\n\n\n\n\n\n\n\n\n\nThe \n==\n is known as a \ncomparison operator\n.  It compares if the left-hand side has the same value as the right-hand side. Other comparison operators include \n>\n (greater than), \n<\n (less than), \n>=\n (greater or equal to), \n<=\n (less than or equal to), and \n!=\n (not equal).\n\n\nIn other words, the function \nfactorial\n will exit and return \n1\n if the parameter \nn\n equals to \n0\n.  The rest of the code (particularly, Line \n5\n 6) will be skipped.\n\n\nWhat if \nn\n is not \n0\n?  The block that contains Line 3 \nreturn 1;\n will be skipped, and Line \n5\n 6 \nreturn n * factorial(n - 1);\n will be executed instead, which is what we intended for the \nfactorial\n function to do.\n\n\nExample: Max of two numbers\n\n\nLet's switch to another example: suppose we have three variables, \nx\n, \ny\n, and \nmax\n, and we want to set \nmax\n to the maximum of \nx\n and \ny\n.\n\n\nConsider the following code snippet:\n\n\n1\n2\n3\n4\n5\n6\nif\n \n(\nx\n \n>\n \ny\n)\n \n{\n\n  \nmax\n \n=\n \nx\n;\n\n\n}\n \n\nif\n \n(\nx\n \n<\n \ny\n)\n \n{\n\n  \nmax\n \n=\n \ny\n;\n\n\n}\n\n\n\n\n\n\n\nTake a moment to understand the code above, and see if you can figure out what is wrong.\n\n\nWhen we think about writing conditionals, we have to exhaustively reason about what are all the possible scenarios that could occur.  In this example, we need to think about what are the possible relationships between \nx\n and \ny\n when we compare \nx\n an \ny\n.  There are actually three possibilities!\n\n\n\n\nx > y\n: in this case, \nx\n is larger and we set \nmax\n to \nx\n\n\ny > x\n: in this case, \ny\n is larger and we set \nmax\n to \ny\n\n\nx == y\n: in this case, both are equally large, so the maximum of the two can be either \nx\n or \ny\n.\n\n\n\n\nIn the code above, \nmax\n is not set properly if \nx == y\n!\n\n\nThe following code adds the third case and arbitrarily chooses to set \nmax\n to \ny\n if both \nx\n and \ny\n have the same value.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nif\n \n(\nx\n \n>\n \ny\n)\n \n{\n\n  \nmax\n \n=\n \nx\n;\n\n\n}\n \n\nif\n \n(\nx\n \n<\n \ny\n)\n \n{\n\n  \nmax\n \n=\n \ny\n;\n\n\n}\n\n\nif\n \n(\nx\n \n==\n \ny\n)\n \n{\n\n  \nmax\n \n=\n \ny\n;\n\n\n}\n\n\n\n\n\n\n\nElse\n\n\nThe code snippet above now correctly sets \nmax\n to the maximum of \nx\n and \ny\n.\nThe code, however, is not very satisfying, since we compare between \nx\n and \ny\n three times.   Let's see how we can reduce the number of comparisons to one.  We are going to do some \nrefactoring\n of the code above.\n\n\nFirst, observe that the \"true block\" for \nx < y\n and \nx == y\n are the same, and we can combine it into a single comparison \nx <= y\n.\n\n\n1\n2\n3\n4\n5\n6\nif\n \n(\nx\n \n>\n \ny\n)\n \n{\n\n  \nmax\n \n=\n \nx\n;\n\n\n}\n \n\nif\n \n(\nx\n \n<=\n \ny\n)\n \n{\n\n  \nmax\n \n=\n \ny\n;\n\n\n}\n\n\n\n\n\n\n\nSecond, observe that if \nx > y\n is false, then \nx <= y\n must be true.  We say that \nx > y\n and \nx <= y\n are \nnegation\n (or opposite) of each other.  So, the check for \nx <= y\n is redundant -- checking \nx > y\n is enough to tell us if \nx <= y\n.  We can re-write the code above as:\n\n\n1\n2\n3\n4\n5\nif\n \n(\nx\n \n>\n \ny\n)\n \n{\n\n  \nmax\n \n=\n \nx\n;\n\n\n}\n \nelse\n \n{\n\n  \nmax\n \n=\n \ny\n;\n\n\n}\n\n\n\n\n\n\n\nThe word \nelse\n as seen above is another C keyword -- it must be used in conjunction with \nif\n to indicate an alternate path of execution if the logical expression is false.\n\n\n1\n2\n3\n4\n5\nif\n \n(\n<\nlogical\n \nexpression\n>\n)\n \n{\n \n  \n\"true block\"\n:\n \nstatements\n \nto\n \nbe\n \nexecuted\n \nif\n \nexpression\n \nevaluates\n \nto\n \ntrue\n\n\n}\n \nelse\n \n{\n\n  \n\"false block\"\n:\n \nstatements\n \nto\n \nbe\n \nexecuted\n \nif\n \nexpression\n \nevaluates\n \nto\n \nfalse\n\n\n}\n\n\n\n\n\n\n\nNested Else-If\n\n\nThe example above considers \ntwo\n possible execution paths only.  In some situations, we may need to consider more than two execution paths.  Take the following problem for example.  You are given the numerical score for an assignment, ranged between 0 and 10.  Print out the letter grade of the assignment according to the table below:\n\n\n\n\n\n\n\n\nScore\n\n\nLetter Grade\n\n\n\n\n\n\n\n\n\n\n8 or higher\n\n\nA\n\n\n\n\n\n\nLess than 8 but 5 or higher\n\n\nB\n\n\n\n\n\n\nLess than 5 but 3 or higher\n\n\nC\n\n\n\n\n\n\nLess than 3\n\n\nD\n\n\n\n\n\n\n\n\nSince the \nif\n-\nelse\n statement only allows branching into two possibilities, we can branch into multiple possibilities by nesting the \nif\n-\nelse\n statements hierarchically.  We can first break the table down into three tables, each containing only two rows, with one row a negation of the other row.\n\n\n\n\n\n\n\n\nScore\n\n\nLetter Grade\n\n\n\n\n\n\n\n\n\n\n8 or higher\n\n\nA\n\n\n\n\n\n\nLess than 8\n\n\nSee Table 1\n\n\n\n\n\n\n\n\nTable 1 (less than 8)\n\n\n\n\n\n\n\n\nScore\n\n\nLetter Grade\n\n\n\n\n\n\n\n\n\n\n5 or higher\n\n\nB\n\n\n\n\n\n\nLess than 5\n\n\nSee Table 2\n\n\n\n\n\n\n\n\nTable 2 (less than 5)\n\n\n\n\n\n\n\n\nScore\n\n\nLetter Grade\n\n\n\n\n\n\n\n\n\n\n3 or higher\n\n\nC\n\n\n\n\n\n\nLess than 3\n\n\nD\n\n\n\n\n\n\n\n\nThe tables above can then be written into the following function:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\nvoid\n \nprint_score\n(\ndouble\n \nscore\n)\n \n\n{\n\n  \nif\n \n(\nscore\n \n>=\n \n8\n)\n \n{\n\n    \ncs1010_println_string\n(\n\"A\"\n);\n\n  \n}\n \nelse\n \n{\n\n    \n// Table 1\n\n    \nif\n \n(\nscore\n \n>=\n \n5\n)\n \n{\n\n      \ncs1010_println_string\n(\n\"B\"\n);\n\n    \n}\n \nelse\n \n{\n\n      \n// Table 2\n\n      \nif\n \n(\nscore\n \n>=\n \n3\n)\n \n{\n\n        \ncs1010_println_string\n(\n\"C\"\n);\n\n      \n}\n \nelse\n \n{\n\n        \ncs1010_println_string\n(\n\"D\"\n);\n\n      \n}\n\n    \n}\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\nThere are three nested \nif\n-\nelse\n in the function above.  Note how I use indentation to clearly indicate the nesting of blocks.  Such nesting or indentation is not required by C standard, but is a commonly accepted coding practice, and is required for CS1010.\n\n\nThe code below compiles perfectly but is not as easy to read by a human as the above.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\nvoid\n \nprint_score\n(\ndouble\n \nscore\n)\n \n\n{\n\n  \nif\n \n(\nscore\n \n>=\n \n8\n)\n \n{\n\n    \ncs1010_println_string\n(\n\"A\"\n);\n \n}\n \nelse\n \n{\n \n// Table 1 \n\n    \nif\n \n(\nscore\n \n>=\n \n5\n)\n \n{\n \ncs1010_println_string\n(\n\"B\"\n);\n\n  \n}\n \nelse\n \n{\n \n// Table 2\n\n\nif\n \n(\nscore\n \n>=\n \n3\n)\n \n{\n\n  \ncs1010_println_string\n(\n\"C\"\n);\n\n      \n}\n \nelse\n \n{\n\n        \ncs1010_println_string\n(\n\"D\"\n);\n\n    \n}\n \n}\n \n}\n \n}\n\n\n// Don't write code like this.\n\n\n\n\n\n\n\nThere are also a couple of \"first\" in the sample code above:\n\n\n\n\nYou see the keyword \nvoid\n for the first time.  \nvoid\n is a special type that indicates nothing.  The function \nprint_score\n does not return anything, it accepts an input \nscore\n and print something to screen.  As such, we say that the return type of \nprint_score\n is \nvoid\n.\n\n\nYou see \nstrings\n for the first time (\n\"A\"\n, etc.).  A \nstring\n basically is a sequence of characters.  We use double quotes \n\"\n to mark the beginning and the end of a string, and use the CS1010 I/O library function \ncs1010_println_string\n to print a string to the screen. \n\n\n\n\nYou can imagine that as the number of possible letter grades increases (NUS has 11), we will have many nested \nif\n-\nelse\n, and the code gets complicated.  To reduce the number of nesting, we can write \nelse if\n directly, without nesting:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\nvoid\n \nprint_score\n(\ndouble\n \nscore\n)\n \n\n{\n\n  \nif\n \n(\nscore\n \n>=\n \n8\n)\n \n{\n\n    \ncs1010_println_string\n(\n\"A\"\n);\n\n  \n}\n \nelse\n \nif\n \n(\nscore\n \n>=\n \n5\n)\n \n{\n\n    \ncs1010_println_string\n(\n\"B\"\n);\n\n  \n}\n \nelse\n \nif\n \n(\nscore\n \n>=\n \n3\n)\n \n{\n\n    \ncs1010_println_string\n(\n\"C\"\n);\n\n  \n}\n \nelse\n \n{\n\n    \ncs1010_println_string\n(\n\"D\"\n);\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\nThe above code is easier to read, but has exactly the same flow as the one with nested \nif\n-\nelse\n earlier.\n\n\nAvoid Skipping the Curly Braces\n\n\nThe C standard says that, if the block contains only one statement, we can skip the curly braces \n{\n and \n}\n.  In the example above, we can write:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\nvoid\n \nprint_score\n(\ndouble\n \nscore\n)\n \n\n{\n\n  \nif\n \n(\nscore\n \n>=\n \n8\n)\n \n    \ncs1010_println_string\n(\n\"A\"\n);\n\n  \nelse\n \nif\n \n(\nscore\n \n>=\n \n5\n)\n\n    \ncs1010_println_string\n(\n\"B\"\n);\n\n  \nelse\n \nif\n \n(\nscore\n \n>=\n \n3\n)\n\n    \ncs1010_println_string\n(\n\"C\"\n);\n\n  \nelse\n\n    \ncs1010_println_string\n(\n\"D\"\n);\n\n\n}\n\n\n\n\n\n\n\nDespite being allowed by the C standard, this is considered a bad practice, and should be avoided.  Imagine some time later, you go back to this code, and want to write something extra:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\nvoid\n \nprint_score\n(\ndouble\n \nscore\n)\n \n\n{\n\n  \nif\n \n(\nscore\n \n>=\n \n8\n)\n \n    \ncs1010_println_string\n(\n\"A\"\n);\n\n  \nelse\n \nif\n \n(\nscore\n \n>=\n \n5\n)\n\n    \ncs1010_println_string\n(\n\"B\"\n);\n\n  \nelse\n \nif\n \n(\nscore\n \n>=\n \n3\n)\n\n    \ncs1010_println_string\n(\n\"C\"\n);\n\n  \nelse\n\n    \ncs1010_println_string\n(\n\"You can do better!\"\n);\n\n    \ncs1010_println_string\n(\n\"D\"\n);\n\n\n}\n\n\n\n\n\n\n\nWhat would be printed?\n\n\nThe famous \nApple \ngoto fail\n bug\n wouldn't have happened in the there is a pair of curly braces added!\n\n\nAlternatively, if you have code like this:\n\n\n1\n2\n3\n4\n5\nif\n \n(\nscore\n \n>=\n \n8\n)\n\n  \nif\n \n(\nlate_penalty\n \n!=\n \n0\n)\n \n      \ncs1010_println_string\n(\n\"late submission\"\n);\n\n\nelse\n \n  \ncs1010_println_string\n(\n\"you can do better!\"\n);\n\n\n\n\n\n\n\nIt might look like \nyou can do better!\n will be printed if \nscore\n is less than 8, but actually, \nyou can do better!\n will be printed if the \nscore\n is larger or equal to 8 and there is no late penalty, which is not what is intended.\n\n\nConditional Operator\n\n\nThe conditional operator consists of two special characters \n?\n and \n:\n and is used in the format of:\n\n\n1\ncondition ? true expression : false expression;\n\n\n\n\n\n\nIf the \ncondition\n evaluates to true, then the \ntrue expression\n will be evaluated and returned, otherwise, the \nfalse expression\n will be evaluated and returned.\n\n\nThe conditional operator allows us to replace\n\n\n1\n2\n3\n4\n5\nif\n \n(\nx\n \n>\n \ny\n)\n \n{\n\n  \nmax\n \n=\n \nx\n;\n\n\n}\n \nelse\n \n{\n\n  \nmax\n \n=\n \ny\n;\n\n\n}\n\n\n\n\n\n\n\nwith a single line:\n\n\n1\nmax = (x > y) ? x : y;\n\n\n\n\n\n\nWe can nest the conditional operator as well, but it does not necessarily make your code easier to read once you start nesting them up.  We do not encourage you to nest the conditional operator in CS1010 and to limit its usage to simple cases above.\n\n\nComparing Real Numbers\n\n\nRecall that we said \nreal numbers cannot be represented exactly in computers\n.  Comparing real numbers, therefore, becomes a little bit trickier in programming.  The \nif\n statement\n\n\n1\n2\n3\n4\n5\ndouble\n \nexpected_value\n \n=\n \n0.3\n;\n\n\ndouble\n \nsum\n \n=\n \n0.1\n \n+\n \n0.2\n;\n\n\nif\n \n(\nsum\n \n==\n \nexpected_value\n)\n \n{\n\n \n:\n\n\n}\n\n\n\n\n\n\n\nwould not be evaluated as \ntrue\n as expected!\n\n\nThus, to compare real numbers, we normally allow some errors in comparisons -- we want the absolute difference between \nsum\n and \nexpected_value\n to be small enough.\n\n\n1\n2\n3\n4\n5\ndouble\n \nexpected_value\n \n=\n \n0.3\n;\n\n\ndouble\n \nsum\n \n=\n \n0.1\n \n+\n \n0.2\n;\n\n\nif\n \n(\nfabs\n(\nsum\n \n-\n \nexpected_value\n)\n \n<\n \n0.000001\n)\n \n{\n\n \n:\n\n\n}\n\n\n\n\n\n\n\nProblem Sets\n\n\nProblem 8.1\n\n\n(a) Do the following two functions behave the same way?  Explain.\n\n\n1\n2\n3\n4\n5\n6\n7\nlong\n \nfactorial\n(\nlong\n \nn\n)\n \n\n{\n\n  \nif\n \n(\nn\n \n==\n \n0\n)\n \n{\n\n    \nreturn\n \n1\n;\n\n  \n}\n\n  \nreturn\n \nn\n \n*\n \nfactorial\n(\nn\n \n-\n \n1\n);\n\n\n}\n\n\n\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\nlong\n \nfactorial\n(\nlong\n \nn\n)\n \n\n{\n\n  \nif\n \n(\nn\n \n==\n \n0\n)\n \n{\n\n    \nreturn\n \n1\n;\n\n  \n}\n \nelse\n \n{\n\n    \nreturn\n \nn\n \n*\n \nfactorial\n(\nn\n \n-\n \n1\n);\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\n(b) How about:\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nlong\n \nfactorial\n(\nlong\n \nn\n)\n \n\n{\n\n  \nlong\n \nresult\n;\n\n  \nif\n \n(\nn\n \n==\n \n0\n)\n \n{\n\n    \nresult\n \n=\n \n1\n;\n\n  \n}\n\n  \nresult\n \n=\n \nn\n \n*\n \nfactorial\n(\nn\n \n-\n \n1\n);\n\n  \nreturn\n \nresult\n;\n\n\n}\n\n\n\n\n\n\n\nand \n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\nlong\n \nfactorial\n(\nlong\n \nn\n)\n \n\n{\n\n  \nlong\n \nresult\n;\n\n  \nif\n \n(\nn\n \n==\n \n0\n)\n \n{\n\n    \nresult\n \n=\n \n1\n;\n\n  \n}\n \nelse\n \n{\n\n    \nresult\n \n=\n \nn\n \n*\n \nfactorial\n(\nn\n \n-\n \n1\n);\n\n  \n}\n\n  \nreturn\n \nresult\n;\n\n\n}\n\n\n\n\n\n\n\nProblem 8.2\n\n\nDraw the flowchart for the code snippet\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nif\n \n(\nx\n \n>\n \ny\n)\n \n{\n\n  \nmax\n \n=\n \nx\n;\n\n\n}\n \n\nif\n \n(\nx\n \n<\n \ny\n)\n \n{\n\n  \nmax\n \n=\n \ny\n;\n\n\n}\n\n\nif\n \n(\nx\n \n==\n \ny\n)\n \n{\n\n  \nmax\n \n=\n \ny\n;\n\n\n}\n\n\n\n\n\n\n\nand\n\n\n1\n2\n3\n4\n5\nif\n \n(\nx\n \n>\n \ny\n)\n \n{\n\n  \nmax\n \n=\n \nx\n;\n\n\n}\n \nelse\n \n{\n\n  \nmax\n \n=\n \ny\n;\n\n\n}\n\n\n\n\n\n\n\nProblem 8.3\n\n\nSuppose we break down the table below in a slightly different way.\n\n\n\n\n\n\n\n\nScore\n\n\nLetter Grade\n\n\n\n\n\n\n\n\n\n\n8 or higher\n\n\nA\n\n\n\n\n\n\nLess than 8 but 5 or higher\n\n\nB\n\n\n\n\n\n\nLess than 5 but 3 or higher\n\n\nC\n\n\n\n\n\n\nLess than 3\n\n\nD\n\n\n\n\n\n\n\n\nWe rewrite the tables into three smaller tables, as:\n\n\n\n\n\n\n\n\nScore\n\n\nLetter Grade\n\n\n\n\n\n\n\n\n\n\n5 or higher\n\n\nSee Table 3\n\n\n\n\n\n\nLess than 5\n\n\nSee Table 4\n\n\n\n\n\n\n\n\nwhere Table 3 (5 or higher) is\n\n\n\n\n\n\n\n\nScore\n\n\nLetter Grade\n\n\n\n\n\n\n\n\n\n\n8 or higher\n\n\nA\n\n\n\n\n\n\nLess than 8\n\n\nB\n\n\n\n\n\n\n\n\nand Table 4 (less than 5) is\n\n\n\n\n\n\n\n\nScore\n\n\nLetter Grade\n\n\n\n\n\n\n\n\n\n\n3 or higher\n\n\nC\n\n\n\n\n\n\nLess than 3\n\n\nD\n\n\n\n\n\n\n\n\nWrite the corresponding \nif\n-\nelse\n statements to print out the letter grade based on the tables above.\n\n\nAppendix: Code From Lecture\n\n\nHere are the C files that Wei Tsang wrote during the lecture.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n#include\n \n\"cs1010.h\"\n\n\n\nlong\n \nfactorial\n(\nlong\n \nn\n)\n\n\n{\n\n  \nif\n \n(\nn\n \n==\n \n0\n)\n \n{\n\n    \nreturn\n \n1\n;\n\n  \n}\n \n  \nreturn\n \nn\n \n*\n \nfactorial\n(\nn\n-\n1\n);\n\n\n}\n\n\n\nint\n \nmain\n()\n\n\n{\n\n  \nlong\n \nn\n \n=\n \ncs1010_read_long\n();\n\n  \nlong\n \nfac\n \n=\n \nfactorial\n(\nn\n);\n\n  \ncs1010_println_long\n(\nfac\n);\n\n\n}\n\n\n\n\n\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n#include\n \n\"cs1010.h\"\n\n\n\nlong\n \nmax\n(\nlong\n \nx\n,\n \nlong\n \ny\n)\n\n\n{\n\n  \nif\n \n(\nx\n \n>\n \ny\n)\n \n{\n\n    \nreturn\n \nx\n;\n\n  \n}\n \nelse\n \n{\n\n    \nreturn\n \ny\n;\n\n  \n}\n\n  \n// alternatively, using the conditional operator ? :\n\n  \n// return (x > y) ? x : y;\n\n\n}\n\n\n\nint\n \nmain\n()\n\n\n{\n\n  \nlong\n \nx\n \n=\n \ncs1010_read_long\n();\n\n  \nlong\n \ny\n \n=\n \ncs1010_read_long\n();\n\n  \nlong\n \nm\n \n=\n \nmax\n(\nx\n,\n \ny\n);\n\n  \ncs1010_println_long\n(\nm\n);\n\n\n}\n\n\n\n\n\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n#include\n \n\"cs1010.h\"\n\n\n\nvoid\n \nprint_score\n(\ndouble\n \nx\n)\n\n\n{\n\n  \nif\n \n(\nx\n \n>=\n \n8\n)\n\n    \ncs1010_println_string\n(\n\"A\"\n);\n\n  \nelse\n \nif\n \n(\nx\n \n>=\n \n5\n)\n\n    \ncs1010_println_string\n(\n\"B\"\n);\n\n  \nelse\n \nif\n \n(\nx\n \n>=\n \n3\n)\n\n    \ncs1010_println_string\n(\n\"C\"\n);\n\n  \nelse\n\n    \ncs1010_println_string\n(\n\"D\"\n);\n\n\n}\n\n\n\nint\n \nmain\n()\n\n\n{\n\n  \ndouble\n \nscore\n \n=\n \ncs1010_read_double\n();\n\n  \nprint_score\n(\nscore\n);\n\n\n}",
            "title": "8. If Else"
        },
        {
            "location": "/08-if-else/index.html#unit-8-conditional-statement",
            "text": "So far the C programs that we have written has a straightforward  execution path .  The execution flows from top to bottom in  main , jumping to a function being called (or  callee ), and back to the caller when the function returns.  We have, however, seen a few examples so far where the execution path can  branch  off to either one of two paths, depends on a condition:   In the algorithm to compute the  max(L, k) max(L, k) , we check if  l_i > m l_i > m , and update  m m  only if this is true.    In the algorithm to compute the  factorial(n) factorial(n) , we check if  n n  equals 0, and return 1 if it is true, otherwise, we return  n \\times factorial(n-1) n \\times factorial(n-1) .   We are not ready to write C code that processes a list yet, so let's use the  factorial(n) factorial(n)  function as an example.  In C, the  factorial(n) factorial(n)  would look like this:  1\n2\n3\n4\n5\n6\n7 long   factorial ( long   n )   { \n   if   ( n   ==   0 )   { \n     return   1 ; \n   } \n   return   n   *   factorial ( n   -   1 );  }     In this example, you see a new C keyword  if .  This keyword is used at the beginning of a conditional block of code.  The general syntax is:  1\n2\n3 if   ( < logical   expression > )   {  \n   \"true block\" :   statements   to   be   executed   if   expression   evaluates   to   true  }    The  if  keyword is followed by a  logical expression  in parenthesis.  This is followed by a block of statements (in curly braces  {  and  } ).  If the logical expression is true, then the statements are executed, otherwise, they are skipped.  For this reason, the group of statements is known as a  true block .",
            "title": "Unit 8: Conditional Statement"
        },
        {
            "location": "/08-if-else/index.html#comparison-operator",
            "text": "The logical expression  n == 0  is true if the variable  n  holds the value of  0 .     ==  vs  =  Note that use of TWO  =  signs.  This is often confused by newbie programmers with a single  =  sign, which is used for assignment.  A common bug is to write  1\n2\n3    if   ( n   =   0 )   { \n      : \n   }     The  ==  is known as a  comparison operator .  It compares if the left-hand side has the same value as the right-hand side. Other comparison operators include  >  (greater than),  <  (less than),  >=  (greater or equal to),  <=  (less than or equal to), and  !=  (not equal).  In other words, the function  factorial  will exit and return  1  if the parameter  n  equals to  0 .  The rest of the code (particularly, Line  5  6) will be skipped.  What if  n  is not  0 ?  The block that contains Line 3  return 1;  will be skipped, and Line  5  6  return n * factorial(n - 1);  will be executed instead, which is what we intended for the  factorial  function to do.",
            "title": "Comparison Operator"
        },
        {
            "location": "/08-if-else/index.html#example-max-of-two-numbers",
            "text": "Let's switch to another example: suppose we have three variables,  x ,  y , and  max , and we want to set  max  to the maximum of  x  and  y .  Consider the following code snippet:  1\n2\n3\n4\n5\n6 if   ( x   >   y )   { \n   max   =   x ;  }   if   ( x   <   y )   { \n   max   =   y ;  }    Take a moment to understand the code above, and see if you can figure out what is wrong.  When we think about writing conditionals, we have to exhaustively reason about what are all the possible scenarios that could occur.  In this example, we need to think about what are the possible relationships between  x  and  y  when we compare  x  an  y .  There are actually three possibilities!   x > y : in this case,  x  is larger and we set  max  to  x  y > x : in this case,  y  is larger and we set  max  to  y  x == y : in this case, both are equally large, so the maximum of the two can be either  x  or  y .   In the code above,  max  is not set properly if  x == y !  The following code adds the third case and arbitrarily chooses to set  max  to  y  if both  x  and  y  have the same value.  1\n2\n3\n4\n5\n6\n7\n8\n9 if   ( x   >   y )   { \n   max   =   x ;  }   if   ( x   <   y )   { \n   max   =   y ;  }  if   ( x   ==   y )   { \n   max   =   y ;  }",
            "title": "Example: Max of two numbers"
        },
        {
            "location": "/08-if-else/index.html#else",
            "text": "The code snippet above now correctly sets  max  to the maximum of  x  and  y .\nThe code, however, is not very satisfying, since we compare between  x  and  y  three times.   Let's see how we can reduce the number of comparisons to one.  We are going to do some  refactoring  of the code above.  First, observe that the \"true block\" for  x < y  and  x == y  are the same, and we can combine it into a single comparison  x <= y .  1\n2\n3\n4\n5\n6 if   ( x   >   y )   { \n   max   =   x ;  }   if   ( x   <=   y )   { \n   max   =   y ;  }    Second, observe that if  x > y  is false, then  x <= y  must be true.  We say that  x > y  and  x <= y  are  negation  (or opposite) of each other.  So, the check for  x <= y  is redundant -- checking  x > y  is enough to tell us if  x <= y .  We can re-write the code above as:  1\n2\n3\n4\n5 if   ( x   >   y )   { \n   max   =   x ;  }   else   { \n   max   =   y ;  }    The word  else  as seen above is another C keyword -- it must be used in conjunction with  if  to indicate an alternate path of execution if the logical expression is false.  1\n2\n3\n4\n5 if   ( < logical   expression > )   {  \n   \"true block\" :   statements   to   be   executed   if   expression   evaluates   to   true  }   else   { \n   \"false block\" :   statements   to   be   executed   if   expression   evaluates   to   false  }",
            "title": "Else"
        },
        {
            "location": "/08-if-else/index.html#nested-else-if",
            "text": "The example above considers  two  possible execution paths only.  In some situations, we may need to consider more than two execution paths.  Take the following problem for example.  You are given the numerical score for an assignment, ranged between 0 and 10.  Print out the letter grade of the assignment according to the table below:     Score  Letter Grade      8 or higher  A    Less than 8 but 5 or higher  B    Less than 5 but 3 or higher  C    Less than 3  D     Since the  if - else  statement only allows branching into two possibilities, we can branch into multiple possibilities by nesting the  if - else  statements hierarchically.  We can first break the table down into three tables, each containing only two rows, with one row a negation of the other row.     Score  Letter Grade      8 or higher  A    Less than 8  See Table 1     Table 1 (less than 8)     Score  Letter Grade      5 or higher  B    Less than 5  See Table 2     Table 2 (less than 5)     Score  Letter Grade      3 or higher  C    Less than 3  D     The tables above can then be written into the following function:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18 void   print_score ( double   score )   { \n   if   ( score   >=   8 )   { \n     cs1010_println_string ( \"A\" ); \n   }   else   { \n     // Table 1 \n     if   ( score   >=   5 )   { \n       cs1010_println_string ( \"B\" ); \n     }   else   { \n       // Table 2 \n       if   ( score   >=   3 )   { \n         cs1010_println_string ( \"C\" ); \n       }   else   { \n         cs1010_println_string ( \"D\" ); \n       } \n     } \n   }  }    There are three nested  if - else  in the function above.  Note how I use indentation to clearly indicate the nesting of blocks.  Such nesting or indentation is not required by C standard, but is a commonly accepted coding practice, and is required for CS1010.  The code below compiles perfectly but is not as easy to read by a human as the above.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12 void   print_score ( double   score )   { \n   if   ( score   >=   8 )   { \n     cs1010_println_string ( \"A\" );   }   else   {   // Table 1  \n     if   ( score   >=   5 )   {   cs1010_println_string ( \"B\" ); \n   }   else   {   // Table 2  if   ( score   >=   3 )   { \n   cs1010_println_string ( \"C\" ); \n       }   else   { \n         cs1010_println_string ( \"D\" ); \n     }   }   }   }  // Don't write code like this.    There are also a couple of \"first\" in the sample code above:   You see the keyword  void  for the first time.   void  is a special type that indicates nothing.  The function  print_score  does not return anything, it accepts an input  score  and print something to screen.  As such, we say that the return type of  print_score  is  void .  You see  strings  for the first time ( \"A\" , etc.).  A  string  basically is a sequence of characters.  We use double quotes  \"  to mark the beginning and the end of a string, and use the CS1010 I/O library function  cs1010_println_string  to print a string to the screen.    You can imagine that as the number of possible letter grades increases (NUS has 11), we will have many nested  if - else , and the code gets complicated.  To reduce the number of nesting, we can write  else if  directly, without nesting:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12 void   print_score ( double   score )   { \n   if   ( score   >=   8 )   { \n     cs1010_println_string ( \"A\" ); \n   }   else   if   ( score   >=   5 )   { \n     cs1010_println_string ( \"B\" ); \n   }   else   if   ( score   >=   3 )   { \n     cs1010_println_string ( \"C\" ); \n   }   else   { \n     cs1010_println_string ( \"D\" ); \n   }  }    The above code is easier to read, but has exactly the same flow as the one with nested  if - else  earlier.",
            "title": "Nested Else-If"
        },
        {
            "location": "/08-if-else/index.html#avoid-skipping-the-curly-braces",
            "text": "The C standard says that, if the block contains only one statement, we can skip the curly braces  {  and  } .  In the example above, we can write:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11 void   print_score ( double   score )   { \n   if   ( score   >=   8 )  \n     cs1010_println_string ( \"A\" ); \n   else   if   ( score   >=   5 ) \n     cs1010_println_string ( \"B\" ); \n   else   if   ( score   >=   3 ) \n     cs1010_println_string ( \"C\" ); \n   else \n     cs1010_println_string ( \"D\" );  }    Despite being allowed by the C standard, this is considered a bad practice, and should be avoided.  Imagine some time later, you go back to this code, and want to write something extra:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12 void   print_score ( double   score )   { \n   if   ( score   >=   8 )  \n     cs1010_println_string ( \"A\" ); \n   else   if   ( score   >=   5 ) \n     cs1010_println_string ( \"B\" ); \n   else   if   ( score   >=   3 ) \n     cs1010_println_string ( \"C\" ); \n   else \n     cs1010_println_string ( \"You can do better!\" ); \n     cs1010_println_string ( \"D\" );  }    What would be printed?  The famous  Apple  goto fail  bug  wouldn't have happened in the there is a pair of curly braces added!  Alternatively, if you have code like this:  1\n2\n3\n4\n5 if   ( score   >=   8 ) \n   if   ( late_penalty   !=   0 )  \n       cs1010_println_string ( \"late submission\" );  else  \n   cs1010_println_string ( \"you can do better!\" );    It might look like  you can do better!  will be printed if  score  is less than 8, but actually,  you can do better!  will be printed if the  score  is larger or equal to 8 and there is no late penalty, which is not what is intended.",
            "title": "Avoid Skipping the Curly Braces"
        },
        {
            "location": "/08-if-else/index.html#conditional-operator",
            "text": "The conditional operator consists of two special characters  ?  and  :  and is used in the format of:  1 condition ? true expression : false expression;   If the  condition  evaluates to true, then the  true expression  will be evaluated and returned, otherwise, the  false expression  will be evaluated and returned.  The conditional operator allows us to replace  1\n2\n3\n4\n5 if   ( x   >   y )   { \n   max   =   x ;  }   else   { \n   max   =   y ;  }    with a single line:  1 max = (x > y) ? x : y;   We can nest the conditional operator as well, but it does not necessarily make your code easier to read once you start nesting them up.  We do not encourage you to nest the conditional operator in CS1010 and to limit its usage to simple cases above.",
            "title": "Conditional Operator"
        },
        {
            "location": "/08-if-else/index.html#comparing-real-numbers",
            "text": "Recall that we said  real numbers cannot be represented exactly in computers .  Comparing real numbers, therefore, becomes a little bit trickier in programming.  The  if  statement  1\n2\n3\n4\n5 double   expected_value   =   0.3 ;  double   sum   =   0.1   +   0.2 ;  if   ( sum   ==   expected_value )   { \n  :  }    would not be evaluated as  true  as expected!  Thus, to compare real numbers, we normally allow some errors in comparisons -- we want the absolute difference between  sum  and  expected_value  to be small enough.  1\n2\n3\n4\n5 double   expected_value   =   0.3 ;  double   sum   =   0.1   +   0.2 ;  if   ( fabs ( sum   -   expected_value )   <   0.000001 )   { \n  :  }",
            "title": "Comparing Real Numbers"
        },
        {
            "location": "/08-if-else/index.html#problem-sets",
            "text": "",
            "title": "Problem Sets"
        },
        {
            "location": "/08-if-else/index.html#problem-81",
            "text": "(a) Do the following two functions behave the same way?  Explain.  1\n2\n3\n4\n5\n6\n7 long   factorial ( long   n )   { \n   if   ( n   ==   0 )   { \n     return   1 ; \n   } \n   return   n   *   factorial ( n   -   1 );  }    1\n2\n3\n4\n5\n6\n7\n8 long   factorial ( long   n )   { \n   if   ( n   ==   0 )   { \n     return   1 ; \n   }   else   { \n     return   n   *   factorial ( n   -   1 ); \n   }  }    (b) How about:  1\n2\n3\n4\n5\n6\n7\n8\n9 long   factorial ( long   n )   { \n   long   result ; \n   if   ( n   ==   0 )   { \n     result   =   1 ; \n   } \n   result   =   n   *   factorial ( n   -   1 ); \n   return   result ;  }    and    1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10 long   factorial ( long   n )   { \n   long   result ; \n   if   ( n   ==   0 )   { \n     result   =   1 ; \n   }   else   { \n     result   =   n   *   factorial ( n   -   1 ); \n   } \n   return   result ;  }",
            "title": "Problem 8.1"
        },
        {
            "location": "/08-if-else/index.html#problem-82",
            "text": "Draw the flowchart for the code snippet  1\n2\n3\n4\n5\n6\n7\n8\n9 if   ( x   >   y )   { \n   max   =   x ;  }   if   ( x   <   y )   { \n   max   =   y ;  }  if   ( x   ==   y )   { \n   max   =   y ;  }    and  1\n2\n3\n4\n5 if   ( x   >   y )   { \n   max   =   x ;  }   else   { \n   max   =   y ;  }",
            "title": "Problem 8.2"
        },
        {
            "location": "/08-if-else/index.html#problem-83",
            "text": "Suppose we break down the table below in a slightly different way.     Score  Letter Grade      8 or higher  A    Less than 8 but 5 or higher  B    Less than 5 but 3 or higher  C    Less than 3  D     We rewrite the tables into three smaller tables, as:     Score  Letter Grade      5 or higher  See Table 3    Less than 5  See Table 4     where Table 3 (5 or higher) is     Score  Letter Grade      8 or higher  A    Less than 8  B     and Table 4 (less than 5) is     Score  Letter Grade      3 or higher  C    Less than 3  D     Write the corresponding  if - else  statements to print out the letter grade based on the tables above.",
            "title": "Problem 8.3"
        },
        {
            "location": "/08-if-else/index.html#appendix-code-from-lecture",
            "text": "Here are the C files that Wei Tsang wrote during the lecture.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16 #include   \"cs1010.h\"  long   factorial ( long   n )  { \n   if   ( n   ==   0 )   { \n     return   1 ; \n   }  \n   return   n   *   factorial ( n - 1 );  }  int   main ()  { \n   long   n   =   cs1010_read_long (); \n   long   fac   =   factorial ( n ); \n   cs1010_println_long ( fac );  }     1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20 #include   \"cs1010.h\"  long   max ( long   x ,   long   y )  { \n   if   ( x   >   y )   { \n     return   x ; \n   }   else   { \n     return   y ; \n   } \n   // alternatively, using the conditional operator ? : \n   // return (x > y) ? x : y;  }  int   main ()  { \n   long   x   =   cs1010_read_long (); \n   long   y   =   cs1010_read_long (); \n   long   m   =   max ( x ,   y ); \n   cs1010_println_long ( m );  }     1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19 #include   \"cs1010.h\"  void   print_score ( double   x )  { \n   if   ( x   >=   8 ) \n     cs1010_println_string ( \"A\" ); \n   else   if   ( x   >=   5 ) \n     cs1010_println_string ( \"B\" ); \n   else   if   ( x   >=   3 ) \n     cs1010_println_string ( \"C\" ); \n   else \n     cs1010_println_string ( \"D\" );  }  int   main ()  { \n   double   score   =   cs1010_read_double (); \n   print_score ( score );  }",
            "title": "Appendix: Code From Lecture"
        },
        {
            "location": "/09-logical-exp/index.html",
            "text": "Unit 9: Logical Expression\n\n\nRepresenting a Boolean Value\n\n\nYou have seen some basic logical expressions in \nUnit 8\n. \nn == 0\n, \nx > y\n, \ny > x\n, are all logical expressions.  They evaluate to either true or false.\n\n\nWe call a type that can contain either true or false as a Boolean data type, named after \nGeorge Boole\n, a mathematician.\n\n\nThe Boolean data type in C named \nbool\n.  It can hold two values: \ntrue\n or \nfalse\n.  All three of \nbool\n, \ntrue\n, and \nfalse\n are keywords introduced in modern C.  To use them, you need to include the file \nstdbool.h\n at the top of your program.  \n\n\nUse \nbool\n is considered a cleaner way of representing true and false in C.  Classically,  C defines the numeric value 0 to be false, and everything else to be true.  So, you can write code like this:\n\n\n1\n2\n3\n4\n5\n// x and y are long.\n\n\nlong\n \nis_diff\n \n=\n \nx\n \n-\n \ny\n;\n\n\nif\n \n(\nis_diff\n)\n \n{\n\n  \ncs1010_println_string\n(\n\"x and y store different values.\"\n);\n\n\n}\n\n\n\n\n\n\n\nThe above is harder to understand and should be avoided.  A cleaner way is to write:\n\n\n1\n2\n3\n4\nbool\n \nis_diff\n \n=\n \nx\n \n!=\n \ny\n;\n\n\nif\n \n(\nis_diff\n)\n \n{\n\n  \ncs1010_println_string\n(\n\"x and y store different values.\"\n);\n\n\n}\n\n\n\n\n\n\n\nAlthough not required by C, we will name a \nbool\n variable with a prefix \nis_\n or \nhas_\n as a convention.  \n\n\nThe code above can also be written as:\n\n1\n2\n3\n4\nbool\n \nis_diff\n \n=\n \nx\n \n!=\n \ny\n;\n\n\nif\n \n(\nis_diff\n \n==\n \ntrue\n)\n \n{\n\n  \ncs1010_println_string\n(\n\"x and y store different values.\"\n);\n\n\n}\n\n\n\n\n\n\nThe comparison with \ntrue\n is redundant, however, and should be skipped.\n\n\nLogical Operators\n\n\nJust like we can perform arithmetic operations on integers and real numbers, we can perform logical operations on boolean values.  These allow us to write complex logical expressions.\n\n\nConsider the example problem: Write a function that, given the birth year of a person, determine if he or she belongs to Generation Z, defined as someone whose birth is between 1995 and 2005, inclusive. \n\n\nWe can write the function as follows using what we have known:\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nbool\n \nis_gen_z\n(\nlong\n \nbirth_year\n)\n \n\n{\n\n  \nif\n \n(\nbirth_year\n \n>=\n \n1995\n)\n \n{\n\n    \nif\n \n(\nbirth_year\n \n<=\n \n2005\n)\n \n{\n\n      \nreturn\n \ntrue\n;\n\n    \n}\n \n  \n}\n\n  \nreturn\n \nfalse\n;\n\n\n}\n\n\n\n\n\n\nTo be in Generation Z, both conditions \nbirth_year >= 1995\n and \nbirth_year <= 2005\n must be true.  We can use the logical AND \n&&\n operator to simplify the code above to:\n\n\n1\n2\n3\n4\n5\n6\n7\nbool\n \nis_gen_z\n(\nlong\n \nbirth_year\n)\n \n\n{\n\n  \nif\n \n((\nbirth_year\n \n>=\n \n1995\n)\n \n&&\n \n(\nbirth_year\n \n<=\n \n2005\n))\n \n{\n\n    \nreturn\n \ntrue\n;\n\n  \n}\n\n  \nreturn\n \nfalse\n;\n\n\n}\n\n\n\n\n\n\n\nor simply:\n\n1\n2\n3\n4\nbool\n \nis_gen_z\n(\nlong\n \nbirth_year\n)\n \n\n{\n\n  \nreturn\n \n((\nbirth_year\n \n>=\n \n1995\n)\n \n&&\n \n(\nbirth_year\n \n<=\n \n2005\n));\n\n\n}\n\n\n\n\n\n\nThe AND operator, \n&&\n, evaluates to true if and only if both operands are true.\n\n\n\n\nCommon Error\n\n\nA common mistake by a new C programmer is to write \n1995 <= birth_year <= 2005\n as the logical expression.  Unfortunately, in C, we cannot chain the comparison operators together.\n\n\n\n\nWhat if we want to write a function to determine if someone is NOT part of Generation Z?   This means that they are born \neither\n before 1995 \nor\n after 2005.  To have an expression that evaluates to true if either one of two expressions is true, we can use the OR operator, \n||\n.\n\n\n1\n2\n3\n4\nbool\n \nis_not_gen_z\n(\nlong\n \nbirth_year\n)\n \n\n{\n\n  \nreturn\n \n((\nbirth_year\n \n<\n \n1995\n)\n \n||\n \n(\nbirth_year\n \n>\n \n2005\n));\n\n\n}\n\n\n\n\n\n\n\nGenerally, we prefer to write functions that check for the positives, as it is generally easier to think in terms of the positives.  So the example \nis_not_gen_z\n above is for illustration purposes only, we do not encourage you to write functions that check for the negatives.   In any case, if we want to check if someone is not a Generation Z, we can use the \n!\n NOT operator.\n\n\n1\n2\n3\nif\n \n(\n!\nis_gen_z\n(\nbirth_year\n))\n \n{\n\n     \n:\n\n\n}\n\n\n\n\n\n\n\nThis operator can be used as part of the boolean expression:\n\n\n1\n2\n3\n4\nbool\n \nis_not_gen_z\n(\nlong\n \nbirth_year\n)\n \n\n{\n\n  \nreturn\n \n!\n((\nbirth_year\n \n>=\n \n1995\n)\n \n&&\n \n(\nbirth_year\n \n<=\n \n2005\n));\n\n\n}\n\n\n\n\n\n\n\nShort Circuiting\n\n\nWhen evaluating the logical expressions that involve \n&&\n and \n||\n, C uses \"short-circuiting\".  This means that, if we already know, for sure, that a logical expression is true or is false, there is no need to continue the evaluation.  The corresponding \ntrue\n and \nfalse\n value will be returned.\n\n\nConsider the following:\n\n1\n2\n3\n4\nbool\n \nis_gen_z\n(\nlong\n \nbirth_year\n)\n \n\n{\n\n  \nreturn\n \n((\nbirth_year\n \n>=\n \n1995\n)\n \n&&\n \n(\nbirth_year\n \n<=\n \n2005\n));\n\n\n}\n\n\n\n\n\n\nIf the argument \nbirth_year\n is \n1970\n, then, the expression \n(birth_year >= 1995)\n already evaluates to \nfalse\n, and the whole statement is false.  We do not need to evaluate the second expression \n(birth_year <= 2005)\n.  \n\n\nSimilarly, for \n\n1\n2\n3\n4\nbool\n \nis_not_gen_z\n(\nlong\n \nbirth_year\n)\n \n\n{\n\n  \nreturn\n \n((\nbirth_year\n \n<\n \n1995\n)\n \n||\n \n(\nbirth_year\n \n>\n \n2005\n));\n\n\n}\n\n\n\n\n\n\nWhen \nbirth_year\n is \n1970\n, the expression \n(birth_year < 1995)\n is \ntrue\n, so we know that the whole statement is \ntrue\n.  There is no need to check if \n(birth_year > 2005)\n.\n\n\nIn both examples above, the savings due to short-circuiting is not much -- since we are basically comparing two numbers, and there is no \nside effects\n in comparing \nbirth_year\n to \n2005\n.  But, let's suppose that we introduce two functions with side effects (of printing to screen):\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\nbool\n \nnot_too_old\n(\nlong\n \nbirth_year\n)\n\n\n{\n\n  \nif\n \n(\nbirth_year\n \n>=\n \n1995\n)\n \n{\n\n    \ncs1010_print_string\n(\n\"not too old..\"\n);\n\n    \nreturn\n \ntrue\n;\n\n  \n}\n\n  \ncs1010_print_string\n(\n\"too old..\"\n);\n\n  \nreturn\n \nfalse\n;\n\n\n}\n\n\n\nbool\n \nnot_too_young\n(\nlong\n \nbirth_year\n)\n\n\n{\n\n  \nif\n \n(\nbirth_year\n \n<=\n \n2005\n)\n \n{\n\n    \ncs1010_print_string\n(\n\"not too young..\"\n);\n\n    \nreturn\n \ntrue\n;\n\n  \n}\n\n  \ncs1010_print_string\n(\n\"too young..\"\n);\n\n  \nreturn\n \nfalse\n;\n\n\n}\n\n\n\nbool\n \nis_gen_z\n(\nlong\n \nbirth_year\n)\n \n\n{\n\n  \nreturn\n \nnot_too_old\n(\nbirth_year\n)\n \n&&\n \nnot_too_young\n(\nbirth_year\n);\n\n\n}\n\n\n\n\n\n\n\nWhen we call \nis_gen_z(1984)\n, you might expect \ntoo old..not too young..\n to be printed, but due to short-circuiting, the code only prints \ntoo old..\n.\n\n\nAnother reason to keep short-circuiting in mind is that the order of the logical expressions matter: we would want to put the logical expression that involves more work in the second half of the expression.  Take the following example:\n\n\n1\n2\n3\nif\n \n(\nnumber\n \n<\n \n100000\n \n&&\n \nis_prime\n(\nnumber\n))\n \n{\n\n    \n:\n\n\n}\n\n\n\n\n\n\n\nChecking whether a number is below 100,000 is easier than checking if a number is prime.  So, we can skip checking for primality if the \nnumber\n is too big.  Compare this to:\n\n\n1\n2\n3\nif\n \n(\nis_prime\n(\nnumber\n)\n \n&&\n \nnumber\n \n<\n \n100000\n)\n \n{\n\n    \n:\n\n\n}\n\n\n\n\n\n\n\nSuppose \nnumber\n is a gigantic integer, then we would have spent lots of effort checking if \nnumber\n is a prime, only to find out that it is too big anyway!\n\n\nProblem Sets\n\n\nProblem 9.1\n\n\nGiven two \nbool\n variables, \na\n and \nb\n, there are four possible combinations of \ntrue\n \nfalse\n values.  What are the values of \na && b\n, \na || b\n, and \n!a\n for each of these combinations?  Fill in the table below.\n\n\n\n\n\n\n\n\na\n\n\nb\n\n\na && b\n\n\na || b\n\n\n!a\n\n\n\n\n\n\n\n\n\n\ntrue\n\n\ntrue\n\n\n\n\n\n\n\n\n\n\n\n\ntrue\n\n\nfalse\n\n\n\n\n\n\n\n\n\n\n\n\nfalse\n\n\ntrue\n\n\n\n\n\n\n\n\n\n\n\n\nfalse\n\n\nfalse\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nProblem 9.2\n\n\nConsider the function below, which aims to return the maximum value given three numbers.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\nlong\n \nmax_of_three\n(\nlong\n \na\n,\n \nlong\n \nb\n,\n \nlong\n \nc\n)\n \n\n{\n\n  \nlong\n \nmax\n \n=\n \n0\n;\n\n  \nif\n \n((\na\n \n>\n \nb\n)\n \n&&\n \n(\na\n \n>\n \nc\n))\n \n{\n\n    \n// a is larger than b and c\n\n    \nmax\n \n=\n \na\n;\n\n  \n}\n\n  \nif\n \n((\nb\n \n>\n \na\n)\n \n&&\n \n(\nb\n \n>\n \nc\n))\n \n{\n\n    \n// b is larger than a and c\n\n    \nmax\n \n=\n \nb\n;\n\n  \n}\n\n  \nif\n \n((\nc\n \n>\n \na\n)\n \n&&\n \n(\nc\n \n>\n \nb\n))\n \n{\n\n    \n// c is larger than a and b\n\n    \nmax\n \n=\n \nc\n;\n\n  \n}\n\n  \nreturn\n \nmax\n;\n\n\n}\n\n\n\n\n\n\n\n(a) What is wrong with the code above?\n\n\n(b) Give a sample test value of \na\n, \nb\n, and \nc\n that would expose the bug.\n\n\n(C) Fix the code above to remove the bug.\n\n\n(d) Replace the three \nif\n statements in the code above with \nif\n-\nelse\n statements.  Draw the corresponding flowchart.\n\n\nProblem 9.3\n\n\nWrite a function that takes in a blood pressure measurement, and prints either \nlow\n, \nideal\n, \npre-high\n, and \nhigh\n depending on the input values.  The blood pressure is given as two \nlong\n values, the systolic and the diastolic.  The text to be printed depends on the range, depicted in the figure below.\n\n\n1\n2\n3\n4\nvoid\n \nprint_blood_pressure\n(\nlong\n \nsystolic\n,\n \nlong\n \ndiastolic\n)\n\n\n{\n\n  \n:\n\n\n}\n\n\n\n\n\n\n\n\n\nThe figure does not say how to classify the data if the values fall exactly on the boundary of two regions.  In this case, you can classify it to either region.\n\n\nAppendix: Code from Lecture\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n#include\n \n\"cs1010.h\"\n\n\n#include\n \n<stdbool.h>\n\n\n\nbool\n \nis_gen_z\n(\nlong\n \nyear\n)\n\n\n{\n\n  \nreturn\n \n((\nyear\n \n>=\n \n1995\n)\n \n&&\n \n(\nyear\n \n<=\n \n2005\n));\n\n\n}\n\n\n\nbool\n \nis_not_gen_z\n(\nlong\n \nyear\n)\n\n\n{\n\n  \nreturn\n \n((\nyear\n \n<\n \n1995\n)\n \n||\n \n(\nyear\n \n>\n \n2005\n));\n\n\n}\n\n\n\nint\n \nmain\n()\n\n\n{\n\n  \nlong\n \nyear\n \n=\n \ncs1010_read_long\n();\n\n  \nif\n \n(\nis_gen_z\n(\nyear\n))\n \n{\n\n    \ncs1010_println_string\n(\n\"Z!\"\n);\n\n  \n}\n \nelse\n \n{\n\n    \ncs1010_println_string\n(\n\"Not Z!\"\n);\n\n  \n}\n\n\n}",
            "title": "9. Logical Expression"
        },
        {
            "location": "/09-logical-exp/index.html#unit-9-logical-expression",
            "text": "",
            "title": "Unit 9: Logical Expression"
        },
        {
            "location": "/09-logical-exp/index.html#representing-a-boolean-value",
            "text": "You have seen some basic logical expressions in  Unit 8 .  n == 0 ,  x > y ,  y > x , are all logical expressions.  They evaluate to either true or false.  We call a type that can contain either true or false as a Boolean data type, named after  George Boole , a mathematician.  The Boolean data type in C named  bool .  It can hold two values:  true  or  false .  All three of  bool ,  true , and  false  are keywords introduced in modern C.  To use them, you need to include the file  stdbool.h  at the top of your program.    Use  bool  is considered a cleaner way of representing true and false in C.  Classically,  C defines the numeric value 0 to be false, and everything else to be true.  So, you can write code like this:  1\n2\n3\n4\n5 // x and y are long.  long   is_diff   =   x   -   y ;  if   ( is_diff )   { \n   cs1010_println_string ( \"x and y store different values.\" );  }    The above is harder to understand and should be avoided.  A cleaner way is to write:  1\n2\n3\n4 bool   is_diff   =   x   !=   y ;  if   ( is_diff )   { \n   cs1010_println_string ( \"x and y store different values.\" );  }    Although not required by C, we will name a  bool  variable with a prefix  is_  or  has_  as a convention.    The code above can also be written as: 1\n2\n3\n4 bool   is_diff   =   x   !=   y ;  if   ( is_diff   ==   true )   { \n   cs1010_println_string ( \"x and y store different values.\" );  }    The comparison with  true  is redundant, however, and should be skipped.",
            "title": "Representing a Boolean Value"
        },
        {
            "location": "/09-logical-exp/index.html#logical-operators",
            "text": "Just like we can perform arithmetic operations on integers and real numbers, we can perform logical operations on boolean values.  These allow us to write complex logical expressions.  Consider the example problem: Write a function that, given the birth year of a person, determine if he or she belongs to Generation Z, defined as someone whose birth is between 1995 and 2005, inclusive.   We can write the function as follows using what we have known: 1\n2\n3\n4\n5\n6\n7\n8\n9 bool   is_gen_z ( long   birth_year )   { \n   if   ( birth_year   >=   1995 )   { \n     if   ( birth_year   <=   2005 )   { \n       return   true ; \n     }  \n   } \n   return   false ;  }    To be in Generation Z, both conditions  birth_year >= 1995  and  birth_year <= 2005  must be true.  We can use the logical AND  &&  operator to simplify the code above to:  1\n2\n3\n4\n5\n6\n7 bool   is_gen_z ( long   birth_year )   { \n   if   (( birth_year   >=   1995 )   &&   ( birth_year   <=   2005 ))   { \n     return   true ; \n   } \n   return   false ;  }    or simply: 1\n2\n3\n4 bool   is_gen_z ( long   birth_year )   { \n   return   (( birth_year   >=   1995 )   &&   ( birth_year   <=   2005 ));  }    The AND operator,  && , evaluates to true if and only if both operands are true.   Common Error  A common mistake by a new C programmer is to write  1995 <= birth_year <= 2005  as the logical expression.  Unfortunately, in C, we cannot chain the comparison operators together.   What if we want to write a function to determine if someone is NOT part of Generation Z?   This means that they are born  either  before 1995  or  after 2005.  To have an expression that evaluates to true if either one of two expressions is true, we can use the OR operator,  || .  1\n2\n3\n4 bool   is_not_gen_z ( long   birth_year )   { \n   return   (( birth_year   <   1995 )   ||   ( birth_year   >   2005 ));  }    Generally, we prefer to write functions that check for the positives, as it is generally easier to think in terms of the positives.  So the example  is_not_gen_z  above is for illustration purposes only, we do not encourage you to write functions that check for the negatives.   In any case, if we want to check if someone is not a Generation Z, we can use the  !  NOT operator.  1\n2\n3 if   ( ! is_gen_z ( birth_year ))   { \n      :  }    This operator can be used as part of the boolean expression:  1\n2\n3\n4 bool   is_not_gen_z ( long   birth_year )   { \n   return   ! (( birth_year   >=   1995 )   &&   ( birth_year   <=   2005 ));  }",
            "title": "Logical Operators"
        },
        {
            "location": "/09-logical-exp/index.html#short-circuiting",
            "text": "When evaluating the logical expressions that involve  &&  and  || , C uses \"short-circuiting\".  This means that, if we already know, for sure, that a logical expression is true or is false, there is no need to continue the evaluation.  The corresponding  true  and  false  value will be returned.  Consider the following: 1\n2\n3\n4 bool   is_gen_z ( long   birth_year )   { \n   return   (( birth_year   >=   1995 )   &&   ( birth_year   <=   2005 ));  }    If the argument  birth_year  is  1970 , then, the expression  (birth_year >= 1995)  already evaluates to  false , and the whole statement is false.  We do not need to evaluate the second expression  (birth_year <= 2005) .    Similarly, for  1\n2\n3\n4 bool   is_not_gen_z ( long   birth_year )   { \n   return   (( birth_year   <   1995 )   ||   ( birth_year   >   2005 ));  }    When  birth_year  is  1970 , the expression  (birth_year < 1995)  is  true , so we know that the whole statement is  true .  There is no need to check if  (birth_year > 2005) .  In both examples above, the savings due to short-circuiting is not much -- since we are basically comparing two numbers, and there is no  side effects  in comparing  birth_year  to  2005 .  But, let's suppose that we introduce two functions with side effects (of printing to screen):   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24 bool   not_too_old ( long   birth_year )  { \n   if   ( birth_year   >=   1995 )   { \n     cs1010_print_string ( \"not too old..\" ); \n     return   true ; \n   } \n   cs1010_print_string ( \"too old..\" ); \n   return   false ;  }  bool   not_too_young ( long   birth_year )  { \n   if   ( birth_year   <=   2005 )   { \n     cs1010_print_string ( \"not too young..\" ); \n     return   true ; \n   } \n   cs1010_print_string ( \"too young..\" ); \n   return   false ;  }  bool   is_gen_z ( long   birth_year )   { \n   return   not_too_old ( birth_year )   &&   not_too_young ( birth_year );  }    When we call  is_gen_z(1984) , you might expect  too old..not too young..  to be printed, but due to short-circuiting, the code only prints  too old.. .  Another reason to keep short-circuiting in mind is that the order of the logical expressions matter: we would want to put the logical expression that involves more work in the second half of the expression.  Take the following example:  1\n2\n3 if   ( number   <   100000   &&   is_prime ( number ))   { \n     :  }    Checking whether a number is below 100,000 is easier than checking if a number is prime.  So, we can skip checking for primality if the  number  is too big.  Compare this to:  1\n2\n3 if   ( is_prime ( number )   &&   number   <   100000 )   { \n     :  }    Suppose  number  is a gigantic integer, then we would have spent lots of effort checking if  number  is a prime, only to find out that it is too big anyway!",
            "title": "Short Circuiting"
        },
        {
            "location": "/09-logical-exp/index.html#problem-sets",
            "text": "",
            "title": "Problem Sets"
        },
        {
            "location": "/09-logical-exp/index.html#problem-91",
            "text": "Given two  bool  variables,  a  and  b , there are four possible combinations of  true   false  values.  What are the values of  a && b ,  a || b , and  !a  for each of these combinations?  Fill in the table below.     a  b  a && b  a || b  !a      true  true       true  false       false  true       false  false",
            "title": "Problem 9.1"
        },
        {
            "location": "/09-logical-exp/index.html#problem-92",
            "text": "Consider the function below, which aims to return the maximum value given three numbers.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17 long   max_of_three ( long   a ,   long   b ,   long   c )   { \n   long   max   =   0 ; \n   if   (( a   >   b )   &&   ( a   >   c ))   { \n     // a is larger than b and c \n     max   =   a ; \n   } \n   if   (( b   >   a )   &&   ( b   >   c ))   { \n     // b is larger than a and c \n     max   =   b ; \n   } \n   if   (( c   >   a )   &&   ( c   >   b ))   { \n     // c is larger than a and b \n     max   =   c ; \n   } \n   return   max ;  }    (a) What is wrong with the code above?  (b) Give a sample test value of  a ,  b , and  c  that would expose the bug.  (C) Fix the code above to remove the bug.  (d) Replace the three  if  statements in the code above with  if - else  statements.  Draw the corresponding flowchart.",
            "title": "Problem 9.2"
        },
        {
            "location": "/09-logical-exp/index.html#problem-93",
            "text": "Write a function that takes in a blood pressure measurement, and prints either  low ,  ideal ,  pre-high , and  high  depending on the input values.  The blood pressure is given as two  long  values, the systolic and the diastolic.  The text to be printed depends on the range, depicted in the figure below.  1\n2\n3\n4 void   print_blood_pressure ( long   systolic ,   long   diastolic )  { \n   :  }     The figure does not say how to classify the data if the values fall exactly on the boundary of two regions.  In this case, you can classify it to either region.",
            "title": "Problem 9.3"
        },
        {
            "location": "/09-logical-exp/index.html#appendix-code-from-lecture",
            "text": "1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22 #include   \"cs1010.h\"  #include   <stdbool.h>  bool   is_gen_z ( long   year )  { \n   return   (( year   >=   1995 )   &&   ( year   <=   2005 ));  }  bool   is_not_gen_z ( long   year )  { \n   return   (( year   <   1995 )   ||   ( year   >   2005 ));  }  int   main ()  { \n   long   year   =   cs1010_read_long (); \n   if   ( is_gen_z ( year ))   { \n     cs1010_println_string ( \"Z!\" ); \n   }   else   { \n     cs1010_println_string ( \"Not Z!\" ); \n   }  }",
            "title": "Appendix: Code from Lecture"
        },
        {
            "location": "/10-assert/index.html",
            "text": "Unit 10: Assertion\n\n\nAn assertion is a logical expression that must always be true for the program to be correct.  We can write assertions either as part of the comment for the code, or use the \nassert()\n macro in C.  Let's look at what is assertion first.  We will introduce the use of \nassert()\n later.\n\n\nTo get started, let's first look at the most trivial assertion:\n\n\n1\n2\nlong\n \nx\n \n=\n \n1\n;\n\n\n// { x == 1 }\n\n\n\n\n\n\n\nThe line above initialize the variable \nx\n to be \n1\n.  The next line, a comment, uses the curly braces \n{\n and \n}\n with a logical expression in between, to indicate that \nx\n must be equals to \n1\n after the assignment.  We use the curly braces as a notation in CS1010, following \nC. A. R. Hoare\n's notation, but this is not part of any C standard.\n\n\nThe assertion above is kind of trivial and not very meaningful. \n\n\nLet's revisit this snippet:\n\n\n1\n2\n3\n4\n5\nif\n \n(\nx\n \n>\n \ny\n)\n \n{\n\n  \nmax\n \n=\n \nx\n;\n\n\n}\n \nelse\n \n{\n\n  \nmax\n \n=\n \ny\n;\n\n\n}\n\n\n\n\n\n\n\nLet's consider the true block and the false block.  Inside the true block, since \nx > y\n, we can assert that, well, \nx > y\n, and inside the false block, we have the negation, so \nx <= y\n.\n\n\n1\n2\n3\n4\n5\n6\n7\nif\n \n(\nx\n \n>\n \ny\n)\n \n{\n\n  \n// { x > y }\n\n  \nmax\n \n=\n \nx\n;\n\n\n}\n \nelse\n \n{\n\n  \n// { x <= y }\n\n  \nmax\n \n=\n \ny\n;\n\n\n}\n\n\n\n\n\n\n\nLet's now consider what happens after initializing \nmax\n to either \nx\n or \ny\n.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nif\n \n(\nx\n \n>\n \ny\n)\n \n{\n\n  \n// { x > y }\n\n  \nmax\n \n=\n \nx\n;\n\n  \n// { max == x && max > y }\n\n\n}\n \nelse\n \n{\n\n  \n// { x <= y }\n\n  \nmax\n \n=\n \ny\n;\n\n  \n// { max >= x && max == y }\n\n\n}\n\n\n\n\n\n\n\nThe assertion on Line 4 consists of two parts: \nmax == x\n which is the result of the assignment (the trivial assertion), but since inside this block, \nx > y\n, we must have \nmax > y\n to be true as well.\n\n\nSimilarly, we can argue the assertion in Line 8 to be true.  \n\n\nWhat can we assert after we exit from the \nif\n-\nelse\n block?  We have either \nmax == x && max > y\n or \nmax >= x && max == y\n.  This is exactly the property we are looking for in \nmax\n when we set it to the maximum of \nx\n and \ny\n!  \n\n\nLet's look at another example:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n  \nif\n \n(\nscore\n \n>=\n \n8\n)\n \n{\n\n    \ncs1010_println_string\n(\n\"A\"\n);\n\n  \n}\n \nelse\n \n{\n\n    \nif\n \n(\nscore\n \n>=\n \n5\n)\n \n{\n\n      \ncs1010_println_string\n(\n\"B\"\n);\n\n    \n}\n \nelse\n \n{\n\n      \nif\n \n(\nscore\n \n>=\n \n3\n)\n \n{\n\n        \ncs1010_println_string\n(\n\"C\"\n);\n\n      \n}\n \nelse\n \n{\n\n        \ncs1010_println_string\n(\n\"D\"\n);\n\n      \n}\n\n    \n}\n\n  \n}\n\n\n\n\n\n\n\nLet's focus on the case of printing \nC\n.  We should print \nC\n if \nscore\n is less than 5 but is 3 or higher.  Let's check if this is correct by finding out what we can assert wrt \nscore\n just before printing \nC\n.  We first add the assert condition to all the true blocks and the false block by negating the \nif\n condition.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n  \nif\n \n(\nscore\n \n>=\n \n8\n)\n \n{\n\n    \ncs1010_println_string\n(\n\"A\"\n);\n\n  \n}\n \nelse\n \n{\n\n    \nif\n \n(\nscore\n \n>=\n \n5\n)\n \n{\n\n      \n// { score >= 5 }\n\n      \ncs1010_println_string\n(\n\"B\"\n);\n\n    \n}\n \nelse\n \n{\n\n      \n// { score < 5 }\n\n      \nif\n \n(\nscore\n \n>=\n \n3\n)\n \n{\n\n        \n// { score < 5 && score >= 3 }\n\n        \ncs1010_println_string\n(\n\"C\"\n);\n\n      \n}\n \nelse\n \n{\n\n        \n// { score < 5 && score < 3 }\n\n        \ncs1010_println_string\n(\n\"D\"\n);\n\n      \n}\n\n    \n}\n\n  \n}\n\n\n\n\n\n\n\nWe can see that, we are printing \nC\n when \nscore < 5 && score >= 3\n, which is what we want.  \n\n\nNote that the last assert \nscore < 5 && score < 3\n can be simplified to \nscore < 3\n.\n\n\nDe Morgan's Law\n\n\nTo write an assertion for the false block, it is useful to know the De Morgan's law, which tells us how to negate some logical expression.  Suppose we have two logical expressions \ne1\n and \ne2\n. \n\n\n\n\n!(e1 && e2)\n is the same as \n(!e1) || (!e2)\n\n\n!(e1 || e2)\n is the same as \n(!e1) && (!e2)\n\n\n\n\nWe have actually seen it in action.  Recall the expression for Generation Z: \n\n\n(birth_year >= 1995) && (birth_year <= 2005)\n.  \n\n\nTo check for NOT Generation Z, we can write it as \n\n\n!((birth_year >= 1995) && (birth_year <= 2005))\n, \n\n\nwhich according to De Morgan's law, is the same as \n\n\n!(birth_year >= 1995) || !(birth_year <= 2005)\n, \n\n\nwhich is just \n\n\n(birth_year < 1995) || (birth_year > 2005)\n, \n\n\nexactly as we have written before!\n\n\nProblem Set 10\n\n\nProblem 10.1\n\n\nNegate the following logical expression, then apply De Morgan's Law to simplify the resulting expression.  Assume all variable names mentioned are boolean variables.\n\n\n(a) \n(x > 1) && (y != 10)\n\n\n(b) \n!eating && drinking\n\n\n(C) \n(has_cs2030 || has_cs2113) && has_cs2040c\n\n\nProblem 10.2\n\n\nIn the code below, replace \n???\n with the appropriate assertion.  What will be printed?\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\nlong\n \nscore\n \n=\n \n4\n;\n\n\nif\n \n(\nsomething\n)\n \n{\n\n  \nscore\n \n=\n \n10\n;\n\n\n}\n \nelse\n \n{\n\n  \nscore\n \n=\n \n0\n;\n\n\n}\n\n\n// { ??? }\n\n\n\nif\n \n(\nscore\n \n==\n \n4\n)\n \n{\n\n    \nscore\n \n=\n \n1\n;\n\n\n}\n \nelse\n \n{\n\n    \nscore\n \n+=\n \n10\n;\n\n\n}\n\n\n// { ??? }\n\n\n\nif\n \n(\nscore\n \n>=\n \n10\n)\n \n{\n\n    \ncs1010_println_string\n(\n\"ok\"\n);\n\n\n}\n \nelse\n \n{\n\n    \ncs1010_println_string\n(\n\"failed\"\n);\n\n\n}",
            "title": "10. Assertion"
        },
        {
            "location": "/10-assert/index.html#unit-10-assertion",
            "text": "An assertion is a logical expression that must always be true for the program to be correct.  We can write assertions either as part of the comment for the code, or use the  assert()  macro in C.  Let's look at what is assertion first.  We will introduce the use of  assert()  later.  To get started, let's first look at the most trivial assertion:  1\n2 long   x   =   1 ;  // { x == 1 }    The line above initialize the variable  x  to be  1 .  The next line, a comment, uses the curly braces  {  and  }  with a logical expression in between, to indicate that  x  must be equals to  1  after the assignment.  We use the curly braces as a notation in CS1010, following  C. A. R. Hoare 's notation, but this is not part of any C standard.  The assertion above is kind of trivial and not very meaningful.   Let's revisit this snippet:  1\n2\n3\n4\n5 if   ( x   >   y )   { \n   max   =   x ;  }   else   { \n   max   =   y ;  }    Let's consider the true block and the false block.  Inside the true block, since  x > y , we can assert that, well,  x > y , and inside the false block, we have the negation, so  x <= y .  1\n2\n3\n4\n5\n6\n7 if   ( x   >   y )   { \n   // { x > y } \n   max   =   x ;  }   else   { \n   // { x <= y } \n   max   =   y ;  }    Let's now consider what happens after initializing  max  to either  x  or  y .  1\n2\n3\n4\n5\n6\n7\n8\n9 if   ( x   >   y )   { \n   // { x > y } \n   max   =   x ; \n   // { max == x && max > y }  }   else   { \n   // { x <= y } \n   max   =   y ; \n   // { max >= x && max == y }  }    The assertion on Line 4 consists of two parts:  max == x  which is the result of the assignment (the trivial assertion), but since inside this block,  x > y , we must have  max > y  to be true as well.  Similarly, we can argue the assertion in Line 8 to be true.    What can we assert after we exit from the  if - else  block?  We have either  max == x && max > y  or  max >= x && max == y .  This is exactly the property we are looking for in  max  when we set it to the maximum of  x  and  y !    Let's look at another example:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13    if   ( score   >=   8 )   { \n     cs1010_println_string ( \"A\" ); \n   }   else   { \n     if   ( score   >=   5 )   { \n       cs1010_println_string ( \"B\" ); \n     }   else   { \n       if   ( score   >=   3 )   { \n         cs1010_println_string ( \"C\" ); \n       }   else   { \n         cs1010_println_string ( \"D\" ); \n       } \n     } \n   }    Let's focus on the case of printing  C .  We should print  C  if  score  is less than 5 but is 3 or higher.  Let's check if this is correct by finding out what we can assert wrt  score  just before printing  C .  We first add the assert condition to all the true blocks and the false block by negating the  if  condition.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17    if   ( score   >=   8 )   { \n     cs1010_println_string ( \"A\" ); \n   }   else   { \n     if   ( score   >=   5 )   { \n       // { score >= 5 } \n       cs1010_println_string ( \"B\" ); \n     }   else   { \n       // { score < 5 } \n       if   ( score   >=   3 )   { \n         // { score < 5 && score >= 3 } \n         cs1010_println_string ( \"C\" ); \n       }   else   { \n         // { score < 5 && score < 3 } \n         cs1010_println_string ( \"D\" ); \n       } \n     } \n   }    We can see that, we are printing  C  when  score < 5 && score >= 3 , which is what we want.    Note that the last assert  score < 5 && score < 3  can be simplified to  score < 3 .",
            "title": "Unit 10: Assertion"
        },
        {
            "location": "/10-assert/index.html#de-morgans-law",
            "text": "To write an assertion for the false block, it is useful to know the De Morgan's law, which tells us how to negate some logical expression.  Suppose we have two logical expressions  e1  and  e2 .    !(e1 && e2)  is the same as  (!e1) || (!e2)  !(e1 || e2)  is the same as  (!e1) && (!e2)   We have actually seen it in action.  Recall the expression for Generation Z:   (birth_year >= 1995) && (birth_year <= 2005) .    To check for NOT Generation Z, we can write it as   !((birth_year >= 1995) && (birth_year <= 2005)) ,   which according to De Morgan's law, is the same as   !(birth_year >= 1995) || !(birth_year <= 2005) ,   which is just   (birth_year < 1995) || (birth_year > 2005) ,   exactly as we have written before!",
            "title": "De Morgan's Law"
        },
        {
            "location": "/10-assert/index.html#problem-set-10",
            "text": "",
            "title": "Problem Set 10"
        },
        {
            "location": "/10-assert/index.html#problem-101",
            "text": "Negate the following logical expression, then apply De Morgan's Law to simplify the resulting expression.  Assume all variable names mentioned are boolean variables.  (a)  (x > 1) && (y != 10)  (b)  !eating && drinking  (C)  (has_cs2030 || has_cs2113) && has_cs2040c",
            "title": "Problem 10.1"
        },
        {
            "location": "/10-assert/index.html#problem-102",
            "text": "In the code below, replace  ???  with the appropriate assertion.  What will be printed?   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20 long   score   =   4 ;  if   ( something )   { \n   score   =   10 ;  }   else   { \n   score   =   0 ;  }  // { ??? }  if   ( score   ==   4 )   { \n     score   =   1 ;  }   else   { \n     score   +=   10 ;  }  // { ??? }  if   ( score   >=   10 )   { \n     cs1010_println_string ( \"ok\" );  }   else   { \n     cs1010_println_string ( \"failed\" );  }",
            "title": "Problem 10.2"
        },
        {
            "location": "/11-loop/index.html",
            "text": "Unit 11: Loops\n\n\nIn \nUnit 8\n, you were introduced to writing code that follows one of two possible execution paths using the \nif\n-\nelse\n statements, using a logical expression to decide which path to take.\n\n\nSometimes, we want to execute one of the branches repeatedly (or interatively), over-and-over again, until a certain logical condition is met.  You have seen this construct in the \nmax\nmax\n and \nsum\nsum\n example, where we repeatedly go through the numbers in the list until \ni == k\ni == k\n.\n\n\nWriting Loops\n\n\nTo write a loop, we need to think about the following four questions:\n\n\n\n\nwhat do we want to do repeatedly?\n\n\nwhat do we need to set up before repeating the above?\n\n\nwhat changes from one repetition to another?  \n\n\nhow to decide if we should stop repeating (or conversely, to continue repeating?)\n\n\n\n\nThere is a fifth question that is as important as the above but is harder to answer (and not necessary for writing simple loops), so we will leave it to \nUnit 12\n.\n\n\nLet's revisit the example of \nmax\n.  Here is the answer to the questions:\n\n\n\n\n\n\nWhat do we want to do repeatedly?  We want to compare the element \nl_i\nl_i\n to \nm\nm\n, and update \nm\nm\n to \nl_i\nl_i\n if \nl_i > m\nl_i > m\n.\n\n\n\n\n\n\nWhat do we need to set up before repeating the above?  We need to have some initial value of \nm\nm\n and \ni\ni\n.  We set it up as \nm = l_0\nm = l_0\n and \ni = 1\ni = 1\n.\n\n\n\n\n\n\nWhat would be different each time we repeat the above?  Every time we repeat, \ni\ni\n will be different.  To be more precise, \ni\ni\n is one more than before.\n\n\n\n\n\n\nHow to decide if we should continue repeating the above?  We stop when there is no more element to compare, i.e., \ni\ni\n equals \nk\nk\n.  In other words, we continue if \ni < k\ni < k\n.\n\n\n\n\n\n\n\n\nLet's consider another example.  We have seen how to compute factorial recursively.  Let's try to compute factorial using a loop.\n\n\nRecall that \nn! = n \\times n-1 \\times n-2 .. 2 \\times 1\nn! = n \\times n-1 \\times n-2 .. 2 \\times 1\n.  Given \nn\nn\n, how do we find \nn!\nn!\n using a loop?  \n\n\nThe idea to solve this with a loop is to start with the value \nn\nn\n, and repeatedly multiply another value \ni\ni\n, starting with \ni = n - 1\ni = n - 1\n, then \ni = n - 2\ni = n - 2\n, etc, until \ni = 2\ni = 2\n.  We do not need to multiple with \ni = 1\ni = 1\n since it does not change the value.\n\n\nLike any other problem, we need to consider what are the variables we need to maintain.  In this case, we should maintain the partial product of the factorial and a variable \ni\ni\n that corresponds to value to multiple into the partial product.\n\n\n\n\nWhat do we want to do repeatedly?  Multiply \ni\ni\n into the partial product. \n\n\nWhat do we need to set up before repeating the above?  We set up the partial product to be \nn\nn\n and \ni\ni\n to be \nn - 1\nn - 1\n.\n\n\nWhat changes from one repetition to another?  \ni\ni\n would decrease by one every time we repeat the above.\n\n\nHow to decide if we should stop repeating (or conversely, to continue repeating?)  We can stop when we have multiplied \ni = 2\ni = 2\n to the partial product.\n\n\n\n\nWe can express the algorithm above using the following flowchart:\n\n\n\n\nA \nfor\n loop\n\n\nC provides three ways to write a loop.  Let's start with a simple one first, a \nfor\n loop.  \n\n\nThe \nfor\n loop in C has the following syntax:\n\n\n1\n2\n3\nfor\n \n(\n<\ninitialize\n>\n;\n \n<\ncondition\n>\n;\n \n<\nupdate\n>\n)\n \n{\n\n    \n<\nbody\n>\n\n\n}\n\n\n\n\n\n\n\nThere are four components, corresponding to the four questions above:\n\n\n\n\nThe \ninitialize\n statement set up the loop (i.e., \"What do we need to set up before repeating the above?\").  \n\n\nThe \ncondition\n statement indicates when we should stop repeating.  If it evaluates to \ntrue\n, it will cause the loop to continue, otherwise, the loop stops.\n\n\nThe \nupdate\n statement is executed after every loop.  (i.e., \"What changes from one repetition to another?\")\n\n\nThe \nbody\n statement is the action that we want to do repeatedly.  \n\n\n\n\n\n\nFor the \ninitialize\n and \nupdate\n statement, even though C allows us to include multiple initializations and multiple updates, it makes the code harder to read and understand.  C also allows us to have empty statements for \ninitialize\n, \ncondition\n and/or \nupdate\n.  As such, in CS1010, we will stick to performing one initialization and one update only.\n\n\nFor example, in the setup phase for factorial, we should initialize the partial product to \nn\nn\n and \ni\ni\n to \nn - 1\nn - 1\n, that's two assignments.  We commonly choose the index which we increment or decrement as we loop, hence we choose to initialize \ni\ni\n in the \ninitialize\n statement of the \nfor\n loop, and leave the initialization of \nproduct\n to a separate assignment before the \nfor\n loop.\n\n\nHere is the example for computing the factorial:\n\n\n1\n2\n3\n4\n5\n6\n7\n8\nlong\n \nfactorial\n(\nlong\n \nn\n)\n \n\n{\n\n    \nlong\n \nproduct\n \n=\n \nn\n;\n\n    \nfor\n \n(\nint\n \ni\n \n=\n \nn\n-\n1\n;\n \ni\n \n>=\n \n2\n;\n \ni\n \n-=\n \n1\n)\n \n{\n\n        \nproduct\n \n*=\n \ni\n;\n\n    \n}\n\n    \nreturn\n \nproduct\n;\n\n\n}\n\n\n\n\n\n\n\nThe code above is almost correct.  We only need to handle the special case when \nn\n is 0.  The complete code for the function is thus:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\nlong\n \nfactorial\n(\nlong\n \nn\n)\n \n\n{\n\n    \nif\n \n(\nn\n \n==\n \n0\n)\n \n{\n\n        \nreturn\n \n1\n;\n\n    \n}\n\n    \nlong\n \nproduct\n \n=\n \nn\n;\n\n    \nfor\n \n(\nint\n \ni\n \n=\n \nn\n-\n1\n;\n \ni\n \n>=\n \n2\n;\n \ni\n \n-=\n \n1\n)\n \n{\n\n        \nproduct\n \n*=\n \ni\n;\n\n    \n}\n\n    \nreturn\n \nproduct\n;\n\n\n}\n\n\n\n\n\n\n\nwhile\n Loop\n\n\nThe second way to write a loop in C is to use a \nwhile\n loop.  The while loop looks like this:\n\n\n1\n2\n3\nwhile\n \n(\n<\ncondition\n>\n)\n \n{\n\n    \n<\nbody\n>\n\n\n}\n\n\n\n\n\n\n\nThe statements in \n<body>\n will be executed if \n<condition>\n is true.  \n\n\nNote that the syntax of the \nwhile\n loop above does not contain the \n<initialize>\n and the \n<update>\n component.  When we write the loop, however, we still need to think about them, and add them to the appropriate place in the code, as follows:\n\n\n1\n2\n3\n4\n5\n<\ninitialize\n>\n\n\nwhile\n \n(\n<\ncondition\n>\n)\n \n{\n\n    \n<\nbody\n>\n\n    \n<\nupdate\n>\n\n\n}\n\n\n\n\n\n\n\nThe corresponding flowchart for \nwhile\n is:\n\n\n\n\nCompare the flowchart for \nwhile\n to the flowchart for \nfor\n earlier.  You will see that they are exactly the same!\n\n\nHere is the \nwhile\n version of the \nfactorial\n function:\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\nlong\n \nfactorial\n(\nlong\n \nn\n)\n \n\n{\n\n    \nif\n \n(\nn\n \n==\n \n0\n)\n \n{\n\n        \nreturn\n \n1\n;\n\n    \n}\n\n    \nlong\n \nproduct\n \n=\n \nn\n;\n\n    \nint\n \ni\n \n=\n \nn\n \n-\n \n1\n;\n\n    \nwhile\n \n(\ni\n \n>=\n \n2\n)\n \n{\n\n        \nproduct\n \n*=\n \ni\n;\n\n        \ni\n \n-=\n \n1\n;\n\n    \n}\n\n    \nreturn\n \nproduct\n;\n\n\n}\n\n\n\n\n\n\nIn the \nwhile\n loop, however, we can be more flexible in terms of what we want to do inside the loop.  Technically, there is no difference between \nupdate\n and \nbody\n since they are just a bunch of C statements.  We can interleave \n<update>\n and \n<body>\n or execute \n<update>\n first before \n<body>\n, depending on the algorithm.  With \nfor\n loop, there is no such flexibility as \n<update>\n has to be executed after \n<body>\n.\n\n\nA \ndo-while\n loop\n\n\nThe third way we can write a loop in C is to use a \ndo-while\n loop.  The \ndo-while\n loop is very similar to \nwhile\n, except that the body of the loop is guaranteed to be executed at least once.  \n\n\n1\n2\n3\n4\n5\n<\ninitialize\n>\n\n\ndo\n \n{\n\n    \n<\nbody\n>\n\n    \n<\nupdate\n>\n\n\n}\n \nwhile\n \n(\n<\ncondition\n>\n);\n\n\n\n\n\n\n\n\n\nSimilar to the \nwhile\n loop, the \n<body>\n component and \n<update>\n component in the loop does not have to be in order.\n\n\n\n\nThere is a semicolor \n;\n after a \ndo-while\n loop.\n\n\n\n\nLet's look at an example where using \ndo-while\n is more natural than \nwhile\n.  \n\n\nExample: Guess a Number\n\n\nLet's write a program that plays a game with the user.  The program generates a random integer number between 1 and 100.  The user will guess what that number is.  If the user guesses correctly, the program congratulates the user.  Otherwise, the program tells the user whether the guess is too high or too low, and let the user guess again.  This process repeats until the guess is correct.\n\n\nNote that, here, the user needs to guess at least once, so it is more natural to use a \ndo\n-\nwhile\n loop than a \nwhile\n or a \nfor\n.\n\n\nAnswering The Four Questions\n\n\n\n\nWhat do we want to do repeatedly?  We want to read the guess from the user and respond back to the user.\n\n\nWhat do we need to set up before repeating the above?  We need to generate a random integer between 1 and 100.\n\n\nWhat changes from one repetition to another?  The guess \nmay\n be different.\n\n\nHow to decide if we should continue repeating the above?  We stop when the guess is correct.\n\n\n\n\nDesigning the Flowchart\n\n\nHere is the flowchart of the steps described above.  \n\n\n\n\nThe C code\n\n\nThe entire corresponding program is shown below:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n#include\n \n<stdlib.h>\n\n\n#include\n \n<sys/times.h>\n\n\n#include\n \n\"cs1010.h\"\n\n\n\nint\n \nmain\n()\n\n\n{\n\n  \n// Initialize the random number generator\n\n  \nsrandom\n(\ntimes\n(\n0\n));\n\n\n  \n// Generate a random number between 1 and 100\n\n  \nlong\n \nanswer\n \n=\n \n(\nrandom\n()\n \n%\n \n100\n)\n \n+\n \n1\n;\n\n\n  \nlong\n \nguess\n;\n\n  \ndo\n \n{\n\n    \n// Read guess and feedback to user\n\n    \nguess\n \n=\n \ncs1010_read_long\n();\n\n    \nif\n \n(\nguess\n \n>\n \nanswer\n)\n \n{\n\n      \ncs1010_println_string\n(\n\"too high\"\n);\n\n    \n}\n \nelse\n \nif\n \n(\nguess\n \n<\n \nanswer\n)\n \n{\n\n      \ncs1010_println_string\n(\n\"too low\"\n);\n\n    \n}\n\n  \n}\n \nwhile\n \n(\nguess\n \n!=\n \nanswer\n);\n\n\n  \n// { guess == answer }\n\n  \ncs1010_println_string\n(\n\"you got it.  congrats!\"\n);\n\n\n}\n\n\n\n\n\n\n\nI will not go into details of what \nsrandom(times(0))\n means.  You can look it up on your own if you are interested (InfoSec students may want to do this as generating good random number is key to keeping systems secure).  \n\n\nThe function \nrandom()\n generates a random integer, which we limit to 0 to 99 by modulo-ing it with 100.  We then add 1 to it to a number between 1 and 100, inclusive.\n\n\nProblem Set\n\n\nProblem 11.1\n\n\nHere is another version of the \nfactorial\n function:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\nlong\n \nfactorial\n(\nlong\n \nn\n)\n \n\n{\n\n    \nint\n \ni\n \n=\n \nn\n \n-\n \n1\n;\n\n    \nlong\n \nproduct\n;\n\n    \nfor\n \n(\nproduct\n \n=\n \nn\n;\n \ni\n \n>=\n \n2\n;\n \nproduct\n \n*=\n \ni\n);\n\n    \n{\n\n        \ni\n \n-=\n \n1\n;\n\n    \n}\n\n    \nreturn\n \nproduct\n;\n\n\n}\n\n\n\n\n\n\n\nDoes this code runs correctly?  If it is incorrect, explain what is wrong and suggest a fix.  (Hint: translate this to the corresponding flowchart and trace through the flowchart).\n\n\nProblem 11.2\n\n\n(a) Rewrite the \"Guess A Number\" program so that it shows the user the number of guesses made before the correct guess is entered.\n\n\n(b) Rewrite the \"Guess A Number\" program with a \nwhile\n loop.\n\n\n(C) Extend the \"Guess A Number\" program so that it plays the game for five rounds with the user, and at the end, shows the user the average number of guesses over five rounds.  (Hint: you should put the loop that reads the guess and prints feedback to the user into another function.)\n\n\n(d) What is the optimal strategy to play the game?\n\n\nProblem 11.3\n\n\nTrace the following algorithms:\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nlong\n \nmystery\n(\nlong\n \nn\n,\n \nlong\n \nk\n)\n \n{\n\n    \nlong\n \nsomething\n \n=\n \nn\n;\n\n    \nlong\n \ncount\n \n=\n \n-\n1\n;\n\n    \nwhile\n \n(\nsomething\n \n>=\n \n1\n)\n \n{\n\n        \nsomething\n \n/=\n \nk\n;\n \n        \ncount\n \n+=\n \n1\n;\n\n    \n}\n\n    \nreturn\n \ncount\n;\n\n\n}\n\n\n\n\n\n\n\n(a) \nWhat is the return value when \n\n\n\n\nn\n is 8 and \nk\n is 2?  \n\n\nn\n is 81 and \nk\n is 3?  \n\n\nn\n is 100 and \nk\n is 5?\n\n\n\n\nAnswer these questions by reading the code first, instead of trying it out on a computer (you can verify later).\n\n\n(b)\nWhat is the mathematical expression that our mystery function here is trying to compute based on the examples above?\n\n\n(C)\nGive a pair of inputs that would cause the function to return the wrong answer.\n\n\n(d) \nGive a pair of inputs that would cause the function to loop forever.",
            "title": "11. Loops"
        },
        {
            "location": "/11-loop/index.html#unit-11-loops",
            "text": "In  Unit 8 , you were introduced to writing code that follows one of two possible execution paths using the  if - else  statements, using a logical expression to decide which path to take.  Sometimes, we want to execute one of the branches repeatedly (or interatively), over-and-over again, until a certain logical condition is met.  You have seen this construct in the  max max  and  sum sum  example, where we repeatedly go through the numbers in the list until  i == k i == k .",
            "title": "Unit 11: Loops"
        },
        {
            "location": "/11-loop/index.html#writing-loops",
            "text": "To write a loop, we need to think about the following four questions:   what do we want to do repeatedly?  what do we need to set up before repeating the above?  what changes from one repetition to another?    how to decide if we should stop repeating (or conversely, to continue repeating?)   There is a fifth question that is as important as the above but is harder to answer (and not necessary for writing simple loops), so we will leave it to  Unit 12 .  Let's revisit the example of  max .  Here is the answer to the questions:    What do we want to do repeatedly?  We want to compare the element  l_i l_i  to  m m , and update  m m  to  l_i l_i  if  l_i > m l_i > m .    What do we need to set up before repeating the above?  We need to have some initial value of  m m  and  i i .  We set it up as  m = l_0 m = l_0  and  i = 1 i = 1 .    What would be different each time we repeat the above?  Every time we repeat,  i i  will be different.  To be more precise,  i i  is one more than before.    How to decide if we should continue repeating the above?  We stop when there is no more element to compare, i.e.,  i i  equals  k k .  In other words, we continue if  i < k i < k .     Let's consider another example.  We have seen how to compute factorial recursively.  Let's try to compute factorial using a loop.  Recall that  n! = n \\times n-1 \\times n-2 .. 2 \\times 1 n! = n \\times n-1 \\times n-2 .. 2 \\times 1 .  Given  n n , how do we find  n! n!  using a loop?    The idea to solve this with a loop is to start with the value  n n , and repeatedly multiply another value  i i , starting with  i = n - 1 i = n - 1 , then  i = n - 2 i = n - 2 , etc, until  i = 2 i = 2 .  We do not need to multiple with  i = 1 i = 1  since it does not change the value.  Like any other problem, we need to consider what are the variables we need to maintain.  In this case, we should maintain the partial product of the factorial and a variable  i i  that corresponds to value to multiple into the partial product.   What do we want to do repeatedly?  Multiply  i i  into the partial product.   What do we need to set up before repeating the above?  We set up the partial product to be  n n  and  i i  to be  n - 1 n - 1 .  What changes from one repetition to another?   i i  would decrease by one every time we repeat the above.  How to decide if we should stop repeating (or conversely, to continue repeating?)  We can stop when we have multiplied  i = 2 i = 2  to the partial product.   We can express the algorithm above using the following flowchart:",
            "title": "Writing Loops"
        },
        {
            "location": "/11-loop/index.html#a-for-loop",
            "text": "C provides three ways to write a loop.  Let's start with a simple one first, a  for  loop.    The  for  loop in C has the following syntax:  1\n2\n3 for   ( < initialize > ;   < condition > ;   < update > )   { \n     < body >  }    There are four components, corresponding to the four questions above:   The  initialize  statement set up the loop (i.e., \"What do we need to set up before repeating the above?\").    The  condition  statement indicates when we should stop repeating.  If it evaluates to  true , it will cause the loop to continue, otherwise, the loop stops.  The  update  statement is executed after every loop.  (i.e., \"What changes from one repetition to another?\")  The  body  statement is the action that we want to do repeatedly.      For the  initialize  and  update  statement, even though C allows us to include multiple initializations and multiple updates, it makes the code harder to read and understand.  C also allows us to have empty statements for  initialize ,  condition  and/or  update .  As such, in CS1010, we will stick to performing one initialization and one update only.  For example, in the setup phase for factorial, we should initialize the partial product to  n n  and  i i  to  n - 1 n - 1 , that's two assignments.  We commonly choose the index which we increment or decrement as we loop, hence we choose to initialize  i i  in the  initialize  statement of the  for  loop, and leave the initialization of  product  to a separate assignment before the  for  loop.  Here is the example for computing the factorial:  1\n2\n3\n4\n5\n6\n7\n8 long   factorial ( long   n )   { \n     long   product   =   n ; \n     for   ( int   i   =   n - 1 ;   i   >=   2 ;   i   -=   1 )   { \n         product   *=   i ; \n     } \n     return   product ;  }    The code above is almost correct.  We only need to handle the special case when  n  is 0.  The complete code for the function is thus:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11 long   factorial ( long   n )   { \n     if   ( n   ==   0 )   { \n         return   1 ; \n     } \n     long   product   =   n ; \n     for   ( int   i   =   n - 1 ;   i   >=   2 ;   i   -=   1 )   { \n         product   *=   i ; \n     } \n     return   product ;  }",
            "title": "A for loop"
        },
        {
            "location": "/11-loop/index.html#while-loop",
            "text": "The second way to write a loop in C is to use a  while  loop.  The while loop looks like this:  1\n2\n3 while   ( < condition > )   { \n     < body >  }    The statements in  <body>  will be executed if  <condition>  is true.    Note that the syntax of the  while  loop above does not contain the  <initialize>  and the  <update>  component.  When we write the loop, however, we still need to think about them, and add them to the appropriate place in the code, as follows:  1\n2\n3\n4\n5 < initialize >  while   ( < condition > )   { \n     < body > \n     < update >  }    The corresponding flowchart for  while  is:   Compare the flowchart for  while  to the flowchart for  for  earlier.  You will see that they are exactly the same!  Here is the  while  version of the  factorial  function:  1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13 long   factorial ( long   n )   { \n     if   ( n   ==   0 )   { \n         return   1 ; \n     } \n     long   product   =   n ; \n     int   i   =   n   -   1 ; \n     while   ( i   >=   2 )   { \n         product   *=   i ; \n         i   -=   1 ; \n     } \n     return   product ;  }    In the  while  loop, however, we can be more flexible in terms of what we want to do inside the loop.  Technically, there is no difference between  update  and  body  since they are just a bunch of C statements.  We can interleave  <update>  and  <body>  or execute  <update>  first before  <body> , depending on the algorithm.  With  for  loop, there is no such flexibility as  <update>  has to be executed after  <body> .",
            "title": "while Loop"
        },
        {
            "location": "/11-loop/index.html#a-do-while-loop",
            "text": "The third way we can write a loop in C is to use a  do-while  loop.  The  do-while  loop is very similar to  while , except that the body of the loop is guaranteed to be executed at least once.    1\n2\n3\n4\n5 < initialize >  do   { \n     < body > \n     < update >  }   while   ( < condition > );     Similar to the  while  loop, the  <body>  component and  <update>  component in the loop does not have to be in order.   There is a semicolor  ;  after a  do-while  loop.   Let's look at an example where using  do-while  is more natural than  while .",
            "title": "A do-while loop"
        },
        {
            "location": "/11-loop/index.html#example-guess-a-number",
            "text": "Let's write a program that plays a game with the user.  The program generates a random integer number between 1 and 100.  The user will guess what that number is.  If the user guesses correctly, the program congratulates the user.  Otherwise, the program tells the user whether the guess is too high or too low, and let the user guess again.  This process repeats until the guess is correct.  Note that, here, the user needs to guess at least once, so it is more natural to use a  do - while  loop than a  while  or a  for .",
            "title": "Example: Guess a Number"
        },
        {
            "location": "/11-loop/index.html#answering-the-four-questions",
            "text": "What do we want to do repeatedly?  We want to read the guess from the user and respond back to the user.  What do we need to set up before repeating the above?  We need to generate a random integer between 1 and 100.  What changes from one repetition to another?  The guess  may  be different.  How to decide if we should continue repeating the above?  We stop when the guess is correct.",
            "title": "Answering The Four Questions"
        },
        {
            "location": "/11-loop/index.html#designing-the-flowchart",
            "text": "Here is the flowchart of the steps described above.",
            "title": "Designing the Flowchart"
        },
        {
            "location": "/11-loop/index.html#the-c-code",
            "text": "The entire corresponding program is shown below:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26 #include   <stdlib.h>  #include   <sys/times.h>  #include   \"cs1010.h\"  int   main ()  { \n   // Initialize the random number generator \n   srandom ( times ( 0 )); \n\n   // Generate a random number between 1 and 100 \n   long   answer   =   ( random ()   %   100 )   +   1 ; \n\n   long   guess ; \n   do   { \n     // Read guess and feedback to user \n     guess   =   cs1010_read_long (); \n     if   ( guess   >   answer )   { \n       cs1010_println_string ( \"too high\" ); \n     }   else   if   ( guess   <   answer )   { \n       cs1010_println_string ( \"too low\" ); \n     } \n   }   while   ( guess   !=   answer ); \n\n   // { guess == answer } \n   cs1010_println_string ( \"you got it.  congrats!\" );  }    I will not go into details of what  srandom(times(0))  means.  You can look it up on your own if you are interested (InfoSec students may want to do this as generating good random number is key to keeping systems secure).    The function  random()  generates a random integer, which we limit to 0 to 99 by modulo-ing it with 100.  We then add 1 to it to a number between 1 and 100, inclusive.",
            "title": "The C code"
        },
        {
            "location": "/11-loop/index.html#problem-set",
            "text": "",
            "title": "Problem Set"
        },
        {
            "location": "/11-loop/index.html#problem-111",
            "text": "Here is another version of the  factorial  function:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10 long   factorial ( long   n )   { \n     int   i   =   n   -   1 ; \n     long   product ; \n     for   ( product   =   n ;   i   >=   2 ;   product   *=   i ); \n     { \n         i   -=   1 ; \n     } \n     return   product ;  }    Does this code runs correctly?  If it is incorrect, explain what is wrong and suggest a fix.  (Hint: translate this to the corresponding flowchart and trace through the flowchart).",
            "title": "Problem 11.1"
        },
        {
            "location": "/11-loop/index.html#problem-112",
            "text": "(a) Rewrite the \"Guess A Number\" program so that it shows the user the number of guesses made before the correct guess is entered.  (b) Rewrite the \"Guess A Number\" program with a  while  loop.  (C) Extend the \"Guess A Number\" program so that it plays the game for five rounds with the user, and at the end, shows the user the average number of guesses over five rounds.  (Hint: you should put the loop that reads the guess and prints feedback to the user into another function.)  (d) What is the optimal strategy to play the game?",
            "title": "Problem 11.2"
        },
        {
            "location": "/11-loop/index.html#problem-113",
            "text": "Trace the following algorithms:  1\n2\n3\n4\n5\n6\n7\n8\n9 long   mystery ( long   n ,   long   k )   { \n     long   something   =   n ; \n     long   count   =   - 1 ; \n     while   ( something   >=   1 )   { \n         something   /=   k ;  \n         count   +=   1 ; \n     } \n     return   count ;  }    (a) \nWhat is the return value when    n  is 8 and  k  is 2?    n  is 81 and  k  is 3?    n  is 100 and  k  is 5?   Answer these questions by reading the code first, instead of trying it out on a computer (you can verify later).  (b)\nWhat is the mathematical expression that our mystery function here is trying to compute based on the examples above?  (C)\nGive a pair of inputs that would cause the function to return the wrong answer.  (d) \nGive a pair of inputs that would cause the function to loop forever.",
            "title": "Problem 11.3"
        },
        {
            "location": "/12-invariant/index.html",
            "text": "Unit 12: Reasoning About Loops\n\n\nUsing Assertions\n\n\nWe have seen how we can use assertions to reason about the state of our program at different points of execution for conditional \nif\n-\nelse\n statements.  We can apply the same techniques to loops.  Take the simple program below:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\nlong\n \ncount\n(\nlong\n \nn\n)\n \n{\n\n  \nlong\n \ny\n \n=\n \n0\n;\n\n  \nlong\n \nx\n \n=\n \nn\n;\n\n  \nwhile\n \n(\nx\n \n>\n \n0\n)\n \n{\n\n    \n// line A\n\n    \nx\n \n-=\n \n1\n;\n\n    \n// line B\n\n    \nif\n \n(\nx\n \n%\n \n5\n \n==\n \n0\n)\n \n{\n\n      \n// line C\n\n      \ny\n \n+=\n \n1\n;\n\n    \n}\n\n  \n}\n\n  \n// line D\n\n  \nreturn\n \ny\n;\n\n\n}\n\n\n\n\n\n\n\nBefore we continue, study this program and try to analyze what the function is counting and returning.\n\n\nTo do this more systematically, we can use assertions.  Let's ask ourselves: what can be said about the variables \nx\n and \ny\n at Lines A, B, C?  Let starts with \nx\n first.\n\n\n\n\nLine A is the first line after entering the loop, so we can reason that to enter the loop (the first time or subsequent times), \nx > 0\n and \nx <= n\n (since we initialize the \nx\n to \nn\n).\n\n\nAt Line B, we decrease \nx\n by 1, so \nx >= 0 && x < n\n must be true.\n\n\nAt Line C, \nx % 5 == 0\n (i.e., x is multiple of 5) must \nalso\n be true (since it is in the true block of the \nif\n block).\n\n\nAt Line D, we already exit from the loop, and the only way to exit here is that \nx > 0\n is false.  So we know that \nx <= 0\n.\n\n\n\n\nLet's annotate the code with the assertions:\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\nlong\n \ncount\n(\nlong\n \nn\n)\n \n{\n\n  \nlong\n \ny\n \n=\n \n0\n;\n\n  \nlong\n \nx\n \n=\n \nn\n;\n\n  \nwhile\n \n(\nx\n \n>\n \n0\n)\n \n{\n\n    \n// { x > 0 && x <= n }\n\n    \nx\n \n-=\n \n1\n;\n\n    \n// { (x >= 0) && (x < n) }\n\n    \nif\n \n(\nx\n \n%\n \n5\n \n==\n \n0\n)\n \n{\n\n      \n// { (x >= 0) && (x < n) && x is multiple of 5 }\n\n      \ny\n \n+=\n \n1\n;\n\n    \n}\n\n  \n}\n\n  \n// { x <= 0 }\n\n  \nreturn\n \ny\n;\n\n\n}\n\n\n\n\n\n\nWhat can be said about \ny\n?  It should be clear now that we increment \ny\n for every value between 0 and \nn-1\n (inclusive) that is a multiple of 5, based on the condition on Line C.  That is, it is counting the number of multiple of 5s between 0 and n-1.\n\n\nLoop Invariant\n\n\nIn the last unit, we say that there are actually five questions that we have to think about when designing loops.  The fifth question is: what is the \nloop invariant\n?  A loop invariant is an assertion that is true before the loop, during the loop, and after the loop.  Thinking about the loop invariant is helpful to convince ourselves that a loop is correct, or to identify bugs in a loop.\n\n\nLet's see an example of a loop invariant.  Consider the example of calculating a factorial using a loop as before.  To make the invariant simpler, let's tweak the loop slightly and start looping from \ni\n equals 1 up to \nn\n.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\nlong\n \nfactorial\n(\nlong\n \nn\n)\n \n\n{\n\n  \nif\n \n(\nn\n \n==\n \n0\n)\n \n{\n\n      \nreturn\n \n1\n;\n\n  \n}\n\n  \nlong\n \nproduct\n \n=\n \n1\n;\n\n  \nint\n \ni\n \n=\n \n1\n;\n\n  \n// Line A\n\n  \nwhile\n \n(\ni\n \n<\n \nn\n)\n \n{\n\n    \ni\n \n+=\n \n1\n;\n\n    \nproduct\n \n*=\n \ni\n;\n\n    \n// Line B\n\n  \n}\n\n  \n// Line C\n\n  \nreturn\n \nproduct\n;\n\n\n}\n\n\n\n\n\n\n\nThe loop invariant for each line A, B, and C are the same: \n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\nlong\n \nfactorial\n(\nlong\n \nn\n)\n \n\n{\n\n  \nif\n \n(\nn\n \n==\n \n0\n)\n \n{\n\n      \nreturn\n \n1\n;\n\n  \n}\n\n  \nlong\n \nproduct\n \n=\n \n1\n;\n\n  \nint\n \ni\n \n=\n \n1\n;\n\n  \n// A: { product == i! }\n\n  \nwhile\n \n(\ni\n \n<\n \nn\n)\n \n{\n\n    \ni\n \n+=\n \n1\n;\n\n    \nproduct\n \n*=\n \ni\n;\n\n    \n// B: { product == i! }\n\n  \n}\n\n  \n// C: { product == i! }\n\n  \nreturn\n \nproduct\n;\n\n\n}\n\n\n\n\n\n\n\nIn Line A, the assertion is obvious.  Let's look at Line B.  Since, at the beginning of the loop (before Line 10) we have \nproduct == i!\n, after Line 10, we have \nproduct == (i-1)!\n (since we have incremented \ni\n).  After Line 11, we have \nproduct == i * (i - 1)! == i!\n again.  The assertion remains true once we exit the loop.\n\n\nThe key here is that after we exit the loop, we can also assert that \ni == n\n, and so combining \nproduct == i! && i == n\n we have \nproduct == n!\n, which is what we want.\n\n\nProblem Set 12\n\n\nProblem 12.1\n\n\n1\n2\n3\n4\n5\n6\nlong\n \ni\n \n=\n \n10\n;\n\n\nlong\n \nj\n \n=\n \n0\n;\n\n\nwhile\n \n(\ni\n \n!=\n \n0\n)\n \n{\n\n    \ni\n \n-=\n \n1\n;\n\n    \nj\n \n+=\n \n1\n;\n\n\n}\n\n\n\n\n\n\n\n(a) Trace through the program.  What is the value of \nj\n when the loop exits?\n\n\n(b) Do you recognize any pattern on the relationship of \ni\n and \nj\n?\n\n\n(C) What is the loop invariant?",
            "title": "12. Reasoning About Loops"
        },
        {
            "location": "/12-invariant/index.html#unit-12-reasoning-about-loops",
            "text": "",
            "title": "Unit 12: Reasoning About Loops"
        },
        {
            "location": "/12-invariant/index.html#using-assertions",
            "text": "We have seen how we can use assertions to reason about the state of our program at different points of execution for conditional  if - else  statements.  We can apply the same techniques to loops.  Take the simple program below:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15 long   count ( long   n )   { \n   long   y   =   0 ; \n   long   x   =   n ; \n   while   ( x   >   0 )   { \n     // line A \n     x   -=   1 ; \n     // line B \n     if   ( x   %   5   ==   0 )   { \n       // line C \n       y   +=   1 ; \n     } \n   } \n   // line D \n   return   y ;  }    Before we continue, study this program and try to analyze what the function is counting and returning.  To do this more systematically, we can use assertions.  Let's ask ourselves: what can be said about the variables  x  and  y  at Lines A, B, C?  Let starts with  x  first.   Line A is the first line after entering the loop, so we can reason that to enter the loop (the first time or subsequent times),  x > 0  and  x <= n  (since we initialize the  x  to  n ).  At Line B, we decrease  x  by 1, so  x >= 0 && x < n  must be true.  At Line C,  x % 5 == 0  (i.e., x is multiple of 5) must  also  be true (since it is in the true block of the  if  block).  At Line D, we already exit from the loop, and the only way to exit here is that  x > 0  is false.  So we know that  x <= 0 .   Let's annotate the code with the assertions:  1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15 long   count ( long   n )   { \n   long   y   =   0 ; \n   long   x   =   n ; \n   while   ( x   >   0 )   { \n     // { x > 0 && x <= n } \n     x   -=   1 ; \n     // { (x >= 0) && (x < n) } \n     if   ( x   %   5   ==   0 )   { \n       // { (x >= 0) && (x < n) && x is multiple of 5 } \n       y   +=   1 ; \n     } \n   } \n   // { x <= 0 } \n   return   y ;  }    What can be said about  y ?  It should be clear now that we increment  y  for every value between 0 and  n-1  (inclusive) that is a multiple of 5, based on the condition on Line C.  That is, it is counting the number of multiple of 5s between 0 and n-1.",
            "title": "Using Assertions"
        },
        {
            "location": "/12-invariant/index.html#loop-invariant",
            "text": "In the last unit, we say that there are actually five questions that we have to think about when designing loops.  The fifth question is: what is the  loop invariant ?  A loop invariant is an assertion that is true before the loop, during the loop, and after the loop.  Thinking about the loop invariant is helpful to convince ourselves that a loop is correct, or to identify bugs in a loop.  Let's see an example of a loop invariant.  Consider the example of calculating a factorial using a loop as before.  To make the invariant simpler, let's tweak the loop slightly and start looping from  i  equals 1 up to  n .   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16 long   factorial ( long   n )   { \n   if   ( n   ==   0 )   { \n       return   1 ; \n   } \n   long   product   =   1 ; \n   int   i   =   1 ; \n   // Line A \n   while   ( i   <   n )   { \n     i   +=   1 ; \n     product   *=   i ; \n     // Line B \n   } \n   // Line C \n   return   product ;  }    The loop invariant for each line A, B, and C are the same:    1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16 long   factorial ( long   n )   { \n   if   ( n   ==   0 )   { \n       return   1 ; \n   } \n   long   product   =   1 ; \n   int   i   =   1 ; \n   // A: { product == i! } \n   while   ( i   <   n )   { \n     i   +=   1 ; \n     product   *=   i ; \n     // B: { product == i! } \n   } \n   // C: { product == i! } \n   return   product ;  }    In Line A, the assertion is obvious.  Let's look at Line B.  Since, at the beginning of the loop (before Line 10) we have  product == i! , after Line 10, we have  product == (i-1)!  (since we have incremented  i ).  After Line 11, we have  product == i * (i - 1)! == i!  again.  The assertion remains true once we exit the loop.  The key here is that after we exit the loop, we can also assert that  i == n , and so combining  product == i! && i == n  we have  product == n! , which is what we want.",
            "title": "Loop Invariant"
        },
        {
            "location": "/12-invariant/index.html#problem-set-12",
            "text": "",
            "title": "Problem Set 12"
        },
        {
            "location": "/12-invariant/index.html#problem-121",
            "text": "1\n2\n3\n4\n5\n6 long   i   =   10 ;  long   j   =   0 ;  while   ( i   !=   0 )   { \n     i   -=   1 ; \n     j   +=   1 ;  }    (a) Trace through the program.  What is the value of  j  when the loop exits?  (b) Do you recognize any pattern on the relationship of  i  and  j ?  (C) What is the loop invariant?",
            "title": "Problem 12.1"
        },
        {
            "location": "/ex01/index.html",
            "text": "Exercise 1: Freezer\n\n\nThis is your first programming exercise.  An exercise is something that you do on your own.  You can submit them but it will not be graded.   Test cases are provided for the exercises so that you can test and check on your own if your code is correct.  This is in contrast to an assignment, where you need to submit for grading and for credits.\n\n\nPrerequisite\n\n\n\n\nYou are able to access the \nCS1010 programming environment\n.\n\n\nYou are familiar with \nbasic UNIX CLI\n and using terminal-based editor \nvim\n.\n\n\n\n\nLearning Outcomes\n\n\n\n\nBe comfortable writing simple C programs that involves arithmetic operations, \nlong\n and \ndouble\n types.\n\n\n\n\nOne-Time Setup\n\n\nBefore going into their first programming exercise, you need to do a one time setup of your account on PE. You need to create a file called \n.gitconfig\n in your home directory and with the following content:\n\n\n1\n2\n3\n4\n5\n[user]\n  name = Your Name\n  email = Your Email\n[github]  \n  user = Your GitHub ID\n\n\n\n\n\n\nYour email should be whatever you used to sign up Github.\n\n\nFor example, a sample \n.gitconfig\n looks like this:\n\n\n1\n2\n3\n4\n5\n[user]\n  name = Jon Snow\n  email = king@north.gov\n[github]  \n  user = jonsnow\n\n\n\n\n\n\nAfter saving this file, run:\n\n\n1\ngit config --get github.user\n\n\n\n\n\n\nIt should return your GitHub user id.\n\n\nIt should print your GitHub user id as set.  If there is a typo, you need to edit \n.gitconfig\n again and reload it by repeating the command above.\n\n\nSetup\n\n\n\n\nClick on \nthis link\n to accept the exercise.\n\n\nLogin to one of the hosts of \nCS1010 programming environment (PE)\n\n\nRun the following on the command line on one of the PE hosts:\n\n\n\n\n1\n~cs1010/get-ex01\n\n\n\n\n\n\n\n\nYou should see a new subdirectory \nex01-<githubid>\n in your current working directory, where \ngithubid\n is your GitHub ID.\n\n\n\n\nWe will call this directory your \nexercise directory\n or \nassignment directory\n.\n\n\n\n\n\n\nInside that directory, you should see a bunch of files:\n\n\n\n\nfreezer1.c\n and \nfreezer2.c\n are the most important files.  They are the skeleton C code that you should edit to solve the exercise.\n\n\ninputs\n and \noutputs\n are sub directories that contain test inputs and test outputs.  We use the convention \nproblem-name\n.\ntest-id\n.in for input test data, and \nproblem-name\n.\ntest-id\n.out for output test data.  So, you will see \nfreezer1.1.in\n, \nfreezer1.1.out\n, etc.  The expected output for \nfreezer1.1.in\n is in \nfreezer1.1.out\n.  You can look at the content of these files if you wish (which \nUNIX\n command should you use to do this?).  You can edit these files to change the test input and output.\n\n\nMakefile\n: This is the configuration for the tool \nmake\n that we use to automate the compilation and testing of the programs.  You do not have to understand how to write a \nMakefile\n for CS1010.  If you are interested to learn how to write a \nMakefile\n, talk to either Wei Tsang or Google.\n\n\ntest.sh\n: This is a bash script for testing your code.  You do not have to edit this file nor call it directly.  It is called by \nmake\n.  If you are interested to learn how to write bash script, talk to either Wei Tsang or Google.\n\n\n\n\n\n\n\n\nIdentifying Yourself\n\n\nIn every C file that you submit to CS1010, you need to identify yourself by writing your name and tutorial group.  Marks will be deducted if you fail to do so.  You need to edit the line:\n\n\n1\n@author XXXX (Group YYYY)\n\n\n\n\n\n\nand change it to something like:\n\n\n1\n@author Jon Snow (Group 10)\n\n\n\n\n\n\nSolving The Assignments\n\n\n\n\nEdit the files \nfreezer1.c\n and \nfreezer2.c\n to solve the corresponding question as described below.\n\n\nTo compile and run the given tests with the sample inputs and outputs, run on the command line,\n\n\n\n\n1\nmake\n\n\n\n\n\n\nThis will compile both C files and if there is no error, run the test scripts.\n\n\nSubmission\n\n\nWhen you are ready, run the following command while you are in the exercise directory:\n\n\n1\n~cs1010/submit-ex01\n\n\n\n\n\n\nThe files \nfreezer1.c\n and \nfreezer2.c\n will be uploaded to GitHub.  You can submit multiple times.\n\n\nGrading\n\n\nThis assignment is not graded.\n\n\n\n\nQuestion 1: Freezer\n\n\n(a)\n\n\nWrite a program \nfreezer1\n (source file \nfreezer1.c\n) that estimates the temperature (in degree Celsius) in a freezer given the elapsed time (in hours) since a power failure.\n\n\nAssume this temperature \nT\nT\n is given by\n1\n:\n\n\n\n\n\nT = \\frac{4t^2}{t + 2} - 20;\n\n\n\n\nT = \\frac{4t^2}{t + 2} - 20;\n\n\n\n\n\nwhere \nt\nt\n is the time (in hours) since the power failure.\n\n\nYour program reads in an integer: the number of hours since the start of the power failure.\n\n\nSample run:\n\n\n1\n2\n3\n4\n5\n6\nooiwt@pe111:~/ex01-ooiwt$ ./freezer1\n0\n-20.0000\nooiwt@pe111:~/ex01-ooiwt$ ./freezer1\n1\n-18.6667\n\n\n\n\n\n\nThe text \nooiwt@pe111:~/ex01-ooiwt$\n is the command prompt.  Yours will look different, of course.  \nfreezer1\n is the executable you created.  The next line, \n0\n, is the input you provide.  Press enter after the input.  \n-20.0000\n is the output printed by \nfreezer1\n.\n\n\n(b)\n\n\nfreezer1\n is rather restrictive, as we can only calculate the temperature after one hour, two hours, etc.  The equation given above works for fractional hours as well.  Modify your program, call it \nfreezer2\n (source file \nfreezer2.c\n), so that it now reads in two integers: the number of hours and the number of additional minutes since the start of the power failure.  For example, to calculate the temperature after 2 hours and 45 minutes of power failure:\n\n\n1\n2\n3\nooiwt@pe111:~/ex01-ooiwt$ ./freezer2\n2 45\n-13.6316\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nI do not know where this formula comes from or if it is correct.  Please ignore the fact that, according to this formula, 32 hours after the power is turned off, the freezer will reach the boiling point of 100 Celsius!\u00a0\n\u21a9",
            "title": "1. Freezer"
        },
        {
            "location": "/ex01/index.html#exercise-1-freezer",
            "text": "This is your first programming exercise.  An exercise is something that you do on your own.  You can submit them but it will not be graded.   Test cases are provided for the exercises so that you can test and check on your own if your code is correct.  This is in contrast to an assignment, where you need to submit for grading and for credits.",
            "title": "Exercise 1: Freezer"
        },
        {
            "location": "/ex01/index.html#prerequisite",
            "text": "You are able to access the  CS1010 programming environment .  You are familiar with  basic UNIX CLI  and using terminal-based editor  vim .",
            "title": "Prerequisite"
        },
        {
            "location": "/ex01/index.html#learning-outcomes",
            "text": "Be comfortable writing simple C programs that involves arithmetic operations,  long  and  double  types.",
            "title": "Learning Outcomes"
        },
        {
            "location": "/ex01/index.html#one-time-setup",
            "text": "Before going into their first programming exercise, you need to do a one time setup of your account on PE. You need to create a file called  .gitconfig  in your home directory and with the following content:  1\n2\n3\n4\n5 [user]\n  name = Your Name\n  email = Your Email\n[github]  \n  user = Your GitHub ID   Your email should be whatever you used to sign up Github.  For example, a sample  .gitconfig  looks like this:  1\n2\n3\n4\n5 [user]\n  name = Jon Snow\n  email = king@north.gov\n[github]  \n  user = jonsnow   After saving this file, run:  1 git config --get github.user   It should return your GitHub user id.  It should print your GitHub user id as set.  If there is a typo, you need to edit  .gitconfig  again and reload it by repeating the command above.",
            "title": "One-Time Setup"
        },
        {
            "location": "/ex01/index.html#setup",
            "text": "Click on  this link  to accept the exercise.  Login to one of the hosts of  CS1010 programming environment (PE)  Run the following on the command line on one of the PE hosts:   1 ~cs1010/get-ex01    You should see a new subdirectory  ex01-<githubid>  in your current working directory, where  githubid  is your GitHub ID.   We will call this directory your  exercise directory  or  assignment directory .    Inside that directory, you should see a bunch of files:   freezer1.c  and  freezer2.c  are the most important files.  They are the skeleton C code that you should edit to solve the exercise.  inputs  and  outputs  are sub directories that contain test inputs and test outputs.  We use the convention  problem-name . test-id .in for input test data, and  problem-name . test-id .out for output test data.  So, you will see  freezer1.1.in ,  freezer1.1.out , etc.  The expected output for  freezer1.1.in  is in  freezer1.1.out .  You can look at the content of these files if you wish (which  UNIX  command should you use to do this?).  You can edit these files to change the test input and output.  Makefile : This is the configuration for the tool  make  that we use to automate the compilation and testing of the programs.  You do not have to understand how to write a  Makefile  for CS1010.  If you are interested to learn how to write a  Makefile , talk to either Wei Tsang or Google.  test.sh : This is a bash script for testing your code.  You do not have to edit this file nor call it directly.  It is called by  make .  If you are interested to learn how to write bash script, talk to either Wei Tsang or Google.",
            "title": "Setup"
        },
        {
            "location": "/ex01/index.html#identifying-yourself",
            "text": "In every C file that you submit to CS1010, you need to identify yourself by writing your name and tutorial group.  Marks will be deducted if you fail to do so.  You need to edit the line:  1 @author XXXX (Group YYYY)   and change it to something like:  1 @author Jon Snow (Group 10)",
            "title": "Identifying Yourself"
        },
        {
            "location": "/ex01/index.html#solving-the-assignments",
            "text": "Edit the files  freezer1.c  and  freezer2.c  to solve the corresponding question as described below.  To compile and run the given tests with the sample inputs and outputs, run on the command line,   1 make   This will compile both C files and if there is no error, run the test scripts.",
            "title": "Solving The Assignments"
        },
        {
            "location": "/ex01/index.html#submission",
            "text": "When you are ready, run the following command while you are in the exercise directory:  1 ~cs1010/submit-ex01   The files  freezer1.c  and  freezer2.c  will be uploaded to GitHub.  You can submit multiple times.",
            "title": "Submission"
        },
        {
            "location": "/ex01/index.html#grading",
            "text": "This assignment is not graded.",
            "title": "Grading"
        },
        {
            "location": "/ex01/index.html#question-1-freezer",
            "text": "",
            "title": "Question 1: Freezer"
        },
        {
            "location": "/ex01/index.html#a",
            "text": "Write a program  freezer1  (source file  freezer1.c ) that estimates the temperature (in degree Celsius) in a freezer given the elapsed time (in hours) since a power failure.  Assume this temperature  T T  is given by 1 :   \nT = \\frac{4t^2}{t + 2} - 20;  \nT = \\frac{4t^2}{t + 2} - 20;   where  t t  is the time (in hours) since the power failure.  Your program reads in an integer: the number of hours since the start of the power failure.",
            "title": "(a)"
        },
        {
            "location": "/ex01/index.html#sample-run",
            "text": "1\n2\n3\n4\n5\n6 ooiwt@pe111:~/ex01-ooiwt$ ./freezer1\n0\n-20.0000\nooiwt@pe111:~/ex01-ooiwt$ ./freezer1\n1\n-18.6667   The text  ooiwt@pe111:~/ex01-ooiwt$  is the command prompt.  Yours will look different, of course.   freezer1  is the executable you created.  The next line,  0 , is the input you provide.  Press enter after the input.   -20.0000  is the output printed by  freezer1 .",
            "title": "Sample run:"
        },
        {
            "location": "/ex01/index.html#b",
            "text": "freezer1  is rather restrictive, as we can only calculate the temperature after one hour, two hours, etc.  The equation given above works for fractional hours as well.  Modify your program, call it  freezer2  (source file  freezer2.c ), so that it now reads in two integers: the number of hours and the number of additional minutes since the start of the power failure.  For example, to calculate the temperature after 2 hours and 45 minutes of power failure:  1\n2\n3 ooiwt@pe111:~/ex01-ooiwt$ ./freezer2\n2 45\n-13.6316       I do not know where this formula comes from or if it is correct.  Please ignore the fact that, according to this formula, 32 hours after the power is turned off, the freezer will reach the boiling point of 100 Celsius!\u00a0 \u21a9",
            "title": "(b)"
        },
        {
            "location": "/ex02/index.html",
            "text": "Exercise 2: Leap, Suffix, Days\n\n\nThis is a programming exercise for you to solve on your own.  You can submit but it will not be graded.  Test cases are provided for the exercises so that you can test and check on your own if your code is correct.  Feel free to discuss your solution with your peers or your TAs.\n\n\nPrerequisite\n\n\n\n\nYou are able to access the \nCS1010 programming environment\n.\n\n\nYou are familiar with \nbasic UNIX CLI\n and using terminal-based editor \nvim\n.\n\n\nYou have a GitHub account and have setup \n.gitconfig\n (see \nExercise 1\n).\n\n\n\n\nLearning Outcomes\n\n\n\n\nBe comfortable writing correct C programs that involve \nif\n, \nelse\n, and logical statements.\n\n\n\n\nSetup\n\n\n\n\nClick on \nthis link\n to accept the exercise.\n\n\nLog in to one of the hosts of \nCS1010 programming environment (PE)\n\n\nRun the following on the command line on one of the PE hosts:\n\n\n\n\n1\n~cs1010/get-ex02\n\n\n\n\n\n\n\n\nYou should see a new subdirectory \nex02-<githubid>\n in your current working directory, where \ngithubid\n is your GitHub ID.\n\n\nInside that directory, you should see a bunch of files:\n\n\nleap.c\n, \nsuffix.c\n, and \ndays.c\n are the most important files.  They are the skeleton C code that you should edit to solve the exercise.\n\n\ninputs\n and \noutputs\n are subdirectories that contain test inputs and test outputs.  We use the same convention as Exercise 1 so you should be familiar with them.\n\n\nMakefile\n: This is the configuration for the tool \nmake\n that we use to automate the compilation and testing of the programs.  \n\n\ntest.sh\n: This is a bash script for testing your code.\n\n\n\n\n\n\n\n\nSolving The Assignments\n\n\n\n\nEdit the .c files to solve the corresponding question as described below\n\n\nYou can assume that all test inputs are valid inputs.\n\n\nTo compile and run the given tests with the sample inputs and outputs, run on the command line,\n\n\n\n\n1\nmake\n\n\n\n\n\n\nThis will compile all your C files and if there is no error, run the test scripts.\n\n\nSubmission\n\n\nWhen you are ready, run the following command while you are in the exercise directory:\n\n\n1\n~cs1010/submit-ex02\n\n\n\n\n\n\nThe .c files will be uploaded to GitHub.  You can submit multiple times.  As an exercise is not graded, submitting your code only serves the purpose of archiving your work for backup purposes.\n\n\n\n\nQuestion 1: Leap Year\n\n\nA \nleap year\n is a calendar year containing an extra day to synchronize the calendar to seasons and astronomical events.  In the Gregorian calendar, years that are multiples of four (with the exception of years divisible by 100 but not by 400) are leap years.\n\n\nWrite a program that reads in an integer representing a year from the standard input and prints out \"\n is a leap year\" if the input is a leap year.  Otherwise, print \"\n is not a leap year\" to the standard output.\n\n\nYour program should include a \nbool\n function \nis_leap_year\n that takes in the input year and returns \ntrue\n if the input is a leap year and returns \nfalse\n otherwise.\n\n\nSample run:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\nooiwt@pe112:~/ex02-ooiwt$ ./leap\n1995\n1995 is not a leap year\nooiwt@pe112:~/ex02-ooiwt$ ./leap\n1996\n1996 is a leap year\nooiwt@pe112:~/ex02-ooiwt$ ./leap\n1900\n1900 is not a leap year\nooiwt@pe112:~/ex02-ooiwt$ ./leap\n2000\n2000 is a leap year\n\n\n\n\n\n\nQuestion 2: Ordinal Suffix\n\n\nIn English, an ordinal number is written with numerals, followed by its letter suffixes.  For instance: 1\nst\n, 2\nnd\n, 3\nrd\n, 4\nth\n, 11\nth\n, 31\nst\n, etc.  The rule is that, a number that ends with digit 1 should have a suffix \"st\" (except if it ends with 11), a number that ends with 2 should have a suffix \"nd\" (except if it ends with 12), and a number that ends with 3 should have a suffix \"rd\" (except if it ends with 13).  All other numbers should end with \"th\".\n\n\nWrite a program \nsuffix\n that reads in an integer number from the standard input and prints out the number with its ordinal suffix.\n\n\nYour program should include a \nvoid\n function \nprint_with_suffix(long n)\n that takes in the input and prints out the number followed by its suffix.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\nooiwt@pe112:~/ex02-ooiwt$ ./suffix\n2\n2nd\nooiwt@pe112:~/ex02-ooiwt$ ./suffix\n13\n13th\nooiwt@pe112:~/ex02-ooiwt$ ./suffix\n412\n412th\nooiwt@pe112:~/ex02-ooiwt$ ./suffix\n3\n3rd\n\n\n\n\n\n\nQuestion 3: Days Since 1 January\n\n\nWrite a program called \ndays\n that reads in two integers from the standard input, the first is the month (ranged 1 to 12, inclusive) and the second is the day (ranged 1 to 31, inclusive).  The program should print to the standard output which day of the year it is.  \nAssume that the year is not a leap year\n.  You can reuse the method \nprint_suffix\n from the previous question.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nooiwt@pe112:~/ex02-ooiwt$ ./days\n1 1\n1st\nooiwt@pe112:~/ex02-ooiwt$ ./days\n8 15\n227th\nooiwt@pe112:~/ex02-ooiwt$ ./days\n12 31\n365th",
            "title": "2. Leap, Suffix, Days"
        },
        {
            "location": "/ex02/index.html#exercise-2-leap-suffix-days",
            "text": "This is a programming exercise for you to solve on your own.  You can submit but it will not be graded.  Test cases are provided for the exercises so that you can test and check on your own if your code is correct.  Feel free to discuss your solution with your peers or your TAs.",
            "title": "Exercise 2: Leap, Suffix, Days"
        },
        {
            "location": "/ex02/index.html#prerequisite",
            "text": "You are able to access the  CS1010 programming environment .  You are familiar with  basic UNIX CLI  and using terminal-based editor  vim .  You have a GitHub account and have setup  .gitconfig  (see  Exercise 1 ).",
            "title": "Prerequisite"
        },
        {
            "location": "/ex02/index.html#learning-outcomes",
            "text": "Be comfortable writing correct C programs that involve  if ,  else , and logical statements.",
            "title": "Learning Outcomes"
        },
        {
            "location": "/ex02/index.html#setup",
            "text": "Click on  this link  to accept the exercise.  Log in to one of the hosts of  CS1010 programming environment (PE)  Run the following on the command line on one of the PE hosts:   1 ~cs1010/get-ex02    You should see a new subdirectory  ex02-<githubid>  in your current working directory, where  githubid  is your GitHub ID.  Inside that directory, you should see a bunch of files:  leap.c ,  suffix.c , and  days.c  are the most important files.  They are the skeleton C code that you should edit to solve the exercise.  inputs  and  outputs  are subdirectories that contain test inputs and test outputs.  We use the same convention as Exercise 1 so you should be familiar with them.  Makefile : This is the configuration for the tool  make  that we use to automate the compilation and testing of the programs.    test.sh : This is a bash script for testing your code.",
            "title": "Setup"
        },
        {
            "location": "/ex02/index.html#solving-the-assignments",
            "text": "Edit the .c files to solve the corresponding question as described below  You can assume that all test inputs are valid inputs.  To compile and run the given tests with the sample inputs and outputs, run on the command line,   1 make   This will compile all your C files and if there is no error, run the test scripts.",
            "title": "Solving The Assignments"
        },
        {
            "location": "/ex02/index.html#submission",
            "text": "When you are ready, run the following command while you are in the exercise directory:  1 ~cs1010/submit-ex02   The .c files will be uploaded to GitHub.  You can submit multiple times.  As an exercise is not graded, submitting your code only serves the purpose of archiving your work for backup purposes.",
            "title": "Submission"
        },
        {
            "location": "/ex02/index.html#question-1-leap-year",
            "text": "A  leap year  is a calendar year containing an extra day to synchronize the calendar to seasons and astronomical events.  In the Gregorian calendar, years that are multiples of four (with the exception of years divisible by 100 but not by 400) are leap years.  Write a program that reads in an integer representing a year from the standard input and prints out \"  is a leap year\" if the input is a leap year.  Otherwise, print \"  is not a leap year\" to the standard output.  Your program should include a  bool  function  is_leap_year  that takes in the input year and returns  true  if the input is a leap year and returns  false  otherwise.",
            "title": "Question 1: Leap Year"
        },
        {
            "location": "/ex02/index.html#sample-run",
            "text": "1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12 ooiwt@pe112:~/ex02-ooiwt$ ./leap\n1995\n1995 is not a leap year\nooiwt@pe112:~/ex02-ooiwt$ ./leap\n1996\n1996 is a leap year\nooiwt@pe112:~/ex02-ooiwt$ ./leap\n1900\n1900 is not a leap year\nooiwt@pe112:~/ex02-ooiwt$ ./leap\n2000\n2000 is a leap year",
            "title": "Sample run:"
        },
        {
            "location": "/ex02/index.html#question-2-ordinal-suffix",
            "text": "In English, an ordinal number is written with numerals, followed by its letter suffixes.  For instance: 1 st , 2 nd , 3 rd , 4 th , 11 th , 31 st , etc.  The rule is that, a number that ends with digit 1 should have a suffix \"st\" (except if it ends with 11), a number that ends with 2 should have a suffix \"nd\" (except if it ends with 12), and a number that ends with 3 should have a suffix \"rd\" (except if it ends with 13).  All other numbers should end with \"th\".  Write a program  suffix  that reads in an integer number from the standard input and prints out the number with its ordinal suffix.  Your program should include a  void  function  print_with_suffix(long n)  that takes in the input and prints out the number followed by its suffix.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12 ooiwt@pe112:~/ex02-ooiwt$ ./suffix\n2\n2nd\nooiwt@pe112:~/ex02-ooiwt$ ./suffix\n13\n13th\nooiwt@pe112:~/ex02-ooiwt$ ./suffix\n412\n412th\nooiwt@pe112:~/ex02-ooiwt$ ./suffix\n3\n3rd",
            "title": "Question 2: Ordinal Suffix"
        },
        {
            "location": "/ex02/index.html#question-3-days-since-1-january",
            "text": "Write a program called  days  that reads in two integers from the standard input, the first is the month (ranged 1 to 12, inclusive) and the second is the day (ranged 1 to 31, inclusive).  The program should print to the standard output which day of the year it is.   Assume that the year is not a leap year .  You can reuse the method  print_suffix  from the previous question.  1\n2\n3\n4\n5\n6\n7\n8\n9 ooiwt@pe112:~/ex02-ooiwt$ ./days\n1 1\n1st\nooiwt@pe112:~/ex02-ooiwt$ ./days\n8 15\n227th\nooiwt@pe112:~/ex02-ooiwt$ ./days\n12 31\n365th",
            "title": "Question 3: Days Since 1 January"
        },
        {
            "location": "/ex03/index.html",
            "text": "Exercise 3: Binary, Rectangle, Fibonacci, Prime\n\n\nThis is a programming exercise for you to solve on your own.  You can submit but it will not be graded.  Test cases are provided for the exercises so that you can test and check on your own if your code is correct.  Feel free to discuss your solution with your peers or your TAs.\n\n\nPrerequisite\n\n\n\n\nYou are able to access the \nCS1010 programming environment\n.\n\n\nYou are familiar with \nbasic UNIX CLI\n and using terminal-based editor \nvim\n.\n\n\nYou have a GitHub account and have setup \n.gitconfig\n (see \nExercise 1\n).\n\n\n\n\nLearning Outcomes\n\n\n\n\nBe comfortable writing correct C programs that involve \nif\n, \nelse\n, loops, and logical statements.\n\n\nBe able to decompose a more complex problem into smaller subproblems and write functions to solve the sub-problems.\n\n\n\n\nSetup\n\n\n\n\nClick on \nthis link\n to accept the exercise.\n\n\nLog in to one of the hosts of \nCS1010 programming environment (PE)\n\n\nRun the following on the command line on one of the PE hosts:\n\n\n\n\n1\n~cs1010/get-ex03\n\n\n\n\n\n\n\n\nYou should see a new subdirectory \nex03-<githubid>\n in your current working directory, where \ngithubid\n is your GitHub ID.\n\n\nInside that directory, you should see a bunch of files:\n\n\nbinary.c\n, \nrectangle.c\n, \nprime.c\n and \nfibonacci.c\n are the most important files.  They are the skeleton C code that you should edit to solve the exercise.\n\n\ninputs\n and \noutputs\n are subdirectories that contain test inputs and test outputs.  We use the same convention as Exercise 1 so you should be familiar with them.\n\n\nMakefile\n: This is the configuration for the tool \nmake\n that we use to automate the compilation and testing of the programs.  \n\n\ntest.sh\n: This is a bash script for testing your code.\n\n\n\n\n\n\n\n\nSolving The Assignments\n\n\n\n\nEdit the .c files on the PE hosts to solve the corresponding question as described below.\n\n\nYou can assume that all test inputs are valid inputs.\n\n\nTo compile and run the given tests with the sample inputs and outputs, run on the command line,\n\n\n\n\n1\nmake\n\n\n\n\n\n\nThis will compile all your C files and if there is no error, run the test scripts.\n\n\nSubmission\n\n\nWhen you are ready, run the following command while you are in the exercise directory:\n\n\n1\n~cs1010/submit-ex03\n\n\n\n\n\n\nThe .c files will be uploaded to GitHub.  You can submit multiple times.  As an exercise is not graded, submitting your code only serves the purpose of archiving your work for backup purposes.\n\n\n\n\nQuestion 1: Binary\n\n\nIn this question, you are asked to convert a number represented in binary format (using digits 0 and 1) into the decimal format (using digits 0 and 9).  A number in decimal format is represented with based 10.  The last digit (rightmost) corresponds to the unit of \n10^0 = 1\n10^0 = 1\n, the next digit (second last) corresponds to the unit of \n10^1 = 10\n10^1 = 10\n, and so on.  So, one can write the decimal number, for instance, 7146 as \n\n7 \\times 10^3 + 1 \\times 10^2 + 4 \\times 10^1 + 6 \\times 10^0\n7 \\times 10^3 + 1 \\times 10^2 + 4 \\times 10^1 + 6 \\times 10^0\n.\n\n\nA number represented in binary uses base 2 instead of base 10.  The last digit corresponds to \n2^0 = 1\n2^0 = 1\n.  The second last digit correponds to \n2^1 = 2\n2^1 = 2\n, the third last digit corresponds to \n2^2 = 4\n2^2 = 4\n, and so on.  So, the binary number 1101, for instance, corresponds to \n1 \\times 2^3 + 1 \\times 2^2 + 1 \\times 2^0 = 13\n1 \\times 2^3 + 1 \\times 2^2 + 1 \\times 2^0 = 13\n.\n\n\nWrite a program called \nbinary\n that reads in a positive integer consists of only 0s and 1s from the standard input, treats it as a binary number, and prints the corresponding decimal number to the standard output.\n\n\nSample run:\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nooiwt@pe113:~/ex03-ooiwt$ ./binary\n1101\n13\nooiwt@pe113:~/ex03-ooiwt$ ./binary\n111\n7\nooiwt@pe113:~/ex03-ooiwt$ ./binary\n10110100\n180\n\n\n\n\n\n\nQuestion 2: Rectangle\n\n\nWrite a program called \nrectangle\n that reads two positive integers from the standard input, corresponding to the width and the height of the rectangle.  The width and height must be at least 2.  Draw a rectangle on the screen using the special ASCII characters #define \"\u2554\" \"\u2557\" \"\u255d\" \"\u255a\" \"\u2550\" \"\u2551\", which corresponds to the top left, top right, bottom right, bottom left, top/bottom edge, and left/right edge of the rectangle respectively.   Strings consisting of these special characters have been given to you in \nrectangle.c\n and we have defined them as constants.   For instance, \"\u2554\" is called \nTOP_LEFT\n, and to print this out, you can write\n\n1\ncs1010_print_string\n(\nTOP_LEFT\n);\n\n\n\n\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\nooiwt@pe113:~/ex03-ooiwt$ ./rectangle\n2 2\n\u2554\u2557\n\u255a\u255d\nooiwt@pe113:~/ex03-ooiwt$ ./rectangle\n2 10\n\u2554\u2557\n\u2551\u2551\n\u2551\u2551\n\u2551\u2551\n\u2551\u2551\n\u2551\u2551\n\u2551\u2551\n\u2551\u2551\n\u2551\u2551\n\u255a\u255d\nooiwt@pe113:~/ex03-ooiwt$ ./rectangle\n10 10\n\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n\u2551        \u2551\n\u2551        \u2551\n\u2551        \u2551\n\u2551        \u2551\n\u2551        \u2551\n\u2551        \u2551\n\u2551        \u2551\n\u2551        \u2551\n\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n\n\n\n\n\n\nQuestion 3: Fibonacci\n\n\nThe Fibonacci sequence is a sequence of numbers 1, 1, 2, 3, 5, 8, 13, ... Fibonacci numbers often appear in mathematics as well as in nature and have \nmany fascinating properties\n. \n\n\nThe Fibonacci sequence can be constructed as follows.  The first Fibonacci number is 1.  The second Fibonacci number is also 1.  Subsequently, the i-th Fibonacci number is computed as the sum of the previous two Fibonacci numbers, the (i-2)-th, and the (i-1)-th.\n\n\nWrite a program called \nfibonacci\n that reads a positive integer number \nn\n from the standard input, and print the \nn\n-th Fibonacci number to the standard output.  Your program must not use recursion.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nooiwt@pe113:~/ex03-ooiwt$ ./fibonacci\n1\n1\nooiwt@pe113:~/ex03-ooiwt$ ./fibonacci\n10\n55\nooiwt@pe113:~/ex03-ooiwt$ ./fibonacci\n83\n99194853094755497\n\n\n\n\n\n\nQuestion 4: Prime\n\n\nWrite a program called \nprime\n that reads a positive integer \nn\n from the standard input and either prints \nprime\n if \nn\n is a prime number, or prints \nnot prime\n if \nn\n is not a prime number.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nooiwt@pe113:~/ex03-ooiwt$ ./prime\n2\nprime\nooiwt@pe113:~/ex03-ooiwt$ ./prime\n14000605\nnot prime\nooiwt@pe113:~/ex03-ooiwt$ ./prime\n99194853094755497\nprime\n\n\n\n\n\n\nBonus: UNIX Pipe\n\n\nIf you look at the output from the last \nfibonacci\n example and the input to the last \nprime\n example, you will see that they are the same number.  This means that the 83\nrd\n Fibonacci number is prime!  \n\n\nSuppose now you want to ask, is the 13\nth\n Fibonacci number a prime?  How can we use the programs that we have wrote to do this?  There are several ways\n\n\n\n\nYou can merge the two C files to create a new program that, given \nn\n, calculate the \nn\n-th Fibonacci number, then check if it is prime.\n\n\nYou can reuse the two programs you have already written.  First, run \nfibonacci\n with input 13, then cut-and-paste the output as input to \nprime\n.\n\n\n\n\nA better alternative is to use a \n|\n in a UNIX-based system.  A \n|\n, called a \npipe\n, basically interconnects the standard output of one command to the standard input of the second command.  Consider the following:\n\n\n1\nooiwt@pe113:~/ex03-ooiwt$ a | b\n\n\n\n\n\n\nWhatever the program \na\n prints to the standard output, will be read by the program \nb\n when it reads from the standard input.  You have seen how the standard input can refer to a keyboard or a file, now you have seen how the standard input can also be another program!\n\n\nBack to the original problem: how to check if the 83\nrd\n Fibonnacci number is prime?  You can run:\n\n1\n2\n3\nooiwt@pe113:~/ex03-ooiwt$ ./fibonacci | ./prime\n83\nprime",
            "title": "3. Binary, Rectangle, Fibonacci, Prime"
        },
        {
            "location": "/ex03/index.html#exercise-3-binary-rectangle-fibonacci-prime",
            "text": "This is a programming exercise for you to solve on your own.  You can submit but it will not be graded.  Test cases are provided for the exercises so that you can test and check on your own if your code is correct.  Feel free to discuss your solution with your peers or your TAs.",
            "title": "Exercise 3: Binary, Rectangle, Fibonacci, Prime"
        },
        {
            "location": "/ex03/index.html#prerequisite",
            "text": "You are able to access the  CS1010 programming environment .  You are familiar with  basic UNIX CLI  and using terminal-based editor  vim .  You have a GitHub account and have setup  .gitconfig  (see  Exercise 1 ).",
            "title": "Prerequisite"
        },
        {
            "location": "/ex03/index.html#learning-outcomes",
            "text": "Be comfortable writing correct C programs that involve  if ,  else , loops, and logical statements.  Be able to decompose a more complex problem into smaller subproblems and write functions to solve the sub-problems.",
            "title": "Learning Outcomes"
        },
        {
            "location": "/ex03/index.html#setup",
            "text": "Click on  this link  to accept the exercise.  Log in to one of the hosts of  CS1010 programming environment (PE)  Run the following on the command line on one of the PE hosts:   1 ~cs1010/get-ex03    You should see a new subdirectory  ex03-<githubid>  in your current working directory, where  githubid  is your GitHub ID.  Inside that directory, you should see a bunch of files:  binary.c ,  rectangle.c ,  prime.c  and  fibonacci.c  are the most important files.  They are the skeleton C code that you should edit to solve the exercise.  inputs  and  outputs  are subdirectories that contain test inputs and test outputs.  We use the same convention as Exercise 1 so you should be familiar with them.  Makefile : This is the configuration for the tool  make  that we use to automate the compilation and testing of the programs.    test.sh : This is a bash script for testing your code.",
            "title": "Setup"
        },
        {
            "location": "/ex03/index.html#solving-the-assignments",
            "text": "Edit the .c files on the PE hosts to solve the corresponding question as described below.  You can assume that all test inputs are valid inputs.  To compile and run the given tests with the sample inputs and outputs, run on the command line,   1 make   This will compile all your C files and if there is no error, run the test scripts.",
            "title": "Solving The Assignments"
        },
        {
            "location": "/ex03/index.html#submission",
            "text": "When you are ready, run the following command while you are in the exercise directory:  1 ~cs1010/submit-ex03   The .c files will be uploaded to GitHub.  You can submit multiple times.  As an exercise is not graded, submitting your code only serves the purpose of archiving your work for backup purposes.",
            "title": "Submission"
        },
        {
            "location": "/ex03/index.html#question-1-binary",
            "text": "In this question, you are asked to convert a number represented in binary format (using digits 0 and 1) into the decimal format (using digits 0 and 9).  A number in decimal format is represented with based 10.  The last digit (rightmost) corresponds to the unit of  10^0 = 1 10^0 = 1 , the next digit (second last) corresponds to the unit of  10^1 = 10 10^1 = 10 , and so on.  So, one can write the decimal number, for instance, 7146 as  7 \\times 10^3 + 1 \\times 10^2 + 4 \\times 10^1 + 6 \\times 10^0 7 \\times 10^3 + 1 \\times 10^2 + 4 \\times 10^1 + 6 \\times 10^0 .  A number represented in binary uses base 2 instead of base 10.  The last digit corresponds to  2^0 = 1 2^0 = 1 .  The second last digit correponds to  2^1 = 2 2^1 = 2 , the third last digit corresponds to  2^2 = 4 2^2 = 4 , and so on.  So, the binary number 1101, for instance, corresponds to  1 \\times 2^3 + 1 \\times 2^2 + 1 \\times 2^0 = 13 1 \\times 2^3 + 1 \\times 2^2 + 1 \\times 2^0 = 13 .  Write a program called  binary  that reads in a positive integer consists of only 0s and 1s from the standard input, treats it as a binary number, and prints the corresponding decimal number to the standard output.",
            "title": "Question 1: Binary"
        },
        {
            "location": "/ex03/index.html#sample-run",
            "text": "1\n2\n3\n4\n5\n6\n7\n8\n9 ooiwt@pe113:~/ex03-ooiwt$ ./binary\n1101\n13\nooiwt@pe113:~/ex03-ooiwt$ ./binary\n111\n7\nooiwt@pe113:~/ex03-ooiwt$ ./binary\n10110100\n180",
            "title": "Sample run:"
        },
        {
            "location": "/ex03/index.html#question-2-rectangle",
            "text": "Write a program called  rectangle  that reads two positive integers from the standard input, corresponding to the width and the height of the rectangle.  The width and height must be at least 2.  Draw a rectangle on the screen using the special ASCII characters #define \"\u2554\" \"\u2557\" \"\u255d\" \"\u255a\" \"\u2550\" \"\u2551\", which corresponds to the top left, top right, bottom right, bottom left, top/bottom edge, and left/right edge of the rectangle respectively.   Strings consisting of these special characters have been given to you in  rectangle.c  and we have defined them as constants.   For instance, \"\u2554\" is called  TOP_LEFT , and to print this out, you can write 1 cs1010_print_string ( TOP_LEFT );     1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28 ooiwt@pe113:~/ex03-ooiwt$ ./rectangle\n2 2\n\u2554\u2557\n\u255a\u255d\nooiwt@pe113:~/ex03-ooiwt$ ./rectangle\n2 10\n\u2554\u2557\n\u2551\u2551\n\u2551\u2551\n\u2551\u2551\n\u2551\u2551\n\u2551\u2551\n\u2551\u2551\n\u2551\u2551\n\u2551\u2551\n\u255a\u255d\nooiwt@pe113:~/ex03-ooiwt$ ./rectangle\n10 10\n\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n\u2551        \u2551\n\u2551        \u2551\n\u2551        \u2551\n\u2551        \u2551\n\u2551        \u2551\n\u2551        \u2551\n\u2551        \u2551\n\u2551        \u2551\n\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d",
            "title": "Question 2: Rectangle"
        },
        {
            "location": "/ex03/index.html#question-3-fibonacci",
            "text": "The Fibonacci sequence is a sequence of numbers 1, 1, 2, 3, 5, 8, 13, ... Fibonacci numbers often appear in mathematics as well as in nature and have  many fascinating properties .   The Fibonacci sequence can be constructed as follows.  The first Fibonacci number is 1.  The second Fibonacci number is also 1.  Subsequently, the i-th Fibonacci number is computed as the sum of the previous two Fibonacci numbers, the (i-2)-th, and the (i-1)-th.  Write a program called  fibonacci  that reads a positive integer number  n  from the standard input, and print the  n -th Fibonacci number to the standard output.  Your program must not use recursion.  1\n2\n3\n4\n5\n6\n7\n8\n9 ooiwt@pe113:~/ex03-ooiwt$ ./fibonacci\n1\n1\nooiwt@pe113:~/ex03-ooiwt$ ./fibonacci\n10\n55\nooiwt@pe113:~/ex03-ooiwt$ ./fibonacci\n83\n99194853094755497",
            "title": "Question 3: Fibonacci"
        },
        {
            "location": "/ex03/index.html#question-4-prime",
            "text": "Write a program called  prime  that reads a positive integer  n  from the standard input and either prints  prime  if  n  is a prime number, or prints  not prime  if  n  is not a prime number.  1\n2\n3\n4\n5\n6\n7\n8\n9 ooiwt@pe113:~/ex03-ooiwt$ ./prime\n2\nprime\nooiwt@pe113:~/ex03-ooiwt$ ./prime\n14000605\nnot prime\nooiwt@pe113:~/ex03-ooiwt$ ./prime\n99194853094755497\nprime",
            "title": "Question 4: Prime"
        },
        {
            "location": "/ex03/index.html#bonus-unix-pipe",
            "text": "If you look at the output from the last  fibonacci  example and the input to the last  prime  example, you will see that they are the same number.  This means that the 83 rd  Fibonacci number is prime!    Suppose now you want to ask, is the 13 th  Fibonacci number a prime?  How can we use the programs that we have wrote to do this?  There are several ways   You can merge the two C files to create a new program that, given  n , calculate the  n -th Fibonacci number, then check if it is prime.  You can reuse the two programs you have already written.  First, run  fibonacci  with input 13, then cut-and-paste the output as input to  prime .   A better alternative is to use a  |  in a UNIX-based system.  A  | , called a  pipe , basically interconnects the standard output of one command to the standard input of the second command.  Consider the following:  1 ooiwt@pe113:~/ex03-ooiwt$ a | b   Whatever the program  a  prints to the standard output, will be read by the program  b  when it reads from the standard input.  You have seen how the standard input can refer to a keyboard or a file, now you have seen how the standard input can also be another program!  Back to the original problem: how to check if the 83 rd  Fibonnacci number is prime?  You can run: 1\n2\n3 ooiwt@pe113:~/ex03-ooiwt$ ./fibonacci | ./prime\n83\nprime",
            "title": "Bonus: UNIX Pipe"
        },
        {
            "location": "/assignment/index.html",
            "text": "Guide to Programming Assignments\n\n\nTimeline\n\n\nThere will be weekly take-home programming assignments, each consisting of 2 to 4 questions. \nThese programming assignments collectively contribute to 30% of your final grade.\n\n\nThe programming assignment is released on the CS1010 website every Friday, with a deadline given.  You must submit all questions for each particular programming assignment before the deadline.\n\n\nGeneral Advice\n\n\nYou are advised to (i) spend some time thinking before you begin coding, (ii) practice incremental coding and (iii) test your programs thoroughly.\n\n\nRemember to spend some time thinking about the algorithm for each question.  Write out the pseudo-code or draw out the flowchart on your own before you start typing in your program. \n\n\nIncremental coding means do NOT type in the whole long program in a single session and then compile it. Instead, type your program in bits and pieces and compile it incrementally. Try to maintain a compilable program even while you are working on it. Submitting a compilable program that partially works is better than submitting an un-compilable one; this is especially important for your practical exams. \n\n\nYou should test your program thoroughly with your own test data before submission.  \n\n\nPlease note that:\n\n\n\n\n\n\nYou may assume that all input data are correct unless otherwise stated. Hence you do NOT need to do input data validation. This is to allow you to focus on getting the program right, instead of worrying about making your program fool-proof which involves a lot more work. \n\n\n\n\n\n\nCopying others' programs or relying on others to help you with these assignments will only offer a short-term reprieve. When Practical Exam (PE) time comes, your inadequacy will be exposed and the consequence would be dire.\n\n\n\n\n\n\nLate Submission\n\n\nAll programming assignments must be submitted on time.  If you need an extension, please ask for one and provide a justification for approval.  Only academic reasons and compassionate reasons can be considered (e.g., representing NUS for a sports event is OK; Attending a wedding is not.)\n\n\nFor late submission, there is a 1% penalty (of the total awarded marks for that particular assignment) for every 5-minute after the deadline, capped at 80%.  For example, if an assignment is awarded 40 marks, and it is submitted 100 minutes after the deadline, the student will get 32 marks instead (20% penalty).  If it is submitted 10 hours after the deadline, the student will get 8 marks (as it has hit the cap of 80% penalty).\n\n\nMethod of Submission\n\n\nPlease follow the instructions provided in each programming assignment to submit the programs to GitHub.  Programs submitted through other means, such as emails, will NOT be accepted.\n\n\nIdentifying Yourself\n\n\nIn every C file that you submit to CS1010, you need to identify yourself by writing your name and tutorial group. Marks will be deducted if you fail to do so. You need to edit the line:\n\n\n1\n@author XXXX (Group YYYY)\n\n\n\n\n\n\nand change it to something like:\n\n\n1\n@author Gamora (Group 10)\n\n\n\n\n\n\nPlease follow the instructions provided in each programming assignment to submit the programs to GitHub.  Programs submitted through other means, such as emails, will NOT be accepted.\n\n\nGrading\n\n\nOnly the final submission of each exercise will be graded.  For each exercise, we will provide you will a limited set of test data.  During grading, we may grade your program with additional test data.\n\n\nEach programming assignment will be graded differently.  Generally, marks are given for attempt, correctness, design, and style, and documentation.  The weight of each one will be adjusted over the semester.  \n\n\nA program that cannot compile will receive 0 marks for correctness.\n\n\nFeedback will be provided by the graders on GitHub.\n\n\nUse of Piazza\n\n\nIf you have doubts about the problem statements of an assignment, you may raise them on Piazza.  But before that, please read through the problem statements carefully first, and check if the same questions have been asked and answered on the forum.\n\n\nPlease exercise discretion when posting to Piazza.  \n\n\nBefore the deadline, you are NOT to post the solution to the assignment, complete or partial, on Piazza (or any publicly accessible online site).\n\n\nDisallowed Syntax\n\n\nSome programming assignments may explicitly disallow the use of certain syntax. Generally, using syntax or statements which are not yet covered either in class or in the assignment statement is strongly discouraged.  We also discourage the use of certain syntax for this module, (e.g., \n++\n) you should not use them.  The assignments are designed such that you should not need to do so (even though doing so may result in your program being shorter or more efficient). If the objective of the assignment is undermined, the penalty for using such forbidden syntax will be heavy. If in doubt, please ask for clarification.\n\n\nPlagiarism\n\n\nYou are NOT to copy from others or allow others to copy your programs.  We take plagiarism seriously.  See \nour policies\n page for details.\n\n\nThis means that you should also guard your solution carefully, not posting them to publicly accessible places, or change the permissions of the files on the CS1010 PE hosts so that it is accessible by others.\n\n\n\n\nThis guideline is adapted from Aaron Tan's CS1010 guideline.",
            "title": "General Guide"
        },
        {
            "location": "/assignment/index.html#guide-to-programming-assignments",
            "text": "",
            "title": "Guide to Programming Assignments"
        },
        {
            "location": "/assignment/index.html#timeline",
            "text": "There will be weekly take-home programming assignments, each consisting of 2 to 4 questions. \nThese programming assignments collectively contribute to 30% of your final grade.  The programming assignment is released on the CS1010 website every Friday, with a deadline given.  You must submit all questions for each particular programming assignment before the deadline.",
            "title": "Timeline"
        },
        {
            "location": "/assignment/index.html#general-advice",
            "text": "You are advised to (i) spend some time thinking before you begin coding, (ii) practice incremental coding and (iii) test your programs thoroughly.  Remember to spend some time thinking about the algorithm for each question.  Write out the pseudo-code or draw out the flowchart on your own before you start typing in your program.   Incremental coding means do NOT type in the whole long program in a single session and then compile it. Instead, type your program in bits and pieces and compile it incrementally. Try to maintain a compilable program even while you are working on it. Submitting a compilable program that partially works is better than submitting an un-compilable one; this is especially important for your practical exams.   You should test your program thoroughly with your own test data before submission.    Please note that:    You may assume that all input data are correct unless otherwise stated. Hence you do NOT need to do input data validation. This is to allow you to focus on getting the program right, instead of worrying about making your program fool-proof which involves a lot more work.     Copying others' programs or relying on others to help you with these assignments will only offer a short-term reprieve. When Practical Exam (PE) time comes, your inadequacy will be exposed and the consequence would be dire.",
            "title": "General Advice"
        },
        {
            "location": "/assignment/index.html#late-submission",
            "text": "All programming assignments must be submitted on time.  If you need an extension, please ask for one and provide a justification for approval.  Only academic reasons and compassionate reasons can be considered (e.g., representing NUS for a sports event is OK; Attending a wedding is not.)  For late submission, there is a 1% penalty (of the total awarded marks for that particular assignment) for every 5-minute after the deadline, capped at 80%.  For example, if an assignment is awarded 40 marks, and it is submitted 100 minutes after the deadline, the student will get 32 marks instead (20% penalty).  If it is submitted 10 hours after the deadline, the student will get 8 marks (as it has hit the cap of 80% penalty).",
            "title": "Late Submission"
        },
        {
            "location": "/assignment/index.html#method-of-submission",
            "text": "Please follow the instructions provided in each programming assignment to submit the programs to GitHub.  Programs submitted through other means, such as emails, will NOT be accepted.",
            "title": "Method of Submission"
        },
        {
            "location": "/assignment/index.html#identifying-yourself",
            "text": "In every C file that you submit to CS1010, you need to identify yourself by writing your name and tutorial group. Marks will be deducted if you fail to do so. You need to edit the line:  1 @author XXXX (Group YYYY)   and change it to something like:  1 @author Gamora (Group 10)   Please follow the instructions provided in each programming assignment to submit the programs to GitHub.  Programs submitted through other means, such as emails, will NOT be accepted.",
            "title": "Identifying Yourself"
        },
        {
            "location": "/assignment/index.html#grading",
            "text": "Only the final submission of each exercise will be graded.  For each exercise, we will provide you will a limited set of test data.  During grading, we may grade your program with additional test data.  Each programming assignment will be graded differently.  Generally, marks are given for attempt, correctness, design, and style, and documentation.  The weight of each one will be adjusted over the semester.    A program that cannot compile will receive 0 marks for correctness.  Feedback will be provided by the graders on GitHub.",
            "title": "Grading"
        },
        {
            "location": "/assignment/index.html#use-of-piazza",
            "text": "If you have doubts about the problem statements of an assignment, you may raise them on Piazza.  But before that, please read through the problem statements carefully first, and check if the same questions have been asked and answered on the forum.  Please exercise discretion when posting to Piazza.    Before the deadline, you are NOT to post the solution to the assignment, complete or partial, on Piazza (or any publicly accessible online site).",
            "title": "Use of Piazza"
        },
        {
            "location": "/assignment/index.html#disallowed-syntax",
            "text": "Some programming assignments may explicitly disallow the use of certain syntax. Generally, using syntax or statements which are not yet covered either in class or in the assignment statement is strongly discouraged.  We also discourage the use of certain syntax for this module, (e.g.,  ++ ) you should not use them.  The assignments are designed such that you should not need to do so (even though doing so may result in your program being shorter or more efficient). If the objective of the assignment is undermined, the penalty for using such forbidden syntax will be heavy. If in doubt, please ask for clarification.",
            "title": "Disallowed Syntax"
        },
        {
            "location": "/assignment/index.html#plagiarism",
            "text": "You are NOT to copy from others or allow others to copy your programs.  We take plagiarism seriously.  See  our policies  page for details.  This means that you should also guard your solution carefully, not posting them to publicly accessible places, or change the permissions of the files on the CS1010 PE hosts so that it is accessible by others.   This guideline is adapted from Aaron Tan's CS1010 guideline.",
            "title": "Plagiarism"
        },
        {
            "location": "/as01/index.html",
            "text": "Assignment 1\n\n\nDeadline\n\n\n14 September, 2018 (Friday), 6:00pm.\n\n\nPrerequisite\n\n\n\n\nYou are able to access the \nCS1010 programming environment\n.\n\n\nYou are familiar with \nbasic UNIX CLI\n and using terminal-based editor \nvim\n.\n\n\nYou have gone through Exercise 1 and have already setup your \n.gitconfig\n.\n\n\nYou are familiar with the steps of accepting, downloading, and submitting your exercise and assignment.\n\n\nYou are familiar with the directory structure and the common files included in your assignment skeleton.\n\n\n\n\nLearning Outcomes\n\n\n\n\nBe comfortable writing simple C programs that involves arithmetic operations, \nlong\n, \ndouble\n, and \nbool\n types, and conditional \nif\n/\nelse\n statements.\n\n\nBe comfortable breaking down a problem into smaller subproblems which can be resolved using functions, including reusing existing functions written for other programs (with a tweak), writing a function that calls itself, designing what should the inputs and return values/types of a function be.\n\n\n\n\nSetup\n\n\n\n\nClick on this link\n to accept the assignment.\n\n\nLogin to one of the hosts of \nCS1010 programming environment\n\n\nRun:\n\n\n\n\n1\n~cs1010/get-as01\n\n\n\n\n\n\n\n\nYou should see the folder \nas01-<github id>\n in your home directory with the assignment skeleton inside.\n\n\n\n\nSolving The Assignments\n\n\n\n\nEdit the files \ninvest.c\n, \nbox.c\n, \ndigits.c\n, and \ntaxi.c\n to solve the corresponding question as described below.\n\n\nTo compile and run tests with the sample inputs and outputs:\n\n\n\n\n1\nmake \n\n\n\n\n\n\n\n\nThe test cases are given in the \ninputs\n and \noutputs\n subdirectory.  You can use \ncat\n or \nless\n to look at the content of these test cases.  You can add more test cases or edit the given ones if needed.\n\n\n\n\nSubmission\n\n\nWhen you are ready, run the following command to submit:\n\n\n1\n~cs1010/submit-as01\n\n\n\n\n\n\nThe four files \ninvest.c\n, \nbox.c\n, \ndigits.c\n, and \ntaxi.c\n will be uploaded to GitHub.  You can submit multiple times, but only the last submission will be graded.\n\n\nIdentifying Yourself\n\n\nIn every C file that you submit to CS1010, you need to identify yourself by writing your name and tutorial group. Marks will be deducted if you fail to do so. You need to edit the line:\n\n\n1\n@author XXXX (Group YYYY)\n\n\n\n\n\n\nand change it to something like:\n\n\n1\n@author Hermione Granger (Group 9)\n\n\n\n\n\n\nGrading\n\n\nThis assignment contributes towards 3% of your final grade.  The total marks for this assignment is 30.  For Programming Assignment 1, the sole criteria for grading is correctness.\n\n\nQuestion 1: Invest (5 marks)\n\n\nIf you invest \nm\nm\n dollars at \nr\nr\n% interest rate compounded annually, after \nn\nn\n years, your investment will grow to \n\\frac{m(1 - (r/100)^{n+1})}{1 - r/100}\n\\frac{m(1 - (r/100)^{n+1})}{1 - r/100}\n dollars.\n\n\nWrite a program \ninvest.c\n that accepts three integers as input: principal \nm\nm\n, rate \nr\nr\n, and number of years \nn\nn\n, and computes the amount of money earned after \nn\nn\n years.\n\n\nYou may assume that \nr <= 100\n \nr < 100\nr < 100\n.\n\n\nSample Run\n\n\n1\n2\n3\n4\n5\n6\nooiwt@pe111:~/as01-skeleton$ ./invest\n100 10 5\n111.1110\nooiwt@pe111:~/as01-skeleton$ ./invest\n20000 5 10\n21052.6316\n\n\n\n\n\n\nQuestion 2: Box (5 marks)\n\n\nWrite a program \nbox.c\n that reads three positive integers representing the length, width, and height of a box, and output (i) its surface area, and (ii) the length of the diagonal between two vertices of the box that are furthest apart (see figure).\n\n\n\n\nYou may assume that the surface area of the box does not exceed the maximum value representable in the \nlong\n data type.\n\n\nYou should break down the problem into smaller ones:\n\n\n\n\nWrite a new method \narea_of_rectangle\n that computes the area of a rectangle given the width and height of the rectangle, then use it to compute the surface area.\n\n\nModify the method \nhypotenuse_of\n seen in \nUnit 5\n to compute the diagonal of the box.  (hint: pay attention to the type of the parameter and the return value).\n\n\n\n\nSample Run\n\n\n1\n2\n3\n4\n5\n6\nooiwt@pe111:~/as01-skeleton$ ./box \n12 3 10\n372 15.9060\nooiwt@pe111:~/as01-skeleton$ ./box \n10 20 30\n2200 37.4166\n\n\n\n\n\n\nQuestion 3: Digits (5 marks)\n\n\nWrite a program \ndigits.c\n that reads in a non-negative integer, and prints the sum of the individual digits in this integer. \n\n\nFor instance, if the input is \n1933091\n, then the sum is 1 + 9 + 3 + 3 + 0 + 9 + 1 = 26.\n\n\nYou should not use a loop to solve this, but rather, you should write a function \nsum_of_digits\n that takes in an integer and return the sum of the digits of that integer, that calls itself:\n\n\n\n\nif the input to \nsum_of_digits\n has only one digit, return this digit.\n\n\nOtherwise, use the modulo operator \n%\n and integer division \n/\n to extract the last digit (e.g., \n1\n) and the rest of the digits (e.g., \n193309\n) respectively, and call \nsum_of_digits\n on the rest of the digits to find its sum (e.g., 1+9+3+3+0+9 = 25).  Finally we add the last digit to this sum to get the total we seek (e.g., 1 + 25 = 26).\n\n\n\n\nSample Run\n\n\n1\n2\n3\n4\n5\n6\nooiwt@pe111:~/as01-skeleton$ ./digits \n1933091\n26\nooiwt@pe111:~/as01-skeleton$ ./digits \n0\n0\n\n\n\n\n\n\nQuestion 4: Taxi Fare (15 marks)\n\n\nThe taxi fare structure in Singapore must be one of the most complex in the world! Check out:\n\nhttp://www.taxisingapore.com/taxi-fare/\n.\n\n\nFor the purpose of this exercise, we will just use the following simpli\ufb01ed fare structure: \n\n\n\n\n\n\n\n\nBasic Fare\n\n\n\n\n\n\n\n\n\n\n\n\nThe first 1 km or less (Flag Down)\n\n\n$3.40\n\n\n\n\n\n\nEvery 400 m thereafter or less, up to 10.2 km\n\n\n$0.22\n\n\n\n\n\n\nEvery 350 m thereafter or less, after 10.2 km\n\n\n$0.22\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSurcharge\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMonday to Friday\n\n\n6:00 to 9:29\n\n\n25% of metered fare\n\n\n\n\n\n\nDaily\n\n\n18:00 to 23:59\n\n\n25% of metered fare\n\n\n\n\n\n\nDaily\n\n\n0:00 (midnight) to 5:59\n\n\n50% of metered fare\n\n\n\n\n\n\n\n\nNote that the surcharge is applicable based on the boarding time. For instance, if the trip started at 17:50 and ended at 18:10, then no surcharged is incurred.\n\n\nWrite a program \ntaxi.c\n that computes the taxi fare.  The program, called \ntaxi\n, takes in four integers as inputs:\n\n\n\n\nThe first is the day of the week.  It can only be the value \n1\n to \n7\n, \n1\n being Monday, \n7\n being Sunday.\n\n\nThe second and the third is the starting time of the trip: the second input indicates the hours since midnight of the stated day, the third input indicates the minutes since the beginning of the stated hours.\n\n\nThe forth and final input is the distance of the trip, in meters.\n\n\n\n\nYour program should print a single floating point number, which is the cost of the fare in dollars.\n\n\nExamine the following examples for more details:\n\n\nExample 1\n\n\n1\n2\n3\nooiwt@pe111:~/as01-skeleton$ ./taxi \n1 17 59 1000\n3.4000\n\n\n\n\n\n\n\n\nStart: Mon 17:59 \n\n\nDistance: 1,000 m\n\n\n\n\nThe metered fare is $3.40 since the distance travelled is 1km.  The boarding time is before 18:00 so there is no surcharge.  The total fare is $3.40.\n\n\nExample 2\n\n\n1\n2\n3\nooiwt@pe111:~/as01-skeleton$ ./taxi \n1 17 57 2000\n4.0600\n\n\n\n\n\n\n\n\nStart: Mon 17:57 \n\n\nDistance: 2,000 m\n\n\n\n\nThe metered fare for the first 1,000 m (1km) is $3.40.  The next 1,000 m is charged $0.22 for every 400 m (or less) travelled.  The pessengar is charged an additional 3 x $0.22, giving the total of metered fare of $4.06.\n\nThe boarding time is before 18:00 so there is no surcharge.\n\n\nExample 3\n\n\n1\n2\n3\nooiwt@pe111:~/as01-skeleton$ ./taxi \n1 5 50 15000\n17.3100\n\n\n\n\n\n\n\n\nStart: Mon 05:50\n\n\nDistance: 15,000 m\n\n\n\n\nThe metered fare for the first 1,000 m (1km) is $3.40.  The next 9,200 m is charged $0.22 for every 400 m travelled.  The pessengar is charged an additional 23 x $0.22 = $5.06.  The remaining 4,800 m is charged $0.22 for every 350 m (or less) travelled).  The pessengar is charged an additional 14 x $0.22 = $3.08.  The total metered fare is $11.54.\n\n\nThe boarding time is before 6:00 so there is a 50% surcharge.  Total fare is $17.31.\n\n\nHints\n\n\n\n\n\n\nYou can break down this problem into multiple subproblems, each can be solved by a function.  \nWrite one function to answer each question below\n:\n\n\n\n\ngiven the day of the week, is it a weekday? \n\n\ngiven the time of boarding, does it fall under the morning peak hour (6:00 - 9:29)?\n\n\ngiven the time of boarding, does it fall under the evening peak hour (18:00 - 23:59)?\n\n\ngiven the time of boarding, does it fall under the midnight peak hour (0:00 - 5:59)?\n\n\n\n\n\n\n\n\nYou can further breakdown the calculation of fare into two parts: the basic metered fare and the surcharge. Each of these can be its own function.  Think about the four inputs to the \ntaxi\n program.  Which one is needed to compute the metered fare?  Which ones are used to compute the surcharge?  Pass in the appropriate arguments to the function that computes the metered fare and the function that computes the surcharge.",
            "title": "1. Invest, Box, Digits, and Taxi"
        },
        {
            "location": "/as01/index.html#assignment-1",
            "text": "",
            "title": "Assignment 1"
        },
        {
            "location": "/as01/index.html#deadline",
            "text": "14 September, 2018 (Friday), 6:00pm.",
            "title": "Deadline"
        },
        {
            "location": "/as01/index.html#prerequisite",
            "text": "You are able to access the  CS1010 programming environment .  You are familiar with  basic UNIX CLI  and using terminal-based editor  vim .  You have gone through Exercise 1 and have already setup your  .gitconfig .  You are familiar with the steps of accepting, downloading, and submitting your exercise and assignment.  You are familiar with the directory structure and the common files included in your assignment skeleton.",
            "title": "Prerequisite"
        },
        {
            "location": "/as01/index.html#learning-outcomes",
            "text": "Be comfortable writing simple C programs that involves arithmetic operations,  long ,  double , and  bool  types, and conditional  if / else  statements.  Be comfortable breaking down a problem into smaller subproblems which can be resolved using functions, including reusing existing functions written for other programs (with a tweak), writing a function that calls itself, designing what should the inputs and return values/types of a function be.",
            "title": "Learning Outcomes"
        },
        {
            "location": "/as01/index.html#setup",
            "text": "Click on this link  to accept the assignment.  Login to one of the hosts of  CS1010 programming environment  Run:   1 ~cs1010/get-as01    You should see the folder  as01-<github id>  in your home directory with the assignment skeleton inside.",
            "title": "Setup"
        },
        {
            "location": "/as01/index.html#solving-the-assignments",
            "text": "Edit the files  invest.c ,  box.c ,  digits.c , and  taxi.c  to solve the corresponding question as described below.  To compile and run tests with the sample inputs and outputs:   1 make     The test cases are given in the  inputs  and  outputs  subdirectory.  You can use  cat  or  less  to look at the content of these test cases.  You can add more test cases or edit the given ones if needed.",
            "title": "Solving The Assignments"
        },
        {
            "location": "/as01/index.html#submission",
            "text": "When you are ready, run the following command to submit:  1 ~cs1010/submit-as01   The four files  invest.c ,  box.c ,  digits.c , and  taxi.c  will be uploaded to GitHub.  You can submit multiple times, but only the last submission will be graded.",
            "title": "Submission"
        },
        {
            "location": "/as01/index.html#identifying-yourself",
            "text": "In every C file that you submit to CS1010, you need to identify yourself by writing your name and tutorial group. Marks will be deducted if you fail to do so. You need to edit the line:  1 @author XXXX (Group YYYY)   and change it to something like:  1 @author Hermione Granger (Group 9)",
            "title": "Identifying Yourself"
        },
        {
            "location": "/as01/index.html#grading",
            "text": "This assignment contributes towards 3% of your final grade.  The total marks for this assignment is 30.  For Programming Assignment 1, the sole criteria for grading is correctness.",
            "title": "Grading"
        },
        {
            "location": "/as01/index.html#question-1-invest-5-marks",
            "text": "If you invest  m m  dollars at  r r % interest rate compounded annually, after  n n  years, your investment will grow to  \\frac{m(1 - (r/100)^{n+1})}{1 - r/100} \\frac{m(1 - (r/100)^{n+1})}{1 - r/100}  dollars.  Write a program  invest.c  that accepts three integers as input: principal  m m , rate  r r , and number of years  n n , and computes the amount of money earned after  n n  years.  You may assume that  r <= 100   r < 100 r < 100 .",
            "title": "Question 1: Invest (5 marks)"
        },
        {
            "location": "/as01/index.html#sample-run",
            "text": "1\n2\n3\n4\n5\n6 ooiwt@pe111:~/as01-skeleton$ ./invest\n100 10 5\n111.1110\nooiwt@pe111:~/as01-skeleton$ ./invest\n20000 5 10\n21052.6316",
            "title": "Sample Run"
        },
        {
            "location": "/as01/index.html#question-2-box-5-marks",
            "text": "Write a program  box.c  that reads three positive integers representing the length, width, and height of a box, and output (i) its surface area, and (ii) the length of the diagonal between two vertices of the box that are furthest apart (see figure).   You may assume that the surface area of the box does not exceed the maximum value representable in the  long  data type.  You should break down the problem into smaller ones:   Write a new method  area_of_rectangle  that computes the area of a rectangle given the width and height of the rectangle, then use it to compute the surface area.  Modify the method  hypotenuse_of  seen in  Unit 5  to compute the diagonal of the box.  (hint: pay attention to the type of the parameter and the return value).",
            "title": "Question 2: Box (5 marks)"
        },
        {
            "location": "/as01/index.html#sample-run_1",
            "text": "1\n2\n3\n4\n5\n6 ooiwt@pe111:~/as01-skeleton$ ./box \n12 3 10\n372 15.9060\nooiwt@pe111:~/as01-skeleton$ ./box \n10 20 30\n2200 37.4166",
            "title": "Sample Run"
        },
        {
            "location": "/as01/index.html#question-3-digits-5-marks",
            "text": "Write a program  digits.c  that reads in a non-negative integer, and prints the sum of the individual digits in this integer.   For instance, if the input is  1933091 , then the sum is 1 + 9 + 3 + 3 + 0 + 9 + 1 = 26.  You should not use a loop to solve this, but rather, you should write a function  sum_of_digits  that takes in an integer and return the sum of the digits of that integer, that calls itself:   if the input to  sum_of_digits  has only one digit, return this digit.  Otherwise, use the modulo operator  %  and integer division  /  to extract the last digit (e.g.,  1 ) and the rest of the digits (e.g.,  193309 ) respectively, and call  sum_of_digits  on the rest of the digits to find its sum (e.g., 1+9+3+3+0+9 = 25).  Finally we add the last digit to this sum to get the total we seek (e.g., 1 + 25 = 26).",
            "title": "Question 3: Digits (5 marks)"
        },
        {
            "location": "/as01/index.html#sample-run_2",
            "text": "1\n2\n3\n4\n5\n6 ooiwt@pe111:~/as01-skeleton$ ./digits \n1933091\n26\nooiwt@pe111:~/as01-skeleton$ ./digits \n0\n0",
            "title": "Sample Run"
        },
        {
            "location": "/as01/index.html#question-4-taxi-fare-15-marks",
            "text": "The taxi fare structure in Singapore must be one of the most complex in the world! Check out: http://www.taxisingapore.com/taxi-fare/ .  For the purpose of this exercise, we will just use the following simpli\ufb01ed fare structure:      Basic Fare       The first 1 km or less (Flag Down)  $3.40    Every 400 m thereafter or less, up to 10.2 km  $0.22    Every 350 m thereafter or less, after 10.2 km  $0.22        Surcharge        Monday to Friday  6:00 to 9:29  25% of metered fare    Daily  18:00 to 23:59  25% of metered fare    Daily  0:00 (midnight) to 5:59  50% of metered fare     Note that the surcharge is applicable based on the boarding time. For instance, if the trip started at 17:50 and ended at 18:10, then no surcharged is incurred.  Write a program  taxi.c  that computes the taxi fare.  The program, called  taxi , takes in four integers as inputs:   The first is the day of the week.  It can only be the value  1  to  7 ,  1  being Monday,  7  being Sunday.  The second and the third is the starting time of the trip: the second input indicates the hours since midnight of the stated day, the third input indicates the minutes since the beginning of the stated hours.  The forth and final input is the distance of the trip, in meters.   Your program should print a single floating point number, which is the cost of the fare in dollars.  Examine the following examples for more details:",
            "title": "Question 4: Taxi Fare (15 marks)"
        },
        {
            "location": "/as01/index.html#example-1",
            "text": "1\n2\n3 ooiwt@pe111:~/as01-skeleton$ ./taxi \n1 17 59 1000\n3.4000    Start: Mon 17:59   Distance: 1,000 m   The metered fare is $3.40 since the distance travelled is 1km.  The boarding time is before 18:00 so there is no surcharge.  The total fare is $3.40.",
            "title": "Example 1"
        },
        {
            "location": "/as01/index.html#example-2",
            "text": "1\n2\n3 ooiwt@pe111:~/as01-skeleton$ ./taxi \n1 17 57 2000\n4.0600    Start: Mon 17:57   Distance: 2,000 m   The metered fare for the first 1,000 m (1km) is $3.40.  The next 1,000 m is charged $0.22 for every 400 m (or less) travelled.  The pessengar is charged an additional 3 x $0.22, giving the total of metered fare of $4.06. \nThe boarding time is before 18:00 so there is no surcharge.",
            "title": "Example 2"
        },
        {
            "location": "/as01/index.html#example-3",
            "text": "1\n2\n3 ooiwt@pe111:~/as01-skeleton$ ./taxi \n1 5 50 15000\n17.3100    Start: Mon 05:50  Distance: 15,000 m   The metered fare for the first 1,000 m (1km) is $3.40.  The next 9,200 m is charged $0.22 for every 400 m travelled.  The pessengar is charged an additional 23 x $0.22 = $5.06.  The remaining 4,800 m is charged $0.22 for every 350 m (or less) travelled).  The pessengar is charged an additional 14 x $0.22 = $3.08.  The total metered fare is $11.54.  The boarding time is before 6:00 so there is a 50% surcharge.  Total fare is $17.31.",
            "title": "Example 3"
        },
        {
            "location": "/as01/index.html#hints",
            "text": "You can break down this problem into multiple subproblems, each can be solved by a function.   Write one function to answer each question below :   given the day of the week, is it a weekday?   given the time of boarding, does it fall under the morning peak hour (6:00 - 9:29)?  given the time of boarding, does it fall under the evening peak hour (18:00 - 23:59)?  given the time of boarding, does it fall under the midnight peak hour (0:00 - 5:59)?     You can further breakdown the calculation of fare into two parts: the basic metered fare and the surcharge. Each of these can be its own function.  Think about the four inputs to the  taxi  program.  Which one is needed to compute the metered fare?  Which ones are used to compute the surcharge?  Pass in the appropriate arguments to the function that computes the metered fare and the function that computes the surcharge.",
            "title": "Hints"
        },
        {
            "location": "/quiz/index.html",
            "text": "Quizzes\n\n\nWe have setup some quizzes to help you check for yourself how much you know about the topics we cover in CS1010.\n\n\nThere are two types of quizzes: (a) in-class Kahoot! quizzes, and (b) out-of-class Google Form quizzes.  The quizzes are linked here:\n\n\nKahoot! Quizzes\n\n\nWeek 4: Flow Charts\n (3 September 2018)\n\n\nGoogle Form Quizzes\n\n\nQuiz 1: Using PE and UNIX\n\n\nQuiz 2: Compiling Your Code",
            "title": "Quizzes"
        },
        {
            "location": "/quiz/index.html#quizzes",
            "text": "We have setup some quizzes to help you check for yourself how much you know about the topics we cover in CS1010.  There are two types of quizzes: (a) in-class Kahoot! quizzes, and (b) out-of-class Google Form quizzes.  The quizzes are linked here:",
            "title": "Quizzes"
        },
        {
            "location": "/quiz/index.html#kahoot-quizzes",
            "text": "",
            "title": "Kahoot! Quizzes"
        },
        {
            "location": "/quiz/index.html#week-4-flow-charts-3-september-2018",
            "text": "",
            "title": "Week 4: Flow Charts (3 September 2018)"
        },
        {
            "location": "/quiz/index.html#google-form-quizzes",
            "text": "",
            "title": "Google Form Quizzes"
        },
        {
            "location": "/quiz/index.html#quiz-1-using-pe-and-unix",
            "text": "",
            "title": "Quiz 1: Using PE and UNIX"
        },
        {
            "location": "/quiz/index.html#quiz-2-compiling-your-code",
            "text": "",
            "title": "Quiz 2: Compiling Your Code"
        },
        {
            "location": "/kahoot01/index.html",
            "text": "Kahoot Quiz 1\n\n\n3 September 2018 (Week 4)\n\n\nQuestion 1\n\n\nWhat is the output of the algorithm in the flowchart below if the input L is 10, 7, 1?\n\n\n\n\n\n\nA. 18\n\n\nB. 27\n\n\nC. 8\n\n\nD. 17\n\n\n\n\n(Answer: B)\n\n\nQuestion 2\n\n\nWhat is the output of the algorithm in the flowchart below if the input L is 5, 6, 10?\n\n\n\n\n\n\nA. 5\n\n\nB. 6\n\n\nC. 10\n\n\nD. No output\n\n\n\n\n(Answer: B)\n\n\nQuestion 3\n\n\nRefer to the flowchart in Question 2.  What is the output of the algorithm if L is 1, 2, 3, 4?\n\n\n\n\nA. 2\n\n\nB. 3\n\n\nC. 4\n\n\nD. No output\n\n\n\n\n(Answer: D)",
            "title": "Flow Charts"
        },
        {
            "location": "/kahoot01/index.html#kahoot-quiz-1",
            "text": "3 September 2018 (Week 4)",
            "title": "Kahoot Quiz 1"
        },
        {
            "location": "/kahoot01/index.html#question-1",
            "text": "What is the output of the algorithm in the flowchart below if the input L is 10, 7, 1?    A. 18  B. 27  C. 8  D. 17   (Answer: B)",
            "title": "Question 1"
        },
        {
            "location": "/kahoot01/index.html#question-2",
            "text": "What is the output of the algorithm in the flowchart below if the input L is 5, 6, 10?    A. 5  B. 6  C. 10  D. No output   (Answer: B)",
            "title": "Question 2"
        },
        {
            "location": "/kahoot01/index.html#question-3",
            "text": "Refer to the flowchart in Question 2.  What is the output of the algorithm if L is 1, 2, 3, 4?   A. 2  B. 3  C. 4  D. No output   (Answer: D)",
            "title": "Question 3"
        },
        {
            "location": "/style/index.html",
            "text": "CS1010 C Style\n\n\nIn CS1010, you should following the following style guide when you write your code for your graded homework and practical exams.  We typically allocate a few marks for coding style (each assignment/exam may have different allocation).  You will lose marks for violation of style.\n\n\nThis guide is modified from past CS1010 style guide by Aaron Tan.\n\n\nWhy Coding Style is Important\n\n\nQuote\n\n\n\"It is not merely a matter of aesthetics that programs should be written in a particular style. Rather there is a psychological basis for writing programs in a conventional manner: programmers have strong expectations that other programmers will follow these discourse rules. If the rules are violated, then the utility afforded by the expectations that programmers have built up over time is effectively nullified. The results from the experiments with novice and advanced student programmers and with professional programmers described in this paper provide clear support for these claims.\"\n\n\nElliot Soloway and Kate Ehrlich. \"Empirical studies of programming knowledge.\" IEEE Transactions on Software Engineering 5 (1984): 595-609.\n\n\n1. Variable Declaration\n\n\nEach variable should be declared in its own line.\n\n\n1\n2\ndouble\n \nweight\n;\n  \n// The weight of the baby\n\n\ndouble\n \nheight\n;\n  \n// The height of the baby\n\n\n\n\n\n\n\nAvoid\n\n\n1\ndouble\n \nweight\n,\n \nheight\n;\n   \n// Weight and height of the baby\n\n\n\n\n\n\n\n2. Give Variables Descriptive Names\n\n\nThis is the most important rule to follow.  The name of a type, variable, function, constant should inform us of its purpose clearly without the readers having to guess or look up its meaning.\n\n\nFor example, \nint number_of_coins;\n is an appropriate variable but not \nint c;\n. Avoid using a single character for variable names.\n\n\nThere are some exceptions, however, as shown below:\n\n\n\n\nIf the variable is the problem size and it is given in the task statement. For example, a problem dealing with n values, hence the variable may be called n (preferably with a comment to explain).\n\n\nIf the variable is a transient/temporary variable whose purpose is clear.\n-If the variable is a loop variable whose purpose is clear.\n\n\n\n\n3. Shorten Variable Names with Naming Conventions\n\n\nDespite the recommendation for descriptive names, identifiers can be short yet descriptive by using abbreviations and/or common naming conventions. For example, \nMAX_LEN\n, \nnum_of_elems\n, \npcurr\n, \ntable_num\n.\n\n\nHowever, do not invent your own abbreviation. For instance, names like \nnm_elemnts\n should be avoided.\n\n\n4. Avoid Negated Variable or Function Names\n\n\nNegated variables often result in hard-to-read double-negatives in an expression like \n!is_not_err\n.\n\n\nSo, avoid \nis_not_error\n, \nis_not_found\n, \nis_not_valid\n, \ncannot_open_file\n.  Instead, we prefer \nis_error\n, \nis_found\n, \nis_valid\n, \ncan_open_file\n etc.\n\n\n5. Use \n#define\n to Define Constants for Magic Numbers\n\n\nAvoid direct use of magic numbers. Constant literals which have special meanings should be named and its named identifier should be used in its place. For example:\n\n\nAvoid:\n\n1\n2\n3\nfor\n \n(\ni\n \n=\n \n0\n;\n \ni\n \n<\n \n100\n;\n \ni\n \n+=\n \n1\n)\n \n{\n\n    \n:\n\n\n}\n\n\n\n\n\n\nPrefer:\n\n1\n2\n3\n4\n5\n#define MAX_LEN 100\n :\nfor (i = 0; i < MAX_LEN; i += 1) {\n    :\n}\n\n\n\n\n\n6. Naming Conventions\n\n\nConstants\n\n\nAll constant identifiers must be written in all caps and separated by an underscore \n_\n.  For instance \nMAX_ITERATIONS\n, \nMAX_LEN\n, \nGOLDEN_RATIO\n, \nCOLOR_DEFAULT\n, \nPI\n.\n\n\nVariables and Functions\n\n\nUse lower case letters for variable names and function names, with multiple words separated by underscore \n_\n.  Example, \ncs1010_read_long\n, \nis_prime\n. \n\n\n7. Use Consistent Indentation to Emphasize Block Structure\n\n\nThe code should be properly and neatly indented to emphasize the nested logical structure of the program. An indentation of 2 or 4 spaces is recommended (8 is too wide).\n\n\nEvery block that follows a \nfor\n, \nwhile\n, \nif-else\n, \ndo-while\n statement must be indented from its enclosing block.\n\n\nComments within a block should follow the indentation level of its enclosing block. For example,\n\n\n1\n2\n3\n4\n5\n6\n7\nfor\n \n(\ni\n \n=\n \n0\n;\n \ni\n \n<\n \n3\n;\n \ni\n \n+=\n \n1\n)\n \n{\n   \n    \n// Comments should be indented too\n\n    \nwhile\n \n(\nj\n \n!=\n \ni\n)\n \n{\n\n        \n// More indented comments\n\n        \nprintf\n(\n\"Hello\n\\n\n\"\n);\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nThe following are the wrong ways to indent the comments.\n\n\n1\n2\n3\n4\n5\n6\n7\nfor\n \n(\ni\n \n=\n \n0\n;\n \ni\n \n<\n \n3\n;\n \ni\n \n+=\n \n1\n)\n \n{\n\n\n// This comment should be indented and aligned with the while statement.\n\n    \nwhile\n \n(\nj\n \n!=\n \ni\n)\n \n{\n\n    \n// This comment should be aligned with the printf statement.\n\n        \nprintf\n(\n\"Hello\n\\n\n\"\n);\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\n8. Don't Mix Tabs and Spaces\n\n\nYou must use only spaces in your code.  Do not use tabs.\n\n\nYou can add the configuration \nset expandtab\n to automatically expand any tab that you enter into spaces.\n\n\n9. Spaces in \nif\n, \nelse\n, \nfor\n, \nwhile\n, \ndo\n-\nwhile\n Statements\n\n\nAdd a single space between the keywords \nif\n,\nelse\n, \nfor\n, \nwhile\n and the following parentheses and between the parentheses and next curly bracket.  For instance:\n\n\n1\n2\n3\nfor( ... ) { // not good\nfor( ... ){ // not good\nfor ( ... ) { // good\n\n\n\n\n\n\n10. Spaces in Assignments\n\n\nAdd a single space before and after \n=\n.\n\n\n1\n2\n3\na= b; // no\na =b; // no\na = b; // OK!\n\n\n\n\n\n\n11. Positions of Open and Close Braces\n\n\nThere are two camps on the position of open braces. The following shows the \"trailing open braces\":\n\n\n1\n2\n3\n4\n5\nfor\n \n(\ni\n \n=\n \n0\n;\n \ni\n \n<\n \n3\n;\n \ni\n \n+=\n \n1\n)\n \n{\n\n    \nwhile\n \n(\nj\n \n!=\n \ni\n)\n \n{\n\n        \nprintf\n(\n\"Hello\n\\n\n\"\n);\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nThe following shows the \"leading open braces\". The leading open brace must be aligned with the block of the construct it is in:\n\n\n1\n2\n3\n4\n5\n6\n7\nfor\n \n(\ni\n \n=\n \n0\n;\n \ni\n \n<\n \n3\n;\n \ni\n \n+=\n \n1\n)\n \n\n{\n\n    \nwhile\n \n(\nj\n \n!=\n \ni\n)\n \n    \n{\n\n        \nprintf\n(\n\"Hello\n\\n\n\"\n);\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nBoth styles are acceptable, but you should be consistent and should not mix both styles in a single program.\n\n\nFor close braces, they should be leading close braces aligned with the block of the construct. Close braces should NOT be trailing as that would make it hard to spot them.\n\n\n12. Comment Major Code Segments Adequately\n\n\nMajor segments of code should have explanatory comments. A major segment may be a loop block or a function block.\n\n\nYou should comment on complicated logic, expressions, or algorithms, explaining what you are doing in the code, including why and how.\n\n\nAn \"if\" block with a complex condition or an expression that is hard to understand should have explanatory comments.  For example,\n\n\n1\n2\n3\n4\n// Check and reject out-of-bounds indices\n\n\nif\n \n(\nk\n \n<\n \n0\n \n||\n \nk\n \n>=\n \nMAX_LEN\n)\n \n{\n\n    \nreturn\n \n-\n1\n;\n\n\n}\n\n\n\n\n\n\n\n13. Avoid Superfluous Comments\n\n\nA comment such as:\n\n\n1\ni\n \n+=\n \n1\n \n// add one to i\n\n\n\n\n\n\n\nserves no purpose, adds clutter to a program and does more harm than good.\n\n\n14. Blank Lines\n\n\nIt is good to add a blank line between two functions, or two long segments of code for readability.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n// This function ...\n\n\nint\n \nf\n(\nint\n \nx\n)\n \n{\n\n    \n// body\n\n\n}\n\n\n\n// This function ...\n\n\nint\n \ng\n(\ndouble\n \ny\n)\n \n{\n\n    \n// body\n\n\n}\n\n\n\n\n\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n// Statements 1 to 10 belong to a sub-task\n\n\nstatement1\n;\n\n\nstatement2\n;\n\n   \n:\n\n\nstatement10\n;\n\n\n\n// Leave a blank line for readability\n\n\nstatement11\n;\n\n\nstatement12\n;\n\n   \n:\n\n\n\n\n\n\n\nHowever, guard against the use of excessive blank lines. Double blank lines and triply blank lines, or more, should not be present.\n\n\n15. Long Lines\n\n\nIf a line (be it a statement or a comment) is too long (more than 80 characters), do not let it run through the screen and wrap around. Instead, split it into a few lines.\n\n\n1\nif\n \n((\nhas_cs2010\n \n||\n \nhas_cs2020\n \n||\n \nhas_cs2040\n \n||\n \nhas_cs2040C\n)\n \n&&\n \n(\nhas_st1232\n \n||\n \nhas_st2131\n \n||\n \nhas_st2132\n \n||\n \nhas_st2334\n)\n \n&&\n \n(\nhas_ma1102R\n \n||\n \nhas_ma1505\n \n||\n \n(\nhas_ma1511\n \n&&\n \nhas_ma1512\n)\n \n||\n \nhas_ma1521\n)\n \n&&\n \n(\nhas_ma1101R\n \n||\n \nhas_ma1311\n \n||\n \nhas_ma1506\n \n||\n \nhas_ma1508E\n))\n \n\n\n\n\nis bad\n\n\n1\n2\n3\n4\nif\n \n((\nhas_cs2010\n \n||\n \nhas_cs2020\n \n||\n \nhas_cs2040\n \n||\n \nhas_cs2040c\n)\n \n&&\n \n   \n(\nhas_st1232\n \n||\n \nhas_st2131\n \n||\n  \nhas_st2132\n \n||\n \nhas_st2334\n)\n \n&&\n \n   \n(\nhas_ma1102r\n \n||\n \nhas_ma1505\n \n||\n \n(\nhas_ma1511\n \n&&\n \nhas_ma1512\n)\n \n||\n \nhas_ma1521\n)\n \n&&\n    \n   \n(\nhas_ma1101r\n \n||\n \nhas_ma1311\n \n||\n \nhas_ma1506\n \n||\n \nhas_ma1508e\n))\n \n\n\n\n\nis better.",
            "title": "Style Guide"
        },
        {
            "location": "/style/index.html#cs1010-c-style",
            "text": "In CS1010, you should following the following style guide when you write your code for your graded homework and practical exams.  We typically allocate a few marks for coding style (each assignment/exam may have different allocation).  You will lose marks for violation of style.  This guide is modified from past CS1010 style guide by Aaron Tan.",
            "title": "CS1010 C Style"
        },
        {
            "location": "/style/index.html#why-coding-style-is-important",
            "text": "Quote  \"It is not merely a matter of aesthetics that programs should be written in a particular style. Rather there is a psychological basis for writing programs in a conventional manner: programmers have strong expectations that other programmers will follow these discourse rules. If the rules are violated, then the utility afforded by the expectations that programmers have built up over time is effectively nullified. The results from the experiments with novice and advanced student programmers and with professional programmers described in this paper provide clear support for these claims.\"  Elliot Soloway and Kate Ehrlich. \"Empirical studies of programming knowledge.\" IEEE Transactions on Software Engineering 5 (1984): 595-609.",
            "title": "Why Coding Style is Important"
        },
        {
            "location": "/style/index.html#1-variable-declaration",
            "text": "Each variable should be declared in its own line.  1\n2 double   weight ;    // The weight of the baby  double   height ;    // The height of the baby    Avoid  1 double   weight ,   height ;     // Weight and height of the baby",
            "title": "1. Variable Declaration"
        },
        {
            "location": "/style/index.html#2-give-variables-descriptive-names",
            "text": "This is the most important rule to follow.  The name of a type, variable, function, constant should inform us of its purpose clearly without the readers having to guess or look up its meaning.  For example,  int number_of_coins;  is an appropriate variable but not  int c; . Avoid using a single character for variable names.  There are some exceptions, however, as shown below:   If the variable is the problem size and it is given in the task statement. For example, a problem dealing with n values, hence the variable may be called n (preferably with a comment to explain).  If the variable is a transient/temporary variable whose purpose is clear.\n-If the variable is a loop variable whose purpose is clear.",
            "title": "2. Give Variables Descriptive Names"
        },
        {
            "location": "/style/index.html#3-shorten-variable-names-with-naming-conventions",
            "text": "Despite the recommendation for descriptive names, identifiers can be short yet descriptive by using abbreviations and/or common naming conventions. For example,  MAX_LEN ,  num_of_elems ,  pcurr ,  table_num .  However, do not invent your own abbreviation. For instance, names like  nm_elemnts  should be avoided.",
            "title": "3. Shorten Variable Names with Naming Conventions"
        },
        {
            "location": "/style/index.html#4-avoid-negated-variable-or-function-names",
            "text": "Negated variables often result in hard-to-read double-negatives in an expression like  !is_not_err .  So, avoid  is_not_error ,  is_not_found ,  is_not_valid ,  cannot_open_file .  Instead, we prefer  is_error ,  is_found ,  is_valid ,  can_open_file  etc.",
            "title": "4. Avoid Negated Variable or Function Names"
        },
        {
            "location": "/style/index.html#5-use-define-to-define-constants-for-magic-numbers",
            "text": "Avoid direct use of magic numbers. Constant literals which have special meanings should be named and its named identifier should be used in its place. For example:  Avoid: 1\n2\n3 for   ( i   =   0 ;   i   <   100 ;   i   +=   1 )   { \n     :  }    Prefer: 1\n2\n3\n4\n5 #define MAX_LEN 100\n :\nfor (i = 0; i < MAX_LEN; i += 1) {\n    :\n}",
            "title": "5. Use #define to Define Constants for Magic Numbers"
        },
        {
            "location": "/style/index.html#6-naming-conventions",
            "text": "",
            "title": "6. Naming Conventions"
        },
        {
            "location": "/style/index.html#constants",
            "text": "All constant identifiers must be written in all caps and separated by an underscore  _ .  For instance  MAX_ITERATIONS ,  MAX_LEN ,  GOLDEN_RATIO ,  COLOR_DEFAULT ,  PI .",
            "title": "Constants"
        },
        {
            "location": "/style/index.html#variables-and-functions",
            "text": "Use lower case letters for variable names and function names, with multiple words separated by underscore  _ .  Example,  cs1010_read_long ,  is_prime .",
            "title": "Variables and Functions"
        },
        {
            "location": "/style/index.html#7-use-consistent-indentation-to-emphasize-block-structure",
            "text": "The code should be properly and neatly indented to emphasize the nested logical structure of the program. An indentation of 2 or 4 spaces is recommended (8 is too wide).  Every block that follows a  for ,  while ,  if-else ,  do-while  statement must be indented from its enclosing block.  Comments within a block should follow the indentation level of its enclosing block. For example,  1\n2\n3\n4\n5\n6\n7 for   ( i   =   0 ;   i   <   3 ;   i   +=   1 )   {    \n     // Comments should be indented too \n     while   ( j   !=   i )   { \n         // More indented comments \n         printf ( \"Hello \\n \" ); \n     }  }    The following are the wrong ways to indent the comments.  1\n2\n3\n4\n5\n6\n7 for   ( i   =   0 ;   i   <   3 ;   i   +=   1 )   {  // This comment should be indented and aligned with the while statement. \n     while   ( j   !=   i )   { \n     // This comment should be aligned with the printf statement. \n         printf ( \"Hello \\n \" ); \n     }  }",
            "title": "7. Use Consistent Indentation to Emphasize Block Structure"
        },
        {
            "location": "/style/index.html#8-dont-mix-tabs-and-spaces",
            "text": "You must use only spaces in your code.  Do not use tabs.  You can add the configuration  set expandtab  to automatically expand any tab that you enter into spaces.",
            "title": "8. Don't Mix Tabs and Spaces"
        },
        {
            "location": "/style/index.html#9-spaces-in-if-else-for-while-do-while-statements",
            "text": "Add a single space between the keywords  if , else ,  for ,  while  and the following parentheses and between the parentheses and next curly bracket.  For instance:  1\n2\n3 for( ... ) { // not good\nfor( ... ){ // not good\nfor ( ... ) { // good",
            "title": "9. Spaces in if, else, for, while, do-while Statements"
        },
        {
            "location": "/style/index.html#10-spaces-in-assignments",
            "text": "Add a single space before and after  = .  1\n2\n3 a= b; // no\na =b; // no\na = b; // OK!",
            "title": "10. Spaces in Assignments"
        },
        {
            "location": "/style/index.html#11-positions-of-open-and-close-braces",
            "text": "There are two camps on the position of open braces. The following shows the \"trailing open braces\":  1\n2\n3\n4\n5 for   ( i   =   0 ;   i   <   3 ;   i   +=   1 )   { \n     while   ( j   !=   i )   { \n         printf ( \"Hello \\n \" ); \n     }  }    The following shows the \"leading open braces\". The leading open brace must be aligned with the block of the construct it is in:  1\n2\n3\n4\n5\n6\n7 for   ( i   =   0 ;   i   <   3 ;   i   +=   1 )   { \n     while   ( j   !=   i )  \n     { \n         printf ( \"Hello \\n \" ); \n     }  }    Both styles are acceptable, but you should be consistent and should not mix both styles in a single program.  For close braces, they should be leading close braces aligned with the block of the construct. Close braces should NOT be trailing as that would make it hard to spot them.",
            "title": "11. Positions of Open and Close Braces"
        },
        {
            "location": "/style/index.html#12-comment-major-code-segments-adequately",
            "text": "Major segments of code should have explanatory comments. A major segment may be a loop block or a function block.  You should comment on complicated logic, expressions, or algorithms, explaining what you are doing in the code, including why and how.  An \"if\" block with a complex condition or an expression that is hard to understand should have explanatory comments.  For example,  1\n2\n3\n4 // Check and reject out-of-bounds indices  if   ( k   <   0   ||   k   >=   MAX_LEN )   { \n     return   - 1 ;  }",
            "title": "12. Comment Major Code Segments Adequately"
        },
        {
            "location": "/style/index.html#13-avoid-superfluous-comments",
            "text": "A comment such as:  1 i   +=   1   // add one to i    serves no purpose, adds clutter to a program and does more harm than good.",
            "title": "13. Avoid Superfluous Comments"
        },
        {
            "location": "/style/index.html#14-blank-lines",
            "text": "It is good to add a blank line between two functions, or two long segments of code for readability.  1\n2\n3\n4\n5\n6\n7\n8\n9 // This function ...  int   f ( int   x )   { \n     // body  }  // This function ...  int   g ( double   y )   { \n     // body  }     1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10 // Statements 1 to 10 belong to a sub-task  statement1 ;  statement2 ; \n    :  statement10 ;  // Leave a blank line for readability  statement11 ;  statement12 ; \n    :    However, guard against the use of excessive blank lines. Double blank lines and triply blank lines, or more, should not be present.",
            "title": "14. Blank Lines"
        },
        {
            "location": "/style/index.html#15-long-lines",
            "text": "If a line (be it a statement or a comment) is too long (more than 80 characters), do not let it run through the screen and wrap around. Instead, split it into a few lines.  1 if   (( has_cs2010   ||   has_cs2020   ||   has_cs2040   ||   has_cs2040C )   &&   ( has_st1232   ||   has_st2131   ||   has_st2132   ||   has_st2334 )   &&   ( has_ma1102R   ||   has_ma1505   ||   ( has_ma1511   &&   has_ma1512 )   ||   has_ma1521 )   &&   ( has_ma1101R   ||   has_ma1311   ||   has_ma1506   ||   has_ma1508E ))    \nis bad  1\n2\n3\n4 if   (( has_cs2010   ||   has_cs2020   ||   has_cs2040   ||   has_cs2040c )   &&  \n    ( has_st1232   ||   has_st2131   ||    has_st2132   ||   has_st2334 )   &&  \n    ( has_ma1102r   ||   has_ma1505   ||   ( has_ma1511   &&   has_ma1512 )   ||   has_ma1521 )   &&     \n    ( has_ma1101r   ||   has_ma1311   ||   has_ma1506   ||   has_ma1508e ))    \nis better.",
            "title": "15. Long Lines"
        },
        {
            "location": "/readings/index.html",
            "text": "Readings\n\n\nMust Read\n\n\n\n\nHow NOT to Go About a Programming Assignment\n, by Agustin Cernuda del Rio. \nComputer programming students invariably fall into more than one bad habit. It can be extremely difficult to eradicate them (and many lecturers and professional programmers keep succumbing to them time and again)..\n\n\nBest Teacher I Ever Had\n, by David Owen.  \nMr. Whitson taught sixth-grade science. On the first day of class, he gave us a lecture about a creature called the cattywampus, ..\n\n\n\n\nWhy C?\n\n\n\n\nLearn C programming and the rest will come, by Marty Jacobs\n\n\nThe Resurgence of C Programming, by Mark Barlow\n\n\nYou Can't Dig Upwards, by Evan Miller\n\n\n\n\nVim\n\n\n\n\n\n\nTime to Drop Emacs and Vi?\n on StackOverflow.  \"\nProgrammers are notorious for using the tools that helps them get the job done in the most efficient way possible. These editors are ancient yet still being used because they are good, solid editors, proven by time. If they get the job done and get the job done well, why should we drop them in favor of something else?\n\"\n\n\n\n\n\n\nWhat are the benefits of learning Vim?\n on Stack Overflow.  \"\nUsually vim's killer features are considered: A) that it's available on pretty much every Unix you'll ever encounter and B) your fingers very rarely have to leave the home row, which means you'll be able to edit text very, very quickly. It's also usually very fast and lightweight even when editing huge files.\n\"\n\n\n\n\n\n\nLearn \nvim\n Progressively\n \"\nI suggest you teach yourself Vim in 4 steps: 1. Survive. 2.  Feel comfortable. 3.  Feel Better, Stronger, Faster. 4.  Use superpowers of vim\n\"\n\n\n\n\n\n\nWhere Vim Came From\n -- from TwoBitHistory.  \"\nPerhaps more importantly, while we\u2019re asking questions, why does exiting Vim involve typing :wq? Sure, it\u2019s a \u201cwrite\u201d operation followed by a \u201cquit\u201d operation, but that is not a particularly intuitive convention. Who decided that copying text should instead be called \u201cyanking\u201d? Why is :%s/foo/bar/gc short for \u201cfind and replace\u201d? Vim\u2019s idiosyncrasies seem too arbitrary to have been made up, but then where did they come from?\"\n\n\n\n\n\n\nVim's Big Idea\n - by Mike Kozlowski. \n\"This philosophy of minimalist commands that can be composed together is the fundamental originating philosophy of Unix, and Vim exemplifies it like no other editor.\"\n\n\n\n\n\n\nVIM Pays Excellent Dividends\n - by John Bjorn Nelson.  \n\"Being conservative, let\u2019s say it makes you 5% more productive. More specifically\u200a\u2014\u200aonce your brain maps the keystrokes to muscle memory\u200a\u2014\u200ait makes you 5% faster at completing the mundane tasks\u2026the ones which dominate programming. That added productivity snowballs. It\u2019s an extra twenty minutes a day to build or explore (or learn), that used to go to copy/paste-like operations.\"\n\n\n\n\n\n\nThe Powers of VIM\n - by Artem Dudarev\n\n\n\n\n\n\nThe 11 Steps to Learning Vim\n - by \ndamassi\n. \n\"Regardless of the initial confusion and difficulty in getting started, you're making your future developer self immensely more productive by diving in and taking the plunge. Seriously. I'm just a few weeks in right now and I can positively say that learning Vim has been the best work-related decision of my life. It's fun, and in the strangest of ways it makes you think better.\"\n\n\n\n\n\n\nVim for People Who Think Things like Vim and Weird and Hard\n - by \nHarry Roberts\n. \n\"the fact that, yes, people still use an editor that is over 20 years old (in turn based on a tool from the 70s), and those people number in the hundreds of thousands, perhaps they might be onto something.\"\n\n\n\n\n\n\nWhy I use Vim\n - Pascal Precht. \"_once I was able to do some basic operations in Vim and actually started working again, I made almost as twice as much progress at work in about half the time. I know that sounds kind of crazy but I\u2019m serious. And that convinced me that I made the right choice.\n\n\n\n\n\n\nSo, do yourself a favor and climb that mountain. Just remember that you can slide down afterwards._\"\n\n\nVim Video Tutorial (from Aaron Tan)\n\n\n\n\nLesson 1\n\n\nLesson 2\n\n\nLesson 3\n\n\nLesson 4",
            "title": "Readings"
        },
        {
            "location": "/readings/index.html#readings",
            "text": "",
            "title": "Readings"
        },
        {
            "location": "/readings/index.html#must-read",
            "text": "How NOT to Go About a Programming Assignment , by Agustin Cernuda del Rio.  Computer programming students invariably fall into more than one bad habit. It can be extremely difficult to eradicate them (and many lecturers and professional programmers keep succumbing to them time and again)..  Best Teacher I Ever Had , by David Owen.   Mr. Whitson taught sixth-grade science. On the first day of class, he gave us a lecture about a creature called the cattywampus, ..",
            "title": "Must Read"
        },
        {
            "location": "/readings/index.html#why-c",
            "text": "Learn C programming and the rest will come, by Marty Jacobs  The Resurgence of C Programming, by Mark Barlow  You Can't Dig Upwards, by Evan Miller",
            "title": "Why C?"
        },
        {
            "location": "/readings/index.html#vim",
            "text": "Time to Drop Emacs and Vi?  on StackOverflow.  \" Programmers are notorious for using the tools that helps them get the job done in the most efficient way possible. These editors are ancient yet still being used because they are good, solid editors, proven by time. If they get the job done and get the job done well, why should we drop them in favor of something else? \"    What are the benefits of learning Vim?  on Stack Overflow.  \" Usually vim's killer features are considered: A) that it's available on pretty much every Unix you'll ever encounter and B) your fingers very rarely have to leave the home row, which means you'll be able to edit text very, very quickly. It's also usually very fast and lightweight even when editing huge files. \"    Learn  vim  Progressively  \" I suggest you teach yourself Vim in 4 steps: 1. Survive. 2.  Feel comfortable. 3.  Feel Better, Stronger, Faster. 4.  Use superpowers of vim \"    Where Vim Came From  -- from TwoBitHistory.  \" Perhaps more importantly, while we\u2019re asking questions, why does exiting Vim involve typing :wq? Sure, it\u2019s a \u201cwrite\u201d operation followed by a \u201cquit\u201d operation, but that is not a particularly intuitive convention. Who decided that copying text should instead be called \u201cyanking\u201d? Why is :%s/foo/bar/gc short for \u201cfind and replace\u201d? Vim\u2019s idiosyncrasies seem too arbitrary to have been made up, but then where did they come from?\"    Vim's Big Idea  - by Mike Kozlowski.  \"This philosophy of minimalist commands that can be composed together is the fundamental originating philosophy of Unix, and Vim exemplifies it like no other editor.\"    VIM Pays Excellent Dividends  - by John Bjorn Nelson.   \"Being conservative, let\u2019s say it makes you 5% more productive. More specifically\u200a\u2014\u200aonce your brain maps the keystrokes to muscle memory\u200a\u2014\u200ait makes you 5% faster at completing the mundane tasks\u2026the ones which dominate programming. That added productivity snowballs. It\u2019s an extra twenty minutes a day to build or explore (or learn), that used to go to copy/paste-like operations.\"    The Powers of VIM  - by Artem Dudarev    The 11 Steps to Learning Vim  - by  damassi .  \"Regardless of the initial confusion and difficulty in getting started, you're making your future developer self immensely more productive by diving in and taking the plunge. Seriously. I'm just a few weeks in right now and I can positively say that learning Vim has been the best work-related decision of my life. It's fun, and in the strangest of ways it makes you think better.\"    Vim for People Who Think Things like Vim and Weird and Hard  - by  Harry Roberts .  \"the fact that, yes, people still use an editor that is over 20 years old (in turn based on a tool from the 70s), and those people number in the hundreds of thousands, perhaps they might be onto something.\"    Why I use Vim  - Pascal Precht. \"_once I was able to do some basic operations in Vim and actually started working again, I made almost as twice as much progress at work in about half the time. I know that sounds kind of crazy but I\u2019m serious. And that convinced me that I made the right choice.    So, do yourself a favor and climb that mountain. Just remember that you can slide down afterwards._\"",
            "title": "Vim"
        },
        {
            "location": "/readings/index.html#vim-video-tutorial-from-aaron-tan",
            "text": "Lesson 1  Lesson 2  Lesson 3  Lesson 4",
            "title": "Vim Video Tutorial (from Aaron Tan)"
        },
        {
            "location": "/environments/index.html",
            "text": "The CS1010 Programming Environment\n\n\nC is a common programming language and you can find different implementations of C compiler on many platforms.  Wikipedia \nlists more than 40 different C compilers\n.  These different compilers support different processor architecture, operating system, may behave slightly differently, and may support different features of C standards.  It is therefore important for CS1010 to stick to a single platform and single compiler.\n\n\nOur platform of choice is \nUbuntu 16.04 (or later)\n using the \nclang\n compiler (\nversion 3.4.2 or later\n).\n\n\nThe school has provided a list of computing servers for you to use.  You can access them remotely via \nssh\n, or secure shell.  The hosts are named \npe111\n, \npe112\n, ..., \npe120\n.  (\npe\n stands for \"programming environment\").\n\n\nYou can choose which of the 10 hosts to use.  You share the same home directory across all 10 hosts (this home directory, however, is different from that of \nsunfire\n).\n\n\nFor simplicity, the following guide uses \npe111\n in all examples.  Do keep in mind that you can use other hosts for CS1010 to spread out the load.\n\n\nWhile it is possible for you to complete the programming assignments on your own computers, the practical exams are done in a controlled environment using the desktop PCs in the programming labs.  It is therefore advisable for you to familiarize with accessing remote computing servers via \nssh\n and edit your program with either \nvim\n or \nmacro\n.\n\n\nBasic Requirements\n\n\n\n\n\n\nYou need to have an SoC UNIX account.  If you do not have one, you can \napply for one online\n.\n\n\n\n\n\n\nOnce you have an account, you need to [activate your access to the PE hosts] (\nhttps://mysoc.nus.edu.sg/~myacct/services.cgi\n), which is part of the SoC computer clusters.\n\n\n\n\n\n\nYou need an \nssh\n client.  MacOS and Linux users should already have it installed by default.  Windows 10 users should install \nthe Windows Subsystem for Linux\n and use Linux.\n\n\n\n\n\n\nFor older versions of Windows, such as those used in the SoC's programming labs, you can check out \nXShell 6\n (free for home/school use), or \nPuTTY\n.  These are GUI-based programs so the command lines instructions below do not apply.\n\n\nThe Command to SSH\n\n\nRun:\n\n1\nssh <username>@pe111.comp.nus.edu.sg\n\n\n\n\n\nReplace \n<username>\n with your SoC UNIX username, for instance, I would do:\n\n1\nssh ooiwt@pe111.comp.nus.edu.sg\n\n\n\n\n\nAfter the command above, following the instructions on the screen.  The first time you ever connect to \npe111.comp.nus.edu.sg\n, you will be warned that you are connecting to a previously unknown host.  Say \nyes\n, and you will be prompted with your SoC UNIX password.\n\n\nAccessing The PE Hosts from Outside SoC\n\n\nThe PE hosts can only be accessed from within the School of Computing networks.  If you want to access it from outside, there are two ways.\n\n\nUsing SoC VPN\n\n\nOne way is to set up a Virtual Private Network (VPN) (See \ninstruction here\n).  The staff at \nhelpdesk@comp.nus.edu.sg\n or the IT helpdesk in COM1, Level 1, will be able to help with you setting up if needed.\n\n\nTunneling through Sunfire\n\n\nThe alternative is to use ssh tunnels.\n\n\nSoC's Sunfire (\nsunfire.comp.nus.edu.sg\n) is configured to allow your connection if it's originating from a local telco. (See \nmore details here\n.)  Since \nsunfire\n is situated within the School of Computing network, \nsunfire\n is able to access the VM.  This opens the possibility of connecting from your device (using an Internet connection from a local telco) to \nsunfire\n, and then from \nsunfire\n to the VM.\n\n\nThere are two ways to achieve this, and in both ways it appears to the PE hosts that Sunfire is the client.\n\n\nSSH Using Sunfire's Terminal\n\n\nConnect to Sunfire at \nsunfire.comp.nus.edu.sg\n via your favorite SSH client.  After logging in, run the command \nssh pe111\n to connect to the programming environment.  This effectively starts an SSH session to the programming environment from within your existing SSH session to Sunfire.  Refer to instructions below on how to connect via SSH.\n\n\nSSH Port Forwarding\n\n\nSSH has built-in support for local and remote port forwarding, and local port forwarding can be used to connect to the programming environments.  Local port forwarding means that a port of the SSH client (your machine) is forwarded to the SSH server (\nsunfire\n), which opens a connection to a preset destination server (e.g., \npe111\n).  This method causes the host to seem as if it is hosted on a local port, e.g. \nlocalhost\n:\n1010\n, allowing you to use your favorite SCP program (e.g. \nFileZilla\n) to access the PE host.\n\n\nTo use local port forwarding (from local port \n1010\n), connect to \nsunfire\n using\n\n1\nssh -L 1010:pe111.comp.nus.edu.sg:22 <username>@sunfire.comp.nus.edu.sg\n\n\n\n\nThis command opens an SSH tunnel from port \n1010\n of your machine to port \n22\n (the default SSH port) of \npe111.comp.nus.edu.sg\n via \nsunfire\n.  After successful login, open a separate SSH (or SCP) connection from your machine to \nlocalhost\n at port \n1010\n to access the PE host:\n\n\n1\nssh <username>@localhost -p 1000\n\n\n\n\n\n\nPuTTY\n supports SSH port forwarding, so this setup can also be used on Windows.\n\n\nSetting up SSH Keys\n\n\nOnce you are comfortable with UNIX, you can set up a pair of public/private keys for authentication.  \n\n\nYou can use\n\n1\nssh-keygen -t rsa\n\n\n\n\n\nto generate a pair of keys on your local computer.  Keep the private key \nid_rsa\n on your local machine in the hidden \n~/.ssh\n directory, and copy the public key \nid_rsa.pub\n to your home directory on PE \npe111\n.  On \npe111\n, run\n\n1\ncat id_rsa.pub >> ~/.ssh/authorized_keys\n\n\n\n\n\nMake sure that the permission for \n.ssh\n both on local machine and on PE is set to \n700\n and the files \nid_rsa\n on local machine and \nauthorized_keys\n on remote machine is set to \n600\n.  Once setup, you need not enter your password every time you run \nssh\n or \nscp\n.",
            "title": "Programming Environments"
        },
        {
            "location": "/environments/index.html#the-cs1010-programming-environment",
            "text": "C is a common programming language and you can find different implementations of C compiler on many platforms.  Wikipedia  lists more than 40 different C compilers .  These different compilers support different processor architecture, operating system, may behave slightly differently, and may support different features of C standards.  It is therefore important for CS1010 to stick to a single platform and single compiler.  Our platform of choice is  Ubuntu 16.04 (or later)  using the  clang  compiler ( version 3.4.2 or later ).  The school has provided a list of computing servers for you to use.  You can access them remotely via  ssh , or secure shell.  The hosts are named  pe111 ,  pe112 , ...,  pe120 .  ( pe  stands for \"programming environment\").  You can choose which of the 10 hosts to use.  You share the same home directory across all 10 hosts (this home directory, however, is different from that of  sunfire ).  For simplicity, the following guide uses  pe111  in all examples.  Do keep in mind that you can use other hosts for CS1010 to spread out the load.  While it is possible for you to complete the programming assignments on your own computers, the practical exams are done in a controlled environment using the desktop PCs in the programming labs.  It is therefore advisable for you to familiarize with accessing remote computing servers via  ssh  and edit your program with either  vim  or  macro .",
            "title": "The CS1010 Programming Environment"
        },
        {
            "location": "/environments/index.html#basic-requirements",
            "text": "You need to have an SoC UNIX account.  If you do not have one, you can  apply for one online .    Once you have an account, you need to [activate your access to the PE hosts] ( https://mysoc.nus.edu.sg/~myacct/services.cgi ), which is part of the SoC computer clusters.    You need an  ssh  client.  MacOS and Linux users should already have it installed by default.  Windows 10 users should install  the Windows Subsystem for Linux  and use Linux.    For older versions of Windows, such as those used in the SoC's programming labs, you can check out  XShell 6  (free for home/school use), or  PuTTY .  These are GUI-based programs so the command lines instructions below do not apply.",
            "title": "Basic Requirements"
        },
        {
            "location": "/environments/index.html#the-command-to-ssh",
            "text": "Run: 1 ssh <username>@pe111.comp.nus.edu.sg   Replace  <username>  with your SoC UNIX username, for instance, I would do: 1 ssh ooiwt@pe111.comp.nus.edu.sg   After the command above, following the instructions on the screen.  The first time you ever connect to  pe111.comp.nus.edu.sg , you will be warned that you are connecting to a previously unknown host.  Say  yes , and you will be prompted with your SoC UNIX password.",
            "title": "The Command to SSH"
        },
        {
            "location": "/environments/index.html#accessing-the-pe-hosts-from-outside-soc",
            "text": "The PE hosts can only be accessed from within the School of Computing networks.  If you want to access it from outside, there are two ways.",
            "title": "Accessing The PE Hosts from Outside SoC"
        },
        {
            "location": "/environments/index.html#using-soc-vpn",
            "text": "One way is to set up a Virtual Private Network (VPN) (See  instruction here ).  The staff at  helpdesk@comp.nus.edu.sg  or the IT helpdesk in COM1, Level 1, will be able to help with you setting up if needed.",
            "title": "Using SoC VPN"
        },
        {
            "location": "/environments/index.html#tunneling-through-sunfire",
            "text": "The alternative is to use ssh tunnels.  SoC's Sunfire ( sunfire.comp.nus.edu.sg ) is configured to allow your connection if it's originating from a local telco. (See  more details here .)  Since  sunfire  is situated within the School of Computing network,  sunfire  is able to access the VM.  This opens the possibility of connecting from your device (using an Internet connection from a local telco) to  sunfire , and then from  sunfire  to the VM.  There are two ways to achieve this, and in both ways it appears to the PE hosts that Sunfire is the client.",
            "title": "Tunneling through Sunfire"
        },
        {
            "location": "/environments/index.html#ssh-using-sunfires-terminal",
            "text": "Connect to Sunfire at  sunfire.comp.nus.edu.sg  via your favorite SSH client.  After logging in, run the command  ssh pe111  to connect to the programming environment.  This effectively starts an SSH session to the programming environment from within your existing SSH session to Sunfire.  Refer to instructions below on how to connect via SSH.",
            "title": "SSH Using Sunfire's Terminal"
        },
        {
            "location": "/environments/index.html#ssh-port-forwarding",
            "text": "SSH has built-in support for local and remote port forwarding, and local port forwarding can be used to connect to the programming environments.  Local port forwarding means that a port of the SSH client (your machine) is forwarded to the SSH server ( sunfire ), which opens a connection to a preset destination server (e.g.,  pe111 ).  This method causes the host to seem as if it is hosted on a local port, e.g.  localhost : 1010 , allowing you to use your favorite SCP program (e.g.  FileZilla ) to access the PE host.  To use local port forwarding (from local port  1010 ), connect to  sunfire  using 1 ssh -L 1010:pe111.comp.nus.edu.sg:22 <username>@sunfire.comp.nus.edu.sg  \nThis command opens an SSH tunnel from port  1010  of your machine to port  22  (the default SSH port) of  pe111.comp.nus.edu.sg  via  sunfire .  After successful login, open a separate SSH (or SCP) connection from your machine to  localhost  at port  1010  to access the PE host:  1 ssh <username>@localhost -p 1000   PuTTY  supports SSH port forwarding, so this setup can also be used on Windows.",
            "title": "SSH Port Forwarding"
        },
        {
            "location": "/environments/index.html#setting-up-ssh-keys",
            "text": "Once you are comfortable with UNIX, you can set up a pair of public/private keys for authentication.    You can use 1 ssh-keygen -t rsa   to generate a pair of keys on your local computer.  Keep the private key  id_rsa  on your local machine in the hidden  ~/.ssh  directory, and copy the public key  id_rsa.pub  to your home directory on PE  pe111 .  On  pe111 , run 1 cat id_rsa.pub >> ~/.ssh/authorized_keys   Make sure that the permission for  .ssh  both on local machine and on PE is set to  700  and the files  id_rsa  on local machine and  authorized_keys  on remote machine is set to  600 .  Once setup, you need not enter your password every time you run  ssh  or  scp .",
            "title": "Setting up SSH Keys"
        },
        {
            "location": "/unix/index.html",
            "text": "Basic UNIX Commands\n\n\nUNIX-based operating systems provide a command line to interact with the system: to create directory, to manipulate files, to run certain applications.  While these tasks can be done through a GUI interface, a command line is still useful because (i) it provides a simple way to interacting with a remote system (only text are exchanged between the local and remote hosts instead of graphics); (ii) it is extremely flexible and provides many customization options; (iii) you can easily automate the sequence of commands to issue for repetitive tasks; and (iv) it is faster.  \n\n\nConnect to the Programming Environment (PE)\n\n\nIf you would like to follow the following examples, you should first \nssh\n into one of the PE hosts provided.  We will use \npe111\n in the following example.  But feel free to use \npe112\n up to \npe120\n for your practice.  You should read \nthis guide\n to see how to access and connect to the environment.\n\n\nOnce you are connected, you should see a prompt like this.\n\n\n1\nooiwt@pe111:~$\n\n\n\n\n\n\nThis interface is provided by a UNIX bash -- this shell sits in a loop and wait for users to enter a command, then it interprets and executes the command.  There are many versions of shells, the default shell for our PE is \nbash\n1\n.\n\n\nThe following is adapted for CS1010 from \nthe instructions created by Aaron Tan\n. Bugs are mine.\n  \n\n\nThe power of UNIX stems from the many commands it offers. The following are a few commonly used commands. This list is by no means exhaustive and you are urged to explore on your own. Note that UNIX commands are \ncase-sensitive\n.\n\n\nAll commands are to be entered after the UNIX prompt of the form\n\n\n1\nooiwt@pe111:~$\n\n\n\n\n\n\n~\n indicates that you are currently in your home directory.  The following examples assumes that user \nooiwt\n is logged into \npe111\n.\n\n\nIt might be good to understand the directory structure in UNIX, a multi-user system. The directory tree is shown below:\n\n\n\n\nEach user has his/her own home directory, which is where he/she will be automatically placed when he/she logs into the system. The above figure shows where the home directory of user \nooiwt\n resides in the directory tree. The user \nooiwt\n may create files or directories in his/her home directory, but not elsewhere unless permission is given.\n\n\npwd\n: Print Current Working directory\n\n\npwd\n shows you which directory you are currently in\n\n1\n2\nooiwt@pe111:~$ pwd\n/home/o/ooiwt\n\n\n\n\n\nUNIX uses forward slash \n/\n to deliminate different parts of the directory structure.  This is the same notation as URLs so you should already be familiar with it.\n\n\nls\n: LiSt files\n\n\nThe \nls\n list the files in the current working directory.\n\n\n1\n2\nooiwt@pe111:~$ ls\nooiwt@pe111:~$\n\n\n\n\n\n\nIf you do not have any regular files in your home directory, as you should when you first login, you should immediately return to the bash prompt.  \n\n\n\n\nRule of Silence\n\n\nUNIX follows the \nrule of silence\n: programs should not print unnecessary output, to allow other programs and users to easily parse the output from one program.  So, if \nls\n has nothing to list, it will list nothing (as oppose to, say, printing \"This is an empty directory.\")\n\n\n\n\nmkdir\n: MaKe a subDIRectory\n\n\nThe \nmkdir\n command creates a subdirectory with the given name in the current directory.\n\n\n1\n2\n3\n4\n5\nooiwt@pe111:~$ mkdir tut01\nooiwt@pe111:~$ ls\ntut01\nooiwt@pe111:~$ ls -F\ntut01/\n\n\n\n\n\n\nHere, you create a directory called \ntut01\n.  Now, when you \nls\n, you can see the directory listed.\n\n\nYou may also use \nls -F\n for more information (\n-F\n is one of the many \noptions\n/\nflags\n available for the \nls\n command. To see a complete list of the options, refer to the man pages, i.e., \nman ls\n.)\n\n\nThe slash \n/\n beside the filename tells you that the file is a directory (aka folder in Windows lingo). A normal file does not have a slash beside its name when \"ls -F\" is used.\n\n\nYou may also use the \nls -l\n command (hyphen el, not hyphen one) to display almost all the file information, include the size of the file and the date of modification.\n\n\n\n\nUse Up Arrow for Command History\n\n\nUNIX maintains a history of your previously executed UNIX commands, and you may use the up and down arrows to go through it. Press the up arrow until you find a previously executed UNIX command. You may then press Enter to execute it, or edit the command before executing it. This is handy when you need to repeatedly executed a long UNIX command.\n\n\n\n\ncd\n: Change Directory\n\n\nTo navigate in the directory tree, changing the current working directory from to another, we use the \ncd\n command.\n\n\n1\n2\nooiwt@pe111:~$ cd tut01\nooiwt@pe111:~/tut01$\n\n\n\n\nNote that the prompt changes to \n~/tut01\n to indicate that you are now in the \ntut01\n directory below your \nHOME\n directory.\n\n\nEntering \ncd\n alone brings you back to your \nHOME\n directory, i.e., the directory in which you started with when you first logged into the system.\n\n1\n2\nooiwt@pe111:~/tut01$ cd\nooiwt@pe111:~$\n\n\n\n\n\nTwo dots \n..\n refers to the parent directory.  So, alternatively, for the case above, since we are only one level down from the \nHOME\n, to return to home, we can alternatively use \ncd ..\n.\n\n\n1\n2\nooiwt@pe111:~/tut01$ cd ..\nooiwt@pe111:~$\n\n\n\n\n\n\nrmdir\n: ReMove a subDIRectory\n\n\nrmdir\n removes a subDIRectory in current directory -- note that a directory must be empty before it can be removed.\n\n\n1\n2\n3\n4\n5\nooiwt@pe111:~$ rmdir tut01\nooiwt@pe111:~$ ls -F\nooiwt@pe111:~$ mkdir tut01\nooiwt@pe111:~$ ls -F\ntut01/\n\n\n\n\n\n\ncp\n: CoPy files\n\n\n1\n2\n3\nooiwt@pe111:~/tut01$ cp ~cs1010/tut01/hello.c .\nooiwt@pe111:~/tut01$ ls\nhello.c\n\n\n\n\nThe command above copies the file \nhello.c\n from the HOME of user \ncs1010\n, under directory \ntut01\n, to the current directory.\n\n\nIf you want to copy the whole directory, use \n-r\n flag, where \nr\n stands for recursive copy.\n\n\n1\nooiwt@pe111:~/tut01$ cp -r ~cs1010/tut01 .\n\n\n\n\n\n\nIn the last command above, the single \n.\n refers to the current directory.  \n\n\nThe directory \ntut01\n and everything under it will be copied to the current directory.\n\n\nmv\n: MoVe or rename files\n\n\nmv\n can move files from one directory to another.\n\n\n1\n2\n3\n4\n5\n6\n7\nooiwt@pe111:~/tut01$ ls\nhello.c\nooiwt@pe111:~/tut01$ mv hello.c ..\nooiwt@pe111:~/tut01$ ls\nooiwt@pe111:~/tut01$ ls ..\nhello.c\nooiwt@pe111:~/tut01$ mv ../hello.c .\n\n\n\n\n\n\nHere, we tell \nmv\n to copy a file \nhello.c\n from the parent directory to the current directory.\n\n\nmv\n can also be used to rename files.\n\n\n1\n2\n3\nooiwt@pe111:~/tut01$ mv hello.c hello_world.c\nooiwt@pe111:~/tut01$ ls\nhello_world.c\n\n\n\n\n\n\n\n\nUse TAB for Name Completion\n\n\nIf you have a very long file name, you may use UNIX's filename completion feature to reduce typing. For instance, you may type:\n\n1\nooiwt@pe111:~/tut01$ mv h\n\n\n\n\nand press the tab key, and UNIX will complete the filename for you if there is only one filename with the prefix \"h\". Otherwise, it will fill up the filename up to point where you need to type in more characters for disambiguation.\nThe tab key can also complete the name of command.\n\n\n\n\nrm\n: ReMove files\n\n\nBe careful with this command -- files deleted cannot be restored.  There is no trash or recycled bin like in Mac or Windows.\n\n\n1\n2\n3\nooiwt@pe111:~/tut01$ rm hello.c\nooiwt@pe111:~/tut01$ ls\nooiwt@pe111:~/tut01$\n\n\n\n\n\n\n\n\nrm -rf *\n\n\nWhile UNIX command line provides lots of flexibility and power, with great power comes great responsibility.  Some of the commands are extremely dangerous.  \nrm -rf *\n is the most famous one.  The notation \n*\n refers to all files, and the flag \n-f\n means forceful deletion (no question asked!) and \n-r\n means remove recursively everything under the current directory tree.  Accidentally running this command has ruined many files.  \nRead more here\n\n\n\n\nrm\n comes with a \n-i\n flag that interactively ask you if you are sure if you want to delete a file.  It is a good idea to always run \nrm -i\n.  On \npe111\n, we have configured everyone's account so that \nrm\n is aliased to \nrm -i\n by default.  So when you run \nrm hello.c\n, it actually runs \nrm -i hello.c\n.  \n\n\n1\n2\nooiwt@pe111:~/tut01$ rm hello.c\nrm: remove regular file \n'hello.c'\n? \n\n\n\n\n\n\nType \ny\n or \nn\n to answer yes or no respectively.\n\n\nIf you setup your own UNIX OS, you should add this alias \n\n\n1\nalias\n \nrm\n=\n\"rm -i\"\n\n\n\n\n\n\n\nto your \n.bashrc\n (Google to find out how).  Other useful aliases to avoid accidentally overwriting existing files are:\n\n\n1\n2\nalias\n \nmv\n=\n\"mv -i\"\n\n\nalias\n \ncp\n=\n\"cp -i\"\n\n\n\n\n\n\n\ncat\n: CATenate file content to screen\n\n\n1\nooiwt@pe111:~/tut01$ cat hello.c\n\n\n\n\n\n\nless\n is variant of \ncat\n that includes features to read each page leisurely)\n\n1\nooiwt@pe111:~/tut01$ less hello.c\n\n\n\n\n\nIn \nless\n, use \n<space>\n to move down one page, \nb\n to move Back up one page, and \nq\n to Quit.\n\n\nman\n: Online MANual\n\n\nAn online help facility is available in UNIX via the \nman\n command (\nman\n stands for MANual). To look for more information about any UNIX command, for example, \nls\n, type \nman ls\n. Type \nman man\n and refer to Man Pages to find out more about the facility. To exit \nman\n, press \nq\n.\n\n\nNow that you are familiar with how the UNIX bash works, I won't show the command prompt any more in the rest of this article.\n\n\nchmod\n: Changing UNIX File Permission\n\n\nIt is important to guide our files properly on a multi-user system where users share the same file system.  UNIX has a simple mechanism to for ensuring that: every file and directory has nine bits of access permission, corresponds to three access operations, read (\nr\n), write (\nw\n), and execute (\nx\n), for four classes of users, the user who owns of the file (\nu\n), users in the same group as the owner (\ng\n), all other users (\no\n), and all users (\na\n) (union of all three classes before)\n\n\nWhen you run \nls -l\n, you will see the permission encoded as strings that look like \n-rw-------\n or \ndrwx--x--x\n besides other file information.   \n\n\n\n\nThe first character indicates if the file is a directory (\nd\n) or not (\n-\n).  \n\n\nThe next three characters are the permission for the owner.  \nrwx\n means that the owner can do all three: reading, writing, and executing, \nrw-\n means that the owner can read and write, but cannot execute.\n\n\nThe next three characters are the permission for the users in the same group.\n\n\nThe last three characters are the permission for the users in the other groups.\n\n\n\n\nTo change permission, we use the \nchmod\n command.  Let's say that we want to remove the read and write permission from all other users in the group.  You can run:\n\n\n1\nchmod g-rw <file>\n\n\n\n\n\n\nwhere \n<file>\n is the name of the file whose permission you want to change.  This would change the permission from \n-rw-rw-rw-\n to \n-rw----rw-\n, or from \n-rwxr--r--\n to \n-rwx---r--\n.\n\n\nTo add executable permission to everyone, you can run:\n\n\n1\nchmod a+x <file>\n\n\n\n\n\n\nThis would change the permission from \n-rw-rw-rw-\n to \n-rwx--xrwx\n \n-rwxrwxrwx\n, or from \n-rwxr--r--\n to \n-rwx--xr-x\n \n-rwxr-xr-x\n, and so on.  You get the idea.\n\n\nAnother way to change the permission is set the permission directly, instead of adding with \n+\n and removing with \n-\n.  To do this, one convenient way is to treat the permission for each class of user as a 3-bit binary number between 0 to 7.  So, \nrwx\n is 7, \nrw-\n is 6, \n-w-\n is 2, \n---\n is 0, etc.  \n\n\nTo set the permission of a file to \n-r--r--r--\n (readable by everyone), run:\n\n\n1\nchmod \n444\n <file>\n\n\n\n\n\n\nTo set the permission to \n-rw-------\n, run:\n\n\n1\nchmod \n600\n <file>\n\n\n\n\n\n\nand so on.\n\n\nIt is important to ensure that your code is not readable and writable by other students, especially for graded lab exercises.\n\n\nscp\n: Secure Copy\n\n\nSecure copy, or \nscp\n, is one way to transfer files from the programming environments to your local computer for archiving or storage.  Let's say you want to transfer a set of C files from the directory \na01\n to your local computer, then, on your local computer, run:\n\n\n1\nooiwt@macbook:~$ scp ooiwt@pe111:~/a01/*.c .\n\n\n\n\n\n\n\n\nWarning\n\n\nIf you have files with the same name in the remote directory, the files will be overwritten without warning.  I have lost my code a few times due to \nscp\n.  \n\n\n\n\nThe expression \n*.c\n is a \nregular expression\n that means all files with filename ending with \n.c\n.  You can copy specific files as well.  For instance,\n\n\n1\nooiwt@macbook:~$ scp ooiwt@pe111:~/a01/hello.c .\n\n\n\n\n\n\nscp\n supports \n-r\n (recursive copy) as well.\n\n\nSpecifying A Path in UNIX\n\n\nIn any command above, when we need to refer to a directory or a file, we need to specify an \nunambiguous location\n of the directory or the file.  The most precise way to specify the location is to use the full path, or the \nabsolute path\n.  For instance:\n\n\n1\ncp /home/o/ooiwt/tut01/hello.c /home/o/ooiwt/tut01/hello_world.c\n\n\n\n\n\n\nThat's a lot of characters to type.  We could shorten it in a few ways.  \n\n\n\n\nWe could specify the location with respect to the home directory using \n~\n.  \n~ooiwt\n refers to the home directory of user \nooiwt\n.  \n\n\n\n\n1\ncp ~ooiwt/tut01/hello.c ~ooiwt/tut01/hello_world.c\n\n\n\n\n\n\nIf you are \nooiwt\n, then you can omit \nooiwt\n, since \n~\n without any username refers to your home directory.\n\n\n1\ncp ~/tut01/hello.c ~/tut01/hello_world.c\n\n\n\n\n\n\n\n\nOr we could specify the location with respect to the current directory.  Suppose the current working directory is \n~/tut01\n (i.e., we have \ncd\n into \n~/tut01\n), then we could say this:\n\n\n\n\n1\ncp ./hello.c ./hello_world.c\n\n\n\n\n\n\nRecall that a single dot \n.\n refers to the current directory.\n\n\nThe \n./\n however is redundant unless you are executing a command.  Since, by specifying a file name or a directory without a path (i.e., not using any \n/\n), the bash looks for the file or directory in the current directory.  So, we could just do:\n\n\n1\ncp hello.c hello_world.c\n\n\n\n\n\n\nAnother important short form for relative location is \n..\n.  Recall that this refers to the parent directory.  Suppose that the current directory is in \n~/tut02\n.  Then, to copy the files in \n~/tut01\n, you can run:\n\n\n1\ncp ../tut01/hello.c ../tut01/hello_world.c\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nI run \nfish\n on my macOS, as you might have noticed during the in-class demos.  You can use any bash you like, if you know what you are doing.  Otherwise, \nbash\n is a popular one.\u00a0\n\u21a9",
            "title": "UNIX"
        },
        {
            "location": "/unix/index.html#basic-unix-commands",
            "text": "UNIX-based operating systems provide a command line to interact with the system: to create directory, to manipulate files, to run certain applications.  While these tasks can be done through a GUI interface, a command line is still useful because (i) it provides a simple way to interacting with a remote system (only text are exchanged between the local and remote hosts instead of graphics); (ii) it is extremely flexible and provides many customization options; (iii) you can easily automate the sequence of commands to issue for repetitive tasks; and (iv) it is faster.",
            "title": "Basic UNIX Commands"
        },
        {
            "location": "/unix/index.html#connect-to-the-programming-environment-pe",
            "text": "If you would like to follow the following examples, you should first  ssh  into one of the PE hosts provided.  We will use  pe111  in the following example.  But feel free to use  pe112  up to  pe120  for your practice.  You should read  this guide  to see how to access and connect to the environment.  Once you are connected, you should see a prompt like this.  1 ooiwt@pe111:~$   This interface is provided by a UNIX bash -- this shell sits in a loop and wait for users to enter a command, then it interprets and executes the command.  There are many versions of shells, the default shell for our PE is  bash 1 .  The following is adapted for CS1010 from  the instructions created by Aaron Tan . Bugs are mine.     The power of UNIX stems from the many commands it offers. The following are a few commonly used commands. This list is by no means exhaustive and you are urged to explore on your own. Note that UNIX commands are  case-sensitive .  All commands are to be entered after the UNIX prompt of the form  1 ooiwt@pe111:~$   ~  indicates that you are currently in your home directory.  The following examples assumes that user  ooiwt  is logged into  pe111 .  It might be good to understand the directory structure in UNIX, a multi-user system. The directory tree is shown below:   Each user has his/her own home directory, which is where he/she will be automatically placed when he/she logs into the system. The above figure shows where the home directory of user  ooiwt  resides in the directory tree. The user  ooiwt  may create files or directories in his/her home directory, but not elsewhere unless permission is given.",
            "title": "Connect to the Programming Environment (PE)"
        },
        {
            "location": "/unix/index.html#pwd-print-current-working-directory",
            "text": "pwd  shows you which directory you are currently in 1\n2 ooiwt@pe111:~$ pwd\n/home/o/ooiwt   UNIX uses forward slash  /  to deliminate different parts of the directory structure.  This is the same notation as URLs so you should already be familiar with it.",
            "title": "pwd: Print Current Working directory"
        },
        {
            "location": "/unix/index.html#ls-list-files",
            "text": "The  ls  list the files in the current working directory.  1\n2 ooiwt@pe111:~$ ls\nooiwt@pe111:~$   If you do not have any regular files in your home directory, as you should when you first login, you should immediately return to the bash prompt.     Rule of Silence  UNIX follows the  rule of silence : programs should not print unnecessary output, to allow other programs and users to easily parse the output from one program.  So, if  ls  has nothing to list, it will list nothing (as oppose to, say, printing \"This is an empty directory.\")",
            "title": "ls: LiSt files"
        },
        {
            "location": "/unix/index.html#mkdir-make-a-subdirectory",
            "text": "The  mkdir  command creates a subdirectory with the given name in the current directory.  1\n2\n3\n4\n5 ooiwt@pe111:~$ mkdir tut01\nooiwt@pe111:~$ ls\ntut01\nooiwt@pe111:~$ ls -F\ntut01/   Here, you create a directory called  tut01 .  Now, when you  ls , you can see the directory listed.  You may also use  ls -F  for more information ( -F  is one of the many  options / flags  available for the  ls  command. To see a complete list of the options, refer to the man pages, i.e.,  man ls .)  The slash  /  beside the filename tells you that the file is a directory (aka folder in Windows lingo). A normal file does not have a slash beside its name when \"ls -F\" is used.  You may also use the  ls -l  command (hyphen el, not hyphen one) to display almost all the file information, include the size of the file and the date of modification.   Use Up Arrow for Command History  UNIX maintains a history of your previously executed UNIX commands, and you may use the up and down arrows to go through it. Press the up arrow until you find a previously executed UNIX command. You may then press Enter to execute it, or edit the command before executing it. This is handy when you need to repeatedly executed a long UNIX command.",
            "title": "mkdir: MaKe a subDIRectory"
        },
        {
            "location": "/unix/index.html#cd-change-directory",
            "text": "To navigate in the directory tree, changing the current working directory from to another, we use the  cd  command.  1\n2 ooiwt@pe111:~$ cd tut01\nooiwt@pe111:~/tut01$  \nNote that the prompt changes to  ~/tut01  to indicate that you are now in the  tut01  directory below your  HOME  directory.  Entering  cd  alone brings you back to your  HOME  directory, i.e., the directory in which you started with when you first logged into the system. 1\n2 ooiwt@pe111:~/tut01$ cd\nooiwt@pe111:~$   Two dots  ..  refers to the parent directory.  So, alternatively, for the case above, since we are only one level down from the  HOME , to return to home, we can alternatively use  cd .. .  1\n2 ooiwt@pe111:~/tut01$ cd ..\nooiwt@pe111:~$",
            "title": "cd: Change Directory"
        },
        {
            "location": "/unix/index.html#rmdir-remove-a-subdirectory",
            "text": "rmdir  removes a subDIRectory in current directory -- note that a directory must be empty before it can be removed.  1\n2\n3\n4\n5 ooiwt@pe111:~$ rmdir tut01\nooiwt@pe111:~$ ls -F\nooiwt@pe111:~$ mkdir tut01\nooiwt@pe111:~$ ls -F\ntut01/",
            "title": "rmdir: ReMove a subDIRectory"
        },
        {
            "location": "/unix/index.html#cp-copy-files",
            "text": "1\n2\n3 ooiwt@pe111:~/tut01$ cp ~cs1010/tut01/hello.c .\nooiwt@pe111:~/tut01$ ls\nhello.c  \nThe command above copies the file  hello.c  from the HOME of user  cs1010 , under directory  tut01 , to the current directory.  If you want to copy the whole directory, use  -r  flag, where  r  stands for recursive copy.  1 ooiwt@pe111:~/tut01$ cp -r ~cs1010/tut01 .   In the last command above, the single  .  refers to the current directory.    The directory  tut01  and everything under it will be copied to the current directory.",
            "title": "cp: CoPy files"
        },
        {
            "location": "/unix/index.html#mv-move-or-rename-files",
            "text": "mv  can move files from one directory to another.  1\n2\n3\n4\n5\n6\n7 ooiwt@pe111:~/tut01$ ls\nhello.c\nooiwt@pe111:~/tut01$ mv hello.c ..\nooiwt@pe111:~/tut01$ ls\nooiwt@pe111:~/tut01$ ls ..\nhello.c\nooiwt@pe111:~/tut01$ mv ../hello.c .   Here, we tell  mv  to copy a file  hello.c  from the parent directory to the current directory.  mv  can also be used to rename files.  1\n2\n3 ooiwt@pe111:~/tut01$ mv hello.c hello_world.c\nooiwt@pe111:~/tut01$ ls\nhello_world.c    Use TAB for Name Completion  If you have a very long file name, you may use UNIX's filename completion feature to reduce typing. For instance, you may type: 1 ooiwt@pe111:~/tut01$ mv h  \nand press the tab key, and UNIX will complete the filename for you if there is only one filename with the prefix \"h\". Otherwise, it will fill up the filename up to point where you need to type in more characters for disambiguation.\nThe tab key can also complete the name of command.",
            "title": "mv: MoVe or rename files"
        },
        {
            "location": "/unix/index.html#rm-remove-files",
            "text": "Be careful with this command -- files deleted cannot be restored.  There is no trash or recycled bin like in Mac or Windows.  1\n2\n3 ooiwt@pe111:~/tut01$ rm hello.c\nooiwt@pe111:~/tut01$ ls\nooiwt@pe111:~/tut01$    rm -rf *  While UNIX command line provides lots of flexibility and power, with great power comes great responsibility.  Some of the commands are extremely dangerous.   rm -rf *  is the most famous one.  The notation  *  refers to all files, and the flag  -f  means forceful deletion (no question asked!) and  -r  means remove recursively everything under the current directory tree.  Accidentally running this command has ruined many files.   Read more here   rm  comes with a  -i  flag that interactively ask you if you are sure if you want to delete a file.  It is a good idea to always run  rm -i .  On  pe111 , we have configured everyone's account so that  rm  is aliased to  rm -i  by default.  So when you run  rm hello.c , it actually runs  rm -i hello.c .    1\n2 ooiwt@pe111:~/tut01$ rm hello.c\nrm: remove regular file  'hello.c' ?    Type  y  or  n  to answer yes or no respectively.  If you setup your own UNIX OS, you should add this alias   1 alias   rm = \"rm -i\"    to your  .bashrc  (Google to find out how).  Other useful aliases to avoid accidentally overwriting existing files are:  1\n2 alias   mv = \"mv -i\"  alias   cp = \"cp -i\"",
            "title": "rm: ReMove files"
        },
        {
            "location": "/unix/index.html#cat-catenate-file-content-to-screen",
            "text": "1 ooiwt@pe111:~/tut01$ cat hello.c   less  is variant of  cat  that includes features to read each page leisurely) 1 ooiwt@pe111:~/tut01$ less hello.c   In  less , use  <space>  to move down one page,  b  to move Back up one page, and  q  to Quit.",
            "title": "cat: CATenate file content to screen"
        },
        {
            "location": "/unix/index.html#man-online-manual",
            "text": "An online help facility is available in UNIX via the  man  command ( man  stands for MANual). To look for more information about any UNIX command, for example,  ls , type  man ls . Type  man man  and refer to Man Pages to find out more about the facility. To exit  man , press  q .  Now that you are familiar with how the UNIX bash works, I won't show the command prompt any more in the rest of this article.",
            "title": "man: Online MANual"
        },
        {
            "location": "/unix/index.html#chmod-changing-unix-file-permission",
            "text": "It is important to guide our files properly on a multi-user system where users share the same file system.  UNIX has a simple mechanism to for ensuring that: every file and directory has nine bits of access permission, corresponds to three access operations, read ( r ), write ( w ), and execute ( x ), for four classes of users, the user who owns of the file ( u ), users in the same group as the owner ( g ), all other users ( o ), and all users ( a ) (union of all three classes before)  When you run  ls -l , you will see the permission encoded as strings that look like  -rw-------  or  drwx--x--x  besides other file information.      The first character indicates if the file is a directory ( d ) or not ( - ).    The next three characters are the permission for the owner.   rwx  means that the owner can do all three: reading, writing, and executing,  rw-  means that the owner can read and write, but cannot execute.  The next three characters are the permission for the users in the same group.  The last three characters are the permission for the users in the other groups.   To change permission, we use the  chmod  command.  Let's say that we want to remove the read and write permission from all other users in the group.  You can run:  1 chmod g-rw <file>   where  <file>  is the name of the file whose permission you want to change.  This would change the permission from  -rw-rw-rw-  to  -rw----rw- , or from  -rwxr--r--  to  -rwx---r-- .  To add executable permission to everyone, you can run:  1 chmod a+x <file>   This would change the permission from  -rw-rw-rw-  to  -rwx--xrwx   -rwxrwxrwx , or from  -rwxr--r--  to  -rwx--xr-x   -rwxr-xr-x , and so on.  You get the idea.  Another way to change the permission is set the permission directly, instead of adding with  +  and removing with  - .  To do this, one convenient way is to treat the permission for each class of user as a 3-bit binary number between 0 to 7.  So,  rwx  is 7,  rw-  is 6,  -w-  is 2,  ---  is 0, etc.    To set the permission of a file to  -r--r--r--  (readable by everyone), run:  1 chmod  444  <file>   To set the permission to  -rw------- , run:  1 chmod  600  <file>   and so on.  It is important to ensure that your code is not readable and writable by other students, especially for graded lab exercises.",
            "title": "chmod: Changing UNIX File Permission"
        },
        {
            "location": "/unix/index.html#scp-secure-copy",
            "text": "Secure copy, or  scp , is one way to transfer files from the programming environments to your local computer for archiving or storage.  Let's say you want to transfer a set of C files from the directory  a01  to your local computer, then, on your local computer, run:  1 ooiwt@macbook:~$ scp ooiwt@pe111:~/a01/*.c .    Warning  If you have files with the same name in the remote directory, the files will be overwritten without warning.  I have lost my code a few times due to  scp .     The expression  *.c  is a  regular expression  that means all files with filename ending with  .c .  You can copy specific files as well.  For instance,  1 ooiwt@macbook:~$ scp ooiwt@pe111:~/a01/hello.c .   scp  supports  -r  (recursive copy) as well.",
            "title": "scp: Secure Copy"
        },
        {
            "location": "/unix/index.html#specifying-a-path-in-unix",
            "text": "In any command above, when we need to refer to a directory or a file, we need to specify an  unambiguous location  of the directory or the file.  The most precise way to specify the location is to use the full path, or the  absolute path .  For instance:  1 cp /home/o/ooiwt/tut01/hello.c /home/o/ooiwt/tut01/hello_world.c   That's a lot of characters to type.  We could shorten it in a few ways.     We could specify the location with respect to the home directory using  ~ .   ~ooiwt  refers to the home directory of user  ooiwt .     1 cp ~ooiwt/tut01/hello.c ~ooiwt/tut01/hello_world.c   If you are  ooiwt , then you can omit  ooiwt , since  ~  without any username refers to your home directory.  1 cp ~/tut01/hello.c ~/tut01/hello_world.c    Or we could specify the location with respect to the current directory.  Suppose the current working directory is  ~/tut01  (i.e., we have  cd  into  ~/tut01 ), then we could say this:   1 cp ./hello.c ./hello_world.c   Recall that a single dot  .  refers to the current directory.  The  ./  however is redundant unless you are executing a command.  Since, by specifying a file name or a directory without a path (i.e., not using any  / ), the bash looks for the file or directory in the current directory.  So, we could just do:  1 cp hello.c hello_world.c   Another important short form for relative location is  .. .  Recall that this refers to the parent directory.  Suppose that the current directory is in  ~/tut02 .  Then, to copy the files in  ~/tut01 , you can run:  1 cp ../tut01/hello.c ../tut01/hello_world.c       I run  fish  on my macOS, as you might have noticed during the in-class demos.  You can use any bash you like, if you know what you are doing.  Otherwise,  bash  is a popular one.\u00a0 \u21a9",
            "title": "Specifying A Path in UNIX"
        },
        {
            "location": "/clang/index.html",
            "text": "CS1010 Compilation Guide\n\n\n1. Compile a standalone C program\n\n\nSuppose we have a standalone C program \nteh.c\n that does not use any external libraries.  We can compile the program using the command\n\n\n1\nooiwt@pe118:~$ clang teh.c\n\n\n\n\n\n\nThis command should create an executable called \na.out\n in the current directory, which you can then run with:\n\n\n1\nooiwt@pe118:~$ ./a.out\n\n\n\n\n\n\n2. Renaming executable file\n\n\nThe name \na.out\n is an abbreviation for \nassembler output\n, a name that many compilers kept as the default output name since the 60s.  We should, however, give our executable more descriptive name, by using the \n-o\n flag.  (\no\n is the mnemonic for output).\n\n\n1\nooiwt@pe118:~$ clang teh.c -o teh\n\n\n\n\n\n\nor\n\n\n1\nooiwt@pe118:~$ clang -o teh teh.c\n\n\n\n\n\n\nThe command above would create an executable called \nteh\n.\n\n\n\n\nBeware of the order\n\n\nIf you are not careful and run the following command instead:\n\n1\nooiwt@pe118:~$ clang -o teh.c teh\n\n\n\n\n\nclang\n would overwrite your code \nteh.c\n -- all your hard work will be gone!!\n\n\n\n\n3. Warning for possible bugs.\n\n\nThe \nclang\n checks for syntax errors in your C files -- i.e., things that violate the C syntax rules.  The compiler, however, is smart enough to identify possible bugs -- errors that will cause your program to behave incorrectly, even if the syntax follows C's rules.  You can ask \nclang\n to warn you about this, using the \n-W\n flag (\nW\n is the mnemonic for warning -- note the capital W).  The manual for \nclang\n lists different types of warnings that \nclang\n can warn you about.  For simplicity, we will ask \nclang\n to warn us about everything, by enabling \nall\n warnings.  The command to do so is:\n\n\n1\nooiwt@pe118:~$ clang -Wall teh.c -o teh\n\n\n\n\n\n\nFor beginners, it is \nhighly recommended\n that you \nalways\n compile with \n-Wall\n flag.\n\n\n4. Generating additional information for debugging.\n\n\nIn order to use the debugger \nlldb\n to trace through and debug your program, \nclang\n needs to generate additional information and store them in the executable file.  We can instruct \nclang\n to generate them with the flag \n-g\n (\ng\n for generate).  \n\n\n1\nooiwt@pe118:~$ clang -Wall -g teh.c -o teh\n\n\n\n\n\n\nIt is recommended that you always compile with \n-g\n flags during development phase.  If you need to measure the performance (e.g., how fast it runs) of your program or when you are releasing the program to the public, you can remove the \n-g\n flag and compile with the optimization flags (e.g., \n-O\n) instead.  \n\n\n5. Linking with standard library.\n\n\nTo link with a standard library, we use the \n-l\n flag to specify the name of the library to link.  For instance, to link with the C standard math library (abbreviated \nm\n), you issue the command:\n\n\n1\nooiwt@pe118:~$ clang -Wall -g teh.c -o teh -lm\n\n\n\n\n\n\n6. Linking with 3\nrd\n party library\n\n\nBy default, \nclang\n looks for headers and libraries in the systems directories (\n/usr/include\n, \n/usr/lib\n, etc) and the current working directory.  \n\n\nIf you use a third party library, you usually need to tell \nclang\n where to look for the corresponding headers and libraries.  You can use the \n-I\n flag and the \n-L\n flag for these purposes. For instance, if you have a library installed under your home called \ncitadel\n, and the file \ncitadel.h\n can be found under \n~/citadel/include\n and the file \nlibcitadel.a\n can be found under \n~/citadel/lib\n, to tell \nclang\n where to find these files, you can compile with:\n\n\n1\nooiwt@pe118:~$ clang -Wall -g -I ~/citadel/include -L ~/citadel/lib teh.c -o teh -lm -lcitadel",
            "title": "CLang"
        },
        {
            "location": "/clang/index.html#cs1010-compilation-guide",
            "text": "",
            "title": "CS1010 Compilation Guide"
        },
        {
            "location": "/clang/index.html#1-compile-a-standalone-c-program",
            "text": "Suppose we have a standalone C program  teh.c  that does not use any external libraries.  We can compile the program using the command  1 ooiwt@pe118:~$ clang teh.c   This command should create an executable called  a.out  in the current directory, which you can then run with:  1 ooiwt@pe118:~$ ./a.out",
            "title": "1. Compile a standalone C program"
        },
        {
            "location": "/clang/index.html#2-renaming-executable-file",
            "text": "The name  a.out  is an abbreviation for  assembler output , a name that many compilers kept as the default output name since the 60s.  We should, however, give our executable more descriptive name, by using the  -o  flag.  ( o  is the mnemonic for output).  1 ooiwt@pe118:~$ clang teh.c -o teh   or  1 ooiwt@pe118:~$ clang -o teh teh.c   The command above would create an executable called  teh .   Beware of the order  If you are not careful and run the following command instead: 1 ooiwt@pe118:~$ clang -o teh.c teh   clang  would overwrite your code  teh.c  -- all your hard work will be gone!!",
            "title": "2. Renaming executable file"
        },
        {
            "location": "/clang/index.html#3-warning-for-possible-bugs",
            "text": "The  clang  checks for syntax errors in your C files -- i.e., things that violate the C syntax rules.  The compiler, however, is smart enough to identify possible bugs -- errors that will cause your program to behave incorrectly, even if the syntax follows C's rules.  You can ask  clang  to warn you about this, using the  -W  flag ( W  is the mnemonic for warning -- note the capital W).  The manual for  clang  lists different types of warnings that  clang  can warn you about.  For simplicity, we will ask  clang  to warn us about everything, by enabling  all  warnings.  The command to do so is:  1 ooiwt@pe118:~$ clang -Wall teh.c -o teh   For beginners, it is  highly recommended  that you  always  compile with  -Wall  flag.",
            "title": "3. Warning for possible bugs."
        },
        {
            "location": "/clang/index.html#4-generating-additional-information-for-debugging",
            "text": "In order to use the debugger  lldb  to trace through and debug your program,  clang  needs to generate additional information and store them in the executable file.  We can instruct  clang  to generate them with the flag  -g  ( g  for generate).    1 ooiwt@pe118:~$ clang -Wall -g teh.c -o teh   It is recommended that you always compile with  -g  flags during development phase.  If you need to measure the performance (e.g., how fast it runs) of your program or when you are releasing the program to the public, you can remove the  -g  flag and compile with the optimization flags (e.g.,  -O ) instead.",
            "title": "4. Generating additional information for debugging."
        },
        {
            "location": "/clang/index.html#5-linking-with-standard-library",
            "text": "To link with a standard library, we use the  -l  flag to specify the name of the library to link.  For instance, to link with the C standard math library (abbreviated  m ), you issue the command:  1 ooiwt@pe118:~$ clang -Wall -g teh.c -o teh -lm",
            "title": "5. Linking with standard library."
        },
        {
            "location": "/clang/index.html#6-linking-with-3rd-party-library",
            "text": "By default,  clang  looks for headers and libraries in the systems directories ( /usr/include ,  /usr/lib , etc) and the current working directory.    If you use a third party library, you usually need to tell  clang  where to look for the corresponding headers and libraries.  You can use the  -I  flag and the  -L  flag for these purposes. For instance, if you have a library installed under your home called  citadel , and the file  citadel.h  can be found under  ~/citadel/include  and the file  libcitadel.a  can be found under  ~/citadel/lib , to tell  clang  where to find these files, you can compile with:  1 ooiwt@pe118:~$ clang -Wall -g -I ~/citadel/include -L ~/citadel/lib teh.c -o teh -lm -lcitadel",
            "title": "6. Linking with 3rd party library"
        },
        {
            "location": "/vim/index.html",
            "text": "Vim Tips\n\n\nI collected below some tips on \nvim\n that I find helpful.  If you are new to \nvim\n, please try out the command \nvimtutor\n on any machine where \nvim\n is installed, and check out the nice article \nLearn vim Progressively\n.  \n\n\n1. Useful Configuration\n\n\nYou can configure your \nvim\n by putting your configuration options and scripts in the \n~/.vimrc\n file (a hidden file named \n.vimrc\n in your home directory).  This file will be loaded whenever you starts \nvim\n.\n\n\nYou can copy a sample \n.vimrc\n file from \n~cs1010/.vimrc\n to your home directory. \nYou can edit this file \n~/.vimrc\n just like any other file, using \nvim\n.\n\n\nHelp\n\n\nIn \nvim,\n the command \n:help <topic>\n shows help about a particular topic in \nvim\n.  Example, \n:help backup\n.\n\n\nBackup Files\n\n\nYou can ask \nvim\n to automatically backup files that you edit.  This has been a life saver for me in multiple  occasions.\n\n\nIn your \n~/.vimrc\n file, \n\n\n1\nset backup\n\n\n\n\n\n\nwill cause a copy of your file to be save with suffix \n~\n appended to its name everytime you save.\n\n\nI prefer not to clutter my working directory, so I set\n\n\n1\nset backupdir=~/.backup\n\n\n\n\n\n\nand create a directory named \n~/.backup\n to store my backup files.\n\n\nSo if you made changes to a file that you regreted, or if you accidentally deleted a file, you can check under \n~/.backup\n to see if the backup can save you.\n\n\nSyntax Highlighting\n\n\nIf for some reasons, syntax highlighting is not on by default, add this to your \n~/.vimrc\n:\n\n\n1\nsyntax on\n\n\n\n\n\n\nRuler and Numbers\n\n\nIf you prefer to show the line number you are on and the column number you are on, adding the commands to \n~/.vimrc\n\n\n1\nset ruler\n\n\n\n\n\n\nwill display the line number and the column number on the lower right corner.  \n\n\nYou can also add\n\n1\nset number\n\n\n\n\n\nto label each line with a line number.\n\n\nAuto Indentation \n(new)\n\n\nProper indentation is important to make your code readable (to yourself and others).  You should enable this in \nvim\n with:\n\n\n1\n2\nset autoindent \nset smartindent\n\n\n\n\n\n\nAutoindent will cause the next line to have the same indentation as the previous line; while smartindent has some understanding of C-like syntax (such as recognizing \n{\n and \n}\n) and indent your code accordingly.  The size of the indentation is based on the setting \nshiftwidth\n.  For CS1010, please set it to either \n2\n or \n4\n:\n\n\n1\nset shiftwidth=2\n\n\n\n\n\n\n2. Navigation\n\n\nBasic Navigation\n\n\nUse \nk\n and \nj\n keys to move up and down (just like Gmail and Facebook!).  \nh\n and \nl\n to move left and right.\n\n\nOther shortcuts (no need to memorize them now, just refer back when you feel like you are typing too many \nhjkl\n to see how you can navigate faster).\n\n\n\n\nw\n   jump to the beginning of the next word\n\n\nb\n   jump to the beginning of the previous word (reverse of \nw\n)\n\n\ne\n   jump to the end of the word (or next word when pressed again)\n\n\nf\n + char: search forward in the line and sit on the next matching char\n\n\nt\n + char:  search forward in the line and sit on one space before the matching char\n\n\n$\n jump to end of line\n\n\n0\n jump to the beginning of the line\n\n\n^\n jump to the first non-blank character of the line\n\n\n%\n jump between matching parentheses\n\n\nCTRL-\nd\n jump forward (Down) half page\n\n\nCTRL-\nf\n jump Forward one page\n\n\nCTRL-\nu\n jump backward (Up) half page\n\n\nCTRL-\nb\n jump Backward half page\n\n\n\n\nJumping to a Line\n\n\nIf the compiler tells you there is an error on Line \nx\nx\n, you can issue \n:<x>\n to jump to Line \nx\nx\n.  For instance, \n:40\n will go to Line 40.\n\n\n3. Editing Operations\n\n\nUndo\n\n\nSince we are on the topic of correcting mistakes, \nu\n in command mode undo your changes.  Prefix it with a number \nn\nn\n to undo \nn\nn\n times.  If you want to undo your undo, \n<CTRL-R>\n will redo.\n\n\nNavigation + Editing\n\n\nvim\n is powerful because you can combine \noperations\n with \nnavigation\n.  For instance \nc\n to change, \nd\n to delete, \ny\n to yank (copy).  Since \nw\n is the navigation command to move over the current word, combining them we get:\n\n\n\n\ncw\n change the current word (delete the current word and enter insert mode)\n\n\ndw\n delete the current word\n\n\nyw\n yank the current word (copy word into buffer)\n\n\n\n\nCan you guess what \ndf)\n, \ndt)\n, \nc$\n, \ny0\n do?\n\n\nIf you repeat the operation \nc\n, \nd\n, and \ny\n, it applies to the whole line, so:\n\n\n\n\ncc\n change the whole line\n\n\ndd\n delete the whole line\n\n\nyy\n yank the whole line\n\n\n\n\nYou can add a number before an operation to specify how many times you want to repeat an operation.  So \n5dd\n deletes 5 lines, \n5dw\n deletes 5 words, etc.\n\n\nSee the article \nOperator, the True Power of \nVim\n for more details.\n\n\nSwapping Lines\n\n\nSometimes you want to swap the order of two lines of code, in command mode, \nddp\n will do the trick.  \ndd\n deletes the current line, \np\n paste it after the current line, in effect swapping the order of the two lines.\n\n\nCommenting blocks of code\n\n\nSometimes we need to comment out a whole block of code in C for testing purposes. There are several ways to do it in \nvim\n:\n\n\n\n\nPlace the cursor on the first line of the block of code you want to comment.\n\n\n0\n to jump to the beginning of the line\n\n\nV\n enter visual mode\n\n\nUse arrow key to select the block of code you want to comment. \n\n\nI\n to insert at the beginning of the line (here, since we already selected the block, we will insert at the beginning of every selected)\n\n\n//\n to insert the Java comment character (you will see it inserted in the current line, but don't worry)\n\n\n to escape from the visual code.\n\n\n\n\nTo uncomment, \n\n\n\n\nPlace the cursor on the first line of the block of code you want to comment.\n\n\n0\n to jump to the beginning of the line\n\n\n<CTRL-v>\n enter block visual mode\n\n\nUse arrow key to select the columns of text containing \n//\n\n\nx\n to delete them\n\n\n\n\n4. Other Advanced Features\n\n\nSearch and Replace in \nvim\n\n\n1\n:%s/oldWord/newWord/gc \n\n\n\n\n\n\n:\n enters the command mode.  \n%\n means apply to the whole document, \ns\n means substitute, \ng\n means global (otherwise, only the first occurance of each line is replaced). \nc\n is optional -- adding it cause \nvim\n to confirm with you before each replacement  \n\n\nShell Command\n\n\nIf you need to issue a shell command quickly, you don't have to exit \nvim\n, run the command, and launch \nvim\n again.  You can use \n!\n, \n\n\n1\n:!<command>\n\n\n\n\n\n\nwill issue the command to shell.  E.g.,\n\n\n1\n:!ls\n\n\n\n\n\n\nYou can use this to compile your current file, without exiting \nvim\n.\n\n\n1\n:!make\n\n\n\n\n\n\nmake\n is actually a builtin command for \nvim\n so you can also simply run\n\n\n1\n:make\n\n\n\n\n\n\nAbbreviation\n\n\nYou can use the command \nab\n to abbreviate frequently typed commands.  E.g., in your \n~/.vimrc\n, \n\n\n1\nab pl cs1010_print_long(\n\n\n\n\n\n\nNow, when you type \npl\n, it will be expanded into \ncs1010_print_long(\n\n\nAuto-Completion\n\n\nYou can \n<CTRL-P>\n to auto-complete.  By default, the auto-complete dictionary is based on text in your current editing buffers.  This is a very useful keystroke saver for long function and variable names.\n\n\nAuto-Indent the Whole File\n\n\nYou can \ngg=G\n in command mode to auto-indent the whole file.  \ngg\n is the command to go to the beginning of the file.  \n=\n is the command to indent.  \nG\n is the command to go to the end of the file.  \n\n\nSplitting \nvim\n's Viewport\n\n\n\n\n:sp file.c\n splits the \nvim\n window horizontally\n\n\n:vsp file.c\n splits the \nvim\n window vertically\n\n\nCtrl-w Ctrl-w\n moves between the different \nvim\n viewports\n\n\n\n\n5. Plugins\n\n\nSyntax and Style Checker\n\n\nI use \nsyntastic\n to check for style and syntax whenever I save a file.  \nsyntastic\n is a \nvim\n plugin. \n\n\nMy \n.vimrc\n configuration file contains the following:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\"For syntastic\nset laststatus=2\nset statusline+=%#warningmsg#\nset statusline+=%{SyntasticStatuslineFlag()}\nset statusline+=%*\n\nlet g:syntastic_error_symbol = '\u2717'\nlet g:syntastic_warning_symbol = '\u26a0'\nlet g:syntastic_always_populate_loc_list = 1\nlet g:syntastic_auto_loc_list = 1\nlet g:syntastic_check_on_open = 1\nlet g:syntastic_check_on_wq = 0\n\nlet g:syntastic_c_checkers = [ 'clang_tidy', 'clang' ]\nlet g:syntastic_c_compiler = 'clang'\nlet g:syntastic_c_clang_args = '-Wall -Werror -Wextra -Iinclude'\nlet g:syntastic_c_clang_tidy_args = '-checks=*'\nlet g:syntastic_c_compiler_options = '-Wall -Iinclude'\nlet g:syntastic_c_include_dirs = [ '../include', 'include' ]\nlet g:syntastic_c_clang_tidy_post_args = \"\"\n\n\n\n\n\n\nNew Addition:\n By default, \nclang-tidy\n does not know where to find the header files.  So if you include non-standard C headers, it will complain that it cannot find headers.  To resolve this, we need to tell \nclang-tidy\n the compilation flags that we use when compiling our program.  \n\n\nWe can do this by creating a file named \ncompile_flags.txt\n in your working directory (where your C files are located), containing one compilation flag per line.  For instance, if the header files are located in \n/home/course/cs1010/include\n, your \ncompile_flags.txt\n should contain the following two lines:\n\n\n1\n2\n-Wall\n-I/home/course/cs1010/include",
            "title": "Vim"
        },
        {
            "location": "/vim/index.html#vim-tips",
            "text": "I collected below some tips on  vim  that I find helpful.  If you are new to  vim , please try out the command  vimtutor  on any machine where  vim  is installed, and check out the nice article  Learn vim Progressively .",
            "title": "Vim Tips"
        },
        {
            "location": "/vim/index.html#1-useful-configuration",
            "text": "You can configure your  vim  by putting your configuration options and scripts in the  ~/.vimrc  file (a hidden file named  .vimrc  in your home directory).  This file will be loaded whenever you starts  vim .  You can copy a sample  .vimrc  file from  ~cs1010/.vimrc  to your home directory. \nYou can edit this file  ~/.vimrc  just like any other file, using  vim .",
            "title": "1. Useful Configuration"
        },
        {
            "location": "/vim/index.html#help",
            "text": "In  vim,  the command  :help <topic>  shows help about a particular topic in  vim .  Example,  :help backup .",
            "title": "Help"
        },
        {
            "location": "/vim/index.html#backup-files",
            "text": "You can ask  vim  to automatically backup files that you edit.  This has been a life saver for me in multiple  occasions.  In your  ~/.vimrc  file,   1 set backup   will cause a copy of your file to be save with suffix  ~  appended to its name everytime you save.  I prefer not to clutter my working directory, so I set  1 set backupdir=~/.backup   and create a directory named  ~/.backup  to store my backup files.  So if you made changes to a file that you regreted, or if you accidentally deleted a file, you can check under  ~/.backup  to see if the backup can save you.",
            "title": "Backup Files"
        },
        {
            "location": "/vim/index.html#syntax-highlighting",
            "text": "If for some reasons, syntax highlighting is not on by default, add this to your  ~/.vimrc :  1 syntax on",
            "title": "Syntax Highlighting"
        },
        {
            "location": "/vim/index.html#ruler-and-numbers",
            "text": "If you prefer to show the line number you are on and the column number you are on, adding the commands to  ~/.vimrc  1 set ruler   will display the line number and the column number on the lower right corner.    You can also add 1 set number   to label each line with a line number.",
            "title": "Ruler and Numbers"
        },
        {
            "location": "/vim/index.html#auto-indentation-czjqqkd0newczjqqkd1",
            "text": "Proper indentation is important to make your code readable (to yourself and others).  You should enable this in  vim  with:  1\n2 set autoindent \nset smartindent   Autoindent will cause the next line to have the same indentation as the previous line; while smartindent has some understanding of C-like syntax (such as recognizing  {  and  } ) and indent your code accordingly.  The size of the indentation is based on the setting  shiftwidth .  For CS1010, please set it to either  2  or  4 :  1 set shiftwidth=2",
            "title": "Auto Indentation (new)"
        },
        {
            "location": "/vim/index.html#2-navigation",
            "text": "",
            "title": "2. Navigation"
        },
        {
            "location": "/vim/index.html#basic-navigation",
            "text": "Use  k  and  j  keys to move up and down (just like Gmail and Facebook!).   h  and  l  to move left and right.  Other shortcuts (no need to memorize them now, just refer back when you feel like you are typing too many  hjkl  to see how you can navigate faster).   w    jump to the beginning of the next word  b    jump to the beginning of the previous word (reverse of  w )  e    jump to the end of the word (or next word when pressed again)  f  + char: search forward in the line and sit on the next matching char  t  + char:  search forward in the line and sit on one space before the matching char  $  jump to end of line  0  jump to the beginning of the line  ^  jump to the first non-blank character of the line  %  jump between matching parentheses  CTRL- d  jump forward (Down) half page  CTRL- f  jump Forward one page  CTRL- u  jump backward (Up) half page  CTRL- b  jump Backward half page",
            "title": "Basic Navigation"
        },
        {
            "location": "/vim/index.html#jumping-to-a-line",
            "text": "If the compiler tells you there is an error on Line  x x , you can issue  :<x>  to jump to Line  x x .  For instance,  :40  will go to Line 40.",
            "title": "Jumping to a Line"
        },
        {
            "location": "/vim/index.html#3-editing-operations",
            "text": "",
            "title": "3. Editing Operations"
        },
        {
            "location": "/vim/index.html#undo",
            "text": "Since we are on the topic of correcting mistakes,  u  in command mode undo your changes.  Prefix it with a number  n n  to undo  n n  times.  If you want to undo your undo,  <CTRL-R>  will redo.",
            "title": "Undo"
        },
        {
            "location": "/vim/index.html#navigation-editing",
            "text": "vim  is powerful because you can combine  operations  with  navigation .  For instance  c  to change,  d  to delete,  y  to yank (copy).  Since  w  is the navigation command to move over the current word, combining them we get:   cw  change the current word (delete the current word and enter insert mode)  dw  delete the current word  yw  yank the current word (copy word into buffer)   Can you guess what  df) ,  dt) ,  c$ ,  y0  do?  If you repeat the operation  c ,  d , and  y , it applies to the whole line, so:   cc  change the whole line  dd  delete the whole line  yy  yank the whole line   You can add a number before an operation to specify how many times you want to repeat an operation.  So  5dd  deletes 5 lines,  5dw  deletes 5 words, etc.  See the article  Operator, the True Power of  Vim  for more details.",
            "title": "Navigation + Editing"
        },
        {
            "location": "/vim/index.html#swapping-lines",
            "text": "Sometimes you want to swap the order of two lines of code, in command mode,  ddp  will do the trick.   dd  deletes the current line,  p  paste it after the current line, in effect swapping the order of the two lines.",
            "title": "Swapping Lines"
        },
        {
            "location": "/vim/index.html#commenting-blocks-of-code",
            "text": "Sometimes we need to comment out a whole block of code in C for testing purposes. There are several ways to do it in  vim :   Place the cursor on the first line of the block of code you want to comment.  0  to jump to the beginning of the line  V  enter visual mode  Use arrow key to select the block of code you want to comment.   I  to insert at the beginning of the line (here, since we already selected the block, we will insert at the beginning of every selected)  //  to insert the Java comment character (you will see it inserted in the current line, but don't worry)   to escape from the visual code.   To uncomment,    Place the cursor on the first line of the block of code you want to comment.  0  to jump to the beginning of the line  <CTRL-v>  enter block visual mode  Use arrow key to select the columns of text containing  //  x  to delete them",
            "title": "Commenting blocks of code"
        },
        {
            "location": "/vim/index.html#4-other-advanced-features",
            "text": "",
            "title": "4. Other Advanced Features"
        },
        {
            "location": "/vim/index.html#search-and-replace-in-vim",
            "text": "1 :%s/oldWord/newWord/gc    :  enters the command mode.   %  means apply to the whole document,  s  means substitute,  g  means global (otherwise, only the first occurance of each line is replaced).  c  is optional -- adding it cause  vim  to confirm with you before each replacement",
            "title": "Search and Replace in vim"
        },
        {
            "location": "/vim/index.html#shell-command",
            "text": "If you need to issue a shell command quickly, you don't have to exit  vim , run the command, and launch  vim  again.  You can use  ! ,   1 :!<command>   will issue the command to shell.  E.g.,  1 :!ls   You can use this to compile your current file, without exiting  vim .  1 :!make   make  is actually a builtin command for  vim  so you can also simply run  1 :make",
            "title": "Shell Command"
        },
        {
            "location": "/vim/index.html#abbreviation",
            "text": "You can use the command  ab  to abbreviate frequently typed commands.  E.g., in your  ~/.vimrc ,   1 ab pl cs1010_print_long(   Now, when you type  pl , it will be expanded into  cs1010_print_long(",
            "title": "Abbreviation"
        },
        {
            "location": "/vim/index.html#auto-completion",
            "text": "You can  <CTRL-P>  to auto-complete.  By default, the auto-complete dictionary is based on text in your current editing buffers.  This is a very useful keystroke saver for long function and variable names.",
            "title": "Auto-Completion"
        },
        {
            "location": "/vim/index.html#auto-indent-the-whole-file",
            "text": "You can  gg=G  in command mode to auto-indent the whole file.   gg  is the command to go to the beginning of the file.   =  is the command to indent.   G  is the command to go to the end of the file.",
            "title": "Auto-Indent the Whole File"
        },
        {
            "location": "/vim/index.html#splitting-vims-viewport",
            "text": ":sp file.c  splits the  vim  window horizontally  :vsp file.c  splits the  vim  window vertically  Ctrl-w Ctrl-w  moves between the different  vim  viewports",
            "title": "Splitting vim's Viewport"
        },
        {
            "location": "/vim/index.html#5-plugins",
            "text": "",
            "title": "5. Plugins"
        },
        {
            "location": "/vim/index.html#syntax-and-style-checker",
            "text": "I use  syntastic  to check for style and syntax whenever I save a file.   syntastic  is a  vim  plugin.   My  .vimrc  configuration file contains the following:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20 \"For syntastic\nset laststatus=2\nset statusline+=%#warningmsg#\nset statusline+=%{SyntasticStatuslineFlag()}\nset statusline+=%*\n\nlet g:syntastic_error_symbol = '\u2717'\nlet g:syntastic_warning_symbol = '\u26a0'\nlet g:syntastic_always_populate_loc_list = 1\nlet g:syntastic_auto_loc_list = 1\nlet g:syntastic_check_on_open = 1\nlet g:syntastic_check_on_wq = 0\n\nlet g:syntastic_c_checkers = [ 'clang_tidy', 'clang' ]\nlet g:syntastic_c_compiler = 'clang'\nlet g:syntastic_c_clang_args = '-Wall -Werror -Wextra -Iinclude'\nlet g:syntastic_c_clang_tidy_args = '-checks=*'\nlet g:syntastic_c_compiler_options = '-Wall -Iinclude'\nlet g:syntastic_c_include_dirs = [ '../include', 'include' ]\nlet g:syntastic_c_clang_tidy_post_args = \"\"   New Addition:  By default,  clang-tidy  does not know where to find the header files.  So if you include non-standard C headers, it will complain that it cannot find headers.  To resolve this, we need to tell  clang-tidy  the compilation flags that we use when compiling our program.    We can do this by creating a file named  compile_flags.txt  in your working directory (where your C files are located), containing one compilation flag per line.  For instance, if the header files are located in  /home/course/cs1010/include , your  compile_flags.txt  should contain the following two lines:  1\n2 -Wall\n-I/home/course/cs1010/include",
            "title": "Syntax and Style Checker"
        },
        {
            "location": "/library/index.html",
            "text": "The CS1010 I/O Library\n\n\nTo help students get started with C programming without worrying too much about the details and pitfalls of using \nprintf\n and \nscanf\n, we provide a simple-to-use library to read and write integers, floating point numbers, and strings.  \n\n\nThe libraries are pre-installed in \nCS1010 programming environments\n, with \ncs1010.h\n located under \n~cs1010/include\n and \nlibcs1010.a\n located under \n~cs1010/lib\n.\n\n\nInstalling the Library\n\n\nIf you want to install the libraries on your own version of Ubuntu, do the following:\n\n\n\n\nTo get an updated copy of the library, clone it from its git repo on GitHub with the command:\n\n\n\n\n1\ngit clone https://github.com/nus-cs1010-1819-s1/libcs1010.git\n\n\n\n\n\n\nIt is recommended you do this in your home directory.\n\n\nYou should see an output similar to:\n\n1\n2\n3\n4\n5\nCloning into 'libcs1010'...\nremote: Counting objects: 6, done.\nremote: Compressing objects: 100% (3/3), done.\nremote: Total 6 (delta 0), reused 0 (delta 0), pack-reused 0\nUnpacking objects: 100% (6/6), done.\n\n\n\n\n\nAfter that, you should see a subdirectory \nlibcs1010\n created in your current directory.  Inside, there should be a file called \nMakefile\n, and two subdirectories called \ninclude\n and \nsrc\n.  \n\n\n\n\nTo compile the library, run\n\n\n\n\n1\nmake\n\n\n\n\n\n\nThis should compile the file \nsrc/cs1010.c\n and create a static C library named \nlibcs1010.a\n under the \nlib\n directory.\n\n\nUsing the Library\n\n\nHeader\n\n\nTo use the CS1010 I/O library, you should \n#include\n the file \ncs1010.h\n, like this:\n\n\n1\n#include\n \n\"cs1010.h\"\n\n\n\n\n\n\n\nat the top of your C program.\n\n\nLinking\n\n\nThe CS1010 I/O library is provided as the file \nlibcs1010.a\n.  To link to the library, you need to compile with \n-lcs1010\n.  Usually, you need to specify where you can find \ncs1010.h\n with the \n-I\n flag, and \nlibcs1010.a\n with the \n-L\n flag.  Assuming that you are compiling in another subdirectory under your home and \nlibcs1010\n are located under your home directory, the header file and the library file are in \n../libcs1010/include\n and \n../libcs1010/lib\n respectively.\n\n\nSo you compile using the command line:\n\n\n1\nclang -I../libcs1010/include -L../libcs1010/lib hello.c -lcs1010\n\n\n\n\n\n\n\nOf course if your header and library files are located in another directory that is not \n../libcs1010/include\n and \n../libcs1010/lib\n, you should change the command above accordingly.\n\n\nAlthough it is a long string to type, you should type it once and use up arrow in bash to go back to this command over-and-over again.   For advanced students, we suggest that you put this in a shell script so that you just need to run the shell script to compile the program.  We have also automate this for you for your assignments and exercises using the \nmake\n command.\n\n\n\nReading of a Single Value\n\n\nThe CS1010 library supports reading of \nlong\n value, \ndouble\n value, and strings (both space-separated words and newline-separated lines) from the standard input.  For \nlong\n and \ndouble\n. The relevant methods are:\n\n\n\n\n\n\nlong cs1010_read_long()\n\nReturns a \nlong\n value from the standard input.  An error message will be printed (to \nstderr\n) if the input sequence is not a valid \nlong\n value -- in which case the value \nLONG_MAX\n will be returned.  Example:\n\n1\nlong\n \nyear\n \n=\n \ncs1010_read_long\n();\n\n\n\n\n\n\n\n\n\n\ndouble cs1010_read_double()\n\nReturns a \ndouble\n value from the standard input.  An error message will be printed (to \nstderr\n) if the input sequence is not a valid \ndouble\n value -- in which case the value \nDBL_MAX\n will be returned. Example:\n\n1\ndouble\n \ncap\n \n=\n \ncs1010_read_double\n();\n\n\n\n\n\n\n\n\n\n\nchar* cs1010_read_word()\n\nReturns a \nchar *\n pointing to the next white-space-separated string from the standard input.  A white-space character is defined based on the standard C function \nisspace()\n and includes the space \n, tab \n\\t\n, and newline \n\\n\n character.  Returns NULL if there is an error.  If the returned value is non-NULL, the caller is responsible for freeing the memory allocated by calling \nfree\n.\n\n\n1\n2\n3\n4\n5\nchar\n*\n \nword\n \n=\n \ncs1010_read_word\n();\n\n\n// use word to do something\n\n \n:\n\n \n:\n\n\nfree\n(\nword\n);\n\n\n\n\n\n\n\n\n\n\nchar* cs1010_read_line()\n\nReturns a \nchar *\n pointing to the next new-line-separated string from the standard input.   The string returns from \ncs1010_read_line()\n includes the newline character (if one is found).\nReturns NULL if there is an error.  If the returned value is non-NULL, the caller is responsible for freeing the memory allocated by calling \nfree\n.\n\n1\n2\n3\n4\n5\nchar\n*\n \nline\n \n=\n \ncs1010_read_line\n();\n\n\n// use line to do something\n\n \n:\n\n \n:\n\n\nfree\n(\nline\n);\n\n\n\n\n\n\n\n\n\n\nReading of Multiple Values\n\n\nThe CS1010 library also supports reading of multiple values.  \n\n\n\n\n\n\nlong* cs1010_read_long_array(int k)\n\nReturns \nk\n numbers of \nlong\n values read from the standard input stored in an array.  An error message will be printed (to \nstderr\n) for each input that is not a valid \nlong\n value -- in which case the value \nLONG_MAX\n will be populated in the corresponding array element.  Returns NULL if there is a memory allocation error.  If the returned value is non-NULL, the caller is responsible for freeing the memory allocated by calling \nfree\n.\n\n1\n2\n3\n4\n5\nlong\n*\n \nvalues\n \n=\n \ncs1010_read_long_array\n(\n10\n);\n\n\n// Do something with array values\n\n \n:\n\n \n:\n\n\nfree\n(\nvalues\n);\n\n\n\n\n\n\n\n\n\n\ndouble* cs1010_read_double_array(int k)\n\nReturns \nk\n numbers of \ndouble\n values read from the standard input stored in an array.  An error message will be printed (to \nstderr\n) for each input that is not a valid \ndouble\n value -- in which case the value \nDBL_MAX\n will be populated in the corresponding array element.\n\nReturns NULL if there is a memory allocation error.  If the returned value is non-NULL, the caller is responsible for freeing the memory allocated by calling \nfree\n.\n\n1\n2\n3\n4\n5\ndouble\n*\n \nvalues\n \n=\n \ncs1010_read_double_array\n(\n10\n);\n\n\n// Do something with array values\n\n \n:\n\n \n:\n\n\nfree\n(\nvalues\n);\n\n\n\n\n\n\n\n\n\n\nchar** cs1010_read_word_array(int k)\n\nReturns \nk\n white-space-separated words read from the standard input stored in an array.  The notion of \"word\" is the same to \ncs1010_read_word()\n.\n\nReturns NULL if there is a memory allocation error.  If the returned value is non-NULL, the caller is responsible for freeing the memory allocated for each word and for the whole array by calling \nfree\n.\n\n1\n2\n3\n4\n5\ndouble\n*\n \nwords\n \n=\n \ncs1010_read_word_array\n(\n10\n);\n\n\n// Do something with array words\n\n \n:\n\n \n:\n\n\nfree\n(\nwords\n);\n\n\n\n\n\n\n\n\n\n\nchar** cs1010_read_line_array(int k)\n\nReturns \nk\n new-line-separated words read from the standard input stored in an array.  The notion of line is the same to \ncs1010_read_line()\n.\n\nReturns NULL if there is a memory allocation error.  If the returned value is non-NULL, the caller is responsible for freeing the memory allocated for each line and for the whole array by calling \nfree\n.\n\n1\n2\n3\n4\n5\ndouble\n*\n \nlines\n \n=\n \ncs1010_read_line_array\n(\n10\n);\n\n\n// Do something with array lines\n\n \n:\n\n \n:\n\n\nfree\n(\nlines\n);\n\n\n\n\n\n\n\n\n\n\nPrinting of a Single Value\n\n\nThe CS1010 library provide a few convenince functions to format and print \nlong\n and \ndouble\n values to the standard output.\n\n\n\n\n\n\nvoid cs1010_print_long(long value)\n and \nvoid cs1010_println_long(long value)\n\nPrint \nvalue\n to the standard output (with printf format \n%ld\n).\n\nThe \ncs1010_println_long\n version prints a newline after the value.\n\n1\n2\n3\n  \nlong\n \nx\n;\n\n    \n:\n\n  \ncs1010_print_long\n(\nx\n);\n\n\n\n\n\n\n\n\n\n\nvoid cs1010_print_double(double value)\n and \nvoid cs1010_println_double(double value)\n\nPrint \nvalue\n to the standard output (with printf format \n%.4f\n).\nThe \ncs1010_println_double\n version prints a newline after the value.\n\n1\n2\n3\n  \ndouble\n \nx\n;\n\n    \n:\n\n  \ncs1010_println_double\n(\nx\n);\n\n\n\n\n\n\n\n\n\n\nvoid cs1010_print_string(char *str)\n and \nvoid cs1010_println_string(char *str)\n\nPrint a given string \nstr\n to the standard output.  These functions are provided for completeness and is a simple wrapper around \nprintf(str)\n and \nprintf(\"%s\\n\", str)\n repsectively.\n\n1\n  \ncs1010_println_string\n(\n\"hello world!\"\n);",
            "title": "CS1010 I/O"
        },
        {
            "location": "/library/index.html#the-cs1010-io-library",
            "text": "To help students get started with C programming without worrying too much about the details and pitfalls of using  printf  and  scanf , we provide a simple-to-use library to read and write integers, floating point numbers, and strings.    The libraries are pre-installed in  CS1010 programming environments , with  cs1010.h  located under  ~cs1010/include  and  libcs1010.a  located under  ~cs1010/lib .",
            "title": "The CS1010 I/O Library"
        },
        {
            "location": "/library/index.html#installing-the-library",
            "text": "If you want to install the libraries on your own version of Ubuntu, do the following:   To get an updated copy of the library, clone it from its git repo on GitHub with the command:   1 git clone https://github.com/nus-cs1010-1819-s1/libcs1010.git   It is recommended you do this in your home directory.  You should see an output similar to: 1\n2\n3\n4\n5 Cloning into 'libcs1010'...\nremote: Counting objects: 6, done.\nremote: Compressing objects: 100% (3/3), done.\nremote: Total 6 (delta 0), reused 0 (delta 0), pack-reused 0\nUnpacking objects: 100% (6/6), done.   After that, you should see a subdirectory  libcs1010  created in your current directory.  Inside, there should be a file called  Makefile , and two subdirectories called  include  and  src .     To compile the library, run   1 make   This should compile the file  src/cs1010.c  and create a static C library named  libcs1010.a  under the  lib  directory.",
            "title": "Installing the Library"
        },
        {
            "location": "/library/index.html#using-the-library",
            "text": "",
            "title": "Using the Library"
        },
        {
            "location": "/library/index.html#header",
            "text": "To use the CS1010 I/O library, you should  #include  the file  cs1010.h , like this:  1 #include   \"cs1010.h\"    at the top of your C program.",
            "title": "Header"
        },
        {
            "location": "/library/index.html#linking",
            "text": "The CS1010 I/O library is provided as the file  libcs1010.a .  To link to the library, you need to compile with  -lcs1010 .  Usually, you need to specify where you can find  cs1010.h  with the  -I  flag, and  libcs1010.a  with the  -L  flag.  Assuming that you are compiling in another subdirectory under your home and  libcs1010  are located under your home directory, the header file and the library file are in  ../libcs1010/include  and  ../libcs1010/lib  respectively.  So you compile using the command line:  1 clang -I../libcs1010/include -L../libcs1010/lib hello.c -lcs1010   \nOf course if your header and library files are located in another directory that is not  ../libcs1010/include  and  ../libcs1010/lib , you should change the command above accordingly.  Although it is a long string to type, you should type it once and use up arrow in bash to go back to this command over-and-over again.   For advanced students, we suggest that you put this in a shell script so that you just need to run the shell script to compile the program.  We have also automate this for you for your assignments and exercises using the  make  command.",
            "title": "Linking"
        },
        {
            "location": "/library/index.html#reading-of-a-single-value",
            "text": "The CS1010 library supports reading of  long  value,  double  value, and strings (both space-separated words and newline-separated lines) from the standard input.  For  long  and  double . The relevant methods are:    long cs1010_read_long() \nReturns a  long  value from the standard input.  An error message will be printed (to  stderr ) if the input sequence is not a valid  long  value -- in which case the value  LONG_MAX  will be returned.  Example: 1 long   year   =   cs1010_read_long ();      double cs1010_read_double() \nReturns a  double  value from the standard input.  An error message will be printed (to  stderr ) if the input sequence is not a valid  double  value -- in which case the value  DBL_MAX  will be returned. Example: 1 double   cap   =   cs1010_read_double ();      char* cs1010_read_word() \nReturns a  char *  pointing to the next white-space-separated string from the standard input.  A white-space character is defined based on the standard C function  isspace()  and includes the space  , tab  \\t , and newline  \\n  character.  Returns NULL if there is an error.  If the returned value is non-NULL, the caller is responsible for freeing the memory allocated by calling  free .  1\n2\n3\n4\n5 char *   word   =   cs1010_read_word ();  // use word to do something \n  : \n  :  free ( word );      char* cs1010_read_line() \nReturns a  char *  pointing to the next new-line-separated string from the standard input.   The string returns from  cs1010_read_line()  includes the newline character (if one is found).\nReturns NULL if there is an error.  If the returned value is non-NULL, the caller is responsible for freeing the memory allocated by calling  free . 1\n2\n3\n4\n5 char *   line   =   cs1010_read_line ();  // use line to do something \n  : \n  :  free ( line );",
            "title": "Reading of a Single Value"
        },
        {
            "location": "/library/index.html#reading-of-multiple-values",
            "text": "The CS1010 library also supports reading of multiple values.      long* cs1010_read_long_array(int k) \nReturns  k  numbers of  long  values read from the standard input stored in an array.  An error message will be printed (to  stderr ) for each input that is not a valid  long  value -- in which case the value  LONG_MAX  will be populated in the corresponding array element.  Returns NULL if there is a memory allocation error.  If the returned value is non-NULL, the caller is responsible for freeing the memory allocated by calling  free . 1\n2\n3\n4\n5 long *   values   =   cs1010_read_long_array ( 10 );  // Do something with array values \n  : \n  :  free ( values );      double* cs1010_read_double_array(int k) \nReturns  k  numbers of  double  values read from the standard input stored in an array.  An error message will be printed (to  stderr ) for each input that is not a valid  double  value -- in which case the value  DBL_MAX  will be populated in the corresponding array element. \nReturns NULL if there is a memory allocation error.  If the returned value is non-NULL, the caller is responsible for freeing the memory allocated by calling  free . 1\n2\n3\n4\n5 double *   values   =   cs1010_read_double_array ( 10 );  // Do something with array values \n  : \n  :  free ( values );      char** cs1010_read_word_array(int k) \nReturns  k  white-space-separated words read from the standard input stored in an array.  The notion of \"word\" is the same to  cs1010_read_word() . \nReturns NULL if there is a memory allocation error.  If the returned value is non-NULL, the caller is responsible for freeing the memory allocated for each word and for the whole array by calling  free . 1\n2\n3\n4\n5 double *   words   =   cs1010_read_word_array ( 10 );  // Do something with array words \n  : \n  :  free ( words );      char** cs1010_read_line_array(int k) \nReturns  k  new-line-separated words read from the standard input stored in an array.  The notion of line is the same to  cs1010_read_line() . \nReturns NULL if there is a memory allocation error.  If the returned value is non-NULL, the caller is responsible for freeing the memory allocated for each line and for the whole array by calling  free . 1\n2\n3\n4\n5 double *   lines   =   cs1010_read_line_array ( 10 );  // Do something with array lines \n  : \n  :  free ( lines );",
            "title": "Reading of Multiple Values"
        },
        {
            "location": "/library/index.html#printing-of-a-single-value",
            "text": "The CS1010 library provide a few convenince functions to format and print  long  and  double  values to the standard output.    void cs1010_print_long(long value)  and  void cs1010_println_long(long value) \nPrint  value  to the standard output (with printf format  %ld ). \nThe  cs1010_println_long  version prints a newline after the value. 1\n2\n3    long   x ; \n     : \n   cs1010_print_long ( x );      void cs1010_print_double(double value)  and  void cs1010_println_double(double value) \nPrint  value  to the standard output (with printf format  %.4f ).\nThe  cs1010_println_double  version prints a newline after the value. 1\n2\n3    double   x ; \n     : \n   cs1010_println_double ( x );      void cs1010_print_string(char *str)  and  void cs1010_println_string(char *str) \nPrint a given string  str  to the standard output.  These functions are provided for completeness and is a simple wrapper around  printf(str)  and  printf(\"%s\\n\", str)  repsectively. 1    cs1010_println_string ( \"hello world!\" );",
            "title": "Printing of a Single Value"
        }
    ]
}